<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.recovery</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.RecoveryUtilizationTracker</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.ReservedFileInfo</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.StartupTracker.Counter</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.StartupTracker.Phase</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.latch.LatchSupport</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.LNLogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.NameLNLogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.recovery.RollbackTracker.Scanner</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.txn.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.txn.TxnChain.RevertInfo</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.DbLsn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.LoggerUtils</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.io.FileNotFoundException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.io.IOException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.atomic.AtomicBoolean</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Level</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Logger</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * Performs recovery when an Environment is opened.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>TODO: Need a description of the recovery algorithm here. For some related information, see the</color>
<color=#75715e> * Checkpointer class comments.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Recovery, the INList and Eviction ================================= There are two major steps</color>
<color=#75715e> * in recovery: 1) recover the mapping database and the INs for all other databases, 2) recover the</color>
<color=#75715e> * LNs for the other databases. In the buildTree method, step 1 comes before the call to buildINList</color>
<color=#75715e> * and step 2 comes after that. The INList is not maintained in step 1.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The INList is not maintained in the step 1 because there is no benefit -- we cannot evict</color>
<color=#75715e> * anyway as explained below -- and there are potential drawbacks to maintaining it: added</color>
<color=#75715e> * complexity and decreased performance. The drawbacks are described in more detail further below.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Even if the INList were maintained in step 1, eviction could not be enabled until step 2,</color>
<color=#75715e> * because logging is not allowed until all the INs are in place. In principle we could evict</color>
<color=#75715e> * non-dirty nodes in step 1, but since recovery is dirtying the tree as it goes, there would be</color>
<color=#75715e> * little or nothing that is non-dirty and could be evicted.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Therefore, the INList has an 'enabled' mode that is initially false (in step 1) and is set to</color>
<color=#75715e> * true by buildINList, just before step 2. The mechanism for adding nodes to the INList is skipped</color>
<color=#75715e> * when it is disabled. In addition to enabling it, buildINList populates it from the contents of</color>
<color=#75715e> * the Btrees that were constructed in step 1. In step 2, eviction is invoked explicitly by calling</color>
<color=#75715e> * EnvironmentImpl.invokeEvictor often during recovery. This is important since the background</color>
<color=#75715e> * evictor thread is not yet running.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>An externally visible limitation created by this situation is that the nodes placed in the</color>
<color=#75715e> * Btree during step 1 must all fit in memory, since no eviction is performed. So memory is a</color>
<color=#75715e> * limiting factor in how large a recovery can be performed. Since eviction is allowed in step 2,</color>
<color=#75715e> * and step 2 is where the bulk of the recovery is normally performed, this limitation of step 1</color>
<color=#75715e> * hasn't been a critical problem.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Maintaining the INList ---------------------- In this section we consider the impact of</color>
<color=#75715e> * maintaining the INList in step 1, if this were done in a future release. It is being considered</color>
<color=#75715e> * for a future release so we can rely on the INList to reference INs by node ID in the in-memory</color>
<color=#75715e> * representation of an IN (see the Big Memory SR [#22292]).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>To maintain the INList in step 1, when a branch of a tree (a parent IN) is spliced in, the</color>
<color=#75715e> * previous branch (all of the previous node's children) would have to be removed from the INList.</color>
<color=#75715e> * Doing this incorrectly could cause an OOME, and it may also have a performance impact.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The performance impact of removing the previous branch from the INList is difficult to</color>
<color=#75715e> * estimate. In the normal case (recovery after normal shutdown), very few nodes will be replaced</color>
<color=#75715e> * because normally only nodes at the max flush level are replayed, and the slots they are placed</color>
<color=#75715e> * into will be empty (not resident). Here is description of a worst case scenario, which is when</color>
<color=#75715e> * there is a crash near the end of a checkpoint:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ The last checkpoint is large, includes all nodes in the tree, is mostly complete, but was</color>
<color=#75715e> * not finished (no CkptEnd). The middle INs (above BIN and below the max flush level) must be</color>
<color=#75715e> * replayed (see Checkpointer and Provisional.BEFORE_CKPT_END).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ For these middle INs, the INs at each level are placed in the tree and replace any IN</color>
<color=#75715e> * present in the slot. For the bottom-most level of middle INs (level 2), these don't replace a</color>
<color=#75715e> * node (the slot will be empty because BINs are never replayed). But for the middle INs in all</color>
<color=#75715e> * levels above that, they replace a node that was fetched earlier; it was fetched because it is the</color>
<color=#75715e> * parent of a node at a lower level that was replayed.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ In the worst case, all INs from level 3 to R-1, where R is the root level, would be replayed</color>
<color=#75715e> * and replace a node. However, it seems the replaced node would not have resident children in the</color>
<color=#75715e> * scenario described, so the cost of removing it from the INList does not seem excessive.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ Here's an example illustrating this scenario. The BINs and their parents (as a sub-tree) are</color>
<color=#75715e> * logged first, followed by all dirty INs at the next level, etc.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>0050 CkptStart 0100 BIN level 1 0200 BIN level 1 ... 1000 IN level 2, parent of 0100, 0200,</color>
<color=#75715e> * etc. 1100 BIN level 1 1200 BIN level 1 ... 2000 IN level 2, parent of 1100, 1200, etc. ... 7000</color>
<color=#75715e> * IN level 2, last level 2 IN logged 8000 IN level 3, parent of 1000, 2000, etc. ... 9000 IN level</color>
<color=#75715e> * 4, parent of 8000, etc. ...</color>
<color=#75715e> *</color>
<color=#75715e> * <p>9000 level 4 / ----8000---- level 3 / / \ 1000 2000 ...... level 2</color>
<color=#75715e> *</color>
<color=#75715e> * <p>BINs not shown</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Only the root (if it happens to be logged right before the crash) is non-provisional. We'll</color>
<color=#75715e> * assume in this example that the root was not logged. Level 2 through R-1 are logged as</color>
<color=#75715e> * Provisional.BEFORE_CKPT_END, and treated as non-provisional (replayed) by recovery because there</color>
<color=#75715e> * is no CkptEnd.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When 1000 (and all other nodes at level 2) is replayed, it is placed into an empty slot.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When 8000 (and all other INs at level 3 and higher, below the root) is replayed, it will</color>
<color=#75715e> * replace a resident node that was fetched and placed in the slot when replaying its children. The</color>
<color=#75715e> * replaced node is one not shown, and assumed to have been logged sometime prior to this</color>
<color=#75715e> * checkpoint. The replaced node will have all the level 2 nodes that were replayed earlier (1000,</color>
<color=#75715e> * 2000, etc.) as its resident children, and these are the nodes that would have to be removed from</color>
<color=#75715e> * the INList, if recovery were changed to place INs on the INList in step 1.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>So if the INs were placed on the INList, in this worst case scenario, all INs from level 3 to</color>
<color=#75715e> * R-1 will be replayed, and all their immediate children would need to be removed from the INList.</color>
<color=#75715e> * Grandchildren would not be resident. In other words, all nodes at level 2 and above (except the</color>
<color=#75715e> * root) would be removed from the INList and replaced by a node being replayed.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When there is a normal shutdown, we don't know of scenarios that would cause this sort of</color>
<color=#75715e> * INList thrashing. So perhaps maintaining the INList in step 1 could be justified, if the</color>
<color=#75715e> * additional recovery cost after a crash is acceptable.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Or, a potential solution for the worst case scenario above might be to place the resident</color>
<color=#75715e> * child nodes in the new parent, rather than discarding them and removing them from the INList.</color>
<color=#75715e> * This would have the benefit of populating the cache and not wasting the work done to read and</color>
<color=#75715e> * replay these nodes. OTOH, it may cause OOME if too much of the tree is loaded in step 1.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>RecoveryManager</color> <color=#f8f8f2>{</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>TRACE_LN_REDO</color> <color=#f92672>=</color> <color=#e6db74>"LNRedo:"</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>TRACE_LN_UNDO</color> <color=#f92672>=</color> <color=#e6db74>"LNUndo"</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>TRACE_IN_REPLACE</color> <color=#f92672>=</color> <color=#e6db74>"INRecover:"</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>TRACE_ROOT_REPLACE</color> <color=#f92672>=</color> <color=#e6db74>"RootRecover:"</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>RecoveryInfo</color> <color=#f8f8f2>info</color><color=#f8f8f2>;</color> <color=#75715e>// stat info</color>
  <color=#75715e>/* Committed txn ID to Commit LSN */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>Long</color><color=#f92672>></color> <color=#f8f8f2>committedTxnIds</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f92672>></color> <color=#f8f8f2>abortedTxnIds</color><color=#f8f8f2>;</color> <color=#75715e>// aborted txns</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>PreparedTxn</color><color=#f92672>></color> <color=#f8f8f2>preparedTxns</color><color=#f8f8f2>;</color> <color=#75715e>// txnid -> prepared Txn</color>

  <color=#75715e>/*</color>
<color=#75715e>   * A set of lsns for log entries that will be resurrected is kept so that</color>
<color=#75715e>   * we can correctly redo utilization. See redoUtilization()</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f92672>></color> <color=#f8f8f2>resurrectedLsns</color><color=#f8f8f2>;</color>

  <color=#75715e>/* dbs for which we have to build the in memory IN list. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f92672>></color> <color=#f8f8f2>inListBuildDbIds</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f92672>></color> <color=#f8f8f2>tempDbIds</color><color=#f8f8f2>;</color> <color=#75715e>// temp DBs to be removed</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f92672>></color> <color=#f8f8f2>expectDeletedMapLNs</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Reserved file db records in the recovery interval are tracked in order</color>
<color=#75715e>   * to redo MapLN updates at the end of recovery.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f92672>></color> <color=#f8f8f2>reservedFiles</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f92672>></color> <color=#f8f8f2>reservedFileDbs</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Handles rollback periods created by HA syncup. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>RollbackTracker</color> <color=#f8f8f2>rollbackTracker</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>RecoveryUtilizationTracker</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>StartupTracker</color> <color=#f8f8f2>startupTracker</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>;</color>

  <color=#75715e>/* DBs that may violate the rule for upgrading to log version 8. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f92672>></color> <color=#f8f8f2>logVersion8UpgradeDbs</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Whether deltas violate the rule for upgrading to log version 8. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicBoolean</color> <color=#f8f8f2>logVersion8UpgradeDeltas</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Used to recalc disk usage to prevent eviction from violating limits. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>nOpsSinceDiskLimitRecalc</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#75715e>/** Make a recovery manager */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>RecoveryManager</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>env</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>env</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>cm</color> <color=#f92672>=</color> <color=#f8f8f2>env</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>readBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_ITERATOR_READ_SIZE</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>committedTxnIds</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>abortedTxnIds</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>preparedTxns</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>resurrectedLsns</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>inListBuildDbIds</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>tempDbIds</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>expectDeletedMapLNs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>reservedFiles</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>reservedFileDbs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>tracker</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RecoveryUtilizationTracker</color><color=#f8f8f2>(</color><color=#f8f8f2>env</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>logger</color> <color=#f92672>=</color> <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>(</color><color=#f8f8f2>getClass</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>rollbackTracker</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RollbackTracker</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>info</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RecoveryInfo</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>logVersion8UpgradeDbs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>logVersion8UpgradeDeltas</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicBoolean</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>startupTracker</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getStartupTracker</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setRecoveryInfo</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Look for an existing log and use it to create an in memory structure for accessing existing</color>
<color=#75715e>   * databases. The file manager and logging system are only available after recovery.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return RecoveryInfo statistics about the recovery process.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>RecoveryInfo</color> <color=#a6e22e>recover</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>readOnly</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>TOTAL_RECOVERY</color><color=#f8f8f2>);</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>FileManager</color> <color=#f8f8f2>fileManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>configManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>();</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>forceCheckpoint</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * After a restore from backup we must flip the file on the first</color>
<color=#75715e>       * write.  The lastFileInBackup must be immutable.  [#22834]</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getBoolean</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>ENV_RECOVERY_FORCE_NEW_FILE</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>forceNewLogFile</color><color=#f8f8f2>();</color>
        <color=#75715e>/* Must write something to create new file.*/</color>
        <color=#f8f8f2>forceCheckpoint</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>forceCheckpoint</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getBoolean</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>ENV_RECOVERY_FORCE_CHECKPOINT</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>filesExist</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Check whether log files are correctly located in the sub</color>
<color=#75715e>         * directories.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getAllFileNumbers</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Establish the location of the end of the log.  Log this</color>
<color=#75715e>         * information to the java.util.logging logger, but delay</color>
<color=#75715e>         * tracing this information in the .jdb file, because the</color>
<color=#75715e>         * logging system is not yet initialized. Because of that, be</color>
<color=#75715e>         * sure to use lazy logging, and do not use</color>
<color=#75715e>         * LoggerUtils.logAndTrace().</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>findEndOfLog</color><color=#f8f8f2>(</color><color=#f8f8f2>readOnly</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>String</color> <color=#f8f8f2>endOfLogMsg</color> <color=#f92672>=</color>
            <color=#e6db74>"Recovery underway, valid end of log = "</color>
                <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>nextAvailableLsn</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>Trace</color><color=#f8f8f2>.</color><color=#a6e22e>traceLazily</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>endOfLogMsg</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Establish the location of the root, the last checkpoint, and</color>
<color=#75715e>         * the first active LSN by finding the last checkpoint.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>findLastCheckpoint</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>setLastLsnAtRecovery</color><color=#f8f8f2>(</color><color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getLastUsedLsn</color><color=#f8f8f2>());</color>

        <color=#75715e>/* Read in the root. */</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>readMapTreeFromLog</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useRootLsn</color><color=#f8f8f2>);</color>

        <color=#75715e>/* Build the in memory tree from the log. */</color>
        <color=#f8f8f2>buildTree</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Nothing more to be done. Enable publishing of debug log</color>
<color=#75715e>         * messages to the database log.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>CONFIG</color><color=#f8f8f2>,</color> <color=#e6db74>"Recovery w/no files."</color><color=#f8f8f2>);</color>

        <color=#75715e>/* Enable the INList and log the root of the mapping tree. */</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>().</color><color=#a6e22e>enable</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEvictor</color><color=#f8f8f2>().</color><color=#a6e22e>setEnabled</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
        <color=#75715e>/* Do not write LNs in a read-only environment. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>readOnly</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>logMapTreeRoot</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Add shared cache environment when buildTree is not used. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSharedCache</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEvictor</color><color=#f8f8f2>().</color><color=#a6e22e>addEnvironment</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Always force a checkpoint during creation.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>forceCheckpoint</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>int</color> <color=#f8f8f2>ptSize</color> <color=#f92672>=</color> <color=#f8f8f2>preparedTxns</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ptSize</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>singular</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>ptSize</color> <color=#f92672>==</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>INFO</color><color=#f8f8f2>,</color>
            <color=#e6db74>"There "</color>
                <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>singular</color> <color=#f92672>?</color> <color=#e6db74>"is "</color> <color=#f8f8f2>:</color> <color=#e6db74>"are "</color><color=#f8f8f2>)</color>
                <color=#f92672>+</color> <color=#f8f8f2>ptSize</color>
                <color=#f92672>+</color> <color=#e6db74>" prepared but unfinished "</color>
                <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>singular</color> <color=#f92672>?</color> <color=#e6db74>"txn."</color> <color=#f8f8f2>:</color> <color=#e6db74>"txns."</color><color=#f8f8f2>));</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We don't need this set any more since these are all</color>
<color=#75715e>         * registered with the TxnManager now.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>preparedTxns</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentConfig</color> <color=#f8f8f2>envConfig</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getEnvironmentConfig</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Use of cleaner DBs may be disabled for unittests. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>getCreateUP</color><color=#f8f8f2>(</color><color=#f8f8f2>envConfig</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Open the file summary DB and populate the cache before the</color>
<color=#75715e>         * first checkpoint so that the checkpoint may flush file</color>
<color=#75715e>         * summary information.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>POPULATE_UP</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>POPULATE_UTILIZATION_PROFILE</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>forceCheckpoint</color> <color=#f92672>|=</color>
            <color=#f8f8f2>envImpl</color>
                <color=#f8f8f2>.</color><color=#a6e22e>getUtilizationProfile</color><color=#f8f8f2>()</color>
                <color=#f8f8f2>.</color><color=#a6e22e>populateCache</color><color=#f8f8f2>(</color>
                    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>POPULATE_UP</color><color=#f8f8f2>),</color>
                    <color=#f8f8f2>info</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>reservedFiles</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>reservedFileDbs</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>POPULATE_UP</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>getCreateEP</color><color=#f8f8f2>(</color><color=#f8f8f2>envConfig</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * Open the file expiration DB, populate the expiration</color>
<color=#75715e>         * profile, and initialize the current expiration tracker.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>POPULATE_EP</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>POPULATE_EXPIRATION_PROFILE</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>envImpl</color>
            <color=#f8f8f2>.</color><color=#a6e22e>getExpirationProfile</color><color=#f8f8f2>()</color>
            <color=#f8f8f2>.</color><color=#a6e22e>populateCache</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>POPULATE_EP</color><color=#f8f8f2>),</color>
                <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getRecoveryProgressListener</color><color=#f8f8f2>());</color>

        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>POPULATE_EP</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Transfer recovery utilization info to the global tracker. */</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>transferToUtilizationTracker</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getUtilizationTracker</color><color=#f8f8f2>());</color>

      <color=#75715e>/*</color>
<color=#75715e>       * After utilization info is complete and prior to the checkpoint,</color>
<color=#75715e>       * remove all temporary databases encountered during recovery.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>removeTempDbs</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * For truncate/remove NameLNs with no corresponding deleted MapLN</color>
<color=#75715e>       * found, delete the MapLNs now.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>deleteMapLNs</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Execute any replication initialization that has to happen before</color>
<color=#75715e>       * the checkpoint.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>preRecoveryCheckpointInit</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * At this point, we've recovered (or there were no log files at</color>
<color=#75715e>       * all). Write a checkpoint into the log.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>readOnly</color>
          <color=#f92672>&&</color> <color=#f8f8f2>((</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLastLsnAtRecovery</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color><color=#f8f8f2>)</color>
              <color=#f92672>||</color> <color=#f8f8f2>forceCheckpoint</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>CheckpointConfig</color> <color=#f8f8f2>config</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>CheckpointConfig</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>setForce</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>setMinimizeRecoveryTime</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>CKPT</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>CKPT</color><color=#f8f8f2>);</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>invokeCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>,</color> <color=#e6db74>"recovery"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DiskLimitException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>WARNING</color><color=#f8f8f2>,</color>
              <color=#e6db74>"Recovery checkpoint failed due to disk limit"</color>
                  <color=#f92672>+</color> <color=#e6db74>" violation but environment can still service reads: "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setStats</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>CKPT</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCheckpointer</color><color=#f8f8f2>().</color><color=#a6e22e>loadStats</color><color=#f8f8f2>(</color><color=#f8f8f2>StatsConfig</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>CKPT</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Initialize intervals when there is no initial checkpoint. */</color>
        <color=#f8f8f2>envImpl</color>
            <color=#f8f8f2>.</color><color=#a6e22e>getCheckpointer</color><color=#f8f8f2>()</color>
            <color=#f8f8f2>.</color><color=#a6e22e>initIntervals</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>IOException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLogException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"RecoveryManager"</color><color=#f8f8f2>,</color> <color=#e6db74>"recover"</color><color=#f8f8f2>,</color> <color=#e6db74>"Couldn't recover"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_READ</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>TOTAL_RECOVERY</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>info</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Find the end of the log, initialize the FileManager. While we're perusing the log, return the</color>
<color=#75715e>   * last checkpoint LSN if we happen to see it.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>findEndOfLog</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>readOnly</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_END_OF_LOG</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_END_OF_LOG</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Counter</color> <color=#f8f8f2>counter</color> <color=#f92672>=</color> <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_END_OF_LOG</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>LastFileReader</color> <color=#f8f8f2>reader</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LastFileReader</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Tell the reader to iterate through the log file until we hit the end</color>
<color=#75715e>     * of the log or an invalid entry.  Remember the last seen CkptEnd, and</color>
<color=#75715e>     * the first CkptStart with no following CkptEnd.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>readNextEntry</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumRead</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumProcessed</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>LogEntryType</color> <color=#f8f8f2>type</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getEntryType</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_CKPT_END</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>type</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>partialCheckpointStartLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_CKPT_START</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>type</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>partialCheckpointStartLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>partialCheckpointStartLsn</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_DBTREE</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>type</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useRootLsn</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_IMMUTABLE_FILE</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>type</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>forceNewLogFile</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_RESTORE_REQUIRED</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>type</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * This log entry is a marker that indicates that the log is</color>
<color=#75715e>         * considered corrupt in some way, and recovery should not</color>
<color=#75715e>         * proceed. Some external action has to happen to obtain new</color>
<color=#75715e>         * log files that are coherent and can be recovered.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>handleRestoreRequired</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getRestoreRequired</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The last valid LSN should point to the start of the last valid log</color>
<color=#75715e>     * entry, while the end of the log should point to the first byte of</color>
<color=#75715e>     * blank space, so these two should not be the same.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastValidLsn</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getEndOfLog</color><color=#f8f8f2>())</color>
        <color=#f8f8f2>:</color> <color=#e6db74>"lastUsed="</color>
            <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastValidLsn</color><color=#f8f8f2>())</color>
            <color=#f92672>+</color> <color=#e6db74>" end="</color>
            <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getEndOfLog</color><color=#f8f8f2>());</color>

    <color=#75715e>/* Now truncate if necessary. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>readOnly</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>setEndOfFile</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Tell the fileManager where the end of the log is. */</color>
    <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>lastUsedLsn</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastValidLsn</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>nextAvailableLsn</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getEndOfLog</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>setRepeatIteratorReads</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>envImpl</color>
        <color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>()</color>
        <color=#f8f8f2>.</color><color=#a6e22e>setLastPosition</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>nextAvailableLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>lastUsedLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getPrevOffset</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_END_OF_LOG</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Find the last checkpoint and establish the firstActiveLsn point, checkpoint start, and</color>
<color=#75715e>   * checkpoint end.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>findLastCheckpoint</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_LAST_CKPT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_LAST_CKPT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Counter</color> <color=#f8f8f2>counter</color> <color=#f92672>=</color> <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_LAST_CKPT</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The checkpointLsn might have been already found when establishing</color>
<color=#75715e>     * the end of the log.  If it was found, then partialCheckpointStartLsn</color>
<color=#75715e>     * was also found.  If it was not found, search backwards for it now</color>
<color=#75715e>     * and also set partialCheckpointStartLsn.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Search backwards though the log for a checkpoint end entry and a</color>
<color=#75715e>       * root entry.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>CheckpointFileReader</color> <color=#f8f8f2>searcher</color> <color=#f92672>=</color>
          <color=#66d9ef>new</color> <color=#f8f8f2>CheckpointFileReader</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
              <color=#66d9ef>false</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>lastUsedLsn</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>nextAvailableLsn</color><color=#f8f8f2>);</color>

      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>searcher</color><color=#f8f8f2>.</color><color=#a6e22e>readNextEntry</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumRead</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumProcessed</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Continue iterating until we find a checkpoint end entry.</color>
<color=#75715e>         * While we're at it, remember the last root seen in case we</color>
<color=#75715e>         * don't find a checkpoint end entry.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searcher</color><color=#f8f8f2>.</color><color=#a6e22e>isCheckpointEnd</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * We're done, the checkpoint end will tell us where the</color>
<color=#75715e>           * root is.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color> <color=#f92672>=</color> <color=#f8f8f2>searcher</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searcher</color><color=#f8f8f2>.</color><color=#a6e22e>isCheckpointStart</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Remember the first CkptStart following the CkptEnd.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>partialCheckpointStartLsn</color> <color=#f92672>=</color> <color=#f8f8f2>searcher</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searcher</color><color=#f8f8f2>.</color><color=#a6e22e>isDbTree</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Save the last root that was found in the log in case we</color>
<color=#75715e>           * don't see a checkpoint.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useRootLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useRootLsn</color> <color=#f92672>=</color> <color=#f8f8f2>searcher</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>setRepeatIteratorReads</color><color=#f8f8f2>(</color><color=#f8f8f2>searcher</color><color=#f8f8f2>.</color><color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If we haven't found a checkpoint, we'll have to recover without</color>
<color=#75715e>     * one. At a minimium, we must have found a root.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>firstActiveLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Read in the checkpoint entry. */</color>
      <color=#f8f8f2>CheckpointEnd</color> <color=#f8f8f2>checkpointEnd</color> <color=#f92672>=</color>
          <color=#f8f8f2>(</color><color=#f8f8f2>CheckpointEnd</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>getEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEnd</color> <color=#f92672>=</color> <color=#f8f8f2>checkpointEnd</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color> <color=#f92672>=</color> <color=#f8f8f2>checkpointEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getCheckpointStartLsn</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>firstActiveLsn</color> <color=#f92672>=</color> <color=#f8f8f2>checkpointEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getFirstActiveLsn</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Use the last checkpoint root only if there is no later root.</color>
<color=#75715e>       * The latest root has the correct per-DB utilization info.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>checkpointEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getRootLsn</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#f92672>&&</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useRootLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useRootLsn</color> <color=#f92672>=</color> <color=#f8f8f2>checkpointEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getRootLsn</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Init the checkpointer's id sequence.*/</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCheckpointer</color><color=#f8f8f2>().</color><color=#a6e22e>setCheckpointId</color><color=#f8f8f2>(</color><color=#f8f8f2>checkpointEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Let the rollback tracker know where the checkpoint start is.</color>
<color=#75715e>     * Rollback periods before the checkpoint start do not need to be</color>
<color=#75715e>     * processed.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>rollbackTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setCheckpointStart</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_LAST_CKPT</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useRootLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_INTEGRITY</color><color=#f8f8f2>,</color>
          <color=#e6db74>"This environment's log file has no root. Since the root "</color>
              <color=#f92672>+</color> <color=#e6db74>"is the first entry written into a log at environment "</color>
              <color=#f92672>+</color> <color=#e6db74>"creation, this should only happen if the initial creation "</color>
              <color=#f92672>+</color> <color=#e6db74>"of the environment was never checkpointed or synced. "</color>
              <color=#f92672>+</color> <color=#e6db74>"Please move aside the existing log files to allow the "</color>
              <color=#f92672>+</color> <color=#e6db74>"creation of a new environment"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Should be called when performing operations that may add to the cache, but only after all INs</color>
<color=#75715e>   * are in place and buildINList has been called.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>invokeEvictor</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * To prevent eviction from violating disk limits we must periodically</color>
<color=#75715e>     * freshen the log size stats. (Since the cleaner isn't running.)</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>nOpsSinceDiskLimitRecalc</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nOpsSinceDiskLimitRecalc</color> <color=#f92672>==</color> <color=#ae81ff>1000</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCleaner</color><color=#f8f8f2>().</color><color=#a6e22e>freshenLogSizeStats</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>nOpsSinceDiskLimitRecalc</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>invokeEvictor</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Use the log to recreate an in memory tree. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>buildTree</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>BUILD_TREE</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Read all map database INs, find largest node ID before any</color>
<color=#75715e>       * possibility of splits, find largest txn Id before any need for a</color>
<color=#75715e>       * root update (which would use an AutoTxn)</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>buildINs</color><color=#f8f8f2>(</color>
          <color=#66d9ef>true</color> <color=#75715e>/*mappingTree*/</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>READ_MAP_INS</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_MAP_INS</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>READ_DBMAP_INFO</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_DBMAP_INFO</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Undo all aborted map LNs. Read and remember all committed,</color>
<color=#75715e>       * prepared, and replicated transaction ids, to prepare for the</color>
<color=#75715e>       * redo phases.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>UNDO_MAP_LNS</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>UNDO_DBMAP_RECORDS</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>LogEntryType</color><color=#f92672>></color> <color=#f8f8f2>mapLNSet</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
      <color=#f8f8f2>mapLNSet</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_TXN_COMMIT</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>mapLNSet</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_TXN_ABORT</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>mapLNSet</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_TXN_PREPARE</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>mapLNSet</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_ROLLBACK_START</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>mapLNSet</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_ROLLBACK_END</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>undoLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>mapLNSet</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*firstUndoPass*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>UNDO_MAP_LNS</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>UNDO_MAP_LNS</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Start file cache warmer after we have read the log from</color>
<color=#75715e>       * firstActiveLsn forward. From here forward, recovery should be</color>
<color=#75715e>       * reading from the file system cache, so another reading thread</color>
<color=#75715e>       * should not cause disk head movement.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>startFileCacheWarmer</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>firstActiveLsn</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Replay all mapLNs, mapping tree in place now. Use the set of</color>
<color=#75715e>       * committed txns, replicated and prepared txns found from the undo</color>
<color=#75715e>       * pass.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_MAP_LNS</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_DBMAP_RECORDS</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>mapLNSet</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>mapLNSet</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_MAPLN</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>redoLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>mapLNSet</color><color=#f8f8f2>,</color> <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_MAP_LNS</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_MAP_LNS</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * When the mapping DB is complete, check for log version 8 upgrade</color>
<color=#75715e>       * violations. Will throw an exception if there is a violation.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>checkLogVersion8UpgradeViolations</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Reconstruct the internal nodes for the main level trees.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>buildINs</color><color=#f8f8f2>(</color>
          <color=#66d9ef>false</color> <color=#75715e>/*mappingTree*/</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>READ_INS</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_INS</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>READ_DATA_INFO</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_DATA_INFO</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Build the in memory IN list.  Now that the INs are complete we</color>
<color=#75715e>       * can add the environment to the evictor (for a shared cache) and</color>
<color=#75715e>       * invoke the evictor.  The evictor will also be invoked during the</color>
<color=#75715e>       * undo and redo passes.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>buildINList</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSharedCache</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEvictor</color><color=#f8f8f2>().</color><color=#a6e22e>addEnvironment</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>invokeEvictor</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Undo aborted LNs. No need to include TxnAbort, TxnCommit,</color>
<color=#75715e>       * TxnPrepare, RollbackStart and RollbackEnd records again, since</color>
<color=#75715e>       * those were scanned during the the undo of all aborted MapLNs.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>UNDO_LNS</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>UNDO_DATA_RECORDS</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>LogEntryType</color><color=#f92672>></color> <color=#f8f8f2>lnSet</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color> <color=#f8f8f2>entryType</color> <color=#f8f8f2>:</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>getAllTypes</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entryType</color><color=#f8f8f2>.</color><color=#a6e22e>isLNType</color><color=#f8f8f2>()</color>
            <color=#f92672>&&</color> <color=#f8f8f2>entryType</color><color=#f8f8f2>.</color><color=#a6e22e>isTransactional</color><color=#f8f8f2>()</color>
            <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>entryType</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_MAPLN_TRANSACTIONAL</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>lnSet</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>entryType</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>undoLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>lnSet</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*firstUndoPass*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>UNDO_LNS</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>UNDO_LNS</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Replay LNs. Also read non-transactional LNs. */</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_LNS</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_DATA_RECORDS</color><color=#f8f8f2>);</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color> <color=#f8f8f2>entryType</color> <color=#f8f8f2>:</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>getAllTypes</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entryType</color><color=#f8f8f2>.</color><color=#a6e22e>isLNType</color><color=#f8f8f2>()</color>
            <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>entryType</color><color=#f8f8f2>.</color><color=#a6e22e>isTransactional</color><color=#f8f8f2>()</color>
            <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>entryType</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_MAPLN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>lnSet</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>entryType</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>redoLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>lnSet</color><color=#f8f8f2>,</color> <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_LNS</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REDO_LNS</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>rollbackTracker</color><color=#f8f8f2>.</color><color=#a6e22e>recoveryEndFsyncInvisible</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>BUILD_TREE</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Perform two passes for the INs of a given level. Root INs must be processed first to account</color>
<color=#75715e>   * for splits/compressions that were done during/after a checkpoint [#14424] [#24663].</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Splits and compression require logging up to the root of the tree, to ensure that all INs</color>
<color=#75715e>   * are properly returned to the correct position at recovery. In other words, splits and</color>
<color=#75715e>   * compression ensure that the creation and deletion of all nodes is promptly logged.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>However, checkpoints are not propagated to the top of the tree, in order to conserve on</color>
<color=#75715e>   * logging. Because of that, a great-aunt situation can occur, where an ancestor of a given node</color>
<color=#75715e>   * can be logged without referring to the latest on-disk position of the node, because that</color>
<color=#75715e>   * ancestor was part of a split or compression.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Take this scenario: Root-A / \ IN-B IN-C / / | \ BIN-D / LN-E</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>1) LN-E is logged, BIN-D is dirtied 2) BIN-D is logged during a checkpoint, IN-B is dirtied</color>
<color=#75715e>   * 3) IN-C is split and Root-A is logged 4) We recover using Root-A and the BIN-D logged at (2) is</color>
<color=#75715e>   * lost</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>At (3) when Root-A is logged, it points to an IN-B on disk that does not point to the most</color>
<color=#75715e>   * recent BIN-D</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>At (4) when we recover, although we will process the BIN-D logged at (2) and splice it into</color>
<color=#75715e>   * the tree, the Root-A logged at (3) is processed last and overrides the entire subtree</color>
<color=#75715e>   * containing BIN-D</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This could be addressed by always logging to the root at every checkpoint. Barring that, we</color>
<color=#75715e>   * address it by replaying the root INs first, and then all non-root INs.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>It is important that no IN is replayed that would cause a fetch of an older IN version which</color>
<color=#75715e>   * has been replaced by a newer version in the checkpoint interval. If the newer version were</color>
<color=#75715e>   * logged as the result of log cleaning, and we attempt to fetch the older version, this would</color>
<color=#75715e>   * cause a LOG_FILE_NOT_FOUND exception. The replay of the root INs in the first pass is safe,</color>
<color=#75715e>   * because it won't cause a fetch [#24663]. The replay of INs in the second pass is safe because</color>
<color=#75715e>   * only nodes at maxFlushLevel were logged non-provisionally and only these nodes are replayed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param mappingTree if true, we're building the mapping tree</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>buildINs</color><color=#f8f8f2>(</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>mappingTree</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Phase</color> <color=#f8f8f2>phaseA</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Phase</color> <color=#f8f8f2>phaseB</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RecoveryProgress</color> <color=#f8f8f2>progressA</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RecoveryProgress</color> <color=#f8f8f2>progressB</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Pass a: Replay root INs.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>phaseA</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>progressA</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mappingTree</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>readRootINsAndTrackIds</color><color=#f8f8f2>(</color><color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>phaseA</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>readRootINs</color><color=#f8f8f2>(</color><color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>phaseA</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>phaseA</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Pass b: Replay non-root INs.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>phaseB</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>progressB</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>readNonRootINs</color><color=#f8f8f2>(</color><color=#f8f8f2>mappingTree</color><color=#f8f8f2>,</color> <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>phaseB</color><color=#f8f8f2>));</color>

    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>phaseB</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Read root INs in the mapping tree DB and place in the in-memory tree.</color>
<color=#75715e>   *</color>
<color=#75715e>   * Also peruse all pertinent log entries in order to update our knowledge</color>
<color=#75715e>   * of the last used database, transaction and node ids, and to to track</color>
<color=#75715e>   * utilization profile and VLSN->LSN mappings.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>readRootINsAndTrackIds</color><color=#f8f8f2>(</color><color=#f8f8f2>Counter</color> <color=#f8f8f2>counter</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>INFileReader</color> <color=#f8f8f2>reader</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>INFileReader</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color><color=#f8f8f2>,</color> <color=#75715e>// start lsn</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>nextAvailableLsn</color><color=#f8f8f2>,</color> <color=#75715e>// finish lsn</color>
            <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#75715e>// track ids</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>partialCheckpointStartLsn</color><color=#f8f8f2>,</color> <color=#75715e>// partialCkptStart</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color><color=#f8f8f2>,</color> <color=#75715e>// ckptEnd</color>
            <color=#f8f8f2>tracker</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>logVersion8UpgradeDbs</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>logVersion8UpgradeDeltas</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>addTargetType</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_IN</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Validate all entries in at least one full recovery pass. */</color>
    <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>setAlwaysValidateChecksum</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbMapTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Process every IN and BIN in the mapping tree. */</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>readNextEntry</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumRead</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabaseId</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>dbId</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>DbTree</color><color=#f8f8f2>.</color><color=#a6e22e>ID_DB_ID</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>db</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color> <color=#75715e>// mapping DB is always available</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getIN</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>).</color><color=#a6e22e>isRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>replayOneIN</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumProcessed</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>setRepeatIteratorReads</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>());</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Update node ID, database ID, and txn ID sequences. Use either</color>
<color=#75715e>       * the maximum of the IDs seen by the reader vs. the IDs stored in</color>
<color=#75715e>       * the checkpoint.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedNodeId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getMinReplicatedNodeId</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxNodeId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getMaxNodeId</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedDbId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getMinReplicatedDbId</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxDbId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getMaxDbId</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedTxnId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getMinReplicatedTxnId</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxTxnId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getMaxTxnId</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEnd</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>CheckpointEnd</color> <color=#f8f8f2>ckptEnd</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEnd</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedNodeId</color> <color=#f92672>></color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastReplicatedNodeId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedNodeId</color> <color=#f92672>=</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastReplicatedNodeId</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxNodeId</color> <color=#f92672><</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLocalNodeId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxNodeId</color> <color=#f92672>=</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLocalNodeId</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedDbId</color> <color=#f92672>></color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastReplicatedDbId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedDbId</color> <color=#f92672>=</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastReplicatedDbId</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxDbId</color> <color=#f92672><</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLocalDbId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxDbId</color> <color=#f92672>=</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLocalDbId</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedTxnId</color> <color=#f92672>></color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastReplicatedTxnId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedTxnId</color> <color=#f92672>=</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastReplicatedTxnId</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxTxnId</color> <color=#f92672><</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLocalTxnId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxTxnId</color> <color=#f92672>=</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLocalTxnId</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeSequence</color><color=#f8f8f2>().</color><color=#a6e22e>setLastNodeId</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedNodeId</color><color=#f8f8f2>,</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxNodeId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>().</color><color=#a6e22e>setLastDbId</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedDbId</color><color=#f8f8f2>,</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxDbId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnManager</color><color=#f8f8f2>().</color><color=#a6e22e>setLastTxnId</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMinReplicatedTxnId</color><color=#f8f8f2>,</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>useMaxTxnId</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>vlsnProxy</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNProxy</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>traceAndThrowException</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>(),</color> <color=#e6db74>"readMapIns"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Read root INs for DBs other than the mapping tree, and process. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>readRootINs</color><color=#f8f8f2>(</color><color=#f8f8f2>Counter</color> <color=#f8f8f2>counter</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Don't need to track IDs. */</color>
    <color=#f8f8f2>INFileReader</color> <color=#f8f8f2>reader</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>INFileReader</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color><color=#f8f8f2>,</color> <color=#75715e>// start lsn</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>nextAvailableLsn</color><color=#f8f8f2>,</color> <color=#75715e>// finish lsn</color>
            <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#75715e>// track ids</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>partialCheckpointStartLsn</color><color=#f8f8f2>,</color> <color=#75715e>// partialCkptStart</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color><color=#f8f8f2>,</color> <color=#75715e>// ckptEnd</color>
            <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// tracker</color>

    <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>addTargetType</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_IN</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Read all non-provisional INs, and process if they don't belong</color>
<color=#75715e>       * to the mapping tree.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbMapTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>

      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>readNextEntry</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumRead</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabaseId</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>DbTree</color><color=#f8f8f2>.</color><color=#a6e22e>ID_DB_ID</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* This db has been deleted, ignore the entry. */</color>
          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumDeleted</color><color=#f8f8f2>();</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getIN</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>).</color><color=#a6e22e>isRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>replayOneIN</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumProcessed</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>setRepeatIteratorReads</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>traceAndThrowException</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>(),</color> <color=#e6db74>"readNonMapIns"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Read non-root INs and process. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>readNonRootINs</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>mappingTree</color><color=#f8f8f2>,</color> <color=#f8f8f2>Counter</color> <color=#f8f8f2>counter</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Don't need to track IDs. */</color>
    <color=#f8f8f2>INFileReader</color> <color=#f8f8f2>reader</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>INFileReader</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color><color=#f8f8f2>,</color> <color=#75715e>// start lsn</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>nextAvailableLsn</color><color=#f8f8f2>,</color> <color=#75715e>// finish lsn</color>
            <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#75715e>// track ids</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>partialCheckpointStartLsn</color><color=#f8f8f2>,</color> <color=#75715e>// partialCkptStart</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color><color=#f8f8f2>,</color> <color=#75715e>// ckptEnd</color>
            <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// tracker</color>

    <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>addTargetType</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_IN</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>addTargetType</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_BIN</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>addTargetType</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_BIN_DELTA</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>addTargetType</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_OLD_BIN_DELTA</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/* Read all non-provisional INs that are in the repeat set. */</color>
      <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbMapTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>

      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>readNextEntry</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumRead</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabaseId</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mappingTree</color> <color=#f92672>!=</color> <color=#f8f8f2>dbId</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>DbTree</color><color=#f8f8f2>.</color><color=#a6e22e>ID_DB_ID</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* This db has been deleted, ignore the entry. */</color>
          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumDeleted</color><color=#f8f8f2>();</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getIN</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>).</color><color=#a6e22e>isRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>replayOneIN</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumProcessed</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>setRepeatIteratorReads</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>traceAndThrowException</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>(),</color> <color=#e6db74>"readNonMapIns"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Get an IN from the reader, set its database, and fit into tree. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>replayOneIN</color><color=#f8f8f2>(</color><color=#f8f8f2>INFileReader</color> <color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Last entry is a node, replay it. Now, we should really call</color>
<color=#75715e>     * IN.postFetchInit, but we want to do something different from the</color>
<color=#75715e>     * faulting-in-a-node path, because we don't want to put the IN on the</color>
<color=#75715e>     * in memory list, and we don't want to search the db map tree, so we</color>
<color=#75715e>     * have a IN.postRecoveryInit.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getIN</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>postRecoveryInit</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>recoverIN</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Add any db that we encounter IN's for because they will be part of</color>
<color=#75715e>     * the in-memory tree and therefore should be included in the INList</color>
<color=#75715e>     * build.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>inListBuildDbIds</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Recover an internal node.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>inFromLog should be latched upon entering this method and it will not be latched upon</color>
<color=#75715e>   * exiting.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param inFromLog - the new node to put in the tree. The identifier key and node ID are used to</color>
<color=#75715e>   *     find the existing version of the node.</color>
<color=#75715e>   * @param logLsn - the location of log entry in in the log.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>recoverIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>TrackingInfo</color><color=#f92672>></color> <color=#f8f8f2>trackingList</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We must know a priori if this node is the root. We can't infer</color>
<color=#75715e>       * that status from a search of the existing tree, because</color>
<color=#75715e>       * splitting the root is done by putting a node above the old root.</color>
<color=#75715e>       * A search downward would incorrectly place the new root below the</color>
<color=#75715e>       * existing tree.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>inFromLog</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>recoverRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Look for a parent. The call to getParentNode unlatches node.</color>
<color=#75715e>         * Then place inFromLog in the tree if appropriate.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>trackingList</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ArrayList</color><color=#f92672><></color><color=#f8f8f2>();</color>
        <color=#f8f8f2>recoverChildIN</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>trackingList</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentFailureException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Pass through untouched. */</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>String</color> <color=#f8f8f2>trace</color> <color=#f92672>=</color> <color=#f8f8f2>printTrackList</color><color=#f8f8f2>(</color><color=#f8f8f2>trackingList</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLogException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color>
          <color=#e6db74>"RecoveryManager"</color><color=#f8f8f2>,</color>
          <color=#e6db74>"recoverIN"</color><color=#f8f8f2>,</color>
          <color=#e6db74>" lsnFromLog: "</color> <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>logLsn</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#e6db74>" "</color> <color=#f92672>+</color> <color=#f8f8f2>trace</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>e</color><color=#f8f8f2>);</color>

      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_INTEGRITY</color><color=#f8f8f2>,</color>
          <color=#e6db74>"lsnFromLog="</color> <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>logLsn</color><color=#f8f8f2>),</color>
          <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color>
            <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#e6db74>"LSN = "</color> <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>(</color><color=#f8f8f2>logLsn</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#e6db74>" inFromLog = "</color> <color=#f92672>+</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * If the root of this tree is null, use this IN from the log as a root. Note that we should</color>
<color=#75715e>   * really also check the LSN of the mapLN, because perhaps the root is null because it's been</color>
<color=#75715e>   * deleted. However, the replay of all the LNs will end up adjusting the tree correctly.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If there is a root, check if this IN is a different LSN and if so, replace it.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>recoverRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>Tree</color> <color=#f8f8f2>tree</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>RootUpdater</color> <color=#f8f8f2>rootUpdater</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RootUpdater</color><color=#f8f8f2>(</color><color=#f8f8f2>tree</color><color=#f8f8f2>,</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Run the root updater while the root latch is held. */</color>
      <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>withRootLatchedExclusive</color><color=#f8f8f2>(</color><color=#f8f8f2>rootUpdater</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Update the mapLN if necessary */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootUpdater</color><color=#f8f8f2>.</color><color=#a6e22e>updateDone</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Dirty the database to call DbTree.modifyDbRoot later during</color>
<color=#75715e>         * the checkpoint.  We should not log a DatabaseImpl until its</color>
<color=#75715e>         * utilization info is correct.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>setDirty</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_INTEGRITY</color><color=#f8f8f2>,</color>
          <color=#e6db74>"lsnFromLog="</color> <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>),</color>
          <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootUpdater</color><color=#f8f8f2>.</color><color=#a6e22e>getInFromLogIsLatched</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>inFromLog</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>trace</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>TRACE_ROOT_REPLACE</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>success</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color>
          <color=#66d9ef>null</color><color=#f8f8f2>,</color>
          <color=#66d9ef>true</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>rootUpdater</color><color=#f8f8f2>.</color><color=#a6e22e>getReplaced</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>rootUpdater</color><color=#f8f8f2>.</color><color=#a6e22e>getInserted</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>rootUpdater</color><color=#f8f8f2>.</color><color=#a6e22e>getOriginalLsn</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color>
          <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * RootUpdater lets us replace the tree root within the tree root latch.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>RootUpdater</color> <color=#66d9ef>implements</color> <color=#f8f8f2>WithRootLatched</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Tree</color> <color=#f8f8f2>tree</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>inserted</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>replaced</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>originalLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>inFromLogIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>RootUpdater</color><color=#f8f8f2>(</color><color=#f8f8f2>Tree</color> <color=#f8f8f2>tree</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>tree</color> <color=#f92672>=</color> <color=#f8f8f2>tree</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>inFromLog</color> <color=#f92672>=</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>getInFromLogIsLatched</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>inFromLogIsLatched</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#f8f8f2>IN</color> <color=#a6e22e>doWork</color><color=#f8f8f2>(</color><color=#f8f8f2>ChildReference</color> <color=#f8f8f2>root</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>ChildReference</color> <color=#f8f8f2>newRoot</color> <color=#f92672>=</color> <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>makeRootChildReference</color><color=#f8f8f2>(</color><color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>0</color><color=#f92672>]</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>inFromLog</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>inFromLogIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>setRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>newRoot</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>inserted</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>originalLsn</color> <color=#f92672>=</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>();</color> <color=#75715e>// for debugLog</color>

        <color=#75715e>/*</color>
<color=#75715e>         * The current in-memory root IN is older than the root IN from</color>
<color=#75715e>         * the log.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>originalLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>setRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>newRoot</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>replaced</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>updateDone</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>inserted</color> <color=#f92672>||</color> <color=#f8f8f2>replaced</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>getInserted</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>inserted</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>getReplaced</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>replaced</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#a6e22e>getOriginalLsn</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>originalLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Recovers a non-root IN. See algorithm below.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Note that this method never inserts a slot for an IN, it only replaces the node in a slot</color>
<color=#75715e>   * under certain conditions. Insertion of slots is unnecessary because splits are logged all the</color>
<color=#75715e>   * way to the root, and therefore inserted slots are always visible via the parent node. In fact,</color>
<color=#75715e>   * it is critical that splits are not allowed during this phase of recovery, because that might</color>
<color=#75715e>   * require splits and logging is not allowed until the INs are all in place.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>recoverChildIN</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>TrackingInfo</color><color=#f92672>></color> <color=#f8f8f2>trackingList</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>replaced</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>treeLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>finished</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>SearchResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>SearchResult</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>targetNodeId</color> <color=#f92672>=</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>();</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>targetKey</color> <color=#f92672>=</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>.</color><color=#a6e22e>getIdentifierKey</color><color=#f8f8f2>();</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>exclusiveLevel</color> <color=#f92672>=</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>inFromLog</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>result</color> <color=#f92672>=</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>()</color>
              <color=#f8f8f2>.</color><color=#a6e22e>getParentINForChildIN</color><color=#f8f8f2>(</color>
                  <color=#f8f8f2>targetNodeId</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>targetKey</color><color=#f8f8f2>,</color>
                  <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#75715e>/*targetLevel*/</color>
                  <color=#f8f8f2>exclusiveLevel</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>true</color> <color=#75715e>/*requireExactMatch*/</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#75715e>/*doFetch*/</color>
                  <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>trackingList</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Does inFromLog exist in this parent?</color>
<color=#75715e>       *</color>
<color=#75715e>       * 1. IN is not in the current tree. Skip this IN; it's represented</color>
<color=#75715e>       *    by a parent that's later in the log or it has been deleted.</color>
<color=#75715e>       *    This works because splits and IN deleteions are logged</color>
<color=#75715e>       *    immediately when they occur all the way up to the root.</color>
<color=#75715e>       * 2. physical match: (LSNs same) this LSN is already in place,</color>
<color=#75715e>       *    do nothing.</color>
<color=#75715e>       * 3. logical match: another version of this IN is in place.</color>
<color=#75715e>       *    Replace child with inFromLog if inFromLog's LSN is greater.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>finished</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color> <color=#75715e>// case 1,</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>;</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>idx</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>;</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>exactParentFound</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetNodeId</color> <color=#f92672>==</color> <color=#f8f8f2>((</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>)).</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>

      <color=#75715e>/* Get the key that will locate inFromLog in this parent. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* case 2: do nothing */</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* Not an exact physical match, now need to look at child. */</color>
        <color=#f8f8f2>treeLsn</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>

        <color=#75715e>/* case 3: It's a logical match, replace */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>treeLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * It's a logical match, replace. Put the child</color>
<color=#75715e>           * node reference into the parent, as well as the</color>
<color=#75715e>           * true LSN of the IN or BIN-delta.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>recoverIN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color> <color=#75715e>/*lastLoggedSize*/</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>replaced</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>finished</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>trace</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>TRACE_IN_REPLACE</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>finished</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>inFromLog</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>exactParentFound</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>replaced</color><color=#f8f8f2>,</color>
          <color=#66d9ef>false</color> <color=#75715e>/*inserted*/</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>treeLsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Undo all LNs that belong to aborted transactions. These are LNs in the log that (1) don't</color>
<color=#75715e>   * belong to a committed txn AND (2) aren't part of a prepared txn AND (3) shouldn't be</color>
<color=#75715e>   * resurrected as part of a replication ReplayTxn.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>LNs that are part of a rollback period do need to be undone, but in a different way from the</color>
<color=#75715e>   * other LNs. They are rolledback and take a different path.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>To find these LNs, walk the log backwards, using log entry commit record to create a</color>
<color=#75715e>   * collection of committed txns. If we see a log entry that doesn't fit the criteria above, undo</color>
<color=#75715e>   * it.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param firstUndoPass is true if this is the first time that undoLNs is called. This is a little</color>
<color=#75715e>   *     awkward, but is done to explicitly indicate to the rollback tracker that this is the</color>
<color=#75715e>   *     tracker's construction phase. During this first pass, RollbackStart and RollbackEnd are in</color>
<color=#75715e>   *     the target log types, and the rollback period map is created. We thought that it was better</color>
<color=#75715e>   *     to be explicit than to reply on checking the logTypes parameter to see if</color>
<color=#75715e>   *     RollbackStart/RollbackEnd is included.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>undoLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>LogEntryType</color><color=#f92672>></color> <color=#f8f8f2>logTypes</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>firstUndoPass</color><color=#f8f8f2>,</color> <color=#f8f8f2>Counter</color> <color=#f8f8f2>counter</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>firstActiveLsn</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>firstActiveLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>lastUsedLsn</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>lastUsedLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>endOfFileLsn</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>nextAvailableLsn</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Set up a reader to pick up target log entries from the log. */</color>
    <color=#f8f8f2>LNFileReader</color> <color=#f8f8f2>reader</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>LNFileReader</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>lastUsedLsn</color><color=#f8f8f2>,</color>
            <color=#66d9ef>false</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>endOfFileLsn</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>firstActiveLsn</color><color=#f8f8f2>,</color>
            <color=#66d9ef>null</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color> <color=#f8f8f2>lt</color> <color=#f8f8f2>:</color> <color=#f8f8f2>logTypes</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>addTargetType</color><color=#f8f8f2>(</color><color=#f8f8f2>lt</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbMapTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * See RollbackTracker.java for details on replication rollback</color>
<color=#75715e>     * periods.  Standalone recovery must handle replication rollback at</color>
<color=#75715e>     * recovery, because we might be opening a replicated environment in a</color>
<color=#75715e>     * read-only, non-replicated way for use by a command line utility.</color>
<color=#75715e>     * Even though the utility will not write invisible bits, it will need</color>
<color=#75715e>     * to ensure that all btree nodes are in the proper state, and reflect</color>
<color=#75715e>     * any rollback related changes.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Note that when opening a read-only environment, because we cannot</color>
<color=#75715e>     * write invisible bits, we may end up redo'ing LNs in rolled back txns</color>
<color=#75715e>     * that should be marked invisible.  This is very unlikely, but should</color>
<color=#75715e>     * be fixed at some point by using the LSNs collected by</color>
<color=#75715e>     * RollbackTracker to determine whether a log entry should be treated</color>
<color=#75715e>     * as invisible by redo.  See [#23708].</color>
<color=#75715e>     *</color>
<color=#75715e>     * The rollbackScanner is a sort of cursor that acts with the known</color>
<color=#75715e>     * state of the rollback period detection.</color>
<color=#75715e>     *</color>
<color=#75715e>     * We let the tracker know if it is the first pass or not, in order</color>
<color=#75715e>     * to support some internal tracker assertions.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>rollbackTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setFirstPass</color><color=#f8f8f2>(</color><color=#f8f8f2>firstUndoPass</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Scanner</color> <color=#f8f8f2>rollbackScanner</color> <color=#f92672>=</color> <color=#f8f8f2>rollbackTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getScanner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Iterate over the target LNs and commit records, constructing the</color>
<color=#75715e>       * tree.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>readNextEntry</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumRead</color><color=#f8f8f2>();</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>isLN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#75715e>/* Get the txnId from the log entry. */</color>
          <color=#f8f8f2>Long</color> <color=#f8f8f2>txnId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnId</color><color=#f8f8f2>();</color>

          <color=#75715e>/* Skip past this, no need to undo non-txnal LNs. */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>txnId</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rollbackScanner</color><color=#f8f8f2>.</color><color=#a6e22e>positionAndCheck</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>(),</color> <color=#f8f8f2>txnId</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#75715e>/*</color>
<color=#75715e>             * If an LN is in the rollback period and was part of a</color>
<color=#75715e>             * rollback, let the rollback scanner decide how it</color>
<color=#75715e>             * should be handled. This does not include LNs that</color>
<color=#75715e>             * were explicitly aborted.</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>rollbackScanner</color><color=#f8f8f2>.</color><color=#a6e22e>rollback</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>,</color> <color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>);</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/* This LN is part of a committed txn. */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>committedTxnIds</color><color=#f8f8f2>.</color><color=#a6e22e>containsKey</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/* This LN is part of a prepared txn. */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>preparedTxns</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>resurrectedLsns</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>());</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/*</color>
<color=#75715e>           * This LN is part of a uncommitted, unaborted</color>
<color=#75715e>           * replicated txn.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isReplicatedUncommittedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>txnId</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>createReplayTxn</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>resurrectedLsns</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>());</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>undoUncommittedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumProcessed</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>isPrepare</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>handlePrepare</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumAux</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>isAbort</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* The entry just read is an abort record. */</color>
          <color=#f8f8f2>abortedTxnIds</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnAbortId</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumAux</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>isCommit</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Sanity check that the commit does not interfere with the</color>
<color=#75715e>           * rollback period. Since the reader includes commits only</color>
<color=#75715e>           * on the first pass, the cost of the check is confined to</color>
<color=#75715e>           * that pass, and is very low if there is no rollback</color>
<color=#75715e>           * period.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>rollbackTracker</color><color=#f8f8f2>.</color><color=#a6e22e>checkCommit</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>(),</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnCommitId</color><color=#f8f8f2>());</color>

          <color=#f8f8f2>committedTxnIds</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnCommitId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumAux</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>isRollbackStart</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>rollbackTracker</color><color=#f8f8f2>.</color><color=#a6e22e>register</color><color=#f8f8f2>((</color><color=#f8f8f2>RollbackStart</color><color=#f8f8f2>)</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getMainItem</color><color=#f8f8f2>(),</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumAux</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>isRollbackEnd</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>rollbackTracker</color><color=#f8f8f2>.</color><color=#a6e22e>register</color><color=#f8f8f2>((</color><color=#f8f8f2>RollbackEnd</color><color=#f8f8f2>)</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getMainItem</color><color=#f8f8f2>(),</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumAux</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"LNreader should not have picked up type "</color> <color=#f92672>+</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>dumpCurrentHeader</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#75715e>/* while */</color>
      <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>setRepeatIteratorReads</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>rollbackTracker</color><color=#f8f8f2>.</color><color=#a6e22e>singlePassSetInvisible</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>RuntimeException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>traceAndThrowException</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>(),</color> <color=#e6db74>"undoLNs"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Uncommitted, unaborted LNs that belong to a replicated txn are resurrected rather than undone.</color>
<color=#75715e>   * This means that the LN is also replicated.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isReplicatedUncommittedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>LNFileReader</color> <color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>Long</color> <color=#f8f8f2>txnId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This only applies if the environment is replicated AND the entry is</color>
<color=#75715e>     * in a replicated txn. If a replicated environment is opened by a read</color>
<color=#75715e>     * only command line utility, it will be opened in a non-replicated</color>
<color=#75715e>     * way, and we don't want to resurrect the txn and acquire write locks.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isReplicated</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>abortedTxnIds</color><color=#f8f8f2>.</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>entryIsReplicated</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * When recovering a replicated environment, all uncommitted, replicated transactions are</color>
<color=#75715e>   * resurrected much the same way as a prepared transaction. If the node turns out to be a new</color>
<color=#75715e>   * master, by definition those txns won't resume, and the code path for new master setup will</color>
<color=#75715e>   * abort these transactions. If the node is a replica, the transactions will either resume or</color>
<color=#75715e>   * abort depending on whether the originating master is alive or not.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>createReplayTxn</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>txnId</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If we didn't see this transaction yet, create a ReplayTxn</color>
<color=#75715e>     * to use in the later redo stage, when we redo and resurrect</color>
<color=#75715e>     * this transaction.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>replayTxns</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>replayTxns</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>createReplayTxn</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The entry just read is a prepare record. Setup a PrepareTxn that will exempt any of its</color>
<color=#75715e>   * uncommitted LNs from undo. Instead, uncommitted LNs that belong to a PrepareTxn are redone.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>handlePrepare</color><color=#f8f8f2>(</color><color=#f8f8f2>LNFileReader</color> <color=#f8f8f2>reader</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>prepareId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnPrepareId</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>Long</color> <color=#f8f8f2>prepareIdL</color> <color=#f92672>=</color> <color=#f8f8f2>prepareId</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>committedTxnIds</color><color=#f8f8f2>.</color><color=#a6e22e>containsKey</color><color=#f8f8f2>(</color><color=#f8f8f2>prepareIdL</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>abortedTxnIds</color><color=#f8f8f2>.</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#f8f8f2>prepareIdL</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>TransactionConfig</color> <color=#f8f8f2>txnConf</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TransactionConfig</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>PreparedTxn</color> <color=#f8f8f2>preparedTxn</color> <color=#f92672>=</color> <color=#f8f8f2>PreparedTxn</color><color=#f8f8f2>.</color><color=#a6e22e>createPreparedTxn</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>txnConf</color><color=#f8f8f2>,</color> <color=#f8f8f2>prepareId</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * There should be no lock conflicts during recovery, but just in</color>
<color=#75715e>       * case there are, we set the locktimeout to 0.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>preparedTxn</color><color=#f8f8f2>.</color><color=#a6e22e>setLockTimeout</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>preparedTxns</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>prepareIdL</color><color=#f8f8f2>,</color> <color=#f8f8f2>preparedTxn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>preparedTxn</color><color=#f8f8f2>.</color><color=#a6e22e>setPrepared</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnManager</color><color=#f8f8f2>().</color><color=#a6e22e>registerXATxn</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnPrepareXid</color><color=#f8f8f2>(),</color> <color=#f8f8f2>preparedTxn</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>INFO</color><color=#f8f8f2>,</color>
          <color=#e6db74>"Found unfinished prepare record: id: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnPrepareId</color><color=#f8f8f2>()</color>
              <color=#f92672>+</color> <color=#e6db74>" Xid: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnPrepareXid</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Found an uncommitted LN, set up the work to undo the LN. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>undoUncommittedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>LNFileReader</color> <color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Invoke the evictor to reduce memory consumption. */</color>
    <color=#f8f8f2>invokeEvictor</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabaseId</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Database may be null if it's been deleted. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>lnEntry</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLNLogEntry</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>postFetchInit</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getLN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>TreeLocation</color> <color=#f8f8f2>location</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TreeLocation</color><color=#f8f8f2>();</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>postFetchInit</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>recoveryUndo</color><color=#f8f8f2>(</color><color=#f8f8f2>location</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Undo utilization info. */</color>
      <color=#f8f8f2>undoUtilizationInfo</color><color=#f8f8f2>(</color><color=#f8f8f2>lnEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastEntrySize</color><color=#f8f8f2>());</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Add any db that we encounter LN's for because they'll be</color>
<color=#75715e>       * part of the in-memory tree and therefore should be included</color>
<color=#75715e>       * in the INList build.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>inListBuildDbIds</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * For temporary DBs that are encountered as MapLNs, add them</color>
<color=#75715e>       * to the set of databases to be removed.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>MapLN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>MapLN</color> <color=#f8f8f2>mapLN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>MapLN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ln</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mapLN</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>isTemporary</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>tempDbIds</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>mapLN</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>getId</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Undo the changes to this node. Here are the rules that govern the action taken.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <pre></color>
<color=#75715e>   *</color>
<color=#75715e>   * found LN in  | abortLsn is | logLsn ==       | action taken</color>
<color=#75715e>   *    tree      | null        | LSN in tree     | by undo</color>
<color=#75715e>   * -------------+-------------+----------------------------------------</color>
<color=#75715e>   *      Y       |     N       |      Y          | replace w/abort LSN</color>
<color=#75715e>   * ------------ +-------------+-----------------+-----------------------</color>
<color=#75715e>   *      Y       |     Y       |      Y          | remove from tree</color>
<color=#75715e>   * ------------ +-------------+-----------------+-----------------------</color>
<color=#75715e>   *      Y       |     N/A     |      N          | no action</color>
<color=#75715e>   * ------------ +-------------+-----------------+-----------------------</color>
<color=#75715e>   *      N       |     N/A     |    N/A          | no action (*)</color>
<color=#75715e>   * (*) If this key is not present in the tree, this record doesn't</color>
<color=#75715e>   * reflect the IN state of the tree and this log entry is not applicable.</color>
<color=#75715e>   *</color>
<color=#75715e>   * </pre></color>
<color=#75715e>   *</color>
<color=#75715e>   * @param location holds state about the search in the tree. Passed in from the recovery manager</color>
<color=#75715e>   *     to reduce objection creation overhead.</color>
<color=#75715e>   * @param logLsn is the LSN from the just-read log entry</color>
<color=#75715e>   *     <p>Undo can take place for regular recovery, for aborts, and for recovery rollback</color>
<color=#75715e>   *     processing. Each flavor has some slight differences, and are factored out below.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>recoveryUndo</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>TreeLocation</color> <color=#f8f8f2>location</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>lnEntry</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>undo</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINE</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortLsn</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortKnownDeleted</color><color=#f8f8f2>(),</color>
        <color=#66d9ef>false</color> <color=#75715e>/*revertPD*/</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortKey</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortData</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortVLSN</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortExpiration</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>isAbortExpirationInHours</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>abortUndo</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Level</color> <color=#f8f8f2>traceLevel</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>TreeLocation</color> <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>lnEntry</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>undo</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>traceLevel</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortLsn</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortKnownDeleted</color><color=#f8f8f2>(),</color>
        <color=#66d9ef>false</color> <color=#75715e>/*revertPD*/</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortKey</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortData</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortVLSN</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortExpiration</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>isAbortExpirationInHours</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>rollbackUndo</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Level</color> <color=#f8f8f2>traceLevel</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>TreeLocation</color> <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>lnEntry</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>undoLsn</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RevertInfo</color> <color=#f8f8f2>revertTo</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>undo</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>traceLevel</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>undoLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>revertTo</color><color=#f8f8f2>.</color><color=#a6e22e>revertLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>revertTo</color><color=#f8f8f2>.</color><color=#a6e22e>revertKD</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>revertTo</color><color=#f8f8f2>.</color><color=#a6e22e>revertPD</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>revertTo</color><color=#f8f8f2>.</color><color=#a6e22e>revertKey</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>revertTo</color><color=#f8f8f2>.</color><color=#a6e22e>revertData</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>revertTo</color><color=#f8f8f2>.</color><color=#a6e22e>revertVLSN</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>revertTo</color><color=#f8f8f2>.</color><color=#a6e22e>revertExpiration</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>revertTo</color><color=#f8f8f2>.</color><color=#a6e22e>revertExpirationInHours</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>undo</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Level</color> <color=#f8f8f2>traceLevel</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>TreeLocation</color> <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>lnEntry</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>revertLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>revertKD</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>revertPD</color><color=#f8f8f2>,</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>revertKey</color><color=#f8f8f2>,</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>revertData</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>revertVLSN</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>revertExpiration</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>revertExpirationInHours</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>found</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>replaced</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/* Find the BIN which is the parent of this LN. */</color>
      <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>reset</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>found</color> <color=#f92672>=</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>()</color>
              <color=#f8f8f2>.</color><color=#a6e22e>getParentBINForChildLN</color><color=#f8f8f2>(</color>
                  <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(),</color>
                  <color=#66d9ef>false</color> <color=#75715e>/*splitsAllowed*/</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>false</color> <color=#75715e>/*blindDeltaOps*/</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>found</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* This LN is in the tree. See if it needs replacing. */</color>
        <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>slotIdx</color> <color=#f92672>=</color> <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>;</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>slotLsn</color> <color=#f92672>=</color> <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>childLsn</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>slotLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Slots can exist and have a NULL_LSN as the result of an</color>
<color=#75715e>           * undo of an insertion that was done without slot reuse.</color>
<color=#75715e>           *</color>
<color=#75715e>           * We must be sure not to compare the NULL_LSN against the</color>
<color=#75715e>           * valid LSN, lest we get a NPE.  [#17427] [#17578]</color>
<color=#75715e>           *</color>
<color=#75715e>           * To be really sure, check that the location is truly</color>
<color=#75715e>           * empty, just as an assertion safety check.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>slotIdx</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>slotIdx</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>location</color>
                    <color=#f92672>+</color> <color=#e6db74>" has a NULL_LSN but the "</color>
                    <color=#f92672>+</color> <color=#e6db74>"slot is not empty. KD="</color>
                    <color=#f92672>+</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>slotIdx</color><color=#f8f8f2>)</color>
                    <color=#f92672>+</color> <color=#e6db74>" PD="</color>
                    <color=#f92672>+</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>slotIdx</color><color=#f8f8f2>));</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>queueSlotDeletion</color><color=#f8f8f2>(</color><color=#f8f8f2>slotIdx</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>boolean</color> <color=#f8f8f2>updateEntry</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>slotLsn</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>updateEntry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#66d9ef>int</color> <color=#f8f8f2>revertLogrecSize</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>revertLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>slotIdx</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>revertData</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>revertLogrecSize</color> <color=#f92672>=</color> <color=#f8f8f2>fetchLNSize</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>revertLsn</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>recoverRecord</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>slotIdx</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>revertLsn</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>revertKD</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>revertPD</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>revertKey</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>revertData</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>revertVLSN</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>revertLogrecSize</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>revertExpiration</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>revertExpirationInHours</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>replaced</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>        * Because we undo before we redo, the record may not be in</color>
<color=#75715e>        * the tree, even if it were in the tree when the write op</color>
<color=#75715e>        * reflected by the current logrec was performed.</color>
<color=#75715e>           } else {</color>
<color=#75715e>               assert(revertLsn == DbLsn.NULL_LSN || revertKD);</color>
<color=#75715e>           }</color>
<color=#75715e>        */</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>trace</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>traceLevel</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>TRACE_LN_UNDO</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>success</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getLN</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>found</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>replaced</color><color=#f8f8f2>,</color>
          <color=#66d9ef>false</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>childLsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>revertLsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Redo all LNs that should be revived. That means - all committed LNs - all prepared LNs - all</color>
<color=#75715e>   * uncommitted, replicated LNs on a replicated node.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>redoLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>LogEntryType</color><color=#f92672>></color> <color=#f8f8f2>lnTypes</color><color=#f8f8f2>,</color> <color=#f8f8f2>Counter</color> <color=#f8f8f2>counter</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>endOfFileLsn</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>nextAvailableLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>firstActiveLsn</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>firstActiveLsn</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Set up a reader to pick up target log entries from the log.</color>
<color=#75715e>     *</color>
<color=#75715e>     * There are 2 RedoLNs passes.</color>
<color=#75715e>     *</color>
<color=#75715e>     * The 1st pass applies to the DbIdMap BTree only. Only LOG_MAPLN</color>
<color=#75715e>     * logrecs are  returned by the reader during this pass. All such</color>
<color=#75715e>     * logrecs are eligible for redo and will be processed further here.</color>
<color=#75715e>     *</color>
<color=#75715e>     * The 2nd pass applies to all other DB BTrees. The logrecs returned by</color>
<color=#75715e>     * the reader during this pass are all user-LN logrecs (transactional</color>
<color=#75715e>     * or not) plus LOG_NAMELN, LOG_NAMELN_TRANSACTIONAL, and</color>
<color=#75715e>     * LOG_FILESUMMARYLN. During this pass, for most logrecs we should only</color>
<color=#75715e>     * redo them if they start after the ckpt start LSN. However, there are</color>
<color=#75715e>     * two categories of logrecs that are not committed, but still need</color>
<color=#75715e>     * to be redone. These are logrecs that belong to 2PC txns that have</color>
<color=#75715e>     * been prepared, but still not committed) and logrecs that belong to</color>
<color=#75715e>     * replicated, uncommitted txns. These logrecs still need to be</color>
<color=#75715e>     * processed and can live in the log between the firstActive LSN and</color>
<color=#75715e>     * the checkpointStart LSN, so we start the LNFileReader at the First</color>
<color=#75715e>     * Active LSN.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>LNFileReader</color> <color=#f8f8f2>reader</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>LNFileReader</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>firstActiveLsn</color><color=#f8f8f2>,</color>
            <color=#66d9ef>true</color> <color=#75715e>/*forward*/</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>endOfFileLsn</color><color=#f8f8f2>,</color>
            <color=#66d9ef>null</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointEndLsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color> <color=#f8f8f2>lt</color> <color=#f8f8f2>:</color> <color=#f8f8f2>lnTypes</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>addTargetType</color><color=#f8f8f2>(</color><color=#f8f8f2>lt</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbMapTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>TreeLocation</color> <color=#f8f8f2>location</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TreeLocation</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Iterate over the target LNs and construct in-memory tree.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>readNextEntry</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumRead</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>RedoEligible</color> <color=#f8f8f2>eligible</color> <color=#f92672>=</color> <color=#f8f8f2>eligibleForRedo</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>eligible</color><color=#f8f8f2>.</color><color=#a6e22e>isEligible</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We're doing a redo. Invoke the evictor in this loop to</color>
<color=#75715e>         * reduce memory consumption.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>invokeEvictor</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabaseId</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>

        <color=#66d9ef>long</color> <color=#f8f8f2>logrecLsn</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Database may be null if it's been deleted. Only redo for</color>
<color=#75715e>         * existing databases.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumDeleted</color><color=#f8f8f2>();</color>

          <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>countObsoleteIfUncounted</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastEntrySize</color><color=#f8f8f2>(),</color> <color=#f8f8f2>dbId</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*trackOffset*/</color><color=#f8f8f2>);</color>

          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>logrec</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLNLogEntry</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>postFetchInit</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumProcessed</color><color=#f8f8f2>();</color>

          <color=#f8f8f2>redoOneLN</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbId</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>eligible</color><color=#f8f8f2>,</color> <color=#f8f8f2>location</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>setRepeatIteratorReads</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>());</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>traceAndThrowException</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>(),</color> <color=#e6db74>"redoLns"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * These categories of LNs are redone: - LNs from committed txns between the ckpt start and end of</color>
<color=#75715e>   * log - non-transactional LNs between the ckpt start and end of log - LNs from prepared txns</color>
<color=#75715e>   * between the first active LSN and end of log - LNs from replicated, uncommitted, unaborted txns</color>
<color=#75715e>   * between the first active LSN and end of log that are NOT invisible.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>LNs that are in a rollback part of the log are invisible and will not be redone.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>RedoEligible</color> <color=#a6e22e>eligibleForRedo</color><color=#f8f8f2>(</color><color=#f8f8f2>LNFileReader</color> <color=#f8f8f2>reader</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>isLN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>.</color><color=#a6e22e>NOT</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>isInvisible</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>.</color><color=#a6e22e>NOT</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * afterCheckpointStart indicates that we're processing log entries</color>
<color=#75715e>     * after the checkpoint start LSN.  We only process prepared or</color>
<color=#75715e>     * replicated resurrected txns before checkpoint start. After</color>
<color=#75715e>     * checkpoint start, we evaluate everything.  If there is no</color>
<color=#75715e>     * checkpoint, the beginning of the log is really the checkpoint start,</color>
<color=#75715e>     * and all LNs should be evaluated.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>afterCheckpointStart</color> <color=#f92672>=</color>
        <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color>
            <color=#f92672>||</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>(),</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * A transaction will be either prepared OR replayed OR will be a</color>
<color=#75715e>     * regular committed transaction. A transaction would never be in more</color>
<color=#75715e>     * than one of these sets.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>Long</color> <color=#f8f8f2>txnId</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnId</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>Txn</color> <color=#f8f8f2>preparedTxn</color> <color=#f92672>=</color> <color=#f8f8f2>preparedTxns</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Txn</color> <color=#f8f8f2>replayTxn</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>replayTxns</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>preparedTxn</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>(</color><color=#f8f8f2>preparedTxn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>replayTxn</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>(</color><color=#f8f8f2>replayTxn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>afterCheckpointStart</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>txnId</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* A non-txnal LN  after ckpt start is always redone. */</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>.</color><color=#a6e22e>ELIGIBLE_NON_TXNAL</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>Long</color> <color=#f8f8f2>commitLongLsn</color> <color=#f92672>=</color> <color=#f8f8f2>committedTxnIds</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>txnId</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>commitLongLsn</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* A committed LN after ckpt start is always redone. */</color>
          <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>(</color><color=#f8f8f2>commitLongLsn</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>.</color><color=#a6e22e>NOT</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* Packages eligibility info. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>RedoEligible</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isEligible</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Txn</color> <color=#f8f8f2>resurrectTxn</color><color=#f8f8f2>;</color> <color=#75715e>// either a prepared or a replay txn</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>commitLsn</color><color=#f8f8f2>;</color>

    <color=#66d9ef>static</color> <color=#f8f8f2>RedoEligible</color> <color=#f8f8f2>NOT</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#66d9ef>static</color> <color=#f8f8f2>RedoEligible</color> <color=#f8f8f2>ELIGIBLE_NON_TXNAL</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Used for eligible prepared and replicated, resurrected txns. */</color>
    <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>(</color><color=#f8f8f2>Txn</color> <color=#f8f8f2>resurrectTxn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>isEligible</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>resurrectTxn</color> <color=#f92672>=</color> <color=#f8f8f2>resurrectTxn</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>commitLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Used for eligible, committed LNs. */</color>
    <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>commitLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>isEligible</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>resurrectTxn</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>commitLsn</color> <color=#f92672>=</color> <color=#f8f8f2>commitLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>RedoEligible</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>eligible</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>isEligible</color> <color=#f92672>=</color> <color=#f8f8f2>eligible</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>resurrectTxn</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>commitLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>isNonTransactional</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>isEligible</color> <color=#f92672>&&</color> <color=#f8f8f2>commitLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#f92672>&&</color> <color=#f8f8f2>resurrectTxn</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>isCommitted</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>commitLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#f92672>||</color> <color=#f8f8f2>isNonTransactional</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Redo the LN and utilization info. LNs from prepared and replay txns are</color>
<color=#75715e>   * "resurrected" and also need to re-establish its write locks and undo</color>
<color=#75715e>   * information.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>redoOneLN</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>LNFileReader</color> <color=#f8f8f2>reader</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>logrec</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RedoEligible</color> <color=#f8f8f2>eligible</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>TreeLocation</color> <color=#f8f8f2>location</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>logrecSize</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastEntrySize</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getLN</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>postFetchInit</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>eligible</color><color=#f8f8f2>.</color><color=#a6e22e>resurrectTxn</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * This is a prepared or replay txn, so we need to reacquire the</color>
<color=#75715e>       * write lock as well as redoing the operation, in order to end up</color>
<color=#75715e>       * with an active txn.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>relock</color><color=#f8f8f2>(</color><color=#f8f8f2>eligible</color><color=#f8f8f2>.</color><color=#a6e22e>resurrectTxn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>treeLsn</color> <color=#f92672>=</color> <color=#f8f8f2>redo</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>location</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>eligible</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Add any db that we encounter LN's for because they'll be part of the</color>
<color=#75715e>     * in-memory tree and therefore should be included in the INList build.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>inListBuildDbIds</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Further processing of MapLNs:</color>
<color=#75715e>     * - For temporary DBs that are encountered as MapLNs, add them to the</color>
<color=#75715e>     *   set of databases to be removed.</color>
<color=#75715e>     * - For deleted MapLNs (truncated or removed DBs), redo utilization</color>
<color=#75715e>     *   counting by counting the entire database as obsolete.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>MapLN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>MapLN</color> <color=#f8f8f2>mapLN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>MapLN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ln</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mapLN</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>isTemporary</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>tempDbIds</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>mapLN</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>getId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mapLN</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>mapLN</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>countObsoleteDb</color><color=#f8f8f2>(</color><color=#f8f8f2>tracker</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * For committed truncate/remove NameLNs, we expect a deleted MapLN</color>
<color=#75715e>     * after it.  Maintain expectDeletedMapLNs to contain all DB IDs for</color>
<color=#75715e>     * which a deleted MapLN is not found.  [#20816]</color>
<color=#75715e>     * <p></color>
<color=#75715e>     * Note that we must use the new NameLNLogEntry operationType to</color>
<color=#75715e>     * identify truncate and remove ops, and to distinguish them from a</color>
<color=#75715e>     * rename (which also deletes the old NameLN) [#21537].</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>eligible</color><color=#f8f8f2>.</color><color=#a6e22e>resurrectTxn</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>NameLNLogEntry</color> <color=#f8f8f2>nameLNEntry</color> <color=#f92672>=</color> <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getNameLNLogEntry</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nameLNEntry</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>nameLNEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getOperationType</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>case</color> <color=#f8f8f2>REMOVE</color><color=#f8f8f2>:</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>nameLNEntry</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>NameLN</color> <color=#f8f8f2>nameLN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>NameLN</color><color=#f8f8f2>)</color> <color=#f8f8f2>nameLNEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getLN</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>expectDeletedMapLNs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>nameLN</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>());</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#66d9ef>case</color> <color=#f8f8f2>TRUNCATE</color><color=#f8f8f2>:</color>
            <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>truncateId</color> <color=#f92672>=</color> <color=#f8f8f2>nameLNEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getTruncateOldDbId</color><color=#f8f8f2>();</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>truncateId</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>expectDeletedMapLNs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>truncateId</color><color=#f8f8f2>);</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#66d9ef>default</color><color=#f8f8f2>:</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>treeLsnIsImmediatelyObsolete</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isLNImmediatelyObsolete</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>treeLsnIsImmediatelyObsolete</color> <color=#f92672>&&</color> <color=#f8f8f2>treeLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>treeLsnIsImmediatelyObsolete</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbedded</color> <color=#f92672>||</color> <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>isKD</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>redoUtilizationInfo</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logrec</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>reader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastEntrySize</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>treeLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>treeLsnIsImmediatelyObsolete</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>childLoggedSize</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>eligible</color><color=#f8f8f2>.</color><color=#a6e22e>commitLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>eligible</color><color=#f8f8f2>.</color><color=#a6e22e>isCommitted</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>db</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>trackReservedFileRecords</color><color=#f8f8f2>(</color><color=#f8f8f2>logrec</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>trackReservedFileRecords</color><color=#f8f8f2>(</color><color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>logrec</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_RESERVED_FILE_LN</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getLogType</color><color=#f8f8f2>())</color> <color=#f92672>||</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>Long</color> <color=#f8f8f2>file</color> <color=#f92672>=</color> <color=#f8f8f2>ReservedFileInfo</color><color=#f8f8f2>.</color><color=#a6e22e>entryToKey</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>()));</color>

    <color=#f8f8f2>ReservedFileInfo</color> <color=#f8f8f2>info</color> <color=#f92672>=</color> <color=#f8f8f2>ReservedFileInfo</color><color=#f8f8f2>.</color><color=#a6e22e>entryToObject</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>()));</color>

    <color=#f8f8f2>reservedFiles</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>file</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>reservedFileDbs</color><color=#f8f8f2>.</color><color=#a6e22e>addAll</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>dbIds</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Reacquire the write lock for the given LN, so we can end up with an</color>
<color=#75715e>   * active txn.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>relock</color><color=#f8f8f2>(</color><color=#f8f8f2>Txn</color> <color=#f8f8f2>txn</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>logrec</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>addLogInfo</color><color=#f8f8f2>(</color><color=#f8f8f2>logLsn</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We're reconstructing an unfinished transaction.  We know that there</color>
<color=#75715e>     * was a write lock on this LN since it exists in the log under this</color>
<color=#75715e>     * txnId.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LockResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color>
        <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>nonBlockingLock</color><color=#f8f8f2>(</color><color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>WRITE</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*jumpAheadOfWaiters*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>getLockGrant</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>LockGrantType</color><color=#f8f8f2>.</color><color=#a6e22e>DENIED</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Resurrected lock denied txn="</color>
              <color=#f92672>+</color> <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>()</color>
              <color=#f92672>+</color> <color=#e6db74>" logLsn="</color>
              <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>logLsn</color><color=#f8f8f2>)</color>
              <color=#f92672>+</color> <color=#e6db74>" abortLsn="</color>
              <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortLsn</color><color=#f8f8f2>()));</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Set abortLsn and database for utilization tracking.  We don't know</color>
<color=#75715e>     * lastLoggedSize, so a default will be used for utilization counting.</color>
<color=#75715e>     * This should not be common.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>setAbortInfo</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortLsn</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortKnownDeleted</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortKey</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortData</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortVLSN</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortExpiration</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>isAbortExpirationInHours</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>db</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>WriteLockInfo</color> <color=#f8f8f2>wli</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>getWriteLockInfo</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>wli</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Resurrected lock has no write info txn="</color>
              <color=#f92672>+</color> <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>()</color>
              <color=#f92672>+</color> <color=#e6db74>" logLsn="</color>
              <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>logLsn</color><color=#f8f8f2>)</color>
              <color=#f92672>+</color> <color=#e6db74>" abortLsn="</color>
              <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortLsn</color><color=#f8f8f2>()));</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>wli</color><color=#f8f8f2>.</color><color=#a6e22e>setAbortLogSize</color><color=#f8f8f2>(</color><color=#ae81ff>0</color> <color=#75715e>/*lastLoggedSize*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Redo a committed LN for recovery.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Let R and T be the record and locker associated with the current logrec L. Let TL be the</color>
<color=#75715e>   * logrec pointed to by the BIN slot for R (if any) just before the call to the redo() method on</color>
<color=#75715e>   * R. Let TT be the locker that wrote TL.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>R slot found | L vs TL | L is | action in tree | | deletion | --------------+--------</color>
<color=#75715e>   * +----------+------------------------ Y | L <= TL | | no action</color>
<color=#75715e>   * --------------+---------+----------+------------------------ Y | L > TL | N | replace w/log LSN</color>
<color=#75715e>   * --------------+---------+----------+------------------------ Y | L > TL | Y | replace w/log</color>
<color=#75715e>   * LSN, put | | | on compressor queue --------------+---------+----------+------------------------</color>
<color=#75715e>   * N | n/a | N | insert into tree --------------+---------+----------+------------------------ N |</color>
<color=#75715e>   * n/a | Y | no action --------------+---------+----------+------------------------</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param location Used to return to the caller info about the R slot found in the tree (if any)</color>
<color=#75715e>   *     before the slot is updated by this method. It is allocated once by the caller and reset by</color>
<color=#75715e>   *     this method; this way the overhead of object creation is avoided.</color>
<color=#75715e>   * @param logrec the LN logrec L that is being redone.</color>
<color=#75715e>   * @param logrecLsn the LSN of L.</color>
<color=#75715e>   * @param logrecSize the on-disk size of L.</color>
<color=#75715e>   * @return the LSN found in the tree, or NULL_LSN if the tree did not contain any slot for the</color>
<color=#75715e>   *     record.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>redo</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>TreeLocation</color> <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>logrec</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>logrecSize</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RedoEligible</color> <color=#f8f8f2>eligible</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>found</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>foundNotKD</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>replaced</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>inserted</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>configManager</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>LogEntryType</color> <color=#f8f8f2>logrecType</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getLogType</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>LN</color> <color=#f8f8f2>logrecLN</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getLN</color><color=#f8f8f2>();</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>logrecVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>logrecLN</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>();</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>isDeletion</color> <color=#f92672>=</color> <color=#f8f8f2>logrecLN</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>();</color>
    <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>logrecKey</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>();</color>
    <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>logrecData</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getEmbeddedData</color><color=#f8f8f2>();</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>abortLsn</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortLsn</color><color=#f8f8f2>();</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>abortKD</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortKnownDeleted</color><color=#f8f8f2>();</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>expiration</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>();</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>expirationInHours</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>();</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>treeLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Let RL be the logrec being replayed here. Let R and T be</color>
<color=#75715e>     * the record and the txn associated with RL.</color>
<color=#75715e>     *</color>
<color=#75715e>     * We say that RL is replayed "blindly" if the search for</color>
<color=#75715e>     * R's key in the tree lands on a BIN-delta, this delta does</color>
<color=#75715e>     * not contain R's key, and we don't mutate the delta to a</color>
<color=#75715e>     * full BIN to check if R is indeed in the tree or not;</color>
<color=#75715e>     * instead we just insert R in the delta.</color>
<color=#75715e>     *</color>
<color=#75715e>     * RL can be applied blindly only if RL is a "pure" insertion,</color>
<color=#75715e>     * i.e. RL is an insertion and R did not exist prior to T.</color>
<color=#75715e>     *</color>
<color=#75715e>     * A non-pure insertion (where R existed before T, it was</color>
<color=#75715e>     * deleted by T, and then reinserted by T) cannot be applied</color>
<color=#75715e>     * blindly, because if it were, it would generate a logrec</color>
<color=#75715e>     * with abortLSN == NULL, and if T were aborted, undoing the</color>
<color=#75715e>     * logrec with the NULL abortLSN would cause the loss of the</color>
<color=#75715e>     * pre-T version of R. So, to replay a non-pure insertion,</color>
<color=#75715e>     * we must check if a slot for R exists in the tree already,</color>
<color=#75715e>     * and if so, generate a new logrec with an abortLSN pointing</color>
<color=#75715e>     * to the pre-T version of R.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Updates and deletes cannot be replayed blindly either,</color>
<color=#75715e>     * because we wouldn't be able to generate logrecs with the</color>
<color=#75715e>     * correct abortLsn, nor count the previous version of R as</color>
<color=#75715e>     * obsolete.</color>
<color=#75715e>     *</color>
<color=#75715e>     * The condition (abortLsn == DbLsn.NULL_LSN || abortKD)</color>
<color=#75715e>     * guarantees that LN is a pure insertion.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>blindInsertions</color> <color=#f92672>=</color>
        <color=#f8f8f2>(</color><color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getBoolean</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>BIN_DELTA_BLIND_OPS</color><color=#f8f8f2>)</color>
            <color=#f92672>&&</color> <color=#f8f8f2>eligible</color><color=#f8f8f2>.</color><color=#a6e22e>isCommitted</color><color=#f8f8f2>()</color>
            <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isLNImmediatelyObsolete</color><color=#f8f8f2>()</color>
                <color=#f92672>||</color> <color=#f8f8f2>((</color><color=#f8f8f2>abortLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#f92672>||</color> <color=#f8f8f2>abortKD</color><color=#f8f8f2>)</color>
                    <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>logrecType</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_INS_LN_TRANSACTIONAL</color><color=#f8f8f2>)</color>
                        <color=#f92672>||</color> <color=#f8f8f2>logrecType</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_INS_LN</color><color=#f8f8f2>)))));</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Find the BIN which is the parent of this LN.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>reset</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>found</color> <color=#f92672>=</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>()</color>
              <color=#f8f8f2>.</color><color=#a6e22e>getParentBINForChildLN</color><color=#f8f8f2>(</color>
                  <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>logrecKey</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>true</color> <color=#75715e>/*splitsAllowed*/</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>blindInsertions</color> <color=#75715e>/*blindDeltaOps*/</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>found</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * There is no possible parent for this LN. This tree was</color>
<color=#75715e>         * probably compressed away.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>;</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>foundNotKD</color> <color=#f92672>=</color> <color=#f8f8f2>found</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>foundNotKD</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>treeLsn</color> <color=#f92672>=</color> <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>childLsn</color><color=#f8f8f2>;</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>lsnCmp</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>treeLsn</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * TL <= L</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsnCmp</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * If L is a deletion, make sure the KD and PD flags in the</color>
<color=#75715e>           * slot are set correctly. Specifically, if T is committed,</color>
<color=#75715e>           * set KD and clear PD (if set); otherwise set PD (we know</color>
<color=#75715e>           * KD is not set here).</color>
<color=#75715e>           */</color>
          <color=#66d9ef>boolean</color> <color=#f8f8f2>redoKD</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
          <color=#66d9ef>boolean</color> <color=#f8f8f2>redoPD</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isDeletion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>eligible</color><color=#f8f8f2>.</color><color=#a6e22e>resurrectTxn</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>redoPD</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>redoKD</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/*</color>
<color=#75715e>           * If TL < L apply L, i.e., replace the TL version with the</color>
<color=#75715e>           * newer L version. Do not attach the LN as a resident LN</color>
<color=#75715e>           * would consume too much memory.</color>
<color=#75715e>           *</color>
<color=#75715e>           * If TL == L we only need to take act if L is a committed</color>
<color=#75715e>           * deletion; in this case, we want to set the KD and clear</color>
<color=#75715e>           * the PD flag.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsnCmp</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>recoverRecord</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>index</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>redoKD</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>redoPD</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecKey</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecData</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecVLSN</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecSize</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>replaced</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isDeletion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>redoKD</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
              <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>
              <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/*</color>
<color=#75715e>           * If L is a deletion, put its slot on the compressor</color>
<color=#75715e>           * queue. Even when there is a resurrectTxn, it will</color>
<color=#75715e>           * not contain delete info ????.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isDeletion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>queueSlotDeletion</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>found</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>treeLsn</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * There is a KD slot with the record's key. If the current</color>
<color=#75715e>         * logrec is not a deletion, insert the record in the existing</color>
<color=#75715e>         * slot.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isDeletion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#f92672>||</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>treeLsn</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>recoverRecord</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>index</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
                <color=#66d9ef>false</color> <color=#75715e>/*KD*/</color><color=#f8f8f2>,</color>
                <color=#66d9ef>false</color> <color=#75715e>/*PD*/</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecKey</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecData</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecVLSN</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>logrecSize</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>inserted</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>queueSlotDeletion</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
          <color=#75715e>/*</color>
<color=#75715e>           * logecLsn cannot be > treeLsn, because the record must</color>
<color=#75715e>           * have been re-inserted between treeLsn and logrecLsn,</color>
<color=#75715e>           * in which case, the slot could not have been KD.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#f92672>||</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>treeLsn</color><color=#f8f8f2>)</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>blindInsertions</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>index</color> <color=#f92672>=</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>insertEntry1</color><color=#f8f8f2>(</color>
                <color=#66d9ef>null</color> <color=#75715e>/*ln*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecData</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*blindInsertion*/</color><color=#f8f8f2>);</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>((</color><color=#f8f8f2>index</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>INSERT_SUCCESS</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>inserted</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>index</color> <color=#f92672>&=</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>INSERT_SUCCESS</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>index</color> <color=#f92672>=</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecSize</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setCachedVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecVLSN</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If current logrec is a deletion set the KD flag to prevent</color>
<color=#75715e>         * fetching a cleaned LN (we know that the logrec is comitted).</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isDeletion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>eligible</color><color=#f8f8f2>.</color><color=#a6e22e>resurrectTxn</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * This LN's key is not in the tree. If the current logrec is</color>
<color=#75715e>         * not a deletion, insert the LN to the tree.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isDeletion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#f8f8f2>index</color> <color=#f92672>=</color>
              <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>insertEntry1</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecData</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*blindInsertion*/</color><color=#f8f8f2>);</color>

          <color=#66d9ef>assert</color> <color=#f8f8f2>((</color><color=#f8f8f2>index</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>INSERT_SUCCESS</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>inserted</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>index</color> <color=#f92672>&=</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>INSERT_SUCCESS</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>index</color> <color=#f92672>=</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>

          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecSize</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setCachedVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecVLSN</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We're about to cast away this instantiated LN. It may have</color>
<color=#75715e>       * registered for some portion of the memory budget, so free</color>
<color=#75715e>       * that now. Specifically, this would be true for the</color>
<color=#75715e>       * DbFileSummaryMap in a MapLN.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>logrecLN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseMemoryBudget</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>treeLsn</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>trace</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>TRACE_LN_REDO</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>success</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>logrecLN</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>foundNotKD</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>replaced</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>inserted</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>childLsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Update utilization info during redo.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Let R and T be the record and txn associated with the current logrec L. Let TL be the logrec</color>
<color=#75715e>   * pointed to by the BIN slot for R (if any) just before the call to the redo() method on R. Let</color>
<color=#75715e>   * TT be the txn that wrote TL. Let AL by the logrec whose LSN is stored as the abortLSN in L (if</color>
<color=#75715e>   * L.abortLsn != NULL).</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method considers whether L, TL, or AL should be counted as obsolete, and if so, it does</color>
<color=#75715e>   * the counting.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param logrec The deserialized logrec L that is being processed.</color>
<color=#75715e>   * @param logrecSize The on-disk size of L.</color>
<color=#75715e>   * @param logrecLsn The LSN of L.</color>
<color=#75715e>   * @param treeLsn The LSN of TL. Will be NULL_LSN if there was no R slot in the BTree, or the R</color>
<color=#75715e>   *     slot was a KD slot with a NULL_LSN.</color>
<color=#75715e>   * @param treeLsnIsImmediatelyObsolete True if (a) the DB is a dups DB with all immediatelly</color>
<color=#75715e>   *     obsolete LNs, or (b) treeLsn is NULL_LSN, or (c) TL is an embedded logrec (as indicated by</color>
<color=#75715e>   *     the embedded flag in the slot).</color>
<color=#75715e>   * @param treeLNLoggedSize The on-disk size of TL</color>
<color=#75715e>   * @param commitLsn The commitLSN of T, if T is a Txn that did commit.</color>
<color=#75715e>   * @param isCommitted True if T is non-transactional or a Txn that did commit.</color>
<color=#75715e>   * @param db The DatabaseImpl obj for the DB containing R.</color>
<color=#75715e>   *     <p>There are cases where we do not count the previous version of an LN as obsolete when</color>
<color=#75715e>   *     that obsolete LN occurs prior to the recovery interval. This happens when a later version</color>
<color=#75715e>   *     of the LN is current in the tree because its parent IN has been flushed non-provisionally</color>
<color=#75715e>   *     after it. The old version of the LN is not in the tree so we never encounter it during</color>
<color=#75715e>   *     recovery and cannot count it as obsolete. For example:</color>
<color=#75715e>   *     <p>100 LN-A checkpoint occurred (ckpt begin, flush, ckpt end) 200 LN-A 300 BIN parent of</color>
<color=#75715e>   *     200 400 IN parent of 300, non-provisional via a sync</color>
<color=#75715e>   *     <p>no utilization info is flushed no checkpoint crash and recover</color>
<color=#75715e>   *     <p>200 is the current LN-A in the tree. When we redo 200 we do not count anything as</color>
<color=#75715e>   *     obsolete because the log and tree LSNs are equal. 100 is never counted obsolete because it</color>
<color=#75715e>   *     is not in the recovery interval.</color>
<color=#75715e>   *     <p>The same thing occurs when a deleted LN is replayed and the old version is not found in</color>
<color=#75715e>   *     the tree because it was compressed and the IN was flushed non-provisionally.</color>
<color=#75715e>   *     <p>In these cases we may be able to count the abortLsn as obsolete but that would not work</color>
<color=#75715e>   *     for non-transactional entries.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>redoUtilizationInfo</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>logrec</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>logrecSize</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>treeLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>treeLsnIsImmediatelyObsolete</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>treeLNLoggedSize</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>commitLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>isCommitted</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the logrec is "immediately obsolete", L was counted as obsolete</color>
<color=#75715e>     * during normal processing and it should be counted here only if its</color>
<color=#75715e>     * obsoleteness was not made durable before the crash, i.e., if it is</color>
<color=#75715e>     * after the latest FSLN for the containing log file. No need to record</color>
<color=#75715e>     * L's LSN in the tracker, because the cleaner already knows that all</color>
<color=#75715e>     * immediately-obsolete logrecs are obsolete.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>isImmediatelyObsolete</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>countObsoleteIfUncounted</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>(),</color> <color=#66d9ef>false</color> <color=#75715e>/*trackOffset*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Nothing more to be done of immediatelly obsolete DBs. If the treeLsn</color>
<color=#75715e>     * or the abortLsn are before the ckpt start, then they are already</color>
<color=#75715e>     * counted as obsolete because utilization info is flushed just before</color>
<color=#75715e>     * ckpt end. And if they are after the ckpt start, then they have been</color>
<color=#75715e>     * processed earlier in this RedoLNs pass and as a result counted by</color>
<color=#75715e>     * the countObsoleteIfUncounted() call above.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isLNImmediatelyObsolete</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Determine whether to count the treeLsn or the logrecLsn obsolete. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>cmpLogLsnToTreeLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>treeLsn</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cmpLogLsnToTreeLsn</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * L < TL.</color>
<color=#75715e>         *</color>
<color=#75715e>         * In normal standalone recovery, if L < TL, we can assume</color>
<color=#75715e>         * that TL belongs to a committed txn. This is because the</color>
<color=#75715e>         * undo phase happened first, and any uncommitted lsns would</color>
<color=#75715e>         * have been removed from the tree. But for replicated and</color>
<color=#75715e>         * prepared txns, this assumption is not true; such txns</color>
<color=#75715e>         * may be committed or aborted later on. So, TL may belong to</color>
<color=#75715e>         * a later, uncommitted txn. [#17710] [#17022]</color>
<color=#75715e>         *</color>
<color=#75715e>         * L may be obsolete. It is obsolete iff:</color>
<color=#75715e>         *</color>
<color=#75715e>         * 1. it is immediately obsolete, or</color>
<color=#75715e>         * 2. TT is committed (we can check this by checking whether</color>
<color=#75715e>         *    TL is not among the resurrected LSNs), or</color>
<color=#75715e>         * 3. L is not the last logrec on R by T.</color>
<color=#75715e>         *</color>
<color=#75715e>         * L is not obsolete if TT is not committed and L is the last</color>
<color=#75715e>         * logrec on R by T. These conditions, together with the fact</color>
<color=#75715e>         * that L < TL imply that T != TT and L is the abortLsn of TT.</color>
<color=#75715e>         *</color>
<color=#75715e>         * We have already handled case 1 above. We cannot check for</color>
<color=#75715e>         * case 3, so we will conservatively assume L is indeed</color>
<color=#75715e>         * obsolete but record its LSN in the tracker only if we know</color>
<color=#75715e>         * for sure that it is obsolete, ie, if TT is committed.</color>
<color=#75715e>         *</color>
<color=#75715e>         * Notice also that if L is indeed obsolete, we cannot be</color>
<color=#75715e>         * sure which logrec caused L to become obsolete during</color>
<color=#75715e>         * normal processing. So, here we conservatively assume</color>
<color=#75715e>         * that it was TL that made L obsolete, and pass TL as the</color>
<color=#75715e>         * "lsn" param to countObsoleteIfUncounted(). This will</color>
<color=#75715e>         * result in double counting if (a) another logrec L',</color>
<color=#75715e>         * with L < L' < TL, made L obsolete, an FSLN for L's</color>
<color=#75715e>         * logfile was logged after L' and before TL, and no other</color>
<color=#75715e>         * FSLN for the that logfile was logged after TL.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>isImmediatelyObsolete</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>countObsoleteIfUncounted</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>treeLsn</color><color=#f8f8f2>,</color>
              <color=#66d9ef>null</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>fetchLNSize</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>),</color>
              <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>(),</color>
              <color=#f92672>!</color><color=#f8f8f2>resurrectedLsns</color><color=#f8f8f2>.</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#f8f8f2>treeLsn</color><color=#f8f8f2>)</color> <color=#75715e>/*trackOffset*/</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cmpLogLsnToTreeLsn</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * TL < L.</color>
<color=#75715e>         *</color>
<color=#75715e>         * Basically, the above discussion for the L < TL case applies</color>
<color=#75715e>         * here as well, with the roles of L and TL reversed.</color>
<color=#75715e>         *</color>
<color=#75715e>         * Notice that in this case, there cannot be another R logrec</color>
<color=#75715e>         * L' such that TL < L' < L. To see why, assume L' exists and</color>
<color=#75715e>         * consider these 2 cases: (a) L' > ckpt_start. Then L' was</color>
<color=#75715e>         * replayed earlier during the current RedoLNs pass, so at this</color>
<color=#75715e>         * time, TL must be L'. (b)  L' < ckpt_start. Then L' <= TL,</color>
<color=#75715e>         * because the ckpt writes all dirty BINs to the log and</color>
<color=#75715e>         * RedoINs is done before RedoLNs.</color>
<color=#75715e>         *</color>
<color=#75715e>         * The above observation implies that either T == TT or TL is</color>
<color=#75715e>         * the abortLSN of L. If TL == AL, then it is T's commit logrec</color>
<color=#75715e>         * that made TL obsolete during normal processing. However, here</color>
<color=#75715e>         * we pass L as the lsn param of countObsoleteIfUncounted().</color>
<color=#75715e>         * As explained below this can result in missing counting for</color>
<color=#75715e>         * a real obsolete logrec.</color>
<color=#75715e>         *</color>
<color=#75715e>         * If TL is immediatelly obsolete, it has been counted already,</color>
<color=#75715e>         * for the same reason described above in the case of</color>
<color=#75715e>         * db.isLNImmediatelyObsolete(). So, to avoid double counting,</color>
<color=#75715e>         * we don't attempt to count it here again.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>treeLsnIsImmediatelyObsolete</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>countObsoleteIfUncounted</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>treeLsn</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
              <color=#66d9ef>null</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>fetchLNSize</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>treeLNLoggedSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>treeLsn</color><color=#f8f8f2>),</color>
              <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>isCommitted</color> <color=#75715e>/*trackOffset*/</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The abortLSN is obsolete iff T is a committed txn. In fact, it is</color>
<color=#75715e>     * the commit logrec of T that makes abortLSN obsolete. So, we pass</color>
<color=#75715e>     * commitLSN as the "lsn" param to the countObsoleteIfUncounted()</color>
<color=#75715e>     * call below. However, to avoid excessive double-counting, we don't</color>
<color=#75715e>     * always call countObsoleteIfUncounted(AL, T-cmt). In relatively</color>
<color=#75715e>     * rare scenarios, this can result in failing to count AL as obsolete.</color>
<color=#75715e>     * Consider the following cases:</color>
<color=#75715e>     *</color>
<color=#75715e>     * TL < L</color>
<color=#75715e>     * -------</color>
<color=#75715e>     *</color>
<color=#75715e>     * If TL < L we don't call countObsoleteIfUncounted() on AL, because</color>
<color=#75715e>     * in most cases this has been done already during the current RedoLNs</color>
<color=#75715e>     * pass or AL was counted durably as obsolete during normal processing.</color>
<color=#75715e>     * The reasoning is as follows. As explained above, if TL < L, one of</color>
<color=#75715e>     * the following is true:</color>
<color=#75715e>     *</color>
<color=#75715e>     * (a) TL == AL.</color>
<color=#75715e>     *</color>
<color=#75715e>     *     TL/AL --- TT-cmt --- L --- (FSLN)? --- T-cmt</color>
<color=#75715e>     *</color>
<color=#75715e>     *     countObsoleteIfUncounted(TL, L) was called above. If FSLN</color>
<color=#75715e>     *     exists, this call did not count TL. However, FSLN does not</color>
<color=#75715e>     *     contain TL, because it is T-cmt that recorded TL as obsolete.</color>
<color=#75715e>     *     Therefore, assuming no other FSLN exists after T-cmt, we miss</color>
<color=#75715e>     *     counting TL by not calling countObsoleteIfUncounted(TL, T-cmt).</color>
<color=#75715e>     *</color>
<color=#75715e>     *     However, in most cases, there won't be any FSLN between L and</color>
<color=#75715e>     *     T-cmt, or there will be another FLSN after T-cmt. As a result,</color>
<color=#75715e>     *     the countObsoleteIfUncounted(TL, L) call suffices. Therefore,</color>
<color=#75715e>     *     we prefer to occasionally miss an abortLSN than doing too much</color>
<color=#75715e>     *     double counting.</color>
<color=#75715e>     *</color>
<color=#75715e>     * (b1) T == TT and TL < ckpt_start. In</color>
<color=#75715e>     *</color>
<color=#75715e>     *      AL --- TL --- ckpt-start --- L --- T-cmt --- (FSLN)?</color>
<color=#75715e>     *</color>
<color=#75715e>     *      TL and L have the same abortLSN and the same commitLSN. TL is</color>
<color=#75715e>     *      not processed during this RedoLNs pass, so unless an FSLN was</color>
<color=#75715e>     *      logged during normal processing after T-cmt, we miss counting</color>
<color=#75715e>     *      AL. Notice that an FSLN will exist if T-cmt occurs before</color>
<color=#75715e>     *      ckpt-end, which is the more common case.</color>
<color=#75715e>     *</color>
<color=#75715e>     * (b2) T == TT and TL > ckpt_start</color>
<color=#75715e>     *</color>
<color=#75715e>     *      ckpt-start --- TL --- L --- (FSLN-1)? --- T-cmt --- (FSLN)?</color>
<color=#75715e>     *</color>
<color=#75715e>     *      TL and L have the same abortLSN and the same commitLSN.</color>
<color=#75715e>     *      Furthermore, TL was processed during the current RedoLNs pass.</color>
<color=#75715e>     *      We assume that what ever was done about AL during the</color>
<color=#75715e>     *      processing of TL was correct and we don't repeat it.</color>
<color=#75715e>     *</color>
<color=#75715e>     * L < TL</color>
<color=#75715e>     * -------</color>
<color=#75715e>     *</color>
<color=#75715e>     * (a) ckpt_start --- AL --- L --- T-cmt --- (FSLN)? --- TL --- (FSLN)?</color>
<color=#75715e>     *</color>
<color=#75715e>     *     AL was processed earlier in this RedoLNs pass. When it was</color>
<color=#75715e>     *     processed, it was < TL, so countObsoleteIfUncounted(AL, TL)</color>
<color=#75715e>     *     was called. There is no reason to count again.</color>
<color=#75715e>     *</color>
<color=#75715e>     * (b) ckpt_start --- AL --- L --- TL --- (FSLN))? --- T-cmt --- (FSLN)?</color>
<color=#75715e>     *</color>
<color=#75715e>     *     AL was processed earlier in this RedoLNs pass. When it was</color>
<color=#75715e>     *     processed, it was < TL, so countObsoleteIfUncounted(AL, TL)</color>
<color=#75715e>     *     was called. To avoid double counting, we will not call</color>
<color=#75715e>     *     countObsoleteIfUncounted(AL, t-cmt). However, in this case</color>
<color=#75715e>     *     we will fail counting AL as obsolete if there is an FSLN</color>
<color=#75715e>     *     between TL and T-cmt and no FSLN after T-cmt.</color>
<color=#75715e>     *</color>
<color=#75715e>     * (c) AL --- ckpt_start --- L --- TL</color>
<color=#75715e>     *</color>
<color=#75715e>     *     In this case we call countObsoleteIfUncounted(AL, t-cmt)</color>
<color=#75715e>     *</color>
<color=#75715e>     * L == TL</color>
<color=#75715e>     * -------</color>
<color=#75715e>     *</color>
<color=#75715e>     * (a) ckpt_start --- AL --- L/TL --- (FSLN)? --- T-cmt --- (FSLN)?</color>
<color=#75715e>     *</color>
<color=#75715e>     *     Same as L < TL, case (b).</color>
<color=#75715e>     *</color>
<color=#75715e>     * (c) AL --- ckpt_start --- L --- TL</color>
<color=#75715e>     *</color>
<color=#75715e>     *     Same as L < TL, case (c).</color>
<color=#75715e>     *</color>
<color=#75715e>     * As usual, we should not count abortLSN as obsolete here if it is</color>
<color=#75715e>     * an immediatelly obsolete logrec (i.e. if abortKD == true or</color>
<color=#75715e>     * abortData != null).</color>
<color=#75715e>     */</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>abortLsn</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortLsn</color><color=#f8f8f2>();</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>abortKD</color> <color=#f92672>=</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortKnownDeleted</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>commitLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color>
        <color=#f92672>&&</color> <color=#f8f8f2>abortLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color>
        <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>abortKD</color>
        <color=#f92672>&&</color> <color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>getAbortData</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color>
          <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>treeLsn</color><color=#f8f8f2>)</color> <color=#f92672><=</color> <color=#ae81ff>0</color>
              <color=#f92672>&&</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>abortLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>checkpointStartLsn</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>countObsoleteIfUncounted</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>abortLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>commitLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>(),</color> <color=#66d9ef>true</color> <color=#75715e>/*trackOffset*/</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Update utilization info during recovery undo (not abort undo).</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Let R and T be the record and txn associated with the current logrec L. L is for sure</color>
<color=#75715e>   * obsolete. It may or may have been counted as such already. Consider the following cases:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>1. L is an immediately obsolete logrec. Then, L was counted as obsolete during normal</color>
<color=#75715e>   * processing and it should be counted here only if its obsoleteness was not made durable before</color>
<color=#75715e>   * the crash, i.e., if it is after the latest FSLN for the containing log file. No need to record</color>
<color=#75715e>   * L's LSN in the tracker, because L is immediately obsolete.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>2. L is not an immediately obsolete logrec.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>2.1. L is the last logrec for R by T. In this case, L was not counted as obsolete during</color>
<color=#75715e>   * normal processing. L is made obsolete here by the fact that it is undone.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>2.2 L is not the last logrec for R by T. In this case, L was counted as obsolete during</color>
<color=#75715e>   * normal processing it should be counted here only if its obsoleteness was not made durable</color>
<color=#75715e>   * before the crash.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Unfortunately, we cannot differentiate between cases 2.1 and 2.2, so the code below calls</color>
<color=#75715e>   * tracker.countObsoleteUnconditional() for both of those cases, which can result to some double</color>
<color=#75715e>   * counting in case 2.2. However, it is not very common for a txn to update the same record</color>
<color=#75715e>   * multiple times, so this should not be a big issue.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>undoUtilizationInfo</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>logrec</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>logrecSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logrec</color><color=#f8f8f2>.</color><color=#a6e22e>isImmediatelyObsolete</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>countObsoleteIfUncounted</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color>
          <color=#66d9ef>null</color> <color=#75715e>/*logEntryType*/</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>logrecSize</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>(),</color>
          <color=#66d9ef>false</color> <color=#75715e>/*trackOffset*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>countObsoleteUnconditional</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logrecLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*logEntryType*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>logrecSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>(),</color> <color=#66d9ef>true</color> <color=#75715e>/*trackOffset*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Fetches the LN to get its size only if necessary and so configured. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>fetchLNSize</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>size</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>size</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCleaner</color><color=#f8f8f2>().</color><color=#a6e22e>getFetchObsoleteSize</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LogEntryHeader</color> <color=#f8f8f2>header</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>getWholeLogEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>).</color><color=#a6e22e>getHeader</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>header</color><color=#f8f8f2>.</color><color=#a6e22e>getEntrySize</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>FileNotFoundException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Ignore errors if the file was cleaned. */</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Build the in memory inList with INs that have been made resident by the recovery process. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>buildINList</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>().</color><color=#a6e22e>enable</color><color=#f8f8f2>();</color> <color=#75715e>// enable INList</color>
    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEvictor</color><color=#f8f8f2>().</color><color=#a6e22e>setEnabled</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>().</color><color=#a6e22e>rebuildINListMapDb</color><color=#f8f8f2>();</color> <color=#75715e>// scan map db</color>

    <color=#75715e>/* For all the dbs that we read in recovery, scan for resident INs. */</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color> <color=#f8f8f2>:</color> <color=#f8f8f2>inListBuildDbIds</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* We already did the map tree, don't do it again. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>dbId</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>DbTree</color><color=#f8f8f2>.</color><color=#a6e22e>ID_DB_ID</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>().</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>/* Temp DBs will be removed, skip build. */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isTemporary</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>().</color><color=#a6e22e>rebuildINList</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>().</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Remove all temporary databases that were encountered as MapLNs during recovery undo/redo. A</color>
<color=#75715e>   * temp DB needs to be removed when it is not closed (closing a temp DB removes it) prior to a</color>
<color=#75715e>   * crash. We ensure that the MapLN for every open temp DBs is logged each checkpoint interval.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>removeTempDbs</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>start</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REMOVE_TEMP_DBS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>setProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>RecoveryProgress</color><color=#f8f8f2>.</color><color=#a6e22e>REMOVE_TEMP_DBS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Counter</color> <color=#f8f8f2>counter</color> <color=#f92672>=</color> <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getCounter</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REMOVE_TEMP_DBS</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbMapTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>BasicLocker</color> <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#f8f8f2>BasicLocker</color><color=#f8f8f2>.</color><color=#a6e22e>createBasicLocker</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*noWait*/</color><color=#f8f8f2>);</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>operationOk</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>tempDbId</color> <color=#f8f8f2>:</color> <color=#f8f8f2>tempDbIds</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumRead</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>tempDbId</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>dbMapTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color> <color=#75715e>// Decrement use count.</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>assert</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isTemporary</color><color=#f8f8f2>();</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumProcessed</color><color=#f8f8f2>();</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>().</color><color=#a6e22e>dbRemove</color><color=#f8f8f2>(</color><color=#f8f8f2>locker</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>(),</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>());</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbTree</color><color=#f8f8f2>.</color><color=#a6e22e>NeedRepLockerException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#75715e>/* Should never happen; db is never replicated. */</color>
              <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedException</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseNotFoundException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedException</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>counter</color><color=#f8f8f2>.</color><color=#a6e22e>incNumDeleted</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>operationOk</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Error</color> <color=#f8f8f2>E</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>invalidate</color><color=#f8f8f2>(</color><color=#f8f8f2>E</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>E</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>operationEnd</color><color=#f8f8f2>(</color><color=#f8f8f2>operationOk</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>startupTracker</color><color=#f8f8f2>.</color><color=#a6e22e>stop</color><color=#f8f8f2>(</color><color=#f8f8f2>Phase</color><color=#f8f8f2>.</color><color=#a6e22e>REMOVE_TEMP_DBS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For committed truncate/remove NameLNs with no corresponding deleted MapLN found, delete the</color>
<color=#75715e>   * MapLNs now. MapLNs are deleted by truncate/remove operations after logging the Commit, so it is</color>
<color=#75715e>   * possible that a crash occurs after logging the Commit of the NameLN, and before deleting the</color>
<color=#75715e>   * MapLN. [#20816]</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>deleteMapLNs</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>id</color> <color=#f8f8f2>:</color> <color=#f8f8f2>expectDeletedMapLNs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>().</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>id</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Delete the MapLN, count the DB obsolete, set the deleted</color>
<color=#75715e>       * state, and call releaseDb.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>finishDeleteProcessing</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Throws an EnvironmentFailureException if there is any Node entry that</color>
<color=#75715e>   * meets these qualifications:</color>
<color=#75715e>   * 1. It is in the recovery interval.</color>
<color=#75715e>   * 2. it belongs to a duplicate DB.</color>
<color=#75715e>   * 3. Its log version is less than 8.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>checkLogVersion8UpgradeViolations</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>EnvironmentFailureException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Previously during the initial INFileReader pass (for ID tracking) we</color>
<color=#75715e>     * collected a set of database IDs for every Node log entry in the</color>
<color=#75715e>     * recovery interval that has a log version less than 8. Now that the</color>
<color=#75715e>     * DbTree is complete we can check to see if any of these are in a</color>
<color=#75715e>     * duplicates DB.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>v8DupNodes</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color> <color=#f8f8f2>:</color> <color=#f8f8f2>logVersion8UpgradeDbs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If DB is null (deleted in the recovery interval), no</color>
<color=#75715e>         * conversion is needed because all entries for the DB will be</color>
<color=#75715e>         * discarded.  [#22203]</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>v8DupNodes</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>v8Deltas</color> <color=#f92672>=</color> <color=#f8f8f2>logVersion8UpgradeDeltas</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>v8DupNodes</color> <color=#f92672>||</color> <color=#f8f8f2>v8Deltas</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>illegalEntries</color> <color=#f92672>=</color> <color=#f8f8f2>v8DupNodes</color> <color=#f92672>?</color> <color=#e6db74>"JE 4.1 duplicate DB entries"</color> <color=#f8f8f2>:</color> <color=#e6db74>"JE 4.1 BINDeltas"</color><color=#f8f8f2>;</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>illegalEntries</color>
              <color=#f92672>+</color> <color=#e6db74>" were found in the recovery interval. "</color>
              <color=#f92672>+</color> <color=#e6db74>"Before upgrading to JE 5.0, the following utility "</color>
              <color=#f92672>+</color> <color=#e6db74>"must be run using JE 4.1 (4.1.20 or later): "</color>
              <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isReplicated</color><color=#f8f8f2>()</color> <color=#f92672>?</color> <color=#e6db74>"DbRepPreUpgrade_4_1 "</color> <color=#f8f8f2>:</color> <color=#e6db74>"DbPreUpgrade_4_1 "</color><color=#f8f8f2>)</color>
              <color=#f92672>+</color> <color=#e6db74>". See the change log."</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Dump a tracking list into a string. */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>String</color> <color=#a6e22e>printTrackList</color><color=#f8f8f2>(</color><color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>TrackingInfo</color><color=#f92672>></color> <color=#f8f8f2>trackingList</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>trackingList</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>Iterator</color><color=#f92672><</color><color=#f8f8f2>TrackingInfo</color><color=#f92672>></color> <color=#f8f8f2>iter</color> <color=#f92672>=</color> <color=#f8f8f2>trackingList</color><color=#f8f8f2>.</color><color=#a6e22e>iterator</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"Trace list:"</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>'\n'</color><color=#f8f8f2>);</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>hasNext</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>'\n'</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Send trace messages to the java.util.logger. Don't rely on the logger alone to conditionalize</color>
<color=#75715e>   * whether we send this message, we don't even want to construct the message if the level is not</color>
<color=#75715e>   * enabled. This is used to construct verbose trace messages for individual log entry processing.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>trace</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>database</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>String</color> <color=#f8f8f2>debugType</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Node</color> <color=#f8f8f2>node</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>found</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>replaced</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>inserted</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>replacedLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>abortLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>trace</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINE</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>database</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>debugType</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>success</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>node</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>parent</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>found</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>replaced</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>inserted</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>replacedLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>abortLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>index</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>trace</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Level</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>database</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>String</color> <color=#f8f8f2>debugType</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Node</color> <color=#f8f8f2>node</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>found</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>replaced</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>inserted</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>replacedLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>abortLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>Level</color> <color=#f8f8f2>useLevel</color> <color=#f92672>=</color> <color=#f8f8f2>level</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>useLevel</color> <color=#f92672>=</color> <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>SEVERE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>useLevel</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>debugType</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" success="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>success</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" node="</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(((</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>node</color><color=#f8f8f2>).</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" lsn="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>logLsn</color><color=#f8f8f2>));</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" parent="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" found="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>found</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" replaced="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>replaced</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" inserted="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>inserted</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>replacedLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" replacedLsn="</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>replacedLsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>abortLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" abortLsn="</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>abortLsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" index="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useLevel</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>SEVERE</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLog</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#f8f8f2>useLevel</color><color=#f8f8f2>,</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#f8f8f2>useLevel</color><color=#f8f8f2>,</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>traceAndThrowException</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>badLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>method</color><color=#f8f8f2>,</color> <color=#f8f8f2>Exception</color> <color=#f8f8f2>originalException</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>String</color> <color=#f8f8f2>badLsnString</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>badLsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLogException</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"RecoveryManager"</color><color=#f8f8f2>,</color> <color=#f8f8f2>method</color><color=#f8f8f2>,</color> <color=#e6db74>"last LSN = "</color> <color=#f92672>+</color> <color=#f8f8f2>badLsnString</color><color=#f8f8f2>,</color> <color=#f8f8f2>originalException</color><color=#f8f8f2>);</color>
    <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_INTEGRITY</color><color=#f8f8f2>,</color>
        <color=#e6db74>"last LSN="</color> <color=#f92672>+</color> <color=#f8f8f2>badLsnString</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>originalException</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>