<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.log</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.StatsConfig</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.ThreadInterruptedException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.*</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.CountDownLatch</color><color=#f8f8f2>;</color>

<color=#f92672>import static</color> <color=#f8f8f2>com.sleepycat.je.log.LogStatDefinition.*</color><color=#f8f8f2>;</color>

<color=#75715e>/*</color>
<color=#75715e> * The FsyncManager ensures that only one file fsync is issued at a time, for</color>
<color=#75715e> * performance optimization. The goal is to reduce the number of fsyncs issued</color>
<color=#75715e> * by the system by issuing 1 fsync on behalf of a number of threads.</color>
<color=#75715e> *</color>
<color=#75715e> * For example, suppose these writes happen which all need to be fsynced to</color>
<color=#75715e> * disk:</color>
<color=#75715e> *</color>
<color=#75715e> *  thread 1 writes a commit record</color>
<color=#75715e> *  thread 2 writes a checkpoint</color>
<color=#75715e> *  thread 3 writes a commit record</color>
<color=#75715e> *  thread 4 writes a commit record</color>
<color=#75715e> *  thread 5 writes a checkpoint</color>
<color=#75715e> *</color>
<color=#75715e> * Rather than executing 5 fsyncs, which all must happen synchronously, we hope</color>
<color=#75715e> * to issue fewer. How many fewer depend on timing. Note that the writes</color>
<color=#75715e> * themselves are serialized and are guaranteed to run in order.</color>
<color=#75715e> *</color>
<color=#75715e> * For example:</color>
<color=#75715e> *    thread 1 wants to fsync first, no other fsync going on, will issue fsync</color>
<color=#75715e> *    thread 2 waits</color>
<color=#75715e> *    thread 3 waits</color>
<color=#75715e> *    thread 4 waits</color>
<color=#75715e> *     - before thread 5 comes, thread 1 finishes fsyncing and returns to</color>
<color=#75715e> *     the caller. Now another fsync can be issued that will cover threads</color>
<color=#75715e> *     2,3,4. One of those threads (2, 3, 4} issues the fsync, the others</color>
<color=#75715e> *     block.</color>
<color=#75715e> *    thread 5 wants to fsync, but sees one going on, so will wait.</color>
<color=#75715e> *     - the fsync issued for 2,3,4 can't cover thread 5 because we're not sure</color>
<color=#75715e> *      if thread 5's write finished before that fsync call. Thread 5 will have</color>
<color=#75715e> *      to issue its own fsync.</color>
<color=#75715e> *</color>
<color=#75715e> * Target file</color>
<color=#75715e> * -----------</color>
<color=#75715e> * Note that when the buffer pool starts a new file, we fsync the previous file</color>
<color=#75715e> * under the log write latch. Therefore, at any time we only have one target</color>
<color=#75715e> * file to fsync, which is the current write buffer. We do this so that we</color>
<color=#75715e> * don't have to coordinate between files.  For example, suppose log files have</color>
<color=#75715e> * 1000 bytes and a commit record is 10 bytes.  An LSN of value 6/990 is in</color>
<color=#75715e> * file 6 at offset 990.</color>
<color=#75715e> *</color>
<color=#75715e> * thread 1: logWriteLatch.acquire()</color>
<color=#75715e> *         write commit record to LSN 6/980</color>
<color=#75715e> *         logWriteLatch.release()</color>
<color=#75715e> * thread 2: logWriteLatch.acquire()</color>
<color=#75715e> *         write commit record to LSN 6/990</color>
<color=#75715e> *         logWriteLatch.release</color>
<color=#75715e> * thread 3: logWriteLatch.acquire()</color>
<color=#75715e> *         gets 7/000 as the next LSN to use</color>
<color=#75715e> *          see that we flipped to a new file, so call fsync on file 6</color>
<color=#75715e> *         write commit record to LSN 7/000</color>
<color=#75715e> *         logWriteLatch.release()</color>
<color=#75715e> *</color>
<color=#75715e> * Thread 3 will fsync file 6 within the log write latch. That way, at any</color>
<color=#75715e> * time, any non-latched fsyncs should only fsync the latest file.  If we</color>
<color=#75715e> * didn't do, there's the chance that thread 3 would fsync file 7 and return to</color>
<color=#75715e> * its caller before the thread 1 and 2 got an fsync for file 6. That wouldn't</color>
<color=#75715e> * be correct, because thread 3's commit might depend on file 6.</color>
<color=#75715e> *</color>
<color=#75715e> * Note that the FileManager keeps a file descriptor that corresponds to the</color>
<color=#75715e> * current end of file, and that is what we fsync.</color>
<color=#75715e> */</color>
<color=#66d9ef>class</color> <color=#a6e22e>FSyncManager</color> <color=#f8f8f2>{</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>timeout</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Use as the target for a synchronization block. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>mgrMutex</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>workInProgress</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>FSyncGroup</color> <color=#f8f8f2>nextFSyncWaiters</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>numNextWaiters</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>startNextWait</color><color=#f8f8f2>;</color>
  <color=#75715e>/* Number of waiters that prevents a group commit wait */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>grpcThreshold</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>grpcInterval</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>grpWaitOn</color><color=#f8f8f2>;</color>

  <color=#75715e>/* stats */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>StatGroup</color> <color=#f8f8f2>stats</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nFSyncRequests</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLongStat</color> <color=#f8f8f2>nFSyncs</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nTimeouts</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nRequests</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nWaitersExceeded</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nTimeExceeded</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nWaits</color><color=#f8f8f2>;</color>

  <color=#75715e>/* For unit tests. */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color><color=#f92672><</color><color=#f8f8f2>CountDownLatch</color><color=#f92672>></color> <color=#f8f8f2>flushHook</color><color=#f8f8f2>;</color>

  <color=#f8f8f2>FSyncManager</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>timeout</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getDuration</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_FSYNC_TIMEOUT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>grpcInterval</color> <color=#f92672>=</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getDurationNS</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_GROUP_COMMIT_INTERVAL</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>grpcThreshold</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_GROUP_COMMIT_THRESHOLD</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>grpWaitOn</color> <color=#f92672>=</color> <color=#f8f8f2>grpcInterval</color> <color=#f92672>!=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>grpcThreshold</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>mgrMutex</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Object</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>workInProgress</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>nextFSyncWaiters</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>FSyncGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>timeout</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>stats</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>StatGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>LogStatDefinition</color><color=#f8f8f2>.</color><color=#a6e22e>FSYNCMGR_GROUP_NAME</color><color=#f8f8f2>,</color> <color=#f8f8f2>LogStatDefinition</color><color=#f8f8f2>.</color><color=#a6e22e>FSYNCMGR_GROUP_DESC</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nFSyncRequests</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>FSYNCMGR_FSYNC_REQUESTS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nFSyncs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>FSYNCMGR_FSYNCS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nTimeouts</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>FSYNCMGR_TIMEOUTS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nRequests</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>GRPCMGR_N_GROUP_COMMIT_REQUESTS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nTimeExceeded</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>GRPCMGR_N_LOG_INTERVAL_EXCEEDED</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nWaitersExceeded</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>GRPCMGR_N_LOG_MAX_GROUP_COMMIT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nWaits</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>GRPCMGR_N_GROUP_COMMIT_WAITS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>numNextWaiters</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Request to flush the log buffer and optionally fsync to disk. This thread may or may not</color>
<color=#75715e>   * actually execute the flush/fsync, but will not return until a flush/fsync has been issued and</color>
<color=#75715e>   * executed on behalf of its write. There is a timeout period specified by</color>
<color=#75715e>   * EnvironmentParam.LOG_FSYNC_TIMEOUT that ensures that no thread gets stuck here indefinitely.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>When a thread comes in, it will find one of two things. 1. There is no work going on right</color>
<color=#75715e>   * now. This thread should go ahead and become the group leader. The leader may wait and executes</color>
<color=#75715e>   * the flush/fsync. 2. There is work going on, wait on the next group commit.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>When a work is going on, all those threads that come along are grouped together as the</color>
<color=#75715e>   * nextFsyncWaiters. When the current work is finished, one of those nextFsyncWaiters will be</color>
<color=#75715e>   * selected as a leader to issue the next flush/fsync. The other members of the group will merely</color>
<color=#75715e>   * wait until the flush/fsync done on their behalf is finished.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>When a thread finishes a flush/fsync, it has to: 1. wake up all the threads that were</color>
<color=#75715e>   * waiting in the group. 2. wake up one member of the next group of waiting threads (the</color>
<color=#75715e>   * nextFsyncWaiters) so that thread can become the new leader and issue the next flush/fysnc call.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If a non-leader member of the nextFsyncWaiters times out, it will issue its own flush/fsync</color>
<color=#75715e>   * anyway, in case something happened to the leader.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param fsyncRequired true if fsync is required</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>flushAndSync</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>fsyncRequired</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>interval</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>doWork</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>isLeader</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>needToWait</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>FSyncGroup</color> <color=#f8f8f2>inProgressGroup</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>FSyncGroup</color> <color=#f8f8f2>myGroup</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>mgrMutex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nRequests</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fsyncRequired</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nFSyncRequests</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>myGroup</color> <color=#f92672>=</color> <color=#f8f8f2>nextFSyncWaiters</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>myGroup</color><color=#f8f8f2>.</color><color=#a6e22e>setDoFsync</color><color=#f8f8f2>(</color><color=#f8f8f2>fsyncRequired</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Figure out if we're calling fsync or waiting. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>workInProgress</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>needToWait</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>numNextWaiters</color><color=#f92672>++</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>grpWaitOn</color> <color=#f92672>&&</color> <color=#f8f8f2>numNextWaiters</color> <color=#f92672>==</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>startNextWait</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>nanoTime</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>isLeader</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>doWork</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>workInProgress</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>grpWaitOn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>numNextWaiters</color> <color=#f92672><</color> <color=#f8f8f2>grpcThreshold</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>interval</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>nanoTime</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>startNextWait</color><color=#f8f8f2>;</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>interval</color> <color=#f92672><</color> <color=#f8f8f2>grpcInterval</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>nWaits</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
                <color=#f8f8f2>mgrMutex</color><color=#f8f8f2>.</color><color=#a6e22e>wait</color><color=#f8f8f2>(</color><color=#f8f8f2>interval</color> <color=#f92672>/</color> <color=#ae81ff>1000000</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>interval</color> <color=#f92672>%</color> <color=#ae81ff>1000000</color><color=#f8f8f2>);</color>
              <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>InterruptedException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>ThreadInterruptedException</color><color=#f8f8f2>(</color>
                    <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Unexpected interrupt while "</color> <color=#f92672>+</color> <color=#e6db74>"waiting for write or fsync"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
              <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color>
            <color=#f8f8f2>nTimeExceeded</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>nWaitersExceeded</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>inProgressGroup</color> <color=#f92672>=</color> <color=#f8f8f2>nextFSyncWaiters</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>nextFSyncWaiters</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>FSyncGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>timeout</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>numNextWaiters</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>needToWait</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Note that there's no problem if we miss the notify on this set</color>
<color=#75715e>       * of waiters. We can check state in the FSyncGroup before we begin</color>
<color=#75715e>       * to wait.</color>
<color=#75715e>       *</color>
<color=#75715e>       * All members of the group may return from their waitForFSync()</color>
<color=#75715e>       * call with the need to do a fsync, because of timeout. Only one</color>
<color=#75715e>       * will return as the leader.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>waitStatus</color> <color=#f92672>=</color> <color=#f8f8f2>myGroup</color><color=#f8f8f2>.</color><color=#a6e22e>waitForEvent</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>waitStatus</color> <color=#f92672>==</color> <color=#f8f8f2>FSyncGroup</color><color=#f8f8f2>.</color><color=#a6e22e>DO_LEADER_FSYNC</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>mgrMutex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Check if there's a fsync in progress; this might happen</color>
<color=#75715e>           * even if you were designated the leader if a new thread</color>
<color=#75715e>           * came in between the point when the old leader woke you</color>
<color=#75715e>           * up and now. This new thread may have found that there</color>
<color=#75715e>           * was no fsync in progress, and may have started a fsync.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>workInProgress</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Ensure that an fsync is done before returning by</color>
<color=#75715e>             * forcing an fsync in this thread. [#20717]</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>doWork</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>isLeader</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>doWork</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>workInProgress</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>grpWaitOn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>numNextWaiters</color> <color=#f92672><</color> <color=#f8f8f2>grpcThreshold</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>interval</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>nanoTime</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>startNextWait</color><color=#f8f8f2>;</color>
                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>interval</color> <color=#f92672><</color> <color=#f8f8f2>grpcInterval</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                  <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
                    <color=#f8f8f2>nWaits</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
                    <color=#f8f8f2>mgrMutex</color><color=#f8f8f2>.</color><color=#a6e22e>wait</color><color=#f8f8f2>(</color><color=#f8f8f2>interval</color> <color=#f92672>/</color> <color=#ae81ff>1000000</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>interval</color> <color=#f92672>%</color> <color=#ae81ff>1000000</color><color=#f8f8f2>);</color>
                  <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>InterruptedException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                    <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>ThreadInterruptedException</color><color=#f8f8f2>(</color>
                        <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Unexpected interrupt while "</color> <color=#f92672>+</color> <color=#e6db74>"waiting for write or fsync"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
                  <color=#f8f8f2>}</color>
                <color=#f8f8f2>}</color>
                <color=#f8f8f2>nTimeExceeded</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
              <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>nWaitersExceeded</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
              <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color>
            <color=#f8f8f2>inProgressGroup</color> <color=#f92672>=</color> <color=#f8f8f2>myGroup</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>nextFSyncWaiters</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>FSyncGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>timeout</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>numNextWaiters</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>waitStatus</color> <color=#f92672>==</color> <color=#f8f8f2>FSyncGroup</color><color=#f8f8f2>.</color><color=#a6e22e>DO_TIMEOUT_FSYNC</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>doWork</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>mgrMutex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>nTimeouts</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>doWork</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * There are 3 ways that this fsync gets called:</color>
<color=#75715e>       *</color>
<color=#75715e>       * 1. A thread calls sync and there is not a sync call already in</color>
<color=#75715e>       * progress.  That thread executes fsync for itself only.  Other</color>
<color=#75715e>       * threads requesting sync form a group of waiters.</color>
<color=#75715e>       *</color>
<color=#75715e>       * 2. A sync finishes and wakes up a group of waiters.  The first</color>
<color=#75715e>       * waiter in the group to wake up becomes the leader.  It executes</color>
<color=#75715e>       * sync for it's group of waiters.  As above, other threads</color>
<color=#75715e>       * requesting sync form a new group of waiters.</color>
<color=#75715e>       *</color>
<color=#75715e>       * 3. If members of a group of waiters have timed out, they'll all</color>
<color=#75715e>       * just go and do their own sync for themselves.</color>
<color=#75715e>       */</color>

      <color=#75715e>/* flush the log buffer */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>myGroup</color><color=#f8f8f2>.</color><color=#a6e22e>getDoFsync</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>flushBeforeSync</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>flushNoSync</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>flushHook</color><color=#f8f8f2>);</color>

      <color=#75715e>/* execute fsync */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>myGroup</color><color=#f8f8f2>.</color><color=#a6e22e>getDoFsync</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>executeFSync</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>nFSyncs</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>mgrMutex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isLeader</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Wake up the group that requested the fsync before you</color>
<color=#75715e>           * started. They've piggybacked off your fsync.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>inProgressGroup</color><color=#f8f8f2>.</color><color=#a6e22e>wakeupAll</color><color=#f8f8f2>();</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Wake up a single waiter, who will become the next</color>
<color=#75715e>           * leader.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>nextFSyncWaiters</color><color=#f8f8f2>.</color><color=#a6e22e>wakeupOne</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>workInProgress</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Stats.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>long</color> <color=#a6e22e>getNFSyncRequests</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nFSyncRequests</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>long</color> <color=#a6e22e>getNFSyncs</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nFSyncs</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>long</color> <color=#a6e22e>getNTimeouts</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nTimeouts</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#f8f8f2>StatGroup</color> <color=#a6e22e>loadStats</color><color=#f8f8f2>(</color><color=#f8f8f2>StatsConfig</color> <color=#f8f8f2>config</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>stats</color><color=#f8f8f2>.</color><color=#a6e22e>cloneGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getClear</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Put the fsync execution into this method so it can be overridden for testing purposes. */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>void</color> <color=#a6e22e>executeFSync</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>syncLogEnd</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit testing only. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setFlushLogHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color><color=#f92672><</color><color=#f8f8f2>CountDownLatch</color><color=#f92672>></color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>flushHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Embodies a group of threads waiting for a common fsync. Note that</color>
<color=#75715e>   * there's no collection here; group membership is merely that the threads</color>
<color=#75715e>   * are all waiting on the same monitor.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>FSyncGroup</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>DO_TIMEOUT_FSYNC</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>DO_LEADER_FSYNC</color> <color=#f92672>=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>NO_FSYNC_NEEDED</color> <color=#f92672>=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>

    <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>doFsync</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>workDone</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>fsyncTimeout</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>leaderExists</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>FSyncGroup</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>fsyncTimeout</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>fsyncTimeout</color> <color=#f92672>=</color> <color=#f8f8f2>fsyncTimeout</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>workDone</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>leaderExists</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>synchronized</color> <color=#66d9ef>boolean</color> <color=#a6e22e>getLeader</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>workDone</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>leaderExists</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>leaderExists</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Wait for either a turn to execute a fsync, or to find out that a fsync was done on your</color>
<color=#75715e>     * behalf.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return true if the fsync wasn't done, and this thread needs to execute a fsync when it wakes</color>
<color=#75715e>     *     up. This may be true because it's the leader of its group, or because the wait timed out.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>synchronized</color> <color=#66d9ef>int</color> <color=#a6e22e>waitForEvent</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>ThreadInterruptedException</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>int</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>NO_FSYNC_NEEDED</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>workDone</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>startTime</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>
        <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>wait</color><color=#f8f8f2>(</color><color=#f8f8f2>fsyncTimeout</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>InterruptedException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>ThreadInterruptedException</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Unexpected interrupt while waiting "</color> <color=#f92672>+</color> <color=#e6db74>"for write or fsync"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/*</color>
<color=#75715e>           * This thread was awoken either by a timeout, by a notify,</color>
<color=#75715e>           * or by an interrupt. Is the fsync done?</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>workDone</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>/* The fsync we're waiting on is done, leave. */</color>
            <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>NO_FSYNC_NEEDED</color><color=#f8f8f2>;</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

            <color=#75715e>/*</color>
<color=#75715e>             * The fsync is not done -- were we woken up to become</color>
<color=#75715e>             * the leader?</color>
<color=#75715e>             */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>leaderExists</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>leaderExists</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
              <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>DO_LEADER_FSYNC</color><color=#f8f8f2>;</color>
              <color=#66d9ef>break</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

              <color=#75715e>/*</color>
<color=#75715e>               * We're just a waiter. See if we're timed out or</color>
<color=#75715e>               * have more to wait.</color>
<color=#75715e>               */</color>
              <color=#66d9ef>long</color> <color=#f8f8f2>now</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>
              <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>now</color> <color=#f92672>-</color> <color=#f8f8f2>startTime</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#f8f8f2>fsyncTimeout</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#75715e>/* we timed out. */</color>
                <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>DO_TIMEOUT_FSYNC</color><color=#f8f8f2>;</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>
              <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>status</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>setDoFsync</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>doSync</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>doFsync</color> <color=#f92672>|=</color> <color=#f8f8f2>doSync</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>synchronized</color> <color=#66d9ef>boolean</color> <color=#a6e22e>getDoFsync</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>doFsync</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>wakeupAll</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>workDone</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>notifyAll</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>wakeupOne</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* FindBugs whines here. */</color>
      <color=#f8f8f2>notify</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>