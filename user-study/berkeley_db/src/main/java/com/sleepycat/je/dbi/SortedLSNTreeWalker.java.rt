<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.dbi</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.CacheMode</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentFailureException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.evictor.OffHeapCache</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogEntryType</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogManager</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.WholeEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.BINDeltaLogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.LNLogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.LogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.OldBINDeltaLogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.DbLsn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.SizeofMarker</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.io.FileNotFoundException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.HashMap</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.List</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Map</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * SortedLSNTreeWalker uses ordered disk access rather than random access to iterate over a database</color>
<color=#75715e> * tree. Faulting in data records by on-disk order can provide much improved performance over</color>
<color=#75715e> * faulting in by key order, since the latter may require random access. SortedLSN walking does not</color>
<color=#75715e> * obey cursor and locking constraints, and therefore can only be guaranteed consistent for a</color>
<color=#75715e> * quiescent tree which is not being modified by user or daemon threads.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The class walks over the tree using sorted LSN fetching for parts of the tree that are not in</color>
<color=#75715e> * memory. It returns LSNs for each node in the tree, <b>except</b> the root IN, in an arbitrary</color>
<color=#75715e> * order (i.e. not key order). The caller is responsible for getting the root IN's LSN explicitly.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>A callback function specified in the constructor is executed for each LSN found.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The walker works in two phases. The first phase is to gather and return all the resident INs</color>
<color=#75715e> * using the roots that were specified when the SLTW was constructed. For each child of each root,</color>
<color=#75715e> * if the child is resident it is passed to the callback method (processLSN). If the child was not</color>
<color=#75715e> * in memory, it is added to a list of LSNs to read. When all of the in-memory INs have been passed</color>
<color=#75715e> * to the callback for all LSNs collected, phase 1 is complete.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>In phase 2, for each of the sorted LSNs, the target is fetched, the type determined, and the</color>
<color=#75715e> * LSN and type passed to the callback method for processing. LSNs of the children of those nodes</color>
<color=#75715e> * are retrieved and the process repeated until there are no more nodes to be fetched for this</color>
<color=#75715e> * database's tree. LSNs are accumulated in batches in this phase so that memory consumption is not</color>
<color=#75715e> * excessive. For instance, if batches were not used then the LSNs of all of the BINs would need to</color>
<color=#75715e> * be held in memory.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>SortedLSNTreeWalker</color> <color=#f8f8f2>{</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The interface for calling back to the user with each LSN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>interface</color> <color=#a6e22e>TreeNodeProcessor</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>void</color> <color=#a6e22e>processLSN</color><color=#f8f8f2>(</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>childLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>LogEntryType</color> <color=#f8f8f2>childType</color><color=#f8f8f2>,</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>theNode</color><color=#f8f8f2>,</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>)</color>
        <color=#66d9ef>throws</color> <color=#f8f8f2>FileNotFoundException</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Used for processing dirty (unlogged) deferred write LNs. [#15365] */</color>
    <color=#66d9ef>void</color> <color=#a6e22e>processDirtyDeletedLN</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>childLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Called when the internal memory limit is exceeded. */</color>
    <color=#66d9ef>void</color> <color=#a6e22e>noteMemoryExceeded</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Optionally passed to the SortedLSNTreeWalker to be called when an</color>
<color=#75715e>   * exception occurs.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>interface</color> <color=#a6e22e>ExceptionPredicate</color> <color=#f8f8f2>{</color>
    <color=#75715e>/* Return true if the exception can be ignored. */</color>
    <color=#66d9ef>boolean</color> <color=#a6e22e>ignoreException</color><color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color><color=#f92672>[]</color> <color=#f8f8f2>dbImpls</color><color=#f8f8f2>;</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Save the root LSN at construction time, because the root may be</color>
<color=#75715e>   * nulled out before walk() executes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>rootLsns</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Whether to call DatabaseImpl.finishedINListHarvest().</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>setDbState</color><color=#f8f8f2>;</color>

  <color=#75715e>/* The limit on memory to be used for internal structures during SLTW. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>internalMemoryLimit</color> <color=#f92672>=</color> <color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>MAX_VALUE</color><color=#f8f8f2>;</color>

  <color=#75715e>/* The current memory usage by internal SLTW structures. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>internalMemoryUsage</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>TreeNodeProcessor</color> <color=#f8f8f2>callback</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * If true, then walker should fetch LNs and pass them to the</color>
<color=#75715e>   * TreeNodeProcessor callback method.  Even if true, dup LNs are not</color>
<color=#75715e>   * fetched because they are normally never used (see accumulateDupLNs).</color>
<color=#75715e>   */</color>
  <color=#66d9ef>boolean</color> <color=#f8f8f2>accumulateLNs</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#66d9ef>boolean</color> <color=#f8f8f2>preloadIntoOffHeapCache</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * If true, fetch LNs in a dup DB.  Since LNs in a dup DB are not used by</color>
<color=#75715e>   * cursor operations, fetching dup LNs should only be needed in very</color>
<color=#75715e>   * exceptional situations.  Currently this field is never set to true.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>boolean</color> <color=#f8f8f2>accumulateDupLNs</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * If non-null, save any exceptions encountered while traversing nodes into</color>
<color=#75715e>   * this savedException list, in order to walk as much of the tree as</color>
<color=#75715e>   * possible. The caller of the tree walker will handle the exceptions.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>DatabaseException</color><color=#f92672>></color> <color=#f8f8f2>savedExceptions</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ExceptionPredicate</color> <color=#f8f8f2>excPredicate</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The batch size of LSNs which will be sorted.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsnBatchSize</color> <color=#f92672>=</color> <color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>MAX_VALUE</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Holder for returning LN key from fetchLSN. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>lnKeyEntry</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>

  <color=#75715e>/*</color>
<color=#75715e>   * This map provides an LSN to IN/index. When an LSN is processed by the</color>
<color=#75715e>   * tree walker, the map is used to lookup the parent IN and child entry</color>
<color=#75715e>   * index of each LSN processed by the tree walker.  Since fetchLSN is</color>
<color=#75715e>   * called with an arbitrary LSN, and since when we fetch (for preload) we</color>
<color=#75715e>   * need to setup the parent to refer to the node which we are prefetching,</color>
<color=#75715e>   * we need to have the parent in hand at the time of the call to fetchLSN.</color>
<color=#75715e>   * This map allows us to keep a reference to that parent so that we can</color>
<color=#75715e>   * call fetchNode on that parent.</color>
<color=#75715e>   *</color>
<color=#75715e>   * It is also necessary to maintain this map for cases other than preload()</color>
<color=#75715e>   * so that during multi-db walks (i.e. multi db preload), we can associate</color>
<color=#75715e>   * an arbitrary LSN back to the parent IN and therefore connect a fetch'ed</color>
<color=#75715e>   * Node into the proper place in the tree.</color>
<color=#75715e>   *</color>
<color=#75715e>   * LSN -> INEntry</color>
<color=#75715e>   */</color>
  <color=#75715e>/* struct to hold IN/entry-index pair. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>INEntry</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>INEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>in</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>in</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>index</color> <color=#f92672>=</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#a6e22e>INEntry</color><color=#f8f8f2>(</color><color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"unused"</color><color=#f8f8f2>)</color> <color=#f8f8f2>SizeofMarker</color> <color=#f8f8f2>marker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>in</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>index</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>Object</color> <color=#a6e22e>getDelta</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#a6e22e>getDeltaLsn</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#a6e22e>getMemorySize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>HASHMAP_ENTRY_OVERHEAD</color> <color=#f92672>+</color> <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>INENTRY_OVERHEAD</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Supplements INEntry with BIN-delta information. When a BIN-delta is encountered during the</color>
<color=#75715e>   * fetching process, we cannot immediately place it in the tree. Instead we queue a DeltaINEntry</color>
<color=#75715e>   * for fetching the full BIN, in LSN order as usual. When the full BIN is fetched, the</color>
<color=#75715e>   * DeltaINEntry is used to apply the delta and place the result in the tree.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>DeltaINEntry</color> <color=#66d9ef>extends</color> <color=#f8f8f2>INEntry</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>delta</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>deltaLsn</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>DeltaINEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>delta</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>deltaLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>delta</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>deltaLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>delta</color> <color=#f92672>=</color> <color=#f8f8f2>delta</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>deltaLsn</color> <color=#f92672>=</color> <color=#f8f8f2>deltaLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#a6e22e>DeltaINEntry</color><color=#f8f8f2>(</color><color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"unused"</color><color=#f8f8f2>)</color> <color=#f8f8f2>SizeofMarker</color> <color=#f8f8f2>marker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>marker</color><color=#f8f8f2>);</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>delta</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>deltaLsn</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#f8f8f2>Object</color> <color=#a6e22e>getDelta</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>delta</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>long</color> <color=#a6e22e>getDeltaLsn</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>deltaLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>long</color> <color=#a6e22e>getMemorySize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>deltaSize</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>delta</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>OldBINDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>deltaSize</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#f8f8f2>OldBINDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>delta</color><color=#f8f8f2>).</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>deltaSize</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>delta</color><color=#f8f8f2>).</color><color=#a6e22e>getInMemorySize</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>deltaSize</color> <color=#f92672>+</color> <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>HASHMAP_ENTRY_OVERHEAD</color> <color=#f92672>+</color> <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>DELTAINENTRY_OVERHEAD</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>INEntry</color><color=#f92672>></color> <color=#f8f8f2>lsnINMap</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>

  <color=#75715e>/*</color>
<color=#75715e>   * @param dbImpls an array of DatabaseImpls which should be walked over</color>
<color=#75715e>   * in disk order.  This array must be parallel to the rootLsns array in</color>
<color=#75715e>   * that rootLsns[i] must be the root LSN for dbImpls[i].</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param setDbState if true, indicate when the INList harvest has</color>
<color=#75715e>   * completed for a particular DatabaseImpl.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param rootLsns is passed in addition to the dbImpls, because the</color>
<color=#75715e>   * root may be nulled out on the dbImpl before walk() is called.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param callback the callback instance</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param savedExceptions a List of DatabaseExceptions encountered during</color>
<color=#75715e>   * the tree walk.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param excPredicate a predicate to determine whether a given exception</color>
<color=#75715e>   * should be ignored.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>SortedLSNTreeWalker</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseImpl</color><color=#f92672>[]</color> <color=#f8f8f2>dbImpls</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>setDbState</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>rootLsns</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>TreeNodeProcessor</color> <color=#f8f8f2>callback</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>DatabaseException</color><color=#f92672>></color> <color=#f8f8f2>savedExceptions</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>ExceptionPredicate</color> <color=#f8f8f2>excPredicate</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbImpls</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>dbImpls</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672><</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"DatabaseImpls array is null or 0-length for "</color> <color=#f92672>+</color> <color=#e6db74>"SortedLSNTreeWalker"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>dbImpls</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpls</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpls</color><color=#f92672>[</color><color=#ae81ff>0</color><color=#f92672>]</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#75715e>/* Make sure all databases are from the same environment. */</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>di</color> <color=#f8f8f2>:</color> <color=#f8f8f2>dbImpls</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>ei</color> <color=#f92672>=</color> <color=#f8f8f2>di</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ei</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
            <color=#e6db74>"environmentImpl is null for target db "</color> <color=#f92672>+</color> <color=#f8f8f2>di</color><color=#f8f8f2>.</color><color=#a6e22e>getDebugName</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ei</color> <color=#f92672>!=</color> <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
            <color=#e6db74>"Environment.preload() must be called with Databases "</color>
                <color=#f92672>+</color> <color=#e6db74>"which are all in the same Environment. ("</color>
                <color=#f92672>+</color> <color=#f8f8f2>di</color><color=#f8f8f2>.</color><color=#a6e22e>getDebugName</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>")"</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>setDbState</color> <color=#f92672>=</color> <color=#f8f8f2>setDbState</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>rootLsns</color> <color=#f92672>=</color> <color=#f8f8f2>rootLsns</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>callback</color> <color=#f92672>=</color> <color=#f8f8f2>callback</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>savedExceptions</color> <color=#f92672>=</color> <color=#f8f8f2>savedExceptions</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>excPredicate</color> <color=#f92672>=</color> <color=#f8f8f2>excPredicate</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>setLSNBatchSize</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsnBatchSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lsnBatchSize</color> <color=#f92672>=</color> <color=#f8f8f2>lsnBatchSize</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>setInternalMemoryLimit</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>internalMemoryLimit</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>internalMemoryLimit</color> <color=#f92672>=</color> <color=#f8f8f2>internalMemoryLimit</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>incInternalMemoryUsage</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>increment</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>internalMemoryUsage</color> <color=#f92672>+=</color> <color=#f8f8f2>increment</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>LSNAccumulator</color> <color=#a6e22e>createLSNAccumulator</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>LSNAccumulator</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#a6e22e>@Override</color>
      <color=#66d9ef>void</color> <color=#a6e22e>noteMemUsage</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>increment</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>incInternalMemoryUsage</color><color=#f8f8f2>(</color><color=#f8f8f2>increment</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>};</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Find all non-resident nodes, and execute the callback. The root IN's LSN is not returned to the</color>
<color=#75715e>   * callback.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>walk</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>walkInternal</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>walkInternal</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Phase 1: seed the SLTW with all of the roots of the DatabaseImpl[].</color>
<color=#75715e>     * For each root, look for all in-memory child nodes and process them</color>
<color=#75715e>     * (i.e. invoke the callback on those LSNs).  For child nodes which are</color>
<color=#75715e>     * not in-memory (i.e. they are LSNs only and no Node references),</color>
<color=#75715e>     * accumulate their LSNs to be later sorted and processed during phase</color>
<color=#75715e>     * 2.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>LSNAccumulator</color> <color=#f8f8f2>pendingLSNs</color> <color=#f92672>=</color> <color=#f8f8f2>createLSNAccumulator</color><color=#f8f8f2>();</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>dbImpls</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>processRootLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpls</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>,</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#f8f8f2>rootLsns</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Phase 2: Sort and process any LSNs we've gathered so far. For each</color>
<color=#75715e>     * LSN, fetch the target record and process it as in Phase 1 (i.e.</color>
<color=#75715e>     * in-memory children get passed to the callback, not in-memory children</color>
<color=#75715e>     * have their LSN accumulated for later sorting, fetching, and</color>
<color=#75715e>     * processing.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>processAccumulatedLSNs</color><color=#f8f8f2>(</color><color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Retrieve the root for the given DatabaseImpl and then process its</color>
<color=#75715e>   * children.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>processRootLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>LSNAccumulator</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>rootLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>root</color> <color=#f92672>=</color> <color=#f8f8f2>getOrFetchRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>rootLsn</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>accumulateLSNs</color><color=#f8f8f2>(</color><color=#f8f8f2>root</color><color=#f8f8f2>,</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>releaseRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>root</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>setDbState</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>finishedINListHarvest</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Traverse the in-memory tree rooted at "parent". For each visited node N</color>
<color=#75715e>   * call the callback method on N and put in pendingLSNs the LSNs of N's</color>
<color=#75715e>   * non-resident children.</color>
<color=#75715e>   *</color>
<color=#75715e>   * On entering this method, parent is latched and remains latched on exit.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>accumulateLSNs</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LSNAccumulator</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dups</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Without dups, all BINs contain only LN children.  With dups, it</color>
<color=#75715e>     * depends on the dup format.  Preload works with the old dup format</color>
<color=#75715e>     * and the new.</color>
<color=#75715e>     *</color>
<color=#75715e>     * In the new dup format (or after dup conversion), BINs contain only</color>
<color=#75715e>     * LNs and no DBINs exist.  In the old dup format, DBINs contain only</color>
<color=#75715e>     * LN children, but BINs may contain a mix of LNs and DINs.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>allChildrenAreLNs</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>dups</color> <color=#f92672>||</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getDupsConverted</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>allChildrenAreLNs</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>allChildrenAreLNs</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>containsDuplicates</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If LNs are not needed, there is no need to accumulate the child LSNs</color>
<color=#75715e>     * when all children are LNs.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>accumulateChildren</color> <color=#f92672>=</color>
        <color=#f92672>!</color><color=#f8f8f2>allChildrenAreLNs</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>dups</color> <color=#f92672>?</color> <color=#f8f8f2>accumulateDupLNs</color> <color=#f8f8f2>:</color> <color=#f8f8f2>accumulateLNs</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>parentBin</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>()</color> <color=#f92672>?</color> <color=#f8f8f2>((</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>OffHeapCache</color> <color=#f8f8f2>ohCache</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapCache</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Process all children, but only accumulate LSNs for children that are</color>
<color=#75715e>     * not in memory.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>Node</color> <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>childCached</color> <color=#f92672>=</color> <color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>lnKey</color> <color=#f92672>=</color>
          <color=#f8f8f2>(</color><color=#f8f8f2>allChildrenAreLNs</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>childCached</color> <color=#f92672>&&</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isLN</color><color=#f8f8f2>()))</color> <color=#f92672>?</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parentBin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>parentBin</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* Dirty LNs (deferred write) get special treatment. */</color>
        <color=#f8f8f2>processDirtyLN</color><color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>);</color>
        <color=#75715e>/* continue; */</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>childCached</color> <color=#f92672>&&</color> <color=#f8f8f2>parentBin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>parentBin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* Embedded LNs are not stored off-heap */</color>
        <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>loadLN</color><color=#f8f8f2>(</color><color=#f8f8f2>parentBin</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>processChild</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>childCached</color> <color=#f92672>&&</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>materializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>getBINBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>));</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>isLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

            <color=#75715e>/* Deltas not allowed with deferred-write. */</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Storing an off-heap reference would use less memory,</color>
<color=#75715e>             * but we prefer to optimize in the future by</color>
<color=#75715e>             * re-implementing preload.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>fullLsn</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLastFullLsn</color><color=#f8f8f2>();</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>fullLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>fullLsn</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>addToLsnINMap</color><color=#f8f8f2>(</color><color=#f8f8f2>fullLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>isLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

            <color=#f8f8f2>processChild</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>accumulateChildren</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>childCached</color> <color=#f92672>&&</color> <color=#f8f8f2>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Child is not in cache. Put its LSN in the current batch of</color>
<color=#75715e>         * LSNs to be sorted and fetched in phase 2. But don't do</color>
<color=#75715e>         * this if the child is an embedded LN.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ohBinParent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>addToLsnINMap</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>addToLsnINMap</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>processChild</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*child*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color> <color=#75715e>/*lastLoggedSize*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>childCached</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>latchShared</color><color=#f8f8f2>();</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>isLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

            <color=#75715e>/* Deltas not allowed with deferred-write. */</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color>

            <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>delta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
            <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>fullLsn</color> <color=#f92672>=</color> <color=#f8f8f2>delta</color><color=#f8f8f2>.</color><color=#a6e22e>getLastFullLsn</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>fullLsn</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>addToLsnINMap</color><color=#f8f8f2>(</color><color=#f8f8f2>fullLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>delta</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>isLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

            <color=#f8f8f2>processChild</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * We are here because the child was not cached and was not</color>
<color=#75715e>         * accumulated either (because it was an LN and LN accumulation</color>
<color=#75715e>         * is turned off or its LSN was NULL).</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>processChild</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*child*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If we've exceeded the batch size then process the current</color>
<color=#75715e>       * batch and start a new one.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>internalMemoryExceeded</color> <color=#f92672>=</color> <color=#f8f8f2>internalMemoryUsage</color> <color=#f92672>></color> <color=#f8f8f2>internalMemoryLimit</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>.</color><color=#a6e22e>getNTotalEntries</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#f8f8f2>lsnBatchSize</color> <color=#f92672>||</color> <color=#f8f8f2>internalMemoryExceeded</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>internalMemoryExceeded</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>callback</color><color=#f8f8f2>.</color><color=#a6e22e>noteMemoryExceeded</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>processAccumulatedLSNs</color><color=#f8f8f2>(</color><color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>processDirtyLN</color><color=#f8f8f2>(</color><color=#f8f8f2>Node</color> <color=#f8f8f2>node</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>isLN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>node</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>isDirty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>callback</color><color=#f8f8f2>.</color><color=#a6e22e>processDirtyDeletedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>processChild</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LSNAccumulator</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>childCached</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the child is resident, use its log type, else it must be an LN.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>callProcessLSNHandleExceptions</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>childCached</color>
            <color=#f92672>?</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_INS_LN</color> <color=#75715e>/* Any LN type will do */</color>
            <color=#f8f8f2>:</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getGenericLogType</color><color=#f8f8f2>()),</color>
        <color=#f8f8f2>child</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>childCached</color> <color=#f92672>&&</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>nodeAsIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nodeAsIN</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>accumulateLSNs</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeAsIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nodeAsIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Process a batch of LSNs by sorting and fetching each of them.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>processAccumulatedLSNs</color><color=#f8f8f2>(</color><color=#f8f8f2>LSNAccumulator</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>currentLSNs</color> <color=#f92672>=</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>.</color><color=#a6e22e>getAndSortPendingLSNs</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>pendingLSNs</color> <color=#f92672>=</color> <color=#f8f8f2>createLSNAccumulator</color><color=#f8f8f2>();</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color> <color=#f8f8f2>:</color> <color=#f8f8f2>currentLSNs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fetchAndProcessLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Fetch the node at 'lsn' and callback to let the invoker process it.  If</color>
<color=#75715e>   * it is an IN, accumulate LSNs for it.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>fetchAndProcessLSN</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>LSNAccumulator</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>lnKeyEntry</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>FetchResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>fetchLSNHandleExceptions</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKeyEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isIN</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>node</color><color=#f8f8f2>.</color><color=#a6e22e>isIN</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>in</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>node</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>in</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>callProcessLSNHandleExceptions</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>node</color><color=#f8f8f2>.</color><color=#a6e22e>getGenericLogType</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>node</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>lnKeyEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>lastLoggedSize</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>accumulateLSNs</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>,</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>ohBinParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>ohBinIndex</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>FetchResult</color> <color=#a6e22e>fetchLSNHandleExceptions</color><color=#f8f8f2>(</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>lnKeyEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>LSNAccumulator</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>dbe</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>fetchLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKeyEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>excPredicate</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>excPredicate</color><color=#f8f8f2>.</color><color=#a6e22e>ignoreException</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>dbe</color> <color=#f92672>=</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbe</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>savedExceptions</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * This LSN fetch hit a failure. Do as much of the rest of</color>
<color=#75715e>         * the tree as possible.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>savedExceptions</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>dbe</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>dbe</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>callProcessLSNHandleExceptions</color><color=#f8f8f2>(</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>childLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>LogEntryType</color> <color=#f8f8f2>childType</color><color=#f8f8f2>,</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>theNode</color><color=#f8f8f2>,</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>dbe</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>callback</color><color=#f8f8f2>.</color><color=#a6e22e>processLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>childLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>childType</color><color=#f8f8f2>,</color> <color=#f8f8f2>theNode</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>FileNotFoundException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>excPredicate</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>excPredicate</color><color=#f8f8f2>.</color><color=#a6e22e>ignoreException</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>dbe</color> <color=#f92672>=</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_FILE_NOT_FOUND</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>excPredicate</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>excPredicate</color><color=#f8f8f2>.</color><color=#a6e22e>ignoreException</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>dbe</color> <color=#f92672>=</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbe</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>savedExceptions</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * This LSN fetch hit a failure. Do as much of the rest of</color>
<color=#75715e>         * the tree as possible.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>savedExceptions</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>dbe</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>dbe</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the root IN, latched shared. Allows subclasses to override getResidentRootIN and/or</color>
<color=#75715e>   * getRootIN to modify behavior. getResidentRootIN is called first,</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>IN</color> <color=#a6e22e>getOrFetchRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>rootLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>root</color> <color=#f92672>=</color> <color=#f8f8f2>getResidentRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>root</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>rootLsn</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The default behavior fetches the rootIN from the log and latches it shared. Classes extending</color>
<color=#75715e>   * this may fetch (and latch) the root from the tree.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>IN</color> <color=#a6e22e>getRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>rootLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>root</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>getEntryHandleFileNotFound</color><color=#f8f8f2>(</color><color=#f8f8f2>rootLsn</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>setDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>latchShared</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>root</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The default behavior returns (and latches shared) the IN if it is resident in the Btree, or</color>
<color=#75715e>   * null otherwise. Classes extending this may return (and latch) a known IN object.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>IN</color> <color=#a6e22e>getResidentRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>().</color><color=#a6e22e>getResidentRootIN</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*latched*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Release the latch. Overriding this method should not be necessary. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>releaseRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>root</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Add an LSN-IN/index entry to the map. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>addToLsnINMap</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>addEntryToLsnMap</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#f8f8f2>INEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Add an LSN-IN/index entry, along with a delta and delta LSN, to the map. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>addToLsnINMap</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>delta</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>deltaLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>addEntryToLsnMap</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#f8f8f2>DeltaINEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>delta</color><color=#f8f8f2>,</color> <color=#f8f8f2>deltaLsn</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>addEntryToLsnMap</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>INEntry</color> <color=#f8f8f2>inEntry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsnINMap</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>inEntry</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>incInternalMemoryUsage</color><color=#f8f8f2>(</color><color=#f8f8f2>inEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>FetchResult</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>node</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>FetchResult</color><color=#f8f8f2>(</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>node</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>node</color> <color=#f92672>=</color> <color=#f8f8f2>node</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lastLoggedSize</color> <color=#f92672>=</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>ohBinParent</color> <color=#f92672>=</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>ohBinIndex</color> <color=#f92672>=</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Process an LSN.  Get & remove its INEntry from the map, then fetch the</color>
<color=#75715e>   * target at the INEntry's IN/index pair.  This method will be called in</color>
<color=#75715e>   * sorted LSN order.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>FetchResult</color> <color=#a6e22e>fetchLSN</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>lnKeyEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>LSNAccumulator</color> <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LogManager</color> <color=#f8f8f2>logManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>OffHeapCache</color> <color=#f8f8f2>ohCache</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapCache</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>INEntry</color> <color=#f8f8f2>inEntry</color> <color=#f92672>=</color> <color=#f8f8f2>lsnINMap</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>inEntry</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>incInternalMemoryUsage</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#f8f8f2>inEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>());</color>

    <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color> <color=#f92672>=</color> <color=#f8f8f2>inEntry</color><color=#f8f8f2>.</color><color=#a6e22e>in</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>inEntry</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>IN</color> <color=#f8f8f2>ohBinParent</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>ohBinIndex</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>IN</color> <color=#f8f8f2>in1ToUnlatch</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>in2ToUnlatch</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>in1ToUnlatch</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>();</color>
    <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>lnKey</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>Node</color> <color=#f8f8f2>residentNode</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>residentNode</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>residentNode</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * When the indexed slot contains an off-heap BIN, the node to</color>
<color=#75715e>       * fetch is an LN within the off-heap BIN or the full BIN to merge</color>
<color=#75715e>       * with an off-heap BIN-delta.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>Object</color> <color=#f8f8f2>deltaObject</color> <color=#f92672>=</color> <color=#f8f8f2>inEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getDelta</color><color=#f8f8f2>();</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>isOffHeapBinInTree</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>isLnInOffHeapBin</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isOffHeapBinInTree</color> <color=#f92672>&&</color> <color=#f8f8f2>deltaObject</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * When fetching an LN within an off-heap BIN, materialize the</color>
<color=#75715e>         * parent BIN and set in/index to this true parent.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>isLnInOffHeapBin</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>ohBin</color> <color=#f92672>=</color> <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>materializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>getBINBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>));</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>foundIndex</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>ohBin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ohBin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>foundIndex</color> <color=#f92672>=</color> <color=#f8f8f2>i</color><color=#f8f8f2>;</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color> <color=#75715e>// See note on concurrent activity below.</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>ohBinParent</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>ohBinIndex</color> <color=#f92672>=</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>in</color> <color=#f92672>=</color> <color=#f8f8f2>ohBin</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>foundIndex</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>in2ToUnlatch</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Concurrent activity (e.g., log cleaning) that was active before</color>
<color=#75715e>       * we took the root latch may have changed the state of a slot.</color>
<color=#75715e>       * Repeat check for LN deletion/expiration and check that the LSN</color>
<color=#75715e>       * has not changed.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>((</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>).</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>deltaObject</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>inEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getDeltaLsn</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>boolean</color> <color=#f8f8f2>mutateResidentDeltaToFullBIN</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>residentNode</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * If the resident node is not a delta then concurrent</color>
<color=#75715e>         * activity (e.g., log cleaning) must have loaded the node.</color>
<color=#75715e>         * Just return it and continue.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>residentNode</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>residentNode</color><color=#f8f8f2>.</color><color=#a6e22e>isLN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>lnKeyEntry</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>
          <color=#f8f8f2>}</color>
          <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>FetchResult</color><color=#f8f8f2>(</color><color=#f8f8f2>residentNode</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>),</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* The resident node is a delta. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(((</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>residentNode</color><color=#f8f8f2>).</color><color=#a6e22e>getLastFullLsn</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color> <color=#75715e>// See note on concurrent activity above.</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>mutateResidentDeltaToFullBIN</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Fetch log entry. */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>WholeEntry</color> <color=#f8f8f2>wholeEntry</color><color=#f8f8f2>;</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>wholeEntry</color> <color=#f92672>=</color> <color=#f8f8f2>logManager</color><color=#f8f8f2>.</color><color=#a6e22e>getWholeLogEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>FileNotFoundException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>msg</color> <color=#f92672>=</color>
            <color=#f8f8f2>(</color><color=#f8f8f2>fetchAndInsertIntoTree</color><color=#f8f8f2>()</color> <color=#f92672>?</color> <color=#e6db74>"Preload failed"</color> <color=#f8f8f2>:</color> <color=#e6db74>"SortedLSNTreeWalker failed"</color><color=#f8f8f2>)</color>
                <color=#f92672>+</color> <color=#e6db74>" dbId="</color>
                <color=#f92672>+</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>" isOffHeapBinInTree="</color>
                <color=#f92672>+</color> <color=#f8f8f2>isOffHeapBinInTree</color>
                <color=#f92672>+</color> <color=#e6db74>" isLnInOffHeapBin="</color>
                <color=#f92672>+</color> <color=#f8f8f2>isLnInOffHeapBin</color>
                <color=#f92672>+</color> <color=#e6db74>" deltaObject="</color>
                <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>deltaObject</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
                <color=#f92672>+</color> <color=#e6db74>" residentNode="</color>
                <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>residentNode</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

        <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_FILE_NOT_FOUND</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>makeFetchErrorMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>msg</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>LogEntry</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>wholeEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getEntry</color><color=#f8f8f2>();</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lastLoggedSize</color> <color=#f92672>=</color> <color=#f8f8f2>wholeEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getHeader</color><color=#f8f8f2>().</color><color=#a6e22e>getEntrySize</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * For a BIN delta, queue fetching of the full BIN and combine the</color>
<color=#75715e>       * full BIN with the delta when it is processed later (see below).</color>
<color=#75715e>       *</color>
<color=#75715e>       * Note that for preload, this means that a BIN-delta is not placed</color>
<color=#75715e>       * in the tree when there is not enough memory for the full BIN.</color>
<color=#75715e>       * Ideally we should place the BIN-delta in the tree here.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BINDeltaLogEntry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>BINDeltaLogEntry</color> <color=#f8f8f2>deltaEntry</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BINDeltaLogEntry</color><color=#f8f8f2>)</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>fullLsn</color> <color=#f92672>=</color> <color=#f8f8f2>deltaEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getPrevFullLsn</color><color=#f8f8f2>();</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>delta</color> <color=#f92672>=</color> <color=#f8f8f2>deltaEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getMainItem</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>fullLsn</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>addToLsnINMap</color><color=#f8f8f2>(</color><color=#f8f8f2>fullLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>delta</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>OldBINDeltaLogEntry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>OldBINDelta</color> <color=#f8f8f2>delta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>OldBINDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>entry</color><color=#f8f8f2>.</color><color=#a6e22e>getMainItem</color><color=#f8f8f2>();</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>fullLsn</color> <color=#f92672>=</color> <color=#f8f8f2>delta</color><color=#f8f8f2>.</color><color=#a6e22e>getLastFullLsn</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>pendingLSNs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>fullLsn</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>addToLsnINMap</color><color=#f8f8f2>(</color><color=#f8f8f2>fullLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>delta</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* For an LNLogEntry, call postFetchInit and get the lnKey. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>LNLogEntry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color> <color=#f8f8f2>lnEntry</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>LNLogEntry</color><color=#f92672><?></color><color=#f8f8f2>)</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>postFetchInit</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>lnKey</color> <color=#f92672>=</color> <color=#f8f8f2>lnEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>lnKeyEntry</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#f8f8f2>lnKey</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Get the Node from the LogEntry. */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>ret</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>Node</color><color=#f8f8f2>)</color> <color=#f8f8f2>entry</color><color=#f8f8f2>.</color><color=#a6e22e>getResolvedItem</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * For an IN Node, set the database so it will be passed down to</color>
<color=#75715e>       * nested fetches.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>lastLoggedLsn</color> <color=#f92672>=</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>isIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>retIn</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>retIn</color><color=#f8f8f2>.</color><color=#a6e22e>setDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If there is a delta, then this is the full BIN to which the</color>
<color=#75715e>       * delta must be applied. The delta LSN is the last logged LSN.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mutateResidentDeltaToFullBIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>fullBIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>BIN</color> <color=#f8f8f2>delta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>residentNode</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fetchAndInsertIntoTree</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>delta</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>fullBIN</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

          <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>FetchResult</color><color=#f8f8f2>(</color><color=#f8f8f2>residentNode</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>delta</color><color=#f8f8f2>.</color><color=#a6e22e>reconstituteBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

          <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>FetchResult</color><color=#f8f8f2>(</color><color=#f8f8f2>ret</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>deltaObject</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>fullBIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>deltaObject</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>OldBINDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>final</color> <color=#f8f8f2>OldBINDelta</color> <color=#f8f8f2>delta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>OldBINDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>deltaObject</color><color=#f8f8f2>;</color>
          <color=#66d9ef>assert</color> <color=#f8f8f2>lsn</color> <color=#f92672>==</color> <color=#f8f8f2>delta</color><color=#f8f8f2>.</color><color=#a6e22e>getLastFullLsn</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>delta</color><color=#f8f8f2>.</color><color=#a6e22e>reconstituteBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>lastLoggedLsn</color> <color=#f92672>=</color> <color=#f8f8f2>inEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getDeltaLsn</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>delta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>deltaObject</color><color=#f8f8f2>;</color>
          <color=#66d9ef>assert</color> <color=#f8f8f2>lsn</color> <color=#f92672>==</color> <color=#f8f8f2>delta</color><color=#f8f8f2>.</color><color=#a6e22e>getLastFullLsn</color><color=#f8f8f2>();</color>

          <color=#f8f8f2>delta</color><color=#f8f8f2>.</color><color=#a6e22e>reconstituteBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>lastLoggedLsn</color> <color=#f92672>=</color> <color=#f8f8f2>inEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getDeltaLsn</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * When we store an off-heap BIN here, the caller must pass its</color>
<color=#75715e>       * parent/index to accumulateLSNs.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>retOhBinParent</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>retOhBinIndex</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

      <color=#75715e>/* During a preload, finally place the Node into the Tree. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fetchAndInsertIntoTree</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* Last logged size is not present before log version 9. */</color>
        <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>setLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We don't worry about the memory usage being kept below the</color>
<color=#75715e>         * max by the evictor, since we keep the root INs latched.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>MemoryBudget</color> <color=#f8f8f2>memBudget</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getMemoryBudget</color><color=#f8f8f2>();</color>
        <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>storeOffHeap</color> <color=#f92672>=</color>
            <color=#f8f8f2>preloadIntoOffHeapCache</color> <color=#f92672>&&</color> <color=#f8f8f2>memBudget</color><color=#f8f8f2>.</color><color=#a6e22e>getCacheMemoryUsage</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#f8f8f2>memBudget</color><color=#f8f8f2>.</color><color=#a6e22e>getMaxMemory</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Note that UINs are always stored in the main cache even if</color>
<color=#75715e>         * it is full. The idea is that LNs and BINs should be evicted</color>
<color=#75715e>         * from main to make room. When the main cache fills with UINs,</color>
<color=#75715e>         * and an off-heap cache is also being filled, we currently</color>
<color=#75715e>         * allow the main cache to overflow.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isOffHeapBinInTree</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>storeOffHeap</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>isUpperIN</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>isLN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#75715e>/*</color>
<color=#75715e>             * Store LN off-heap. If an oh LN was added to an oh</color>
<color=#75715e>             * BIN we must re-store the oh BIN as well. This is</color>
<color=#75715e>             * inefficient but we don't know of a simple way to</color>
<color=#75715e>             * optimize.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>
            <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>retLn</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>storePreloadedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>retLn</color><color=#f8f8f2>);</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isOffHeapBinInTree</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>assert</color> <color=#f8f8f2>isLnInOffHeapBin</color><color=#f8f8f2>;</color>
              <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>storePreloadedBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohBinIndex</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#75715e>/*</color>
<color=#75715e>             * Store full BIN off-heap. Note that setLastLoggedLSN</color>
<color=#75715e>             * is normally called by postFetchInit or postLoadInit,</color>
<color=#75715e>             * but neither is used during preload so we must call</color>
<color=#75715e>             * setLastLoggedLsn here.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>isLnInOffHeapBin</color><color=#f8f8f2>;</color>
            <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>retBin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>retBin</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>retBin</color><color=#f8f8f2>.</color><color=#a6e22e>setLastLoggedLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
            <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>storePreloadedBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>retBin</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color> <color=#75715e>// could not allocate memory</color>
              <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>retBin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
            <color=#f8f8f2>retOhBinParent</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>retOhBinIndex</color> <color=#f92672>=</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* Attach node to the Btree as in a normal operation. */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>isIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>retIn</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>retIn</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>postFetchInit</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedLsn</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>attachNode</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>ret</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>retIn</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>postFetchInit</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedLsn</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>attachNode</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>ret</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnKey</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/* BINs with resident LNs shouldn't be in the dirty LRU. */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>final</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>mode</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>getDefaultCacheMode</color><color=#f8f8f2>();</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mode</color> <color=#f92672>!=</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>EVICT_LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEvictor</color><color=#f8f8f2>().</color><color=#a6e22e>moveToPri1LRU</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Clear the fetched-cold flag set, since we want the preloaded</color>
<color=#75715e>         * data to be "hot". This is necessary because the node is not</color>
<color=#75715e>         * latched after being preloaded, as it normally would be after</color>
<color=#75715e>         * being attached.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>isIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>((</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ret</color><color=#f8f8f2>).</color><color=#a6e22e>setFetchedCold</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>isLN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>((</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>ret</color><color=#f8f8f2>).</color><color=#a6e22e>setFetchedCold</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>FetchResult</color><color=#f8f8f2>(</color><color=#f8f8f2>ret</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>retOhBinParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>retOhBinIndex</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>residentNode</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>residentNode</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in1ToUnlatch</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>in1ToUnlatch</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in2ToUnlatch</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>in2ToUnlatch</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Overriden by subclasses if fetch of an LSN should result in insertion</color>
<color=#75715e>   * into tree rather than just instantiating the target.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>boolean</color> <color=#a6e22e>fetchAndInsertIntoTree</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>