<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.tree</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DatabaseImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.INList</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.latch.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.Loggable</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.*</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.nio.ByteBuffer</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.ArrayList</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Comparator</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.List</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Level</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Logger</color><color=#f8f8f2>;</color>

<color=#f92672>import static</color> <color=#f8f8f2>com.sleepycat.je.dbi.BTreeStatDefinition.*</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * Tree implements the JE B+Tree.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>A note on tree search patterns: There's a set of Tree.search* methods. Some clients of the</color>
<color=#75715e> * tree use those search methods directly, whereas other clients of the tree tend to use methods</color>
<color=#75715e> * built on top of search.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The semantics of search* are they leave you pointing at a BIN or IN they don't tell you where</color>
<color=#75715e> * the reference of interest is. The semantics of the get* methods are: they leave you pointing at a</color>
<color=#75715e> * BIN or IN they return the index of the slot of interest they traverse down to whatever level is</color>
<color=#75715e> * needed they are built on top of search* methods. For the future: Over time, we need to clarify</color>
<color=#75715e> * which methods are to be used by clients of the tree. Preferably clients that call the tree use</color>
<color=#75715e> * get*, although their are cases where they need visibility into the tree structure.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Also, search* should return the location of the slot to save us a second binary search.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Search Method Call Hierarchy ---------------------------- getFirst/LastNode search CALLED BY:</color>
<color=#75715e> * CursorImpl.getFirstOrLast</color>
<color=#75715e> *</color>
<color=#75715e> * <p>getNext/PrevBin getParentINForChildIN searchSubTree CALLED BY: DupConvert CursorImpl.getNext</color>
<color=#75715e> *</color>
<color=#75715e> * <p>getParentINForChildIN IN.findParent does not use shared latching CALLED BY:</color>
<color=#75715e> * Checkpointer.flushIN (doFetch=false, targetLevel=-1) FileProcessor.processIN (doFetch=true,</color>
<color=#75715e> * targetLevel=LEVEL) Evictor.evictIN (doFetch=true, targetLevel=-1)</color>
<color=#75715e> * RecoveryManager.replaceOrInsertChild (doFetch=true, targetLevel=-1) getNext/PrevBin</color>
<color=#75715e> * (doFetch=true, targetLevel=-1)</color>
<color=#75715e> *</color>
<color=#75715e> * <p>search searchSubTree CALLED BY: CursorImpl.searchAndPosition INCompressor to find BIN</color>
<color=#75715e> *</color>
<color=#75715e> * <p>searchSubTree uses shared grandparent latching</color>
<color=#75715e> *</color>
<color=#75715e> * <p>getParentBINForChildLN searchSplitsAllowed CALLED BY: RecoveryManager.redo</color>
<color=#75715e> * RecoveryManager.recoveryUndo search CALLED BY: RecoveryManager.abortUndo</color>
<color=#75715e> * RecoveryManager.rollbackUndo FileProcessor.processLN Cleaner.processPendingLN</color>
<color=#75715e> * UtilizationProfile.verifyLsnIsObsolete (utility)</color>
<color=#75715e> *</color>
<color=#75715e> * <p>findBinForInsert searchSplitsAllowed CALLED BY: CursorImpl.putInternal</color>
<color=#75715e> *</color>
<color=#75715e> * <p>searchSplitsAllowed uses shared non-grandparent latching CALLED BY: DupConvert (instead of</color>
<color=#75715e> * findBinForInsert, which needs a cursor)</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Possible Shared Latching Improvements ------------------------------------- By implementing</color>
<color=#75715e> * shared latching for BINs we would get better concurrency in these cases: Reads when LN is in</color>
<color=#75715e> * cache, or LN is not needed (key-only op, e.g., dups)</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>class</color> <color=#a6e22e>Tree</color> <color=#66d9ef>implements</color> <color=#f8f8f2>Loggable</color> <color=#f8f8f2>{</color>

  <color=#75715e>/* For debug tracing */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>TRACE_ROOT_SPLIT</color> <color=#f92672>=</color> <color=#e6db74>"RootSplit:"</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>database</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxTreeEntriesPerNode</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>ChildReference</color> <color=#f8f8f2>root</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Latch that must be held when using/accessing the root node.  Protects</color>
<color=#75715e>   * against the root being changed out from underneath us by splitRoot.</color>
<color=#75715e>   * After the root IN is latched, the rootLatch can be released.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>SharedLatch</color> <color=#f8f8f2>rootLatch</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * We don't need the stack trace on this so always throw a static and</color>
<color=#75715e>   * avoid the cost of Throwable.fillInStack() every time it's thrown.</color>
<color=#75715e>   * [#13354].</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>SplitRequiredException</color> <color=#f8f8f2>splitRequiredException</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>SplitRequiredException</color><color=#f8f8f2>();</color>

  <color=#75715e>/* Stats */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>StatGroup</color> <color=#f8f8f2>stats</color><color=#f8f8f2>;</color>

  <color=#75715e>/* The number of tree root splited. */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>IntStat</color> <color=#f8f8f2>rootSplits</color><color=#f8f8f2>;</color>
  <color=#75715e>/* The number of latch upgrades from shared to exclusive required. */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>relatchesRequired</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ThreadLocal</color><color=#f92672><</color><color=#f8f8f2>TreeWalkerStatsAccumulator</color><color=#f92672>></color> <color=#f8f8f2>treeStatsAccumulatorTL</color> <color=#f92672>=</color>
      <color=#66d9ef>new</color> <color=#f8f8f2>ThreadLocal</color><color=#f92672><</color><color=#f8f8f2>TreeWalkerStatsAccumulator</color><color=#f92672>></color><color=#f8f8f2>();</color>

  <color=#75715e>/* For unit tests */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color> <color=#f8f8f2>waitHook</color><color=#f8f8f2>;</color> <color=#75715e>// used for generating race conditions</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color> <color=#f8f8f2>searchHook</color><color=#f8f8f2>;</color> <color=#75715e>// [#12736]</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color> <color=#f8f8f2>ckptHook</color><color=#f8f8f2>;</color> <color=#75715e>// [#13897]</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color> <color=#f8f8f2>getParentINHook</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color> <color=#f8f8f2>fetchINHook</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Embodies an enum for the type of search being performed. NORMAL means do a regular search down</color>
<color=#75715e>   * the tree. LEFT/RIGHT means search down the left/right side to find the first/last node in the</color>
<color=#75715e>   * tree.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>SearchType</color> <color=#f8f8f2>{</color>
    <color=#75715e>/* Search types */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>SearchType</color> <color=#f8f8f2>NORMAL</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>();</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>SearchType</color> <color=#f8f8f2>LEFT</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>();</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>SearchType</color> <color=#f8f8f2>RIGHT</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>();</color>

    <color=#75715e>/* No lock types can be defined outside this class. */</color>
    <color=#66d9ef>private</color> <color=#a6e22e>SearchType</color><color=#f8f8f2>()</color> <color=#f8f8f2>{}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Class that overrides ChildReference methods to enforce rules that apply</color>
<color=#75715e>   * to the root.</color>
<color=#75715e>   *</color>
<color=#75715e>   * Overrides fetchTarget() so that if the rootLatch is not held exclusively</color>
<color=#75715e>   * when the root is fetched, we upgrade it to exclusive. Also overrides</color>
<color=#75715e>   * setter methods to assert that an exclusive latch is held.</color>
<color=#75715e>   *</color>
<color=#75715e>   * Overrides setDirty to dirty the DatabaseImpl, so that the MapLN will be</color>
<color=#75715e>   * logged during the next checkpoint. This is critical when updating the</color>
<color=#75715e>   * root LSN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>class</color> <color=#a6e22e>RootChildReference</color> <color=#66d9ef>extends</color> <color=#f8f8f2>ChildReference</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>private</color> <color=#a6e22e>RootChildReference</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#a6e22e>RootChildReference</color><color=#f8f8f2>(</color><color=#f8f8f2>Node</color> <color=#f8f8f2>target</color><color=#f8f8f2>,</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Caller is responsible for releasing rootLatch. */</color>
    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#f8f8f2>Node</color> <color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>getTarget</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>isExclusiveOwner</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If the root field changed while unlatched then we have an</color>
<color=#75715e>         * invalid state and cannot continue. [#21686]</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color> <color=#f92672>!=</color> <color=#f8f8f2>root</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#e6db74>"Root changed while unlatched, dbId="</color> <color=#f92672>+</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>Node</color> <color=#f8f8f2>target</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>isExclusiveOwner</color><color=#f8f8f2>();</color>
      <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>setTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>clearTarget</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>isExclusiveOwner</color><color=#f8f8f2>();</color>
      <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>clearTarget</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setLsn</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>isExclusiveOwner</color><color=#f8f8f2>();</color>
      <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>setLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>void</color> <color=#a6e22e>updateLsnAfterOptionalLog</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>isExclusiveOwner</color><color=#f8f8f2>();</color>
      <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>updateLsnAfterOptionalLog</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>void</color> <color=#a6e22e>setDirty</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>setDirty</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>setDirty</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Create a new tree. */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>Tree</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>database</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>init</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>setDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Create a tree that's being read in from the log. */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>Tree</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>init</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>maxTreeEntriesPerNode</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** constructor helper */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>init</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>database</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>root</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>database</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Do the stats definitions. */</color>
    <color=#f8f8f2>stats</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StatGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>GROUP_NAME</color><color=#f8f8f2>,</color> <color=#f8f8f2>GROUP_DESC</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>relatchesRequired</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>BTREE_RELATCHES_REQUIRED</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>rootSplits</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>IntStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>BTREE_ROOT_SPLITS</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Set the database for this tree. Used by recovery when recreating an existing tree. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>database</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>database</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The LatchContext for the root is special in that it is considered a</color>
<color=#75715e>     * Btree latch (the Btree latch table is used), but the context is not</color>
<color=#75715e>     * implemented by the IN class.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LatchContext</color> <color=#f8f8f2>latchContext</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>LatchContext</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
          <color=#a6e22e>@Override</color>
          <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getLatchTimeoutMs</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLatchTimeoutMs</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>

          <color=#a6e22e>@Override</color>
          <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>getLatchName</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#e6db74>"RootLatch"</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#a6e22e>@Override</color>
          <color=#66d9ef>public</color> <color=#f8f8f2>LatchTable</color> <color=#a6e22e>getLatchTable</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>btreeLatchTable</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#a6e22e>@Override</color>
          <color=#66d9ef>public</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#a6e22e>getEnvImplForFatalException</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>};</color>

    <color=#f8f8f2>rootLatch</color> <color=#f92672>=</color> <color=#f8f8f2>LatchFactory</color><color=#f8f8f2>.</color><color=#a6e22e>createSharedLatch</color><color=#f8f8f2>(</color><color=#f8f8f2>latchContext</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*exclusiveOnly*/</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>maxTreeEntriesPerNode</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeMaxTreeEntries</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return the database for this Tree. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>DatabaseImpl</color> <color=#a6e22e>getDatabase</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>database</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called when latching a child and the parent is latched. Used to opportunistically validate the</color>
<color=#75715e>   * parent pointer.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>latchChild</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getParent</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called when latching a child and the parent is latched. Used to opportunistically validate the</color>
<color=#75715e>   * parent pointer.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>latchChildShared</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>latchShared</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getParent</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>latchRootLatchExclusive</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>releaseRootLatch</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Set the root for the tree. Should only be called within the root latch. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>ChildReference</color> <color=#f8f8f2>newRoot</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>notLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>notLatched</color> <color=#f92672>||</color> <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>isExclusiveOwner</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>root</color> <color=#f92672>=</color> <color=#f8f8f2>newRoot</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>ChildReference</color> <color=#a6e22e>makeRootChildReference</color><color=#f8f8f2>(</color><color=#f8f8f2>Node</color> <color=#f8f8f2>target</color><color=#f8f8f2>,</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>RootChildReference</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>RootChildReference</color> <color=#a6e22e>makeRootChildReference</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>RootChildReference</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * A tree doesn't have a root if (a) the root field is null, or (b) the</color>
<color=#75715e>   * root is non-null, but has neither a valid target nor a valid LSN. Case</color>
<color=#75715e>   * (b) can happen if the database is or was previously opened in deferred</color>
<color=#75715e>   * write mode.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return false if there is no real root.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>rootExists</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Perform a fast check to see if the root IN is resident. No latching is performed. To ensure</color>
<color=#75715e>   * that the root IN is not loaded by another thread, this method should be called while holding a</color>
<color=#75715e>   * write lock on the MapLN. That will prevent opening the DB in another thread, and potentially</color>
<color=#75715e>   * loading the root IN. [#13415]</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isRootResident</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>root</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Helper to obtain the root IN with shared root latching. Optionally updates the generation of</color>
<color=#75715e>   * the root when latching it.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>IN</color> <color=#a6e22e>getRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>getRootINInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*exclusive*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Helper to obtain the root IN with exclusive root latching. Optionally updates the generation of</color>
<color=#75715e>   * the root when latching it.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>IN</color> <color=#a6e22e>getRootINLatchedExclusive</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>getRootINInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*exclusive*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>IN</color> <color=#a6e22e>getRootINInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>exclusive</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireShared</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>getRootINRootAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#f8f8f2>exclusive</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Helper to obtain the root IN, when the root latch is already held. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>IN</color> <color=#a6e22e>getRootINRootAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>exclusive</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>rootExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>exclusive</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>latchShared</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>IN</color> <color=#a6e22e>getResidentRootIN</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>latched</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>latched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>latchShared</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>IN</color> <color=#a6e22e>withRootLatchedExclusive</color><color=#f8f8f2>(</color><color=#f8f8f2>WithRootLatched</color> <color=#f8f8f2>wrl</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>wrl</color><color=#f8f8f2>.</color><color=#a6e22e>doWork</color><color=#f8f8f2>(</color><color=#f8f8f2>root</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>IN</color> <color=#a6e22e>withRootLatchedShared</color><color=#f8f8f2>(</color><color=#f8f8f2>WithRootLatched</color> <color=#f8f8f2>wrl</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireShared</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>wrl</color><color=#f8f8f2>.</color><color=#a6e22e>doWork</color><color=#f8f8f2>(</color><color=#f8f8f2>root</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Get LSN of the rootIN. Obtained without latching, should only be accessed while quiescent. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getRootLsn</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Cheaply calculates and returns the maximum possible number of LNs in the btree. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getMaxLNs</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>levels</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>topLevelSlots</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireShared</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>levels</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>LEVEL_MASK</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>topLevelSlots</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>topLevelSlots</color> <color=#f92672>*</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>pow</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeMaxTreeEntries</color><color=#f8f8f2>(),</color> <color=#f8f8f2>levels</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Deletes a BIN specified by key from the tree. If the BIN resides in a subtree that can be</color>
<color=#75715e>   * pruned away, prune as much as possible, so we don't leave a branch that has no BINs.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>It's possible that the targeted BIN will now have entries, or will have resident cursors.</color>
<color=#75715e>   * Either will prevent deletion (see exceptions).</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Unlike splits, IN deletion does not immediately log the subtree parent or its ancestors. It</color>
<color=#75715e>   * is sufficient to simply dirty the subtree parent. Logging is not necessary for correctness, and</color>
<color=#75715e>   * if a checkpoint does not flush the subtree parent then recovery will add the BINs to the</color>
<color=#75715e>   * compressor queue when redoing the LN deletions.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param idKey - the identifier key of the node to delete.</color>
<color=#75715e>   * @throws NodeNotEmptyException if the BIN is not empty. The deletion is no longer possible.</color>
<color=#75715e>   * @throws CursorsExistException is the BIN has cursors. The deletion should be retried later by</color>
<color=#75715e>   *     the INCompressor.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>delete</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>idKey</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>NodeNotEmptyException</color><color=#f8f8f2>,</color> <color=#f8f8f2>CursorsExistException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>SplitInfo</color><color=#f92672>></color> <color=#f8f8f2>nodeLadder</color> <color=#f92672>=</color> <color=#f8f8f2>searchDeletableSubTree</color><color=#f8f8f2>(</color><color=#f8f8f2>idKey</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodeLadder</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * The tree is empty, so do nothing.  Root compression is no</color>
<color=#75715e>       * longer supported.  Root compression has no impact on memory</color>
<color=#75715e>       * usage now that we evict the root IN.  It reduces log space</color>
<color=#75715e>       * taken by INs for empty (but not removed) databases, yet</color>
<color=#75715e>       * requires logging a INDelete and MapLN; this provides very</color>
<color=#75715e>       * little benefit, if any.  Because it requires extensive</color>
<color=#75715e>       * testing (which has not been done), this minor benefit is not</color>
<color=#75715e>       * worth the cost.  And by removing it we no longer log</color>
<color=#75715e>       * INDelete, which reduces complexity going forward. [#17546]</color>
<color=#75715e>       */</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Detach this subtree. */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>SplitInfo</color> <color=#f8f8f2>detachPoint</color> <color=#f92672>=</color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>branchParent</color> <color=#f92672>=</color> <color=#f8f8f2>detachPoint</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>branchRoot</color> <color=#f92672>=</color> <color=#f8f8f2>detachPoint</color><color=#f8f8f2>.</color><color=#a6e22e>child</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINEST</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>envLogMsg</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINEST</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#e6db74>"Tree.delete() "</color>
                <color=#f92672>+</color> <color=#f8f8f2>Thread</color><color=#f8f8f2>.</color><color=#a6e22e>currentThread</color><color=#f8f8f2>().</color><color=#a6e22e>getId</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>"-"</color>
                <color=#f92672>+</color> <color=#f8f8f2>Thread</color><color=#f8f8f2>.</color><color=#a6e22e>currentThread</color><color=#f8f8f2>().</color><color=#a6e22e>getName</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>"-"</color>
                <color=#f92672>+</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>" Deleting child node: "</color>
                <color=#f92672>+</color> <color=#f8f8f2>branchRoot</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>" from parent node: "</color>
                <color=#f92672>+</color> <color=#f8f8f2>branchParent</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>" parent has "</color>
                <color=#f92672>+</color> <color=#f8f8f2>branchParent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>" children"</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>branchParent</color><color=#f8f8f2>.</color><color=#a6e22e>deleteEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>detachPoint</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Remove deleted INs from the INList/cache and count them as</color>
<color=#75715e>       * provisionally obsolete. The parent is not logged immediately, so</color>
<color=#75715e>       * we can't count them immediately obsolete. They will be counted</color>
<color=#75715e>       * obsolete when an ancestor is logged non-provisionally. [#21348]</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>INList</color> <color=#f8f8f2>inList</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>();</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>SplitInfo</color> <color=#f8f8f2>info</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>child</color><color=#f8f8f2>;</color>

        <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isUpperIN</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Remove child from cache. The branch root was removed by</color>
<color=#75715e>         * deleteEntry above.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#f8f8f2>branchRoot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>inList</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Count full and delta versions as obsolete. */</color>
        <color=#f8f8f2>branchParent</color><color=#f8f8f2>.</color><color=#a6e22e>trackProvisionalObsolete</color><color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getLastFullLsn</color><color=#f8f8f2>());</color>

        <color=#f8f8f2>branchParent</color><color=#f8f8f2>.</color><color=#a6e22e>trackProvisionalObsolete</color><color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getLastDeltaLsn</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINE</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>envLogMsg</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINE</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"SubtreeRemoval: subtreeRoot = "</color> <color=#f92672>+</color> <color=#f8f8f2>branchRoot</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseNodeLadderLatches</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeLadder</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Search down the tree using a key, but instead of returning the BIN that houses that key, find</color>
<color=#75715e>   * the point where we can detach a deletable subtree. A deletable subtree is a branch where each</color>
<color=#75715e>   * IN has one child, and the bottom BIN has no entries and no resident cursors. That point can be</color>
<color=#75715e>   * found by saving a pointer to the lowest node in the path with more than one entry.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>INa / \ INb INc | | INd .. / \ INe .. | BINx (suspected of being empty)</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>In this case, we'd like to prune off the subtree headed by INe. INd is the parent of this</color>
<color=#75715e>   * deletable subtree.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The method returns a list of parent/child/index structures. In this example, the list will</color>
<color=#75715e>   * hold: INd/INe/index INe/BINx/index All three nodes will be EX-latched.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return null if the entire Btree is empty, or a list of SplitInfo for the branch to be deleted.</color>
<color=#75715e>   *     If non-null is returned, the INs in the list will be EX-latched; otherwise, no INs will be</color>
<color=#75715e>   *     latched.</color>
<color=#75715e>   * @throws NodeNotEmptyException if the BIN is not empty.</color>
<color=#75715e>   * @throws CursorsExistException is the BIN has cursors.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>SplitInfo</color><color=#f92672>></color> <color=#a6e22e>searchDeletableSubTree</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>NodeNotEmptyException</color><color=#f8f8f2>,</color> <color=#f8f8f2>CursorsExistException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>key</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>getRootINLatchedExclusive</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Tree was never persisted. */</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>ArrayList</color><color=#f92672><</color><color=#f8f8f2>SplitInfo</color><color=#f92672>></color> <color=#f8f8f2>nodeLadder</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ArrayList</color><color=#f92672><></color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>pinedIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

      <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"Found upper IN with 0 entries"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * A node with more than one entry is the lowest potential</color>
<color=#75715e>           * branch parent. Unlatch/discard ancestors of this parent.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>SplitInfo</color> <color=#f8f8f2>info</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>pinedIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isPinned</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>pinedIN</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

        <color=#75715e>/* Get the child node that matches. */</color>
        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>fetchIN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>latchChild</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>SplitInfo</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>));</color>

        <color=#75715e>/* Continue down a level */</color>
        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>());</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pinedIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>CursorsExistException</color><color=#f8f8f2>.</color><color=#a6e22e>CURSORS_EXIST</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * See if there is a reason we can't delete this BIN -- i.e.</color>
<color=#75715e>       * new items have been inserted, or a cursor exists on it.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>());</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>NodeNotEmptyException</color><color=#f8f8f2>.</color><color=#a6e22e>NODE_NOT_EMPTY</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"Found BIN delta with 0 entries"</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * This case can happen if we are keeping a cursor on an empty</color>
<color=#75715e>       * BIN as we traverse.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>nCursors</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isPinned</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>CursorsExistException</color><color=#f8f8f2>.</color><color=#a6e22e>CURSORS_EXIST</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>).</color><color=#a6e22e>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672><=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* The entire tree is empty. */</color>
        <color=#f8f8f2>releaseNodeLadderLatches</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeLadder</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Throwable</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseNodeLadderLatches</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeLadder</color><color=#f8f8f2>);</color>
      <color=#75715e>/* Release parent in case it was not added to nodeLadder. */</color>
      <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatchIfOwner</color><color=#f8f8f2>();</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Release latched acquired by searchDeletableSubTree. Each child is latched, plus the parent of</color>
<color=#75715e>   * the first node (the branch parent).</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>releaseNodeLadderLatches</color><color=#f8f8f2>(</color><color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>SplitInfo</color><color=#f92672>></color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>).</color><color=#a6e22e>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>SplitInfo</color> <color=#f8f8f2>info</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Find the leftmost node (IN or BIN) in the tree.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the leftmost node in the tree, null if the tree is empty. The returned node is latched</color>
<color=#75715e>   *     and the caller must release it.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>getFirstNode</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color>
        <color=#f8f8f2>search</color><color=#f8f8f2>(</color><color=#66d9ef>null</color> <color=#75715e>/*key*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>LEFT</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*binBoundary*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*comparator*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Find the rightmost node (IN or BIN) in the tree.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the rightmost node in the tree, null if the tree is empty. The returned node is latched</color>
<color=#75715e>   *     and the caller must release it.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>getLastNode</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color>
        <color=#f8f8f2>search</color><color=#f8f8f2>(</color>
            <color=#66d9ef>null</color> <color=#75715e>/*key*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>RIGHT</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*binBoundary*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*comparator*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return a reference to the adjacent BIN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param bin The BIN to find the next BIN for. This BIN is latched.</color>
<color=#75715e>   * @return The next BIN, or null if there are no more. The returned node is latched and the caller</color>
<color=#75715e>   *     must release it. If null is returned, the argument BIN remains latched.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>getNextBin</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>getNextIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return a reference to the previous BIN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param bin The BIN to find the next BIN for. This BIN is latched.</color>
<color=#75715e>   * @return The previous BIN, or null if there are no more. The returned node is latched and the</color>
<color=#75715e>   *     caller must release it. If null is returned, the argument bin remains latched.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>getPrevBin</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>getNextIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the next IN in the tree before/after the given IN, and at the same level. For example,</color>
<color=#75715e>   * if a BIN is passed in the prevIn parameter, the next BIN will be returned.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>TODO: A possible problem with this method is that we don't know for certain whether it works</color>
<color=#75715e>   * properly in the face of splits. There are comments below indicating it does. But the</color>
<color=#75715e>   * Cursor.checkForInsertion method was apparently added because getNextBin/getPrevBin didn't work</color>
<color=#75715e>   * properly, and may skip a BIN. So at least it didn't work properly in the distant past.</color>
<color=#75715e>   * Archeology and possibly testing are needed to find the truth. Hopefully it does now work, and</color>
<color=#75715e>   * Cursor.checkForInsertion can be removed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>TODO: To eliminate EX latches on upper INs, a new getParentINForChildIN is needed, which</color>
<color=#75715e>   * will return with both the parent and the grandparent SH-latched. If we do this, then in</color>
<color=#75715e>   * Tree.getNextIN() the call to searchSubtree() will be able to do grandparent latching, and the</color>
<color=#75715e>   * call to parent.fetchIN(index) will also be replace with a local version of grandparent</color>
<color=#75715e>   * latching.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>IN</color> <color=#a6e22e>getNextIN</color><color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>prevIn</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>latchShared</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevIn</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>());</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>prevIn</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Use the right most key (for a forward progressing cursor) or the</color>
<color=#75715e>     * left most key (for a backward progressing cursor) as the search key.</color>
<color=#75715e>     * The reason is that the IN may get split while finding the next IN so</color>
<color=#75715e>     * it's not safe to take the IN's identifierKey entry.  If the IN gets</color>
<color=#75715e>     * split, then the right (left) most key will still be on the</color>
<color=#75715e>     * resultant node.  The exception to this is that if there are no</color>
<color=#75715e>     * entries, we just use the identifier key.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>searchKey</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevIn</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>searchKey</color> <color=#f92672>=</color> <color=#f8f8f2>prevIn</color><color=#f8f8f2>.</color><color=#a6e22e>getIdentifierKey</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>searchKey</color> <color=#f92672>=</color> <color=#f8f8f2>prevIn</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>prevIn</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>searchKey</color> <color=#f92672>=</color> <color=#f8f8f2>prevIn</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetLevel</color> <color=#f92672>=</color> <color=#f8f8f2>prevIn</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>curr</color> <color=#f92672>=</color> <color=#f8f8f2>prevIn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>currIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>nextIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>nextINIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>normalExit</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Ascend the tree until we find a level that still has nodes to the</color>
<color=#75715e>     * right (or left if !forward) of the path that we're on.  If we reach</color>
<color=#75715e>     * the root level, we're done.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Move up a level from where we are now and check to see if we</color>
<color=#75715e>         * reached the top of the tree.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>currIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>curr</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* We've reached the root of the tree. */</color>
          <color=#f8f8f2>curr</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>normalExit</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>SearchResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color>
            <color=#f8f8f2>getParentINForChildIN</color><color=#f8f8f2>(</color><color=#f8f8f2>curr</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#75715e>/*useTargetLevel*/</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#75715e>/*doFetch*/</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>exactParentFound</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"Failed to find parent for IN"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Figure out which entry we are in the parent. Add (subtract)</color>
<color=#75715e>         * 1 to move to the next (previous) one and check that we're</color>
<color=#75715e>         * still pointing to a valid child.  Don't just use the result</color>
<color=#75715e>         * of the parent.findEntry call in getParentNode, because we</color>
<color=#75715e>         * want to use our explicitly chosen search key.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>searchKey</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

        <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>moreEntriesThisIn</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>index</color><color=#f92672>++</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>moreEntriesThisIn</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672><</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>moreEntriesThisIn</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>index</color><color=#f92672>--</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>moreEntriesThisIn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * There are more entries to the right of the current path</color>
<color=#75715e>           * in parent.  Get the entry, and then descend down the</color>
<color=#75715e>           * left most path to an IN.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>nextIN</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>fetchIN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nextIN</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>latchShared</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>latchChildShared</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>nextIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>latchChild</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>nextIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
            <color=#f8f8f2>nextINIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

            <color=#f8f8f2>nextIN</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color> <color=#75715e>// to avoid falsely unlatching parent</color>

            <color=#66d9ef>final</color> <color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>=</color> <color=#f8f8f2>getTreeStatsAccumulator</color><color=#f8f8f2>();</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>nextIN</color><color=#f8f8f2>.</color><color=#a6e22e>accumulateStats</color><color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>

            <color=#f8f8f2>normalExit</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>nextIN</color><color=#f8f8f2>;</color>

          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

            <color=#75715e>/*</color>
<color=#75715e>             * We landed at a higher level than the target level.</color>
<color=#75715e>             * Descend down to the appropriate level.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>nextIN</color><color=#f8f8f2>.</color><color=#a6e22e>isUpperIN</color><color=#f8f8f2>());</color>
            <color=#f8f8f2>nextIN</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>nextINIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color> <color=#75715e>// to avoid falsely unlatching parent</color>
            <color=#f8f8f2>nextINIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

            <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>ret</color> <color=#f92672>=</color>
                <color=#f8f8f2>searchSubTree</color><color=#f8f8f2>(</color>
                    <color=#f8f8f2>nextIN</color><color=#f8f8f2>,</color>
                    <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#75715e>/*key*/</color>
                    <color=#f8f8f2>(</color><color=#f8f8f2>forward</color> <color=#f92672>?</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>LEFT</color> <color=#f8f8f2>:</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>RIGHT</color><color=#f8f8f2>),</color>
                    <color=#f8f8f2>targetLevel</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>latchShared</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color>
                    <color=#66d9ef>null</color> <color=#75715e>/*comparator*/</color><color=#f8f8f2>);</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>normalExit</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
              <color=#66d9ef>return</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
                  <color=#e6db74>"subtree did not have a IN at level "</color> <color=#f92672>+</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Nothing at this level. Ascend to a higher level. */</color>
        <color=#f8f8f2>curr</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>currIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color> <color=#75715e>// to avoid falsely unlatching parent below</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>normalExit</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>curr</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>currIsLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>curr</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nextIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>nextINIsLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>nextIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Search for the parent P of a given IN C (where C is viewed as a logical node; not as a java</color>
<color=#75715e>   * obj). If found, P is returned latched exclusively. The method is used when C has been accessed</color>
<color=#75715e>   * "directly", i.e., not via a tree search, and we need to perform an operation on C that requires</color>
<color=#75715e>   * an update to its parent. Such situations arise during eviction (C has been accessed via the LRU</color>
<color=#75715e>   * list), checkpointing, and recovery (C has been read from the log and is not attached to the</color>
<color=#75715e>   * in-memory tree).</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The method uses C's identifierKey to search down the tree until:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>(a) doFetch is false and we need to access a node that is not cached. In this case, we are</color>
<color=#75715e>   * actually looking for the cached copies of both C and its parent, so a cache miss on the path to</color>
<color=#75715e>   * C is considered a failure. This search mode is used by the evictor: to evict C (which has been</color>
<color=#75715e>   * retrieved from the LRU), its parent must be found and EX-latched; however, if the C has been</color>
<color=#75715e>   * evicted already by another thread, there is nothing to do (C will GC-ed). or (b) We reach a</color>
<color=#75715e>   * node whose node id equals the C's node id. In this case, we know for sure that C still belongs</color>
<color=#75715e>   * to the BTree and its parent has been found. or (c) useTargetLevel is true and we reach a node P</color>
<color=#75715e>   * that is at one level above C's level. We know that P contains a slot S whose corresponding key</color>
<color=#75715e>   * range includes C's identifierKey. Since we haven't read the child node under S to check its</color>
<color=#75715e>   * node id, we cannot know for sure that C is still in the tree. Nevertheless, we consider this</color>
<color=#75715e>   * situation a success, i.e., P is the parent node we are looking for. In this search mode, after</color>
<color=#75715e>   * this method returns, the caller is expected to take further action based on the info in slot S.</color>
<color=#75715e>   * For example, if C was created by reading a log entry at LSN L, and the LSN at slot S is also L,</color>
<color=#75715e>   * then we know P is the real parent (and we have thus saved a possible extra I/O to refetch the C</color>
<color=#75715e>   * node from the log to check its node id). This search mode is used by the cleaner. or (d) None</color>
<color=#75715e>   * of the above conditions occur and the bottom of the BTree is reached. In this case, no parent</color>
<color=#75715e>   * exists (the child node is an old version of a node that has been removed from the BTree).</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param child The child node for which to find the parent. This node is latched by the caller</color>
<color=#75715e>   *     and is unlatched by this function before returning to the caller.</color>
<color=#75715e>   * @param useTargetLevel If true, the search is considered successful if a node P is reached at</color>
<color=#75715e>   *     one level above C's level. P is the parent to return to the caller.</color>
<color=#75715e>   * @param doFetch if false, stop the search if we run into a non-resident child and assume that no</color>
<color=#75715e>   *     parent exists.</color>
<color=#75715e>   * @param cacheMode The CacheMode for affecting the hotness of the nodes visited during the</color>
<color=#75715e>   *     search.</color>
<color=#75715e>   * @return a SearchResult object. If the parent has been found, result.foundExactMatch is true,</color>
<color=#75715e>   *     result.parent refers to that node, and result.index is the slot for the child IN inside the</color>
<color=#75715e>   *     parent IN. Otherwise, result.foundExactMatch is false and result.parent is null.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>SearchResult</color> <color=#a6e22e>getParentINForChildIN</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useTargetLevel</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>doFetch</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>getParentINForChildIN</color><color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>useTargetLevel</color><color=#f8f8f2>,</color> <color=#f8f8f2>doFetch</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*trackingList*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * This version of getParentINForChildIN does the same thing as the version above, but also adds a</color>
<color=#75715e>   * "trackingList" param. If trackingList is not null, the LSNs of the parents visited along the</color>
<color=#75715e>   * way are added to the list, as a debug tracing mechanism. This is meant to stay in production,</color>
<color=#75715e>   * to add information to the log.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>SearchResult</color> <color=#a6e22e>getParentINForChildIN</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>useTargetLevel</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>doFetch</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>TrackingInfo</color><color=#f92672>></color> <color=#f8f8f2>trackingList</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Sanity checks */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"getParentINForChildIN given null child node"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Get information from child before releasing latch.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>targetId</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>();</color>
    <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>targetKey</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getIdentifierKey</color><color=#f8f8f2>();</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>targetLevel</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>useTargetLevel</color> <color=#f92672>?</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f8f8f2>:</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>exclusiveLevel</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>requireExactMatch</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>getParentINForChildIN</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>targetId</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>targetKey</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>targetLevel</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>exclusiveLevel</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>requireExactMatch</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>doFetch</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>trackingList</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * This version of getParentINForChildIN() is the actual implementation of the previous 2 versions</color>
<color=#75715e>   * (read the comments there), but it also implements one additional use cases via the extra</color>
<color=#75715e>   * "requireExactMatch" param.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>requireExactMatch == false && doFetch == false In this case we are actually looking for the</color>
<color=#75715e>   * lowest cached ancestor of the C node. The method will always return a node (considered as the</color>
<color=#75715e>   * "parent") unless the BTree is empty (has no nodes at all). The returned node must be latched,</color>
<color=#75715e>   * but not necessarily in EX mode. This search mode is used by the checkpointer.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The exclusiveLevel param: In general, if exclusiveLevel == L, nodes above L will be SH</color>
<color=#75715e>   * latched and nodes at or below L will be EX-latched. In all current use cases, L is set to 1 +</color>
<color=#75715e>   * C.level. Note that if doFetch == false, the normalized exclusiveLevel must be >= 2 so that</color>
<color=#75715e>   * loadIN can be called.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>SearchResult</color> <color=#a6e22e>getParentINForChildIN</color><color=#f8f8f2>(</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>targetNodeId</color><color=#f8f8f2>,</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>targetKey</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>exclusiveLevel</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>requireExactMatch</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>doFetch</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>TrackingInfo</color><color=#f92672>></color> <color=#f8f8f2>trackingList</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Call hook before latching. No latches are held. */</color>
    <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>getParentINHook</color><color=#f8f8f2>);</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>doFetch</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>exclusiveLevel</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>LEVEL_MASK</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * SearchResult is initialized as follows:</color>
<color=#75715e>     * exactParentFound = false;</color>
<color=#75715e>     * parent = null; index = -1; childNotResident = false;</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>SearchResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>SearchResult</color><color=#f8f8f2>();</color>

    <color=#75715e>/* Get the tree root, SH-latched. */</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>getRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* If the root is the target node, there is no parent */</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>targetNodeId</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#f8f8f2>exclusiveLevel</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>:</color> <color=#e6db74>" rootLevel="</color> <color=#f92672>+</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#e6db74>" exLevel="</color> <color=#f92672>+</color> <color=#f8f8f2>exclusiveLevel</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672><=</color> <color=#f8f8f2>exclusiveLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>getRootINLatchedExclusive</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>targetKey</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>trackingList</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>trackingList</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color>
              <color=#66d9ef>new</color> <color=#f8f8f2>TrackingInfo</color><color=#f8f8f2>(</color>
                  <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>),</color>
                  <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>(),</color>
                  <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>(),</color>
                  <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>searchHook</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetLevel</color> <color=#f92672>></color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>targetLevel</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>exactParentFound</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>doFetch</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>fetchINWithNoLatch</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>trackingList</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>trackingList</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
            <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>reset</color><color=#f8f8f2>();</color>

            <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>fetchINHook</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>getRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672><=</color> <color=#f8f8f2>exclusiveLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
              <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>getRootINLatchedExclusive</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
              <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>

            <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * We can only call loadIN if we have an EX-latch on the</color>
<color=#75715e>           * parent. However, calling loadIN is only necessary when</color>
<color=#75715e>           * the parent is at level 2, since UINs are not cached</color>
<color=#75715e>           * off-heap, and exclusiveLevel is currently always >= 2.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNormalizedLevel</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>loadIN</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>doFetch</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>requireExactMatch</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>childNotResident</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>targetNodeId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>exactParentFound</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>requireExactMatch</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* We can search further down the tree. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672><=</color> <color=#f8f8f2>exclusiveLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>latchChild</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>latchChildShared</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>((</color><color=#f92672>!</color><color=#f8f8f2>doFetch</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>requireExactMatch</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return a reference to the parent of this LN. This searches through the tree and allows splits,</color>
<color=#75715e>   * if the splitsAllowed param is true. Set the tree location to the proper BIN parent whether or</color>
<color=#75715e>   * not the LN child is found. That's because if the LN is not found, recovery or abort will need</color>
<color=#75715e>   * to place it within the tree, and so we must point at the appropriate position.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>When this method returns with location.bin non-null, the BIN is latched and must be</color>
<color=#75715e>   * unlatched by the caller. Note that location.bin may be non-null even if this method returns</color>
<color=#75715e>   * false.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param location a holder class to hold state about the location of our search. Sort of an</color>
<color=#75715e>   *     internal cursor.</color>
<color=#75715e>   * @param key key to navigate through main key</color>
<color=#75715e>   * @param splitsAllowed true if this method is allowed to cause tree splits as a side effect. In</color>
<color=#75715e>   *     practice, recovery can cause splits, but abort can't.</color>
<color=#75715e>   * @param blindDeltaOps Normally, if this method lands on a BIN-delta and the search key is not in</color>
<color=#75715e>   *     that delta, it will mutate the delta to a full BIN to make sure whether the search key</color>
<color=#75715e>   *     exists in the tree or not. However, by passing true for blindDeltaOps, the caller indicates</color>
<color=#75715e>   *     that it doesn't really care whether the key is in the tree or not: it is going to insert</color>
<color=#75715e>   *     the key in the BIN-delta, if not already there, essentially overwritting the slot that may</color>
<color=#75715e>   *     exist in the full BIN. So, if blindDeltaOps is true, the method will not mutate a BIN-delta</color>
<color=#75715e>   *     parent (unless the BIN-delta has no space for a slot insertion).</color>
<color=#75715e>   * @param cacheMode The CacheMode for affecting the hotness of the tree.</color>
<color=#75715e>   * @return true if node found in tree. If false is returned and there is the possibility that we</color>
<color=#75715e>   *     can insert the record into a plausible parent we must also set - location.bin (may be null</color>
<color=#75715e>   *     if no possible parent found) - location.lnKey (don't need to set if no possible parent).</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>getParentBINForChildLN</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>TreeLocation</color> <color=#f8f8f2>location</color><color=#f8f8f2>,</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>splitsAllowed</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>blindDeltaOps</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Find the BIN that either points to this LN or could be its</color>
<color=#75715e>     * ancestor.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>reset</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>splitsAllowed</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>searchSplitsAllowed</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*comparator*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>search</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*indicateIfExact*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*exactSearch*/</color><color=#f8f8f2>);</color>

        <color=#66d9ef>boolean</color> <color=#f8f8f2>match</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>index</color> <color=#f92672>&=</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>index</color> <color=#f92672>=</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>lnKey</color> <color=#f92672>=</color> <color=#f8f8f2>key</color><color=#f8f8f2>;</color>

        <color=#75715e>/*</color>
<color=#75715e>        if (!match && bin.isBINDelta() && blindDeltaOps) {</color>
<color=#75715e>              System.out.println(</color>
<color=#75715e>                  "Blind op on BIN-delta : " + bin.getNodeId() +</color>
<color=#75715e>                  " nEntries = " +</color>
<color=#75715e>                  bin.getNEntries() +</color>
<color=#75715e>                  " max entries = " +</color>
<color=#75715e>                  bin.getMaxEntries() +</color>
<color=#75715e>                  " full BIN entries = " +</color>
<color=#75715e>                  bin.getFullBinNEntries() +</color>
<color=#75715e>                  " full BIN max entries = " +</color>
<color=#75715e>                  bin.getFullBinMaxEntries());</color>
<color=#75715e>        }</color>
<color=#75715e>        */</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>match</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>childLsn</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>childLoggedSize</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>isKD</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbedded</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

          <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>blindDeltaOps</color> <color=#f92672>||</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getMaxEntries</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>splitsAllowed</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>reset</color><color=#f8f8f2>();</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>RuntimeException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>location</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Find the BIN that is relevant to the insert. If the tree doesn't exist yet, then create the</color>
<color=#75715e>   * first IN and BIN. On return, the cursor is set to the BIN that is found or created, and the BIN</color>
<color=#75715e>   * is latched.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>findBinForInsert</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>rootLatchIsHeld</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We may have to try several times because of a small</color>
<color=#75715e>       * timing window, explained below.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>rootLatchIsHeld</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireShared</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>rootExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>rootLatchIsHeld</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>env</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
          <color=#66d9ef>final</color> <color=#f8f8f2>INList</color> <color=#f8f8f2>inMemoryINs</color> <color=#f92672>=</color> <color=#f8f8f2>env</color><color=#f8f8f2>.</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>();</color>

          <color=#75715e>/*</color>
<color=#75715e>           * This is an empty tree, either because it's brand new</color>
<color=#75715e>           * tree or because everything in it was deleted. Create an</color>
<color=#75715e>           * IN and a BIN.  We could latch the rootIN here, but</color>
<color=#75715e>           * there's no reason to since we're just creating the</color>
<color=#75715e>           * initial tree and we have the rootLatch held. Remember</color>
<color=#75715e>           * that referred-to children must be logged before any</color>
<color=#75715e>           * references to their LSNs.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>IN</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxTreeEntriesPerNode</color><color=#f8f8f2>,</color> <color=#ae81ff>2</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>setIsRoot</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

          <color=#75715e>/* First BIN in the tree, log provisionally right away. */</color>
          <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BIN</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxTreeEntriesPerNode</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>logLsn</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>optionalLogProvisionalNoCompress</color><color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>);</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Log the root right away. Leave the root dirty, because</color>
<color=#75715e>           * the MapLN is not being updated, and we want to avoid</color>
<color=#75715e>           * this scenario from [#13897], where the LN has no</color>
<color=#75715e>           * possible parent.</color>
<color=#75715e>           *  provisional BIN</color>
<color=#75715e>           *  root IN</color>
<color=#75715e>           *  checkpoint start</color>
<color=#75715e>           *  LN is logged</color>
<color=#75715e>           *  checkpoint end</color>
<color=#75715e>           *  BIN is dirtied, but is not part of checkpoint</color>
<color=#75715e>           */</color>
          <color=#66d9ef>boolean</color> <color=#f8f8f2>insertOk</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>insertEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>);</color>
          <color=#66d9ef>assert</color> <color=#f8f8f2>insertOk</color><color=#f8f8f2>;</color>

          <color=#f8f8f2>logLsn</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>optionalLog</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>setDirty</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color> <color=#75715e>/*force re-logging, see [#13897]*/</color>

          <color=#f8f8f2>root</color> <color=#f92672>=</color> <color=#f8f8f2>makeRootChildReference</color><color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>0</color><color=#f92672>]</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>

          <color=#75715e>/* Add the new nodes to the in memory list. */</color>
          <color=#f8f8f2>inMemoryINs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>inMemoryINs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>env</color><color=#f8f8f2>.</color><color=#a6e22e>getEvictor</color><color=#f8f8f2>().</color><color=#a6e22e>addBack</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>rootLatchIsHeld</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>rootLatchIsHeld</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

          <color=#75715e>/*</color>
<color=#75715e>           * There's a tree here, so search for where we should</color>
<color=#75715e>           * insert. However, note that a window exists after we</color>
<color=#75715e>           * release the root latch. We release the latch because the</color>
<color=#75715e>           * search method expects to take the latch. After the</color>
<color=#75715e>           * release and before search, the INCompressor may come in</color>
<color=#75715e>           * and delete the entire tree, so search may return with a</color>
<color=#75715e>           * null.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>searchSplitsAllowed</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>/* The tree was deleted by the INCompressor. */</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#75715e>/* search() found a BIN where this key belongs. */</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootLatchIsHeld</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* testing hook to insert item into log. */</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>ckptHook</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Do a key based search, permitting pre-emptive splits. Returns the target node's parent. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>searchSplitsAllowed</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>searchSplitsAllowed</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>searchSplitsAllowed</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#f8f8f2>Comparator</color><color=#f92672><</color><color=#66d9ef>byte</color><color=#f92672>[]></color> <color=#f8f8f2>comparator</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>BIN</color> <color=#f8f8f2>insertTarget</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>insertTarget</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireShared</color><color=#f8f8f2>();</color>

      <color=#66d9ef>boolean</color> <color=#f8f8f2>rootLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>rootINLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Latch the rootIN, check if it needs splitting. If so split it</color>
<color=#75715e>       * and update the associated MapLN. To update the MapLN, we must</color>
<color=#75715e>       * lock it, which implies that all latches must be released prior</color>
<color=#75715e>       * to the lock, and as a result, the root may require splitting</color>
<color=#75715e>       * again or may be split by another thread. So we must restart</color>
<color=#75715e>       * the loop to get the latest root.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>rootExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>needsSplitting</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>rootExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>needsSplitting</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>splitRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>rootLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

            <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>env</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>env</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>().</color><color=#a6e22e>optionalModifyDbRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>);</color>

            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>latchShared</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>rootINLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color> <color=#f92672>&&</color> <color=#f8f8f2>rootINLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Now, search the tree, doing splits if required. The rootIN</color>
<color=#75715e>       * is latched in SH mode, but this.root is not latched. If any</color>
<color=#75715e>       * splits are needed, this.root will first be latched exclusivelly</color>
<color=#75715e>       * and will stay latched until all splits are done.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootINLatched</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>insertTarget</color> <color=#f92672>=</color> <color=#f8f8f2>searchSplitsAllowed</color><color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#f8f8f2>comparator</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>insertTarget</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>relatchesRequired</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>incRelatchesRequired</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>SplitRequiredException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * The last slot in the root was used at the point when this</color>
<color=#75715e>         * thread released the rootIN latch in order to force splits.</color>
<color=#75715e>         * Retry. SR [#11147].</color>
<color=#75715e>         */</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>insertTarget</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Search the tree, permitting preemptive splits.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>When this returns, parent will be unlatched unless parent is the returned IN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>searchSplitsAllowed</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>,</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#f8f8f2>Comparator</color><color=#f92672><</color><color=#66d9ef>byte</color><color=#f92672>[]></color> <color=#f8f8f2>comparator</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>SplitRequiredException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>());</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"A null or non-root IN was given as the parent"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Search downward until we hit a node that needs a split. In that</color>
<color=#75715e>     * case, retreat to the top of the tree and force splits downward.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"Found upper IN with 0 entries"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>comparator</color><color=#f8f8f2>);</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>fetchINWithNoLatch</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color> <color=#75715e>// restart the search</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* if child is a BIN, it is actually EX-latched */</color>
        <color=#f8f8f2>latchChildShared</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If we need to split, try compressing first and check again.</color>
<color=#75715e>         * Mutate to a full BIN because compression has no impact on a</color>
<color=#75715e>         * BIN-delta, and a full BIN is needed for splitting anyway.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>needsSplitting</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>lazyCompress</color><color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*compressDirtySlots*/</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>needsSplitting</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>

            <color=#75715e>/* SR [#11144]*/</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>waitHook</color><color=#f8f8f2>);</color>

            <color=#75715e>/*</color>
<color=#75715e>             * forceSplit may throw SplitRequiredException if it</color>
<color=#75715e>             * finds that the root needs splitting. Allow the</color>
<color=#75715e>             * exception to propagate up to the caller, who will</color>
<color=#75715e>             * do the root split. Otherwise, restart the search</color>
<color=#75715e>             * from the root IN again.</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>forceSplit</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>

            <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>());</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
                  <color=#e6db74>"A null or non-root IN was given as the parent"</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Continue down a level */</color>
        <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>());</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#f8f8f2>child</color> <color=#f92672>&&</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Do pre-emptive splitting: search down the tree until we get to the BIN level, and split any</color>
<color=#75715e>   * nodes that fit the splittable requirement except for the root. If the root needs splitting, a</color>
<color=#75715e>   * splitRequiredException is thrown and the root split is handled at a higher level.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Note that more than one node in the path may be splittable. For example, a tree might have a</color>
<color=#75715e>   * level2 IN and a BIN that are both splittable, and would be encountered by the same insert</color>
<color=#75715e>   * operation.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Splits cause INs to be logged in all ancestors, including the root. This is to avoid the</color>
<color=#75715e>   * "great aunt" problem described in LevelRecorder.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>INs below the root are logged provisionally; only the root is logged non-provisionally.</color>
<color=#75715e>   * Provisional logging is necessary during a checkpoint for levels less than maxFlushLevel.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method acquires and holds this.rootLatch in EX mode during its whole duration (so</color>
<color=#75715e>   * splits are serialized). The rootLatch is released on return.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the tree root node, latched in EX mode. This may be different than the tree root when</color>
<color=#75715e>   *     this method was called, because no latches are held on entering this method.</color>
<color=#75715e>   *     <p>All latches are released in case of exception.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>IN</color> <color=#a6e22e>forceSplit</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color><color=#f8f8f2>,</color> <color=#f8f8f2>SplitRequiredException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>ArrayList</color><color=#f92672><</color><color=#f8f8f2>SplitInfo</color><color=#f92672>></color> <color=#f8f8f2>nodeLadder</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ArrayList</color><color=#f92672><</color><color=#f8f8f2>SplitInfo</color><color=#f92672>></color><color=#f8f8f2>();</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>allLeftSideDescent</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>allRightSideDescent</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Latch the root in order to update the root LSN when we're done.</color>
<color=#75715e>     * Latch order must be: root, root IN. We'll leave this method with the</color>
<color=#75715e>     * original parent latched.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* The root IN may have been evicted. [#16173] */</color>
      <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Another thread may have crept in and</color>
<color=#75715e>       *  - used the last free slot in the parent, making it impossible</color>
<color=#75715e>       *    to correctly propagate the split.</color>
<color=#75715e>       *  - actually split the root, in which case we may be looking at</color>
<color=#75715e>       *    the wrong subtree for this search.</color>
<color=#75715e>       * If so, throw and retry from above. SR [#11144]</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>needsSplitting</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>splitRequiredException</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Search downward to the BIN level, saving the information</color>
<color=#75715e>       * needed to do a split if necessary.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"Found upper IN with 0 entries"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Look for the entry matching key in the current node. */</color>
        <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>allLeftSideDescent</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>!=</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>allRightSideDescent</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Get the child node that matches. We only need to work on</color>
<color=#75715e>         * nodes in residence.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>loadIN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>latchChild</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>SplitInfo</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>));</color>

        <color=#75715e>/* Continue down a level */</color>
        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>());</color>

      <color=#66d9ef>boolean</color> <color=#f8f8f2>startedSplits</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Process the accumulated nodes from the bottom up. Split each</color>
<color=#75715e>       * node if required. If the node should not split, we check if</color>
<color=#75715e>       * there have been any splits on the ladder yet. If there are none,</color>
<color=#75715e>       * we merely release the node, since there is no update.  If splits</color>
<color=#75715e>       * have started, we need to propagate new LSNs upward, so we log</color>
<color=#75715e>       * the node and update its parent.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>lastParentForSplit</color> <color=#f92672>=</color> <color=#f8f8f2>Node</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_NODE_ID</color><color=#f8f8f2>;</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>-=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>SplitInfo</color> <color=#f8f8f2>info</color> <color=#f92672>=</color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>child</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>;</color>

        <color=#75715e>/* Opportunistically split the node if it is full. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>needsSplitting</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

          <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>grandParent</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>).</color><color=#a6e22e>parent</color> <color=#f8f8f2>:</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>allLeftSideDescent</color> <color=#f92672>||</color> <color=#f8f8f2>allRightSideDescent</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>splitSpecial</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>grandParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxTreeEntriesPerNode</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>allLeftSideDescent</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>split</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>grandParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxTreeEntriesPerNode</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>lastParentForSplit</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>startedSplits</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

          <color=#75715e>/*</color>
<color=#75715e>           * If the DB root IN was logged, update the DB tree's child</color>
<color=#75715e>           * reference. Now the MapLN is logically dirty. Be sure to</color>
<color=#75715e>           * flush the MapLN if we ever evict the root.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>updateLsnAfterOptionalLog</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedLsn</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>startedSplits</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newChildLsn</color><color=#f8f8f2>;</color>

            <color=#75715e>/*</color>
<color=#75715e>             * If this child was the parent of a split, it's</color>
<color=#75715e>             * already logged by the split call. We just need to</color>
<color=#75715e>             * propagate the logging upwards. If this child is just</color>
<color=#75715e>             * a link in the chain upwards, log it.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastParentForSplit</color> <color=#f92672>==</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>newChildLsn</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedLsn</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>newChildLsn</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>optionalLogProvisional</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>

            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>updateEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>newChildLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color> <color=#75715e>/*lastLoggedSize*/</color><color=#f8f8f2>);</color>

            <color=#75715e>/*</color>
<color=#75715e>             * The root is never a 'child' in nodeLadder so it must</color>
<color=#75715e>             * be logged separately.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

              <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newRootLsn</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>optionalLog</color><color=#f8f8f2>();</color>

              <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>updateLsnAfterOptionalLog</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>newRootLsn</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatchIfOwner</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>SplitInfo</color> <color=#f8f8f2>info</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodeLadder</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>info</color><color=#f8f8f2>.</color><color=#a6e22e>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatchIfOwner</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatchIfOwner</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Split the root of the tree. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>splitRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Create a new root IN, insert the current root IN into it, and then</color>
<color=#75715e>     * call split.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>env</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>INList</color> <color=#f8f8f2>inMemoryINs</color> <color=#f92672>=</color> <color=#f8f8f2>env</color><color=#f8f8f2>.</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>IN</color> <color=#f8f8f2>curRoot</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>curRoot</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>curRoot</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>curRootLsn</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>logLsn</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>newRoot</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Make a new root IN, giving it an id key from the previous root.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>rootIdKey</color> <color=#f92672>=</color> <color=#f8f8f2>curRoot</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>newRoot</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>IN</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>rootIdKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxTreeEntriesPerNode</color><color=#f8f8f2>,</color> <color=#f8f8f2>curRoot</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>newRoot</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>newRoot</color><color=#f8f8f2>.</color><color=#a6e22e>setIsRoot</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>curRoot</color><color=#f8f8f2>.</color><color=#a6e22e>setIsRoot</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Make the new root IN point to the old root IN. Log the old root</color>
<color=#75715e>       * provisionally, because we modified it so it's not the root</color>
<color=#75715e>       * anymore, then log the new root. We are guaranteed to be able to</color>
<color=#75715e>       * insert entries, since we just made this root.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>logSuccess</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>curRootLsn</color> <color=#f92672>=</color> <color=#f8f8f2>curRoot</color><color=#f8f8f2>.</color><color=#a6e22e>optionalLogProvisional</color><color=#f8f8f2>(</color><color=#f8f8f2>newRoot</color><color=#f8f8f2>);</color>

        <color=#66d9ef>boolean</color> <color=#f8f8f2>inserted</color> <color=#f92672>=</color> <color=#f8f8f2>newRoot</color><color=#f8f8f2>.</color><color=#a6e22e>insertEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>curRoot</color><color=#f8f8f2>,</color> <color=#f8f8f2>rootIdKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>curRootLsn</color><color=#f8f8f2>);</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>inserted</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>logLsn</color> <color=#f92672>=</color> <color=#f8f8f2>newRoot</color><color=#f8f8f2>.</color><color=#a6e22e>optionalLog</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>logSuccess</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>logSuccess</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* Something went wrong when we tried to log. */</color>
          <color=#f8f8f2>curRoot</color><color=#f8f8f2>.</color><color=#a6e22e>setIsRoot</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>inMemoryINs</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>newRoot</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Don't add the new root into the LRU because it has a cached</color>
<color=#75715e>       * child.</color>
<color=#75715e>       */</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Make the tree's root reference point to this new node. Now the</color>
<color=#75715e>       * MapLN is logically dirty, but the change hasn't been logged.  Be</color>
<color=#75715e>       * sure to flush the MapLN if we ever evict the root.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>setTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>newRoot</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>updateLsnAfterOptionalLog</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>curRoot</color><color=#f8f8f2>.</color><color=#a6e22e>split</color><color=#f8f8f2>(</color><color=#f8f8f2>newRoot</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxTreeEntriesPerNode</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>setLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>newRoot</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedLsn</color><color=#f8f8f2>());</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* FindBugs ignore possible null pointer dereference of newRoot. */</color>
      <color=#f8f8f2>newRoot</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>curRoot</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>rootSplits</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>traceSplitRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINE</color><color=#f8f8f2>,</color> <color=#f8f8f2>TRACE_ROOT_SPLIT</color><color=#f8f8f2>,</color> <color=#f8f8f2>newRoot</color><color=#f8f8f2>,</color> <color=#f8f8f2>logLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>curRoot</color><color=#f8f8f2>,</color> <color=#f8f8f2>curRootLsn</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>search</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>search</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>NORMAL</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Search the tree, starting at the root. Depending on search type either (a) search for the BIN</color>
<color=#75715e>   * that *should* contain a given key, or (b) return the right-most or left-most BIN in the tree.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Preemptive splitting is not done during the search.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param key - the key to search for, or null if searchType is LEFT or RIGHT.</color>
<color=#75715e>   * @param searchType - The type of tree search to perform. NORMAL means we're searching for key in</color>
<color=#75715e>   *     the tree. LEFT/RIGHT means we're descending down the left or right side, resp.</color>
<color=#75715e>   * @param binBoundary - If non-null, information is returned about whether the BIN found is the</color>
<color=#75715e>   *     first or last BIN in the database.</color>
<color=#75715e>   * @return - the BIN that matches the criteria, if any. Returns null if the root is null. BIN is</color>
<color=#75715e>   *     latched (unless it's null) and must be unlatched by the caller. In a NORMAL search, it is</color>
<color=#75715e>   *     the caller's responsibility to do the findEntry() call on the key and BIN to locate the</color>
<color=#75715e>   *     entry (if any) that matches key.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>search</color><color=#f8f8f2>(</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>SearchType</color> <color=#f8f8f2>searchType</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>BINBoundary</color> <color=#f8f8f2>binBoundary</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Comparator</color><color=#f92672><</color><color=#66d9ef>byte</color><color=#f92672>[]></color> <color=#f8f8f2>comparator</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>getRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>((</color><color=#f8f8f2>searchType</color> <color=#f92672>!=</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>LEFT</color> <color=#f92672>&&</color> <color=#f8f8f2>searchType</color> <color=#f92672>!=</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>RIGHT</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>key</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>binBoundary</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>binBoundary</color><color=#f8f8f2>.</color><color=#a6e22e>isLastBin</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>binBoundary</color><color=#f8f8f2>.</color><color=#a6e22e>isFirstBin</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>=</color> <color=#f8f8f2>getTreeStatsAccumulator</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>accumulateStats</color><color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"Upper IN with 0 entries"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchType</color> <color=#f92672>==</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>NORMAL</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>comparator</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchType</color> <color=#f92672>==</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>LEFT</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchType</color> <color=#f92672>==</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>RIGHT</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#e6db74>"Invalid value of searchType: "</color> <color=#f92672>+</color> <color=#f8f8f2>searchType</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>binBoundary</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>!=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>binBoundary</color><color=#f8f8f2>.</color><color=#a6e22e>isLastBin</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>binBoundary</color><color=#f8f8f2>.</color><color=#a6e22e>isFirstBin</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>fetchINWithNoLatch</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>getRootIN</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
          <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>accumulateStats</color><color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Latch the child. Note: BINs are always latched exclusive. */</color>
        <color=#f8f8f2>latchChildShared</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>accumulateStats</color><color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>());</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * In [#14903] we encountered a latch exception below and the</color>
<color=#75715e>         * original exception was lost.  Print the stack trace and</color>
<color=#75715e>         * allow the original exception to be thrown if this happens</color>
<color=#75715e>         * again, to get more information about the problem.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#f8f8f2>child</color> <color=#f92672>&&</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLogException</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#e6db74>"Tree"</color><color=#f8f8f2>,</color> <color=#e6db74>"searchSubTreeInternal"</color><color=#f8f8f2>,</color> <color=#e6db74>""</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Search for the given key in the subtree rooted at the given parent IN.</color>
<color=#75715e>   * The search descends until the given target level, and the IN that</color>
<color=#75715e>   * contains or covers the key is returned latched in EX or SH mode as</color>
<color=#75715e>   * specified by the latchShared param.</color>
<color=#75715e>   *</color>
<color=#75715e>   * The method uses grandparent latching, but only if the parent is the</color>
<color=#75715e>   * root of the whole Btree and it is SH-latched on entry.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>IN</color> <color=#a6e22e>searchSubTree</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>SearchType</color> <color=#f8f8f2>searchType</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>latchShared</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Comparator</color><color=#f92672><</color><color=#66d9ef>byte</color><color=#f92672>[]></color> <color=#f8f8f2>comparator</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If a an intermediate IN (e.g., from getNextIN) was</color>
<color=#75715e>     * originally passed, it was latched exclusively.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>()));</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>searchType</color> <color=#f92672>==</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>LEFT</color> <color=#f92672>||</color> <color=#f8f8f2>searchType</color> <color=#f92672>==</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>RIGHT</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>key</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If caller is asking for a right or left search, they shouldn't</color>
<color=#75715e>       * be passing us a key.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"searchSubTree passed key and left/right search"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isUpperIN</color><color=#f8f8f2>());</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>());</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>subtreeRoot</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>grandParent</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>childIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>grandParentIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>doGrandparentLatching</color> <color=#f92672>=</color> <color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>=</color> <color=#f8f8f2>getTreeStatsAccumulator</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>accumulateStats</color><color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchType</color> <color=#f92672>==</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>NORMAL</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* Look for the entry matching key in the current node. */</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>comparator</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchType</color> <color=#f92672>==</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>LEFT</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* Left search, always take the 0th entry. */</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchType</color> <color=#f92672>==</color> <color=#f8f8f2>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>RIGHT</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* Right search, always take the highest entry. */</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#e6db74>"Invalid value of searchType: "</color> <color=#f92672>+</color> <color=#f8f8f2>searchType</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Get the child IN.</color>
<color=#75715e>         *</color>
<color=#75715e>         * If the child is not cached and we are usimg grandparent</color>
<color=#75715e>         * latching, then:</color>
<color=#75715e>         *</color>
<color=#75715e>         * (a) If "parent" is not the subtree root, is is always</color>
<color=#75715e>         * SH-latched at this point. So, to fetch the child, we need to</color>
<color=#75715e>         * unlatch the parent and relatch it exclusively. Because we</color>
<color=#75715e>         * have the grandparent latch (in either SH or EX mode), the</color>
<color=#75715e>         * parent will not be evicted or detached from the tree and the</color>
<color=#75715e>         * index of the child within the parent won't change. After</color>
<color=#75715e>         * the parent is EX-latched, we can release the grandparent so</color>
<color=#75715e>         *. it won't be held while reading the child from the log.</color>
<color=#75715e>         *</color>
<color=#75715e>         * (b) If "parent" is the BTree root, it may be SH-latched. In</color>
<color=#75715e>         * this case, since there is no grandparent, we must unlatch</color>
<color=#75715e>         * the parent and relatch it in EX mode under the protection</color>
<color=#75715e>         * of the rootLatch; then we restart the do-loop.</color>
<color=#75715e>         *</color>
<color=#75715e>         * (c) If "parent" is the subtree root, but not the root of</color>
<color=#75715e>         * the full Btree, then it must be EX-latched already, and</color>
<color=#75715e>         * we can just fetch the child.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>doGrandparentLatching</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#f8f8f2>subtreeRoot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

            <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>());</color>
            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>grandParent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>grandParentIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>grandParent</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>doGrandparentLatching</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>subtreeRoot</color> <color=#f92672>=</color> <color=#f8f8f2>getRootINLatchedExclusive</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>subtreeRoot</color><color=#f8f8f2>;</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
            <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>grandParent</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>doGrandparentLatching</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>fetchIN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>fetchIN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* After fetching the child we can release the grandparent. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>grandParent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>grandParent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>grandParentIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Latch the child. Note: BINs are always latched exclusive. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>latchShared</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>latchShared</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>doGrandparentLatching</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>latchChild</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>childIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>accumulateStats</color><color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Continue down a level */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>doGrandparentLatching</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>grandParent</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>grandParentIsLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * In [#14903] we encountered a latch exception below and the</color>
<color=#75715e>         * original exception was lost.  Print the stack trace and</color>
<color=#75715e>         * allow the original exception to be thrown if this happens</color>
<color=#75715e>         * again, to get more information about the problem.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>childIsLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#f8f8f2>child</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLogException</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#e6db74>"Tree"</color><color=#f8f8f2>,</color> <color=#e6db74>"searchSubTreeInternal"</color><color=#f8f8f2>,</color> <color=#e6db74>""</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>grandParent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>grandParentIsLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>grandParent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** rebuildINList is used by recovery to add all the resident nodes to the IN list. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>rebuildINList</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>INList</color> <color=#f8f8f2>inMemoryList</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireShared</color><color=#f8f8f2>();</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>Node</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>();</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>rebuildINList</color><color=#f8f8f2>(</color><color=#f8f8f2>inMemoryList</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Debugging check that all resident nodes are on the INList and no stray nodes are present in the</color>
<color=#75715e>   * unused portion of the IN arrays.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>validateINList</color><color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>INList</color> <color=#f8f8f2>inList</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>inList</color><color=#f8f8f2>.</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
            <color=#e6db74>"IN "</color> <color=#f92672>+</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#e6db74>" missing from INList"</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>Node</color> <color=#f8f8f2>node</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672>>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
                  <color=#e6db74>"IN "</color> <color=#f92672>+</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#e6db74>" has stray node "</color> <color=#f92672>+</color> <color=#f8f8f2>node</color> <color=#f92672>+</color> <color=#e6db74>" at index "</color> <color=#f92672>+</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
            <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>key</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
                  <color=#e6db74>"IN "</color> <color=#f92672>+</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#e6db74>" has stray key "</color> <color=#f92672>+</color> <color=#f8f8f2>key</color> <color=#f92672>+</color> <color=#e6db74>" at index "</color> <color=#f92672>+</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>validateINList</color><color=#f8f8f2>((</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>ArrayIndexOutOfBoundsException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Logging support</color>
<color=#75715e>   */</color>

  <color=#75715e>/** @see Loggable#getLogSize */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getLogSize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color> <color=#75715e>// rootExists</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getLogSize</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @see Loggable#writeToLog */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>writeToLog</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>logBuffer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>byte</color> <color=#f8f8f2>booleans</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>((</color><color=#f8f8f2>root</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#ae81ff>1</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>logBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>booleans</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>writeToLog</color><color=#f8f8f2>(</color><color=#f8f8f2>logBuffer</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @see Loggable#readFromLog */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>readFromLog</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>itemBuffer</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>entryVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>rootExists</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>byte</color> <color=#f8f8f2>booleans</color> <color=#f92672>=</color> <color=#f8f8f2>itemBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>rootExists</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>booleans</color> <color=#f92672>&</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootExists</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>root</color> <color=#f92672>=</color> <color=#f8f8f2>makeRootChildReference</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>readFromLog</color><color=#f8f8f2>(</color><color=#f8f8f2>itemBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>entryVersion</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @see Loggable#dumpLog */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>dumpLog</color><color=#f8f8f2>(</color><color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>verbose</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"<root>"</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>dumpLog</color><color=#f8f8f2>(</color><color=#f8f8f2>sb</color><color=#f8f8f2>,</color> <color=#f8f8f2>verbose</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"</root>"</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @see Loggable#getTransactionId */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getTransactionId</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @see Loggable#logicalEquals Always return false, this item should never be compared. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>logicalEquals</color><color=#f8f8f2>(</color><color=#f8f8f2>Loggable</color> <color=#f8f8f2>other</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return the TreeStats for this tree. */</color>
  <color=#66d9ef>int</color> <color=#a6e22e>getTreeStats</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>rootSplits</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#a6e22e>getTreeStatsAccumulator</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getThreadLocalReferenceCount</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>treeStatsAccumulatorTL</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setTreeStatsAccumulator</color><color=#f8f8f2>(</color><color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#f8f8f2>tSA</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>treeStatsAccumulatorTL</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>tSA</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>loadStats</color><color=#f8f8f2>(</color><color=#f8f8f2>StatsConfig</color> <color=#f8f8f2>config</color><color=#f8f8f2>,</color> <color=#f8f8f2>BtreeStats</color> <color=#f8f8f2>btreeStats</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#75715e>/* Add the tree statistics to BtreeStats. */</color>
    <color=#f8f8f2>btreeStats</color><color=#f8f8f2>.</color><color=#a6e22e>setTreeStats</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>.</color><color=#a6e22e>cloneGroup</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>));</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getClear</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>relatchesRequired</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>rootSplits</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Debugging stuff.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>dump</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#f8f8f2>dumpString</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>dumpString</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>nSpaces</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>TreeUtils</color><color=#f8f8f2>.</color><color=#a6e22e>indent</color><color=#f8f8f2>(</color><color=#f8f8f2>nSpaces</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"<tree>"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>'\n'</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>dumpString</color><color=#f8f8f2>(</color><color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(),</color> <color=#f8f8f2>nSpaces</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>'\n'</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"<in/>"</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>'\n'</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>TreeUtils</color><color=#f8f8f2>.</color><color=#a6e22e>indent</color><color=#f8f8f2>(</color><color=#f8f8f2>nSpaces</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"</tree>"</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Unit test support to validate subtree pruning. Didn't want to make root access public. */</color>
  <color=#66d9ef>boolean</color> <color=#a6e22e>validateDelete</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireShared</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>();</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>validateSubtreeBeforeDelete</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>rootLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit testing only. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setWaitHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>waitHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit testing only. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setSearchHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>searchHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit testing only. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setCkptHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>ckptHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit testing only. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setGetParentINHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>getParentINHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setFetchINHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>fetchINHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>
  <color=#75715e>/**</color>
<color=#75715e>   * Send trace messages to the java.util.logger. Don't rely on the logger alone to conditionalize</color>
<color=#75715e>   * whether we send this message, we don't even want to construct the message if the level is not</color>
<color=#75715e>   * enabled.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>traceSplitRoot</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Level</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>splitType</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>newRoot</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>newRootLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>oldRoot</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>oldRootLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color> <color=#f92672>=</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getLogger</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>splitType</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" newRoot="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>newRoot</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" newRootLsn="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>newRootLsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" oldRoot="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>oldRoot</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" oldRootLsn="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>oldRootLsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>database</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>SplitInfo</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>SplitInfo</color><color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>child</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>index</color> <color=#f92672>=</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>