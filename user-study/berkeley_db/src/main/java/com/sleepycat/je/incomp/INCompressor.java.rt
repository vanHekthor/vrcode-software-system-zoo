<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.incomp</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.CacheMode</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.StatsConfig</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.LocalUtilizationTracker</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DatabaseId</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DatabaseImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DbTree</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.latch.LatchSupport</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.*</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.util.*</color><color=#f8f8f2>;</color>

<color=#f92672>import static</color> <color=#f8f8f2>com.sleepycat.je.incomp.INCompStatDefinition.*</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * JE compression consists of removing BIN slots for deleted and expired records, and pruning empty</color>
<color=#75715e> * IN/BINs from the tree which is also called a reverse split.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>One of the reasons compression is treated specially is that slot compression cannot be</color>
<color=#75715e> * performed inline as part of a delete operation. When we delete an LN, a cursor is always present</color>
<color=#75715e> * on the LN. The API dictates that the cursor will remain positioned on the deleted record. In</color>
<color=#75715e> * addition, if the deleting transaction aborts we must restore the slot and the possibility of a</color>
<color=#75715e> * split during an abort is something we wish to avoid; for this reason, compression will not occur</color>
<color=#75715e> * if the slot's LSN is locked. In principle, slot compression could be performed during transaction</color>
<color=#75715e> * commit, but that would be expensive because a Btree lookup would be required, and this would</color>
<color=#75715e> * negatively impact operation latency. For all these reasons, slot compression is performed after</color>
<color=#75715e> * the delete operation is complete and committed, and not in the thread performing the operation or</color>
<color=#75715e> * transaction commit.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Compression is of two types:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ "Queued compression" is carried out by the INCompressor daemon thread. Both slot compression</color>
<color=#75715e> * and pruning are performed.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ "Lazy compression" is carried out opportunistically at various times when compression is</color>
<color=#75715e> * beneficial.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The use of BIN-deltas has a big impact on slot compression because dirty slots cannot be</color>
<color=#75715e> * compressed until we know that a full BIN will be logged next. If a dirty slot were compressed</color>
<color=#75715e> * prior to logging a BIN-delta, the record of the compression would be lost and the slot would</color>
<color=#75715e> * "reappear" when the BIN is reconstituted. Normally we do not compress dirty slots when a delta</color>
<color=#75715e> * would next be logged. However, there are times when we do compress dirty slots, and in that case</color>
<color=#75715e> * the "prohibit next logged delta" flag is set on the BIN.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Queued compression prior to logging a BIN-delta is also wasteful because the dequeued entry</color>
<color=#75715e> * cannot be processed. Therefore, lazy compression is relied on when a BIN-delta will next be</color>
<color=#75715e> * logged. Because, BIN-deltas are logged more often than BINs, lazy compression is used for slot</color>
<color=#75715e> * compression more often than queued compression.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Lazy compression is used for compressing expired slots, in addition to deleted slots. This is</color>
<color=#75715e> * done opportunistically as described above. Expired slots are normally not dirty, so they can</color>
<color=#75715e> * often be compressed even when a BIN will be logged next as a BIN-delta. The same is true of</color>
<color=#75715e> * deleted slots that are not dirty, although these occur infrequently.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Since we don't lazy-compress BIN-deltas, how can we prevent their expired slots from using</color>
<color=#75715e> * space for long time periods? Currently the expired space will be reclaimed only when the delta is</color>
<color=#75715e> * mutated to a full BIN and then compressed, including when the full BIN is cleaned. This is the</color>
<color=#75715e> * same as reclaiming space for deleted slots, so this is acceptable for now at least.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>You may wonder, since lazy compression is necessary, why use queued compression for slot</color>
<color=#75715e> * compression at all? Queued compression is useful for the following reasons:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ If a BIN-delta will not be logged next, queued compression will cause the compression to</color>
<color=#75715e> * occur sooner than with lazy compression.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ When a cursor is on a BIN or a deleted entry is locked during lazy compression, we cannot</color>
<color=#75715e> * compress the slot. Queuing allows it to be compressed sooner than if we waited for the next lazy</color>
<color=#75715e> * compression.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ The code to process a queue entry must do slot compression anyway, even if we only want to</color>
<color=#75715e> * prune the BIN. We have to account for the case where all slots are deleted but not yet</color>
<color=#75715e> * compressed. So the code to process the queue entry could not be simplified even if we were to</color>
<color=#75715e> * decide not to queue entries for slot compression.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>INCompressor</color> <color=#66d9ef>extends</color> <color=#f8f8f2>DaemonThread</color> <color=#f8f8f2>{</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>DEBUG</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lockTimeout</color><color=#f8f8f2>;</color>

  <color=#75715e>/* stats */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>StatGroup</color> <color=#f8f8f2>stats</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>splitBins</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>dbClosedBins</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>cursorsBins</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nonEmptyBins</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>processedBins</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>compQueueSize</color><color=#f8f8f2>;</color>

  <color=#75715e>/* per-run stats */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>splitBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>dbClosedBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>cursorsBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>nonEmptyBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>processedBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The following stats are not kept per run, because they're set by</color>
<color=#75715e>   * multiple threads doing lazy compression. They are debugging aids; it</color>
<color=#75715e>   * didn't seem like a good idea to add synchronization to the general path.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>lazyProcessed</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>wokenUp</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Store logical references to BINs that have deleted entries and are</color>
<color=#75715e>   * candidates for compaction.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>BINReference</color><color=#f92672>></color> <color=#f8f8f2>binRefQueue</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>binRefQueueSync</color><color=#f8f8f2>;</color>

  <color=#75715e>/* For unit tests */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color> <color=#f8f8f2>beforeFlushTrackerHook</color><color=#f8f8f2>;</color> <color=#75715e>// [#15528]</color>

  <color=#66d9ef>public</color> <color=#a6e22e>INCompressor</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>env</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>waitTime</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>name</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>waitTime</color><color=#f8f8f2>,</color> <color=#f8f8f2>name</color><color=#f8f8f2>,</color> <color=#f8f8f2>env</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>lockTimeout</color> <color=#f92672>=</color> <color=#f8f8f2>env</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getDuration</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>COMPRESSOR_LOCK_TIMEOUT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>binRefQueue</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>binRefQueueSync</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Object</color><color=#f8f8f2>();</color>

    <color=#75715e>/* Do the stats definitions. */</color>
    <color=#f8f8f2>stats</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StatGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>GROUP_NAME</color><color=#f8f8f2>,</color> <color=#f8f8f2>GROUP_DESC</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>splitBins</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>INCOMP_SPLIT_BINS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>dbClosedBins</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>INCOMP_DBCLOSED_BINS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>cursorsBins</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>INCOMP_CURSORS_BINS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nonEmptyBins</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>INCOMP_NON_EMPTY_BINS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>processedBins</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>INCOMP_PROCESSED_BINS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>compQueueSize</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>INCOMP_QUEUE_SIZE</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit testing only. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setBeforeFlushTrackerHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>beforeFlushTrackerHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>verifyCursors</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Environment may have been closed.  If so, then our job here is done.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isClosed</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Use a snapshot to verify the cursors.  This way we don't have to</color>
<color=#75715e>     * hold a latch while verify takes locks.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>BINReference</color><color=#f92672>></color> <color=#f8f8f2>queueSnapshot</color><color=#f8f8f2>;</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>binRefQueueSync</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>queueSnapshot</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ArrayList</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>binRefQueue</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Use local caching to reduce DbTree.getDb overhead.  Do not call</color>
<color=#75715e>     * releaseDb after each getDb, since the entire dbCache will be</color>
<color=#75715e>     * released at the end.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color><color=#f92672>></color> <color=#f8f8f2>dbCache</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BINReference</color> <color=#f8f8f2>binRef</color> <color=#f8f8f2>:</color> <color=#f8f8f2>queueSnapshot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>binRef</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabaseId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>lockTimeout</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbCache</color><color=#f8f8f2>);</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>searchForBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>verifyCursors</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDbs</color><color=#f8f8f2>(</color><color=#f8f8f2>dbCache</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getBinRefQueueSize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>binRefQueueSync</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>binRefQueue</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * There are multiple flavors of the addBin*ToQueue methods. All allow</color>
<color=#75715e>   * the caller to specify whether the daemon should be notified. Currently</color>
<color=#75715e>   * no callers proactively notify, and we rely on lazy compression and</color>
<color=#75715e>   * the daemon timebased wakeup to process the queue.</color>
<color=#75715e>   */</color>

  <color=#75715e>/** Adds the BIN to the queue if the BIN is not already in the queue. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>addBinToQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>binRefQueueSync</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>addBinToQueueAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Adds the BINReference to the queue if the BIN is not already in the queue. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>addBinRefToQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>BINReference</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>binRefQueueSync</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>addBinRefToQueueAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>binRef</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds an entire collection of BINReferences to the queue at once. Use this to avoid latching for</color>
<color=#75715e>   * each add.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>addMultipleBinRefsToQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>Collection</color><color=#f92672><</color><color=#f8f8f2>BINReference</color><color=#f92672>></color> <color=#f8f8f2>binRefs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>binRefQueueSync</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BINReference</color> <color=#f8f8f2>binRef</color> <color=#f8f8f2>:</color> <color=#f8f8f2>binRefs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>addBinRefToQueueAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>binRef</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Adds the BINReference with the latch held. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>addBinRefToQueueAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>BINReference</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Long</color> <color=#f8f8f2>node</color> <color=#f92672>=</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>binRefQueue</color><color=#f8f8f2>.</color><color=#a6e22e>containsKey</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>binRefQueue</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>,</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Adds the BIN with the latch held. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>addBinToQueueAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Long</color> <color=#f8f8f2>node</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>binRefQueue</color><color=#f8f8f2>.</color><color=#a6e22e>containsKey</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>binRefQueue</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>createReference</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>exists</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>binRefQueueSync</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>binRefQueue</color><color=#f8f8f2>.</color><color=#a6e22e>containsKey</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Return stats */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>StatGroup</color> <color=#a6e22e>loadStats</color><color=#f8f8f2>(</color><color=#f8f8f2>StatsConfig</color> <color=#f8f8f2>config</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>compQueueSize</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>getBinRefQueueSize</color><color=#f8f8f2>());</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"lazyProcessed = "</color> <color=#f92672>+</color> <color=#f8f8f2>lazyProcessed</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"wokenUp="</color> <color=#f92672>+</color> <color=#f8f8f2>wokenUp</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getClear</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lazyProcessed</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>wokenUp</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>stats</color><color=#f8f8f2>.</color><color=#a6e22e>cloneGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getClear</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Return the number of retries when a deadlock exception occurs. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#a6e22e>nDeadlockRetries</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>COMPRESSOR_RETRY</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>onWakeup</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isClosing</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>wokenUp</color><color=#f92672>++</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>doCompress</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The real work to doing a compress. This may be called by the compressor thread or</color>
<color=#75715e>   * programatically.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>doCompress</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Make a snapshot of the current work queue so the compressor thread</color>
<color=#75715e>     * can safely iterate over the queue. Note that this impacts lazy</color>
<color=#75715e>     * compression, because it lazy compressors will not see BINReferences</color>
<color=#75715e>     * that have been moved to the snapshot.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>BINReference</color><color=#f92672>></color> <color=#f8f8f2>queueSnapshot</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>binQueueSize</color><color=#f8f8f2>;</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>binRefQueueSync</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>binQueueSize</color> <color=#f92672>=</color> <color=#f8f8f2>binRefQueue</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>binQueueSize</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>queueSnapshot</color> <color=#f92672>=</color> <color=#f8f8f2>binRefQueue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>binRefQueue</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* There is work to be done. */</color>
    <color=#f8f8f2>resetPerRunCounters</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>fine</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"InCompress.doCompress called, queue size: "</color> <color=#f92672>+</color> <color=#f8f8f2>binQueueSize</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Compressed entries must be counted as obsoleted.  A separate</color>
<color=#75715e>     * tracker is used to accumulate tracked obsolete info so it can be</color>
<color=#75715e>     * added in a single call under the log write latch.  We log the</color>
<color=#75715e>     * info for deleted subtrees immediately because we don't process</color>
<color=#75715e>     * deleted IN entries during recovery; this reduces the chance of</color>
<color=#75715e>     * lost info.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LocalUtilizationTracker</color> <color=#f8f8f2>localTracker</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LocalUtilizationTracker</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Use local caching to reduce DbTree.getDb overhead. */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color><color=#f92672>></color> <color=#f8f8f2>dbCache</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>BINSearch</color> <color=#f8f8f2>binSearch</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BINSearch</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BINReference</color> <color=#f8f8f2>binRef</color> <color=#f8f8f2>:</color> <color=#f8f8f2>queueSnapshot</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isClosed</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>findDBAndBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>binSearch</color><color=#f8f8f2>,</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbCache</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Either the db is closed, or the BIN doesn't exist.</color>
<color=#75715e>           * Don't process this BINReference.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Compress deleted slots and prune if possible. */</color>
        <color=#f8f8f2>compressBin</color><color=#f8f8f2>(</color><color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>,</color> <color=#f8f8f2>localTracker</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* SR [#11144]*/</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>beforeFlushTrackerHook</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Count obsolete nodes and write out modified file summaries</color>
<color=#75715e>       * for recovery.  All latches must have been released.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getUtilizationProfile</color><color=#f8f8f2>().</color><color=#a6e22e>flushLocalTracker</color><color=#f8f8f2>(</color><color=#f8f8f2>localTracker</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDbs</color><color=#f8f8f2>(</color><color=#f8f8f2>dbCache</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>accumulatePerRunCounters</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Compresses a single BIN and then deletes the BIN if it is empty.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param bin is latched when this method is called, and unlatched when it returns.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>compressBin</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>BINReference</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>,</color> <color=#f8f8f2>LocalUtilizationTracker</color> <color=#f8f8f2>localTracker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Safe to get identifier keys; bin is latched. */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>idKey</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getIdentifierKey</color><color=#f8f8f2>();</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>empty</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>empty</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Deltas in cache cannot be compressed.</color>
<color=#75715e>         *</color>
<color=#75715e>         * We strive not to add a slot to the queue when we will log a</color>
<color=#75715e>         * delta.  However, it is possible that an entry is added, or</color>
<color=#75715e>         * that an entry is not cleared by lazy compression prior to</color>
<color=#75715e>         * logging a full BIN.  Clean-up for such queue entries is</color>
<color=#75715e>         * here.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* If there are cursors on the BIN, requeue and try later. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>nCursors</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>addBinRefToQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>binRef</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>cursorsBinsThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If a delta should be logged, do not compress dirty slots,</color>
<color=#75715e>         * since this would prevent logging a delta.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>compress</color><color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>shouldLogDelta</color><color=#f8f8f2>()</color> <color=#75715e>/*compressDirtySlots*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>localTracker</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

          <color=#75715e>/* If compression is incomplete, requeue and try later. */</color>
          <color=#f8f8f2>addBinRefToQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>binRef</color><color=#f8f8f2>);</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* After compression the BIN may be empty. */</color>
        <color=#f8f8f2>empty</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* After releasing the latch, prune the BIN if it is empty. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>empty</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>pruneBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>,</color> <color=#f8f8f2>idKey</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** If the target BIN is empty, attempt to remove the empty branch of the tree. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>pruneBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>BINReference</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>,</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>idKey</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Tree</color> <color=#f8f8f2>tree</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>delete</color><color=#f8f8f2>(</color><color=#f8f8f2>idKey</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>processedBinsThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>NodeNotEmptyException</color> <color=#f8f8f2>NNEE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Something was added to the node since the point when the</color>
<color=#75715e>       * deletion occurred; we can't prune, and we can throw away this</color>
<color=#75715e>       * BINReference.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>nonEmptyBinsThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>CursorsExistException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* If there are cursors in the way of the delete, retry later. */</color>
      <color=#f8f8f2>addBinRefToQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>binRef</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>cursorsBinsThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Search the tree for the BIN that corresponds to this BINReference.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param binRef the BINReference that indicates the bin we want.</color>
<color=#75715e>   * @return the BIN that corresponds to this BINReference. The node is latched upon return. Returns</color>
<color=#75715e>   *     null if the BIN can't be found.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>searchForBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>BINReference</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>().</color><color=#a6e22e>search</color><color=#f8f8f2>(</color><color=#f8f8f2>binRef</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(),</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Reset per-run counters. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>resetPerRunCounters</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>splitBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>dbClosedBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>cursorsBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>nonEmptyBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>processedBinsThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>accumulatePerRunCounters</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>splitBins</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>splitBinsThisRun</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>dbClosedBins</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>dbClosedBinsThisRun</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>cursorsBins</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>cursorsBinsThisRun</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nonEmptyBins</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>nonEmptyBinsThisRun</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>processedBins</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>processedBinsThisRun</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Lazily/opportunistically compress a full BIN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The target IN should be latched when we enter, and it will be remain latched.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If compression succeeds, does not prune empty BINs, but does queue them for pruning later.</color>
<color=#75715e>   * If compression fails because a record lock cannot be obtained, queues the BIN to retry later.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Note that we do not bother to delete queue entries for the BIN if compression succeeds.</color>
<color=#75715e>   * Queue entries are normally removed quickly by the compressor. In the case where queue entries</color>
<color=#75715e>   * happen to exist when we do the final compression below, we rely on the compressor to clean them</color>
<color=#75715e>   * up later on when they are processed.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>lazyCompress</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>compressDirtySlots</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>();</color>

    <color=#75715e>/* Only full BINs can be compressed. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Cursors prohibit compression. We queue for later when there is</color>
<color=#75715e>     * anything that can be compressed.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>nCursors</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>addBinToQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>compress</color><color=#f8f8f2>(</color><color=#f8f8f2>compressDirtySlots</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*localTracker*/</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* The BIN is empty. Prune it later. */</color>
        <color=#f8f8f2>addBinToQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* A record lock prevented slot removal. Try again later. */</color>
      <color=#f8f8f2>addBinToQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>lazyProcessed</color><color=#f92672>++</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Find the db and bin for a BINReference.</color>
<color=#75715e>   * @return true if the db is open and the target bin is found.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>findDBAndBIN</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>BINSearch</color> <color=#f8f8f2>binSearch</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>BINReference</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color><color=#f92672>></color> <color=#f8f8f2>dbCache</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Find the database.  Do not call releaseDb after this getDb, since</color>
<color=#75715e>     * the entire dbCache will be released later.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>binRef</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabaseId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>lockTimeout</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbCache</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>db</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* The db was deleted. Ignore this BIN Ref. */</color>
      <color=#f8f8f2>dbClosedBinsThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Perform eviction before each operation. */</color>
    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>daemonEviction</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*backgroundIO*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Find the BIN. */</color>
    <color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>=</color> <color=#f8f8f2>searchForBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>binRef</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* The BIN may have been split. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>binSearch</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>splitBinsThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* Struct to return multiple values from findDBAndBIN. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>BINSearch</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>public</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>;</color>
    <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>