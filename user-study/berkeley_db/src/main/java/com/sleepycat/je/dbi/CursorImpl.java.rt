<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.dbi</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.latch.LatchSupport</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogItem</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogUtils</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.ReplicationContext</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.txn.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.*</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.util.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Level</color><color=#f8f8f2>;</color>

<color=#75715e>/** A CursorImpl is the internal implementation of the cursor. */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>CursorImpl</color> <color=#66d9ef>implements</color> <color=#f8f8f2>Cloneable</color> <color=#f8f8f2>{</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>DEBUG</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color> <color=#f8f8f2>CURSOR_NOT_INITIALIZED</color> <color=#f92672>=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color> <color=#f8f8f2>CURSOR_INITIALIZED</color> <color=#f92672>=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color> <color=#f8f8f2>CURSOR_CLOSED</color> <color=#f92672>=</color> <color=#ae81ff>3</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>TRACE_DELETE</color> <color=#f92672>=</color> <color=#e6db74>"Delete"</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>TRACE_MOD</color> <color=#f92672>=</color> <color=#e6db74>"Mod:"</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>TRACE_INSERT</color> <color=#f92672>=</color> <color=#e6db74>"Ins:"</color><color=#f8f8f2>;</color>

  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>FOUND</color> <color=#f92672>=</color> <color=#ae81ff>0x1</color><color=#f8f8f2>;</color>
  <color=#75715e>/* Exact match on the key portion. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>EXACT_KEY</color> <color=#f92672>=</color> <color=#ae81ff>0x2</color><color=#f8f8f2>;</color>
  <color=#75715e>/* Record found is the last one in the dbImpl. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>FOUND_LAST</color> <color=#f92672>=</color> <color=#ae81ff>0x4</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Allocate hashCode ids from this. [#13896]</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastAllocatedId</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Unique id that we can return as a hashCode to prevent calls to</color>
<color=#75715e>   * Object.hashCode(). [#13896]</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>thisId</color><color=#f8f8f2>;</color>

  <color=#75715e>/* The dbImpl behind the handle. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Owning transaction. */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>retainNonTxnLocks</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isSecondaryCursor</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Cursor location in the dbImpl, represented by a BIN and an index</color>
<color=#75715e>   * in the BIN.  The bin is null if not established, and the index is</color>
<color=#75715e>   * negative if not established.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>

  <color=#75715e>/* State of the cursor. See CURSOR_XXX above. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>byte</color> <color=#f8f8f2>status</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>allowEviction</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>priorBIN</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * A cache of the record version for the operation at the current position.</color>
<color=#75715e>   * Is null if the cursor is uninitialized.  For a secondary cursor, is the</color>
<color=#75715e>   * version of the primary record.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>RecordVersion</color> <color=#f8f8f2>currentRecordVersion</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * A cache of the storage size for the operation at the cursor position.</color>
<color=#75715e>   * Both values are zero if the cursor is uninitialized. priStorageSize is</color>
<color=#75715e>   * non-zero only if Cursor.readPrimaryAfterGet was called.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>storageSize</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>priStorageSize</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Number of secondary records written by a primary put or delete. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>nSecWrites</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>ThreadLocal</color><color=#f92672><</color><color=#f8f8f2>TreeWalkerStatsAccumulator</color><color=#f92672>></color> <color=#f8f8f2>treeStatsAccumulatorTL</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color> <color=#f8f8f2>testHook</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Creates a cursor with retainNonTxnLocks=true, isSecondaryCursor=false. These are the standard</color>
<color=#75715e>   * settings for an internal cursor.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>CursorImpl</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>(</color><color=#f8f8f2>database</color><color=#f8f8f2>,</color> <color=#f8f8f2>locker</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*retainNonTxnLocks*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*isSecondaryCursor*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Creates a cursor.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>A cursor always retains transactional locks when it is reset or closed. Non-transaction</color>
<color=#75715e>   * locks may be retained or not, depending on the retainNonTxnLocks parameter value.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Normally a user-created non-transactional Cursor releases locks on reset and close, and a</color>
<color=#75715e>   * ThreadLocker is normally used. However, by passing true for retainNonTxnLocks a ThreadLocker</color>
<color=#75715e>   * can be made to retain locks; this capability is used by SecondaryCursor.readPrimaryAfterGet.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>For internal (non-user) cursors, a BasicLocker is often used and locks are retained. In</color>
<color=#75715e>   * these internal use cases the caller explicitly calls BasicLocker.operationEnd() after the</color>
<color=#75715e>   * cursor is closed, and retainNonTxnLocks is set to true to prevent the locks acquired by the</color>
<color=#75715e>   * BasicLocker from being released when the cursor is closed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>BasicLocker is also used for NameLN operations while opening a Database handle. Database</color>
<color=#75715e>   * handle locks must be retained, even if the Database is opened non-transactionally.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param retainNonTxnLocks is true if non-transactional locks should be retained (not released</color>
<color=#75715e>   *     automatically) when the cursor is reset or closed.</color>
<color=#75715e>   * @param isSecondaryCursor whether to treat this cursor as a secondary cursor, e.g., secondary</color>
<color=#75715e>   *     records don't have record versions.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>CursorImpl</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>retainNonTxnLocks</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isSecondaryCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>thisId</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>getNextCursorId</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>retainNonTxnLocks</color> <color=#f92672>=</color> <color=#f8f8f2>retainNonTxnLocks</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>isSecondaryCursor</color> <color=#f92672>=</color> <color=#f8f8f2>isSecondaryCursor</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Associate this cursor with the dbImpl. */</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>dbImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>locker</color> <color=#f92672>=</color> <color=#f8f8f2>locker</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>locker</color><color=#f8f8f2>.</color><color=#a6e22e>registerCursor</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This default value is used only when the CursorImpl is used directly</color>
<color=#75715e>     * (mainly for internal databases).  When the CursorImpl is created by</color>
<color=#75715e>     * a Cursor, CursorImpl.setCacheMode will be called.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>cacheMode</color> <color=#f92672>=</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>CURSOR_NOT_INITIALIZED</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Do not perform eviction here because we may be synchronized on the</color>
<color=#75715e>     * Database instance. For example, this happens when we call</color>
<color=#75715e>     * Database.openCursor().  Also eviction may be disabled after the</color>
<color=#75715e>     * cursor is constructed.</color>
<color=#75715e>     */</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Performs a shallow copy and returns the new cursor.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param samePosition If true, this cursor's position is used for the new cursor, and addCursor</color>
<color=#75715e>   *     is called on the new cursor to register it with the current BIN. If false, the new cursor</color>
<color=#75715e>   *     will be uninitialized.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>CursorImpl</color> <color=#a6e22e>cloneCursor</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>samePosition</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>ret</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>ret</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color><color=#f8f8f2>)</color> <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>clone</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>retainNonTxnLocks</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>locker</color> <color=#f92672>=</color> <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>newNonTxnLocker</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>locker</color><color=#f8f8f2>.</color><color=#a6e22e>registerCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>ret</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>samePosition</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>addCursor</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>CloneNotSupportedException</color> <color=#f8f8f2>cannotOccur</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Perform eviction before and after each cursor operation. */</color>
    <color=#f8f8f2>criticalEviction</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Allocate a new hashCode id.  Doesn't need to be synchronized since it's</color>
<color=#75715e>   * ok for two objects to have the same hashcode.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>long</color> <color=#a6e22e>getNextCursorId</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f92672>++</color><color=#f8f8f2>lastAllocatedId</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>hashCode</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>thisId</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>Locker</color> <color=#a6e22e>getLocker</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>locker</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called when a cursor has been duplicated prior to being moved. The new locker is informed of</color>
<color=#75715e>   * the old locker, so that a preempted lock taken by the old locker can be ignored. [#16513]</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param closingCursor the old cursor that will be closed if the new cursor is moved</color>
<color=#75715e>   *     successfully.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setClosingLocker</color><color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>closingCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the two lockers are different, then the old locker will be closed</color>
<color=#75715e>     * when the operation is complete.  This is currently the case only for</color>
<color=#75715e>     * ReadCommitted cursors and non-transactional cursors that do not</color>
<color=#75715e>     * retain locks.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>retainNonTxnLocks</color> <color=#f92672>&&</color> <color=#f8f8f2>locker</color> <color=#f92672>!=</color> <color=#f8f8f2>closingCursor</color><color=#f8f8f2>.</color><color=#a6e22e>locker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>setClosingLocker</color><color=#f8f8f2>(</color><color=#f8f8f2>closingCursor</color><color=#f8f8f2>.</color><color=#a6e22e>locker</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called when a cursor move operation is complete. Clears the closingLocker so that a reference</color>
<color=#75715e>   * to the old closed locker is not held.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>clearClosingLocker</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>setClosingLocker</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>CacheMode</color> <color=#a6e22e>getCacheMode</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Sets the effective cache mode to use for the next operation. The cacheMode field will never be</color>
<color=#75715e>   * set to null, and can be passed directly to latching methods.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @see #performCacheModeEviction</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setCacheMode</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>mode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>cacheMode</color> <color=#f92672>=</color> <color=#f8f8f2>mode</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setTreeStatsAccumulator</color><color=#f8f8f2>(</color><color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#f8f8f2>tSA</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>maybeInitTreeStatsAccumulator</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>treeStatsAccumulatorTL</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>tSA</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>maybeInitTreeStatsAccumulator</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulatorTL</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>treeStatsAccumulatorTL</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ThreadLocal</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#a6e22e>getTreeStatsAccumulator</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getThreadLocalReferenceCount</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>maybeInitTreeStatsAccumulator</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>treeStatsAccumulatorTL</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>incrementLNCount</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>=</color> <color=#f8f8f2>getTreeStatsAccumulator</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>.</color><color=#a6e22e>incrementLNCount</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getIndex</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>getBIN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setIndex</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>idx</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setOnFirstSlot</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setOnLastSlot</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isOnBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>==</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>assertBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>==</color> <color=#f8f8f2>bin</color> <color=#f8f8f2>:</color> <color=#e6db74>"nodeId="</color> <color=#f92672>+</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#e6db74>" cursor="</color> <color=#f92672>+</color> <color=#f8f8f2>dumpToString</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isOnSamePosition</color><color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>other</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672>==</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>newBin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Historical note. In the past we checked here that the cursor was</color>
<color=#75715e>     * removed for the prior BIN by calling BIN.containsCursor [#16280].</color>
<color=#75715e>     * Because the containsCursor method takes a latch on the prior BIN,</color>
<color=#75715e>     * this causes a rare latch deadlock when newBin is latched (during an</color>
<color=#75715e>     * insert, for example), since this thread will latch two BINs in</color>
<color=#75715e>     * arbitrary order; so the assertion was removed [#21395].</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>newBin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>latchBIN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>BIN</color> <color=#f8f8f2>waitingOn</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>waitingOn</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#f8f8f2>waitingOn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>waitingOn</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>releaseBIN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatchIfOwner</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>addCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>addCursor</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Add to the current cursor. */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>addCursor</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>addCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Change cursor to point to the given BIN/index. If the new BIN is different, then old BIN must</color>
<color=#75715e>   * be unlatched and the new BIN must be latched.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>setPosition</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>newBin</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>newIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#f8f8f2>newBin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>removeCursor</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>setBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>newBin</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>addCursor</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>setIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>newIndex</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Called for creating trace messages without any latching. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getCurrentNodeId</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>b</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>b</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>?</color> <color=#f92672>-</color><color=#ae81ff>1</color> <color=#f8f8f2>:</color> <color=#f8f8f2>b</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getCurrentLsn</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>());</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>());</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#a6e22e>getCurrentKey</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getCurrentKey</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the key at the current position, regardless of whether the record is defunct. Does not</color>
<color=#75715e>   * lock. The key returned is not a copy and may not be returned directly to the user without</color>
<color=#75715e>   * copying it first.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The cursor must be initialized.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>TODO: The returned byte array is normally, but not always a copied, and then copied again</color>
<color=#75715e>   * into the user's DatabaseEntry. If this method always returns a copy, the extra copy into</color>
<color=#75715e>   * DatabaseEntry could be avoided.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#a6e22e>getCurrentKey</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>());</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isProbablyExpired</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isProbablyExpired</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getExpirationTime</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>TTL</color><color=#f8f8f2>.</color><color=#a6e22e>expirationToSystemTime</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>),</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>setInitialized</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>CURSOR_INITIALIZED</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return true if this cursor is closed */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isClosed</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>==</color> <color=#f8f8f2>CURSOR_CLOSED</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return true if this cursor is not initialized */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isNotInitialized</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>==</color> <color=#f8f8f2>CURSOR_NOT_INITIALIZED</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isInternalDbCursor</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isInternalDb</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>hasDuplicates</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For a non-sticky cursor, this method is called when the cursor is initialized and an advancing</color>
<color=#75715e>   * operation (next/prev/skip) is about to be performed. The cursor position is not reset as it</color>
<color=#75715e>   * would be if the operation were a search or an insertion, for example.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>beforeNonStickyOp</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * When the cache mode dictates that we evict the LN or BIN, we evict</color>
<color=#75715e>     * the LN here before the cursor's position changes. We can assume that</color>
<color=#75715e>     * either the position will change or the cursor will be reset. The BIN</color>
<color=#75715e>     * is evicted later.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color> <color=#f92672>!=</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color> <color=#f92672>&&</color> <color=#f8f8f2>cacheMode</color> <color=#f92672>!=</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>KEEP_HOT</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>performCacheModeLNEviction</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>releaseNonTxnLocks</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>criticalEviction</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For a non-sticky cursor, this method is called after a successful operation. The cursor</color>
<color=#75715e>   * position is not reset as it would be if the operation failed.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>afterNonStickyOp</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * To implement BIN eviction for a non-sticky cursor we must save the</color>
<color=#75715e>     * prior BIN, and only evict it after the operation and only when the</color>
<color=#75715e>     * BIN changes. The prior BIN is evicted after the operation (in this</color>
<color=#75715e>     * method) and when the cursor is reset or closed.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>performPriorBINEviction</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>priorBIN</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>priorBIN</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>criticalEviction</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Reset a cursor to an uninitialized state, but unlike close(), allow it to be used further. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>reset</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Must remove cursor before evicting BIN and releasing locks. */</color>
    <color=#f8f8f2>removeCursorAndPerformCacheEviction</color><color=#f8f8f2>(</color><color=#66d9ef>null</color> <color=#75715e>/*newCursor*/</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>releaseNonTxnLocks</color><color=#f8f8f2>();</color>

    <color=#75715e>/* Perform eviction before and after each cursor operation. */</color>
    <color=#f8f8f2>criticalEviction</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>clear</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>CURSOR_NOT_INITIALIZED</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>currentRecordVersion</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>storageSize</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>priStorageSize</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>nSecWrites</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>priorBIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>releaseNonTxnLocks</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>retainNonTxnLocks</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>releaseNonTxnLocks</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>close</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>close</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Close a cursor.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param newCursor is another cursor that is kept open by the parent Cursor object, or null if no</color>
<color=#75715e>   *     other cursor is kept open.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>close</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>newCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Must remove cursor before evicting BIN and releasing locks. */</color>
    <color=#f8f8f2>removeCursorAndPerformCacheEviction</color><color=#f8f8f2>(</color><color=#f8f8f2>newCursor</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>unRegisterCursor</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>retainNonTxnLocks</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>nonTxnOperationEnd</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>CURSOR_CLOSED</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Perform eviction before and after each cursor operation. */</color>
    <color=#f8f8f2>criticalEviction</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>removeCursorAndPerformCacheEviction</color><color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>newCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>performPriorBINEviction</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>clear</color><color=#f8f8f2>();</color> <color=#75715e>// ensure that state is uninitialized</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Must remove cursor before evicting BIN. */</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>removeCursor</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>performCacheModeEviction</color><color=#f8f8f2>(</color><color=#f8f8f2>newCursor</color><color=#f8f8f2>);</color> <color=#75715e>// may release latch</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>clear</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Performs cache mode-based eviction but for the prior BIN only. This is called after a</color>
<color=#75715e>   * successful operation using a non-sticky cursor. The prior BIN is evicted only if the BIN has</color>
<color=#75715e>   * changed.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>performPriorBINEviction</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>priorBIN</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>priorBIN</color> <color=#f92672>==</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This priorBIN should not be processed again, and setting it to null</color>
<color=#75715e>     * enables the setting of a new priorBIN.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>BIN</color> <color=#f8f8f2>binToEvict</color> <color=#f92672>=</color> <color=#f8f8f2>priorBIN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>priorBIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Short circuit modes that do not perform BIN eviction. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color> <color=#f92672>==</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color>
        <color=#f92672>||</color> <color=#f8f8f2>cacheMode</color> <color=#f92672>==</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>KEEP_HOT</color>
        <color=#f92672>||</color> <color=#f8f8f2>cacheMode</color> <color=#f92672>==</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>EVICT_LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>binToEvict</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>performCacheModeBINEviction</color><color=#f8f8f2>(</color><color=#f8f8f2>binToEvict</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>binToEvict</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatchIfOwner</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Disables or enables eviction during cursor operations. For example, a cursor used to implement</color>
<color=#75715e>   * eviction (e.g., in some UtilizationProfile and most DbTree and VLSNIndex methods) should not</color>
<color=#75715e>   * itself perform eviction, but eviction should be enabled for user cursors. Eviction is disabled</color>
<color=#75715e>   * by default.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setAllowEviction</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>allowed</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>allowEviction</color> <color=#f92672>=</color> <color=#f8f8f2>allowed</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>criticalEviction</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * In addition to disabling critical eviction for internal cursors (see</color>
<color=#75715e>     * setAllowEviction above), we do not perform critical eviction when</color>
<color=#75715e>     * UNCHANGED, EVICT_BIN or MAKE_COLD is used and the BIN is not dirty.</color>
<color=#75715e>     * Operations using these modes for a non-dirty BIN generally do not</color>
<color=#75715e>     * add any net memory to the cache, so they shouldn't have to perform</color>
<color=#75715e>     * critical eviction or block while another thread performs eviction.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>allowEviction</color>
        <color=#f92672>&&</color> <color=#f8f8f2>((</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>())</color>
            <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color> <color=#f92672>!=</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color>
                <color=#f92672>&&</color> <color=#f8f8f2>cacheMode</color> <color=#f92672>!=</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>EVICT_BIN</color>
                <color=#f92672>&&</color> <color=#f8f8f2>cacheMode</color> <color=#f92672>!=</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>MAKE_COLD</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>criticalEviction</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*backgroundIO*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * When multiple operations are performed, CacheMode-based eviction is performed for a given</color>
<color=#75715e>   * operation at the end of the next operation, which calls close() or reset() on the CursorImpl of</color>
<color=#75715e>   * the previous operation. Eviction for the last operation (including when only one operation is</color>
<color=#75715e>   * performed) also occurs during Cursor.close(), which calls CursorImpl.close().</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>By default, the CacheMode returned by DatabaseImpl.getCacheMode is used, and the defaults</color>
<color=#75715e>   * specified by the user for the Database or Environment are applied. However, the default mode</color>
<color=#75715e>   * can be overridden by the user by calling Cursor.setCacheMode, and the mode may be changed prior</color>
<color=#75715e>   * to each operation, if desired.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>To implement a per-operation CacheMode, two CacheMode fields are maintained.</color>
<color=#75715e>   * Cursor.cacheMode is the mode to use for the next operation. CursorImpl.cacheMode is the mode</color>
<color=#75715e>   * that was used for the previous operation, and that is used for eviction when that CursorImpl is</color>
<color=#75715e>   * closed or reset.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method must be called with the BIN latched but may release it, namely when the BIN is</color>
<color=#75715e>   * evicted.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>performCacheModeEviction</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>newCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Short circuit modes that do not perform LN or BIN eviction. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color> <color=#f92672>==</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color> <color=#f92672>||</color> <color=#f8f8f2>cacheMode</color> <color=#f92672>==</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>KEEP_HOT</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>movedOffBin</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>movedOffLn</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newCursor</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>movedOffBin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#f8f8f2>newCursor</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>movedOffLn</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>movedOffBin</color> <color=#f92672>||</color> <color=#f8f8f2>index</color> <color=#f92672>!=</color> <color=#f8f8f2>newCursor</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>movedOffBin</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>movedOffLn</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>movedOffLn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>performCacheModeLNEviction</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Short circuit modes that do not perform BIN eviction. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color> <color=#f92672>==</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>EVICT_LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>movedOffBin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>performCacheModeBINEviction</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Performs the LN portion of CacheMode eviction. The BIN is latched on method entry and exit.</color>
<color=#75715e>   * Must be called only for CacheMode.EVICT_LN, EVICT_BIN, UNCHANGED and MAKE_COLD.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>performCacheModeLNEviction</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>EVICT_LN</color><color=#f8f8f2>:</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>EVICT_BIN</color><color=#f8f8f2>:</color>
        <color=#f8f8f2>evictLN</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*isLatched*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*ifFetchedCold*/</color><color=#f8f8f2>);</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>UNCHANGED</color><color=#f8f8f2>:</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>MAKE_COLD</color><color=#f8f8f2>:</color>
        <color=#f8f8f2>evictLN</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*isLatched*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*ifFetchedCold*/</color><color=#f8f8f2>);</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>default</color><color=#f8f8f2>:</color>
        <color=#66d9ef>assert</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Performs the BIN portion of CacheMode eviction. The BIN is latched on method entry, but may or</color>
<color=#75715e>   * may not be latched on exit. Must be called only for CacheMode.EVICT_BIN, UNCHANGED and</color>
<color=#75715e>   * MAKE_COLD.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>performCacheModeBINEviction</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>binToEvict</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>EVICT_BIN</color><color=#f8f8f2>:</color>
        <color=#f8f8f2>evictBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>binToEvict</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>EVICT_BIN</color><color=#f8f8f2>);</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>UNCHANGED</color><color=#f8f8f2>:</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>MAKE_COLD</color><color=#f8f8f2>:</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>binToEvict</color><color=#f8f8f2>.</color><color=#a6e22e>getFetchedCold</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>evictBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>binToEvict</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>default</color><color=#f8f8f2>:</color>
        <color=#66d9ef>assert</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Evict the given BIN. Must already be latched. The latch will be released inside the</color>
<color=#75715e>   * doCacheModeEvict() call.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>evictBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>binToEvict</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getEvictor</color><color=#f8f8f2>().</color><color=#a6e22e>doCacheModeEvict</color><color=#f8f8f2>(</color><color=#f8f8f2>binToEvict</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Evict the LN node at the cursor position. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>evictLN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>evictLN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*isLatched*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*ifFetchedCold*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Evict the LN node at the cursor position. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>evictLN</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>isLatched</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>ifFetchedCold</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>evictLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>ifFetchedCold</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>shouldEmbedLN</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>data</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672><=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getMaxEmbeddedLN</color><color=#f8f8f2>()</color>
        <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>()</color>
        <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbType</color><color=#f8f8f2>().</color><color=#a6e22e>isInternal</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Delete the item pointed to by the cursor. If the item is already defunct, return KEYEMPTY.</color>
<color=#75715e>   * Returns with nothing latched.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>OperationResult</color> <color=#a6e22e>deleteCurrentRecord</color><color=#f8f8f2>(</color><color=#f8f8f2>ReplicationContext</color> <color=#f8f8f2>repContext</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>DbType</color> <color=#f8f8f2>dbType</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbType</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>currLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LogItem</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>;</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * Get a write lock. An uncontended lock is permitted because we</color>
<color=#75715e>       * will log a new LN before releasing the BIN latch.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LockStanding</color> <color=#f8f8f2>lockStanding</color> <color=#f92672>=</color>
          <color=#f8f8f2>lockLN</color><color=#f8f8f2>(</color><color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>WRITE</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*allowUncontended*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*noWait*/</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>recordExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>revertLock</color><color=#f8f8f2>(</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>currLsn</color> <color=#f92672>=</color> <color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>;</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>currLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>currEmbeddedLN</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>currLoggedSize</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>currKey</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>expiration</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>expirationInHours</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Must fetch LN if the LN is not embedded and any of the following</color>
<color=#75715e>       * are true:</color>
<color=#75715e>       *  - CLEANER_FETCH_OBSOLETE_SIZE is configured and lastLoggedSize</color>
<color=#75715e>       *    is unknown</color>
<color=#75715e>       *  - this database does not use the standard LN class and we</color>
<color=#75715e>       *    cannot call DbType.createdDeletedLN further below</color>
<color=#75715e>       * For other cases, we are careful not to fetch, in order to avoid</color>
<color=#75715e>       * a random read during a delete operation.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>currLoggedSize</color> <color=#f92672>==</color> <color=#ae81ff>0</color>
              <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>currEmbeddedLN</color>
              <color=#f92672>&&</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCleaner</color><color=#f8f8f2>().</color><color=#a6e22e>getFetchObsoleteSize</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>))</color>
          <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>dbType</color><color=#f8f8f2>.</color><color=#a6e22e>mayCreateDeletedLN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>fetchLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* An expired LN was purged. */</color>
          <color=#f8f8f2>revertLock</color><color=#f8f8f2>(</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Make the existing LN deleted, if cached; otherwise, create a</color>
<color=#75715e>       * new deleted LN (with ln.data == null), but do not attach it</color>
<color=#75715e>       * to the tree yet.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>oldLNMemSize</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>oldLNMemSize</color> <color=#f92672>=</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySizeIncludedByParent</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>delete</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>dbType</color><color=#f8f8f2>.</color><color=#a6e22e>createDeletedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Get a wli to log. */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>WriteLockInfo</color> <color=#f8f8f2>wli</color> <color=#f92672>=</color> <color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>prepareForUpdate</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Log the deleted record version and lock its new LSN. */</color>
      <color=#f8f8f2>logItem</color> <color=#f92672>=</color>
          <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>optionalLog</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>locker</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>wli</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>currEmbeddedLN</color> <color=#75715e>/*newEmbeddedLN*/</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>currKey</color> <color=#75715e>/*newKey*/</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>currEmbeddedLN</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>currLsn</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>currLoggedSize</color><color=#f8f8f2>,</color>
              <color=#66d9ef>false</color> <color=#75715e>/*isInsertion*/</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>repContext</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Now update the parent BIN to reference the logrec written</color>
<color=#75715e>       * above, set the PD flag on, and do the BIN memory counting.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>deleteRecord</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>oldLNMemSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If the LN is not cached, we don't need to attach the LN to the</color>
<color=#75715e>       * tree, because as long as the PD flag is on, the record's data</color>
<color=#75715e>       * will  never be accessed. But for DW DBs, we must attach the LN</color>
<color=#75715e>       * because no logrec was generated above, and as a result, the LN</color>
<color=#75715e>       * must be in the tree so that a logrec will be generated when</color>
<color=#75715e>       * a db.sync() occurs later (that logrec is needed for crash</color>
<color=#75715e>       * recovery, because BINs are not replayed during crash recovery).</color>
<color=#75715e>       *</color>
<color=#75715e>       * If the LN child is cached, it is desirable to evict it because</color>
<color=#75715e>       * as long as the PD flag is on, the record's data will  never be</color>
<color=#75715e>       * accessed. But for DW DBs we should not evict the dirty LN since</color>
<color=#75715e>       * it will be logged unnecessarily.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>attachNode</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*lnKey*/</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>evictLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Cache record version/size for delete operation. */</color>
      <color=#f8f8f2>setCurrentVersion</color><color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>setStorageSize</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>addDeleteInfo</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>trace</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINER</color><color=#f8f8f2>,</color> <color=#f8f8f2>TRACE_DELETE</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>currLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>);</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>makeResult</color><color=#f8f8f2>(</color><color=#f8f8f2>expiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>success</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isInternalDb</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>incBinDeltaDeletes</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Modify the current record with the given data, and optionally replace the key.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param key The new key value for the BIN slot S to be updated. Cannot be partial. For a no-dups</color>
<color=#75715e>   *     DB, it is null. For dups DBs it is a 2-part key combining the current primary key of slot S</color>
<color=#75715e>   *     with the original, user-provided data. "key" (if not null) must compare equal to S.key</color>
<color=#75715e>   *     (otherwise DuplicateDataException is thrown), but the 2 keys may not be identical if custom</color>
<color=#75715e>   *     comparators are used. So, S.key will actually be replaced by "key".</color>
<color=#75715e>   * @param data The new data to (perhaps partially) replace the data of the LN associated with the</color>
<color=#75715e>   *     BIN slot. For dups DBs it is EMPTY_DUPS_DATA. Note: for dups DBs the original,</color>
<color=#75715e>   *     user-provided "data" must not be partial.</color>
<color=#75715e>   * @param returnOldData To receive the old LN data (before the update). It is needed only by DBs</color>
<color=#75715e>   *     with indexes/triggers; will be null otherwise.</color>
<color=#75715e>   * @param returnNewData To receive the full data of the updated LN. It is needed only by DBs with</color>
<color=#75715e>   *     indexes/triggers and only if "data" is partial; will be null otherwise. Note:</color>
<color=#75715e>   *     "returnNewData" may be different than "data" only if "data" is partial.</color>
<color=#75715e>   * @return OperationResult, or null if an expired LN was purged and a partial 'data' param was</color>
<color=#75715e>   *     supplied.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>OperationResult</color> <color=#a6e22e>updateCurrentRecord</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>ExpirationInfo</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>returnOldData</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>returnNewData</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>ReplicationContext</color> <color=#f8f8f2>repContext</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>returnOldData</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>returnOldData</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>returnNewData</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>returnNewData</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LockStanding</color> <color=#f8f8f2>lockStanding</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>OperationResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Get a write lock. */</color>
      <color=#f8f8f2>lockStanding</color> <color=#f92672>=</color> <color=#f8f8f2>lockLN</color><color=#f8f8f2>(</color><color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>WRITE</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*allowUncontended*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*noWait*/</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>recordExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>revertLock</color><color=#f8f8f2>(</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>result</color> <color=#f92672>=</color>
            <color=#f8f8f2>updateRecordInternal</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>(</color><color=#f8f8f2>key</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>?</color> <color=#f8f8f2>Key</color><color=#f8f8f2>.</color><color=#a6e22e>makeKey</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#66d9ef>null</color><color=#f8f8f2>),</color>
                <color=#f8f8f2>data</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>expInfo</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>returnOldData</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>returnNewData</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>lockStanding</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>repContext</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>success</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isInternalDb</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>incBinDeltaUpdates</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Insert the given record (key + LN) in the tree or return false if the key is already present.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The cursor must initially be uninitialized.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method is called directly internally for putting tree map LNs and file summary LNs.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>insertRecord</color><color=#f8f8f2>(</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>blindInsertion</color><color=#f8f8f2>,</color> <color=#f8f8f2>ReplicationContext</color> <color=#f8f8f2>repContext</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>LockStanding</color><color=#f8f8f2>,</color> <color=#f8f8f2>OperationResult</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color>
          <color=#f8f8f2>insertRecordInternal</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*expirationInfo*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>blindInsertion</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*returnNewData*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>repContext</color><color=#f8f8f2>);</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Insert or update a given record. The method searches for the record using its key. It will</color>
<color=#75715e>   * perform an update if the record is found, otherwise an insertion.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The cursor must initially be uninitialized.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Called by all the Cursor.putXXX() ops, except putCurrent().</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param key The new key value for the BIN slot S to be inserted/updated. Cannot be partial. For</color>
<color=#75715e>   *     dups DBs it is a 2-part key combining the original, user-provided key and data. In case of</color>
<color=#75715e>   *     update, "key" must compare equal to S.key (otherwise DuplicateDataException is thrown), but</color>
<color=#75715e>   *     the 2 keys may not be identical if custom comparators are used. So, S.key will actually be</color>
<color=#75715e>   *     replaced by "key".</color>
<color=#75715e>   * @param data In case of update, the new data to (perhaps partially) replace the data of the LN</color>
<color=#75715e>   *     associated with the BIN slot. For dups DBs it is EMPTY_DUPS_DATA. Note: for dups DBs the</color>
<color=#75715e>   *     original, user-provided "data" must not be partial.</color>
<color=#75715e>   * @param ln is normally a new LN node that is created for insertion, and will be discarded if an</color>
<color=#75715e>   *     update occurs. However, HA will pass an existing node.</color>
<color=#75715e>   * @param putMode OVERWRITE or NO_OVERWRITE</color>
<color=#75715e>   * @param returnOldData To receive, in case of update, the old LN data (before the update). It is</color>
<color=#75715e>   *     needed only by DBs with indexes/triggers; will be null otherwise.</color>
<color=#75715e>   * @param returnNewData To receive the full data of the new or updated LN. It is needed only by</color>
<color=#75715e>   *     DBs with indexes/triggers and only if "data" is partial; will be null otherwise. Note:</color>
<color=#75715e>   *     "returnNewData" may be different than "data" only if "data" is partial.</color>
<color=#75715e>   * @return OperationResult where isUpdate() distinguishes insertions and updates. Is null only if</color>
<color=#75715e>   *     an expired LN was purged and a partial 'data' param was supplied.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>OperationResult</color> <color=#a6e22e>insertOrUpdateRecord</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>ExpirationInfo</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>PutMode</color> <color=#f8f8f2>putMode</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>returnOldData</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>returnNewData</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>ReplicationContext</color> <color=#f8f8f2>repContext</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>key</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>data</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>putMode</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>putMode</color> <color=#f92672>!=</color> <color=#f8f8f2>PutMode</color><color=#f8f8f2>.</color><color=#a6e22e>OVERWRITE</color> <color=#f92672>&&</color> <color=#f8f8f2>putMode</color> <color=#f92672>!=</color> <color=#f8f8f2>PutMode</color><color=#f8f8f2>.</color><color=#a6e22e>NO_OVERWRITE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#f8f8f2>putMode</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>inserted</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>keyCopy</color> <color=#f92672>=</color> <color=#f8f8f2>Key</color><color=#f8f8f2>.</color><color=#a6e22e>makeKey</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Try to insert the key/data pair as a new record. Will succeed if</color>
<color=#75715e>       * the record does not exist in the DB already. Otherwise, the</color>
<color=#75715e>       * insertRecord() returns with the cursor registered on the slot</color>
<color=#75715e>       * whose key is equal to "key", with the LSN of that slot locked</color>
<color=#75715e>       * in WRITE mode, and with the containing BIN latched.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>LockStanding</color><color=#f8f8f2>,</color> <color=#f8f8f2>OperationResult</color><color=#f92672>></color> <color=#f8f8f2>insertResult</color> <color=#f92672>=</color>
          <color=#f8f8f2>insertRecordInternal</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>keyCopy</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*blindInsertion*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>returnNewData</color><color=#f8f8f2>,</color> <color=#f8f8f2>repContext</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>insertResult</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>inserted</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>insertResult</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * There is a non-defunct slot whose key is == "key". So, this is</color>
<color=#75715e>       * going to be an update. Note: Cursor has been registered on the</color>
<color=#75715e>       * existing slot by insertRecord()</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>putMode</color> <color=#f92672>==</color> <color=#f8f8f2>PutMode</color><color=#f8f8f2>.</color><color=#a6e22e>NO_OVERWRITE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Update the non-defunct record at the cursor position. We have</color>
<color=#75715e>       * optimized by preferring to take an uncontended lock. The</color>
<color=#75715e>       * lockStanding var is guaranteed to be non-null in this case.</color>
<color=#75715e>       * The BIN must remain latched when calling this method.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>OperationResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color>
          <color=#f8f8f2>updateRecordInternal</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>keyCopy</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>data</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>expInfo</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>returnOldData</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>returnNewData</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>insertResult</color><color=#f8f8f2>.</color><color=#a6e22e>first</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>repContext</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>success</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isInternalDb</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>inserted</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>incBinDeltaInserts</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>incBinDeltaUpdates</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Try to insert the key/data pair as a new record. Will succeed if a non-defunct record does not</color>
<color=#75715e>   * exist already with the given key.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The cursor must initially be uninitialized.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>On return, this.bin is latched.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return a non-null pair of LockStanding and OperationResult.</color>
<color=#75715e>   *     <p>+ LockStanding will be non-null if a slot with the given key already exists, whether or</color>
<color=#75715e>   *     not we reuse the slot for this record (i.e., whether or not the result is non-null). In</color>
<color=#75715e>   *     other words, we always lock the record in an existing slot for the give key.</color>
<color=#75715e>   *     <p>+ OperationResult will be non-null if we inserted a slot or reused a slot having a</color>
<color=#75715e>   *     defunct record, or null if the insertion failed because a non-defunct record exists with</color>
<color=#75715e>   *     the given key.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>LockStanding</color><color=#f8f8f2>,</color> <color=#f8f8f2>OperationResult</color><color=#f92672>></color> <color=#a6e22e>insertRecordInternal</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>ExpirationInfo</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>blindInsertion</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>returnNewData</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>ReplicationContext</color> <color=#f8f8f2>repContext</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Tree</color> <color=#f8f8f2>tree</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>WriteLockInfo</color> <color=#f8f8f2>wli</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>LockStanding</color> <color=#f8f8f2>lockStanding</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isSlotReuse</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>currLsn</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>currEmbeddedLN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>newEmbeddedLN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>data</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>shouldEmbedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>newEmbeddedLN</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>newEmbeddedLN</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expInfo</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>expInfo</color> <color=#f92672>=</color> <color=#f8f8f2>ExpirationInfo</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * At this point, this cursor does not have a position so it cannot be</color>
<color=#75715e>     * registered with the BIN that will be used. This is good because it</color>
<color=#75715e>     * allows slot compression to occur before BIN splits (thus avoiding</color>
<color=#75715e>     * splits if compression finds and removes any defunct slots). However,</color>
<color=#75715e>     * if another cursor, including the one from which this was cloned, is</color>
<color=#75715e>     * registered with the BIN, then splits won't be allowed. This is a</color>
<color=#75715e>     * good reason to use non-sticky cursors for insertions, especially</color>
<color=#75715e>     * sequential insertions since they will often end up in the same BIN.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Find and latch the BIN that should contain the "key". On return from</color>
<color=#75715e>     * the tree search, this.bin is latched, but "this" is still not</color>
<color=#75715e>     * registered.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>findBinForInsert</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>getCacheMode</color><color=#f8f8f2>());</color>

    <color=#75715e>/*</color>
<color=#75715e>     * In the case where logging occurs before locking, allow lockers to</color>
<color=#75715e>     * reject the operation (e.g., if writing on a replica) and also</color>
<color=#75715e>     * prepare to undo in the (very unlikely) event that logging succeeds</color>
<color=#75715e>     * but locking fails. Call this method BEFORE slot insertion, in case</color>
<color=#75715e>     * it throws an exception which would leave the slot with a null LSN.</color>
<color=#75715e>     *</color>
<color=#75715e>     * For Txn, creates the writeInfo map (if not done already), and</color>
<color=#75715e>     * inserts dbImpl in the undoDatabases map. Noop for other</color>
<color=#75715e>     * non-HA lockers.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>preLogWithoutLock</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the key exists already, insertEntry1() does not insert, but</color>
<color=#75715e>     * returns the index of the existing key.</color>
<color=#75715e>     *</color>
<color=#75715e>     * If bin is a delta and it does not contain the key, then:</color>
<color=#75715e>     * (a) if blindInsertion is false, insertEntry1() will mutate it to a</color>
<color=#75715e>     * full BIN and check again if the key exists or not.</color>
<color=#75715e>     * (b) if blindInsertion is true, insertEntry1() will not mutate the</color>
<color=#75715e>     * delta; it will just insert the key into the delta. This is OK,</color>
<color=#75715e>     * because blindInsertion will be true only if we know already that the</color>
<color=#75715e>     * key does not exist in the tree.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>insertIndex</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>insertEntry1</color><color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>blindInsertion</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>insertIndex</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>INSERT_SUCCESS</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * Key exists. Insertion was not successful. Register the cursor on</color>
<color=#75715e>       * the existing slot. If the slot is defunct, the key does not</color>
<color=#75715e>       * really exist and the slot can be reused to do an insertion.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>isSlotReuse</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>setIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>insertIndex</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>addCursor</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>setInitialized</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Lock the LSN for the existing LN slot, and check defunct-ness.</color>
<color=#75715e>       * An uncontended lock request is permitted because we are holding</color>
<color=#75715e>       * the bin latch. If no locker holds a lock on the slot, then no</color>
<color=#75715e>       * lock is taken by this cursor either.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>lockStanding</color> <color=#f92672>=</color> <color=#f8f8f2>lockLN</color><color=#f8f8f2>(</color><color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>WRITE</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*allowUncontended*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*noWait*/</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockStanding</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>recordExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>Pair</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The record in the current slot is defunct. Note: it may have</color>
<color=#75715e>       * been made defunct by this.locker itself.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>currLsn</color> <color=#f92672>=</color> <color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>currEmbeddedLN</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Create a new WriteLockInfo or get an existing one for the LSN</color>
<color=#75715e>       * of the current slot, and set its abortLSN and abortKD fields,</color>
<color=#75715e>       * if needed, i.e, if it is not the current txn the one who created</color>
<color=#75715e>       * this LSN. The abortLSN and abortKD fields of the wli will be</color>
<color=#75715e>       * included in the new logrec.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>wli</color> <color=#f92672>=</color> <color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>prepareForUpdate</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * Register the cursor at the slot that has been successfully</color>
<color=#75715e>       * inserted.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>isSlotReuse</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>currEmbeddedLN</color> <color=#f92672>=</color> <color=#f8f8f2>newEmbeddedLN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>currLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>setIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>insertIndex</color> <color=#f92672>&=</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>INSERT_SUCCESS</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>addCursor</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>setInitialized</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Create a new WriteLockInfo */</color>
      <color=#f8f8f2>wli</color> <color=#f92672>=</color> <color=#f8f8f2>LockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>prepareForInsert</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Log the new LN and lock the LSN of the new logrec in WRITE mode.</color>
<color=#75715e>     * Note: in case of slot reuse, we pass NULL_LSN for the oldLsn param</color>
<color=#75715e>     * because the old defunct LN is counted obsolete by other means.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>LogItem</color> <color=#f8f8f2>logItem</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>logItem</color> <color=#f92672>=</color>
          <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>optionalLog</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>locker</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>wli</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>newEmbeddedLN</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expiration</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expirationInHours</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>currEmbeddedLN</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>currLsn</color><color=#f8f8f2>,</color>
              <color=#ae81ff>0</color> <color=#75715e>/*currSize*/</color><color=#f8f8f2>,</color>
              <color=#66d9ef>true</color> <color=#75715e>/*isInsertion*/</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>repContext</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logItem</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>isSlotReuse</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * Possible buffer overflow, out-of-memory, or I/O exception</color>
<color=#75715e>         * during logging. The BIN entry will contain a NULL_LSN. To</color>
<color=#75715e>         * prevent an exception during a future fetchLN() call, we</color>
<color=#75715e>         * set the KD flag. We do not call BIN.deleteEntry because it</color>
<color=#75715e>         * does not adjust cursors. We do not add this entry to the</color>
<color=#75715e>         * compressor queue to avoid complexity (this situation is</color>
<color=#75715e>         * rare).</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setKnownDeletedAndEvictLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>logItem</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockStanding</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * No slot reuse; straight insertion. Update LSN in BIN slot.</color>
<color=#75715e>       * The LN is already in the slot.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>updateEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expirationInHours</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The following call accounts for extra marshaled memory, i.e.,</color>
<color=#75715e>       * memory that was added to the LN as a side-effect of logging it.</color>
<color=#75715e>       * This can happen for FileSummaryLN's only (it is a noop for</color>
<color=#75715e>       * other kinds of LNs).</color>
<color=#75715e>       *</color>
<color=#75715e>       * To avoid violating assertions (e.g., in IN.changeMemorySize), we</color>
<color=#75715e>       * must must finish the memory adjustment while the BIN is still</color>
<color=#75715e>       * latched. [#20069]</color>
<color=#75715e>       *</color>
<color=#75715e>       * This special handling does not apply to slot reuse, because the</color>
<color=#75715e>       * updateEntry() version used in the slot reuse case will recalc</color>
<color=#75715e>       * the BIN memory from scratch, and as a result, will take into</color>
<color=#75715e>       * account the extra marshaled memory. [#20845]</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>ln</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>addExtraMarshaledMemorySize</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Slot reuse. When reusing a slot, the key is replaced in the BIN</color>
<color=#75715e>       * slot. This ensures that the correct key value is used when the</color>
<color=#75715e>       * new key is non-identical to the key in the slot but is</color>
<color=#75715e>       * considered equal by the btree comparator.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>insertRecord</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>index</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>ln</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>data</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expiration</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expirationInHours</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>returnNewData</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>returnNewData</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>setEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>returnNewData</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Cursor is positioned on new record. */</color>
    <color=#f8f8f2>setInitialized</color><color=#f8f8f2>();</color>

    <color=#75715e>/* Cache record version/size for insertion operation. */</color>
    <color=#f8f8f2>setCurrentVersion</color><color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>setStorageSize</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * It is desirable to evict the LN in a duplicates DB because it will</color>
<color=#75715e>     * never be fetched again. But for deferred-write DBs we should not</color>
<color=#75715e>     * evict a dirty LN since it may be logged unnecessarily.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>()</color>
        <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>()</color>
        <color=#f92672>&&</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>evictLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>traceInsert</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINER</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>Pair</color><color=#f92672><></color><color=#f8f8f2>(</color>
        <color=#f8f8f2>lockStanding</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>makeResult</color><color=#f8f8f2>(</color><color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expirationInHours</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Update the record where the cursor is currently positioned at. The cursor is registered with</color>
<color=#75715e>   * this position, the associated bin is latched, the BIN slot is not defunct, and it has been</color>
<color=#75715e>   * locked in WRITE mode.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param returnOldData if non-null, will be filled in with the pre-existing record's data.</color>
<color=#75715e>   *     However, if an expired LN was purged, it will not be filled in and the caller should expect</color>
<color=#75715e>   *     this; see {@link Cursor#putNotify}.</color>
<color=#75715e>   * @return OperationResult, or null if an expired LN was purged and a partial 'data' param was</color>
<color=#75715e>   *     supplied.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>OperationResult</color> <color=#a6e22e>updateRecordInternal</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>ExpirationInfo</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>returnOldData</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>returnNewData</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LockStanding</color> <color=#f8f8f2>lockStanding</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>ReplicationContext</color> <color=#f8f8f2>repContext</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>recordExists</color><color=#f8f8f2>());</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>DbType</color> <color=#f8f8f2>dbType</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbType</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>currLsn</color> <color=#f92672>=</color> <color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>currLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>currLoggedSize</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>currKey</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>currData</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>currEmbeddedLN</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>newEmbeddedLN</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LogItem</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Must fetch LN if it is not embedded and any of the following</color>
<color=#75715e>     * are true:</color>
<color=#75715e>     *  - returnOldData is non-null: data needs to be returned</color>
<color=#75715e>     *  - data is a partial entry: needs to be resolved</color>
<color=#75715e>     *  - CLEANER_FETCH_OBSOLETE_SIZE is configured and lastLoggedSize</color>
<color=#75715e>     *    is unknown</color>
<color=#75715e>     *  - this database does not use the standard LN class and we</color>
<color=#75715e>     *    cannot call DbType.createdUpdatedLN further below (this is</color>
<color=#75715e>     *    the case for NameLNs, MapLNs, and FileSummaryLNs).</color>
<color=#75715e>     * For other cases, we are careful not to fetch, in order to avoid</color>
<color=#75715e>     * a random read during an update operation.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>returnOldData</color> <color=#f92672>!=</color> <color=#66d9ef>null</color>
        <color=#f92672>||</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>getPartial</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>currLoggedSize</color> <color=#f92672>==</color> <color=#ae81ff>0</color>
            <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>currEmbeddedLN</color>
            <color=#f92672>&&</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCleaner</color><color=#f8f8f2>().</color><color=#a6e22e>getFetchObsoleteSize</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>))</color>
        <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>dbType</color><color=#f8f8f2>.</color><color=#a6e22e>mayCreateUpdatedLN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currEmbeddedLN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>currData</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>fetchLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>currData</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>?</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>()</color> <color=#f8f8f2>:</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>currData</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>?</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>()</color> <color=#f8f8f2>:</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>newData</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>getPartial</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currData</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Expired LN was purged. Cannot use a partial entry. */</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>newData</color> <color=#f92672>=</color> <color=#f8f8f2>LN</color><color=#f8f8f2>.</color><color=#a6e22e>resolvePartialEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>currData</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>newData</color> <color=#f92672>=</color> <color=#f8f8f2>LN</color><color=#f8f8f2>.</color><color=#a6e22e>copyEntryData</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the key is changed (according to the comparator), we assume</color>
<color=#75715e>     * it is actually the data that has changed for a duplicate's DB.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>key</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>Key</color><color=#f8f8f2>.</color><color=#a6e22e>compareKeys</color><color=#f8f8f2>(</color><color=#f8f8f2>currKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getKeyComparator</color><color=#f8f8f2>())</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>DuplicateDataException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Can't replace a duplicate with new data that is not "</color>
              <color=#f92672>+</color> <color=#e6db74>"equal to the existing data according to the duplicate "</color>
              <color=#f92672>+</color> <color=#e6db74>" comparator."</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>returnOldData</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>currData</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>returnOldData</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>LN</color><color=#f8f8f2>.</color><color=#a6e22e>setEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>returnOldData</color><color=#f8f8f2>,</color> <color=#f8f8f2>currData</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>newEmbeddedLN</color> <color=#f92672>=</color> <color=#f8f8f2>shouldEmbedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>newData</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Update the existing LN, if cached, else create new LN. */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>oldLNMemSize</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>oldLNMemSize</color> <color=#f92672>=</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySizeIncludedByParent</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>modify</color><color=#f8f8f2>(</color><color=#f8f8f2>newData</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>oldLNMemSize</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>dbType</color><color=#f8f8f2>.</color><color=#a6e22e>createUpdatedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>newData</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>oldExpiration</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>oldExpirationInHours</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expInfo</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>setOldExpirationTime</color><color=#f8f8f2>(</color><color=#f8f8f2>TTL</color><color=#f8f8f2>.</color><color=#a6e22e>expirationToSystemTime</color><color=#f8f8f2>(</color><color=#f8f8f2>oldExpiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>oldExpirationInHours</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>expiration</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expInfo</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>updateExpiration</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expiration</color> <color=#f92672>!=</color> <color=#f8f8f2>oldExpiration</color>
          <color=#f92672>||</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expirationInHours</color> <color=#f92672>!=</color> <color=#f8f8f2>oldExpirationInHours</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>setExpirationUpdated</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>expiration</color> <color=#f92672>=</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expiration</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>expirationInHours</color> <color=#f92672>=</color> <color=#f8f8f2>expInfo</color><color=#f8f8f2>.</color><color=#a6e22e>expirationInHours</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>expiration</color> <color=#f92672>=</color> <color=#f8f8f2>oldExpiration</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>expirationInHours</color> <color=#f92672>=</color> <color=#f8f8f2>oldExpirationInHours</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Create a new WriteLockInfo or get an existing one for the LSN</color>
<color=#75715e>     * of the current slot, and set its abortLSN and abortKD fields,</color>
<color=#75715e>     * if needed, i.e, if it is not the current txn the one who created</color>
<color=#75715e>     * this LSN. The abortLSN and abortKD fields of the wli will be</color>
<color=#75715e>     * included in the new logrec.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>WriteLockInfo</color> <color=#f8f8f2>wli</color> <color=#f92672>=</color> <color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>prepareForUpdate</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Log the new record version and lock its new LSN . */</color>
    <color=#f8f8f2>logItem</color> <color=#f92672>=</color>
        <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>optionalLog</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>locker</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>wli</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>newEmbeddedLN</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>(</color><color=#f8f8f2>key</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>?</color> <color=#f8f8f2>key</color> <color=#f8f8f2>:</color> <color=#f8f8f2>currKey</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>currEmbeddedLN</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>currLsn</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>currLoggedSize</color><color=#f8f8f2>,</color>
            <color=#66d9ef>false</color> <color=#75715e>/*isInsertion*/</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>repContext</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Return a copy of resulting data, if requested. [#16932] */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>returnNewData</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>returnNewData</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>setEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>returnNewData</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Update the parent BIN. Update the key, if changed. [#15704]</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>updateRecord</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>index</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>oldLNMemSize</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>(</color><color=#f8f8f2>newEmbeddedLN</color> <color=#f92672>?</color> <color=#f8f8f2>newData</color> <color=#f8f8f2>:</color> <color=#66d9ef>null</color><color=#f8f8f2>),</color>
        <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the LN child is not cached, attach it to the tree if the DB</color>
<color=#75715e>     * is a DW one or if the record is not embedded in the BIN. For</color>
<color=#75715e>     * DW DBs, we must attach the LN even if the record in embedded,</color>
<color=#75715e>     * because no logrec was generated above, and as a result, the LN</color>
<color=#75715e>     * must be in the tree so that a logrec will be generated when</color>
<color=#75715e>     * a db.sync() occurs later (that logrec is needed for crash</color>
<color=#75715e>     * recovery, because BINs are not replayed during crash recovery).</color>
<color=#75715e>     *</color>
<color=#75715e>     * If the LN child is cached, it is desirable to evict it if the</color>
<color=#75715e>     * record is embedded because it will never be fetched again.</color>
<color=#75715e>     * But for DW DBs we should not evict a dirty LN since it will</color>
<color=#75715e>     * be logged unnecessarily.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>shouldCache</color> <color=#f92672>=</color>
        <color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>newEmbeddedLN</color><color=#f8f8f2>));</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>shouldCache</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>attachNode</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*lnKey*/</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>shouldCache</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>evictLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Cache record version/size for update operation. */</color>
    <color=#f8f8f2>setCurrentVersion</color><color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>setStorageSize</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>trace</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINER</color><color=#f8f8f2>,</color> <color=#f8f8f2>TRACE_MOD</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>currLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>makeUpdateResult</color><color=#f8f8f2>(</color><color=#f8f8f2>expiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Position the cursor at the first or last record of the dbImpl. It's okay if this record is</color>
<color=#75715e>   * defunct.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The cursor must initially be uninitialized.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Returns with the target BIN latched!</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if a first or last position is found, false if the tree being searched is empty.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>positionFirstOrLast</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>first</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>found</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>first</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>().</color><color=#a6e22e>getFirstNode</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>().</color><color=#a6e22e>getLastNode</color><color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>=</color> <color=#f8f8f2>getTreeStatsAccumulator</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * An IN was found. Even if it's empty, let Cursor</color>
<color=#75715e>           * handle moving to the first non-defunct entry.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>found</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>first</color> <color=#f92672>?</color> <color=#ae81ff>0</color> <color=#f8f8f2>:</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>));</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color>
              <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color>
              <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>.</color><color=#a6e22e>incrementLNCount</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Even if the entry is defunct, just leave our</color>
<color=#75715e>           * position here and return.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>found</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>addCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>setInitialized</color><color=#f8f8f2>();</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>found</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Throwable</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Release latch on error. */</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Position this cursor on the slot whose key is the max key less or equal to the given search</color>
<color=#75715e>   * key.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>To be more precise, let K1 be search key. The method positions the cursor on the BIN that</color>
<color=#75715e>   * should contain K1. If the BIN does contain K1, this.index is set to the containing slot.</color>
<color=#75715e>   * Otherwise, this.index is set to the right-most slot whose key is < K1, or to -1 if K1 is < than</color>
<color=#75715e>   * all keys in the BIN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The cursor must initially be uninitialized.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The method returns with the BIN latched, unless an exception is raised.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The method returns an integer that encodes the search outcome: If the FOUND bit is not set,</color>
<color=#75715e>   * the tree is completely empty (has no BINs). If the FOUND bit is set, the EXACT_KEY bit says</color>
<color=#75715e>   * whether K1 was found or not and the FOUND_LAST bit says whether the cursor is positioned to the</color>
<color=#75715e>   * very last slot of the BTree (note that this state can only be counted on as long as the BIN is</color>
<color=#75715e>   * latched).</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Even if the search returns an exact result, the record may be defunct. The caller must</color>
<color=#75715e>   * therefore check whether the cursor is positioned on a defunct record.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method does not lock the record. The caller is expected to call lockAndGetCurrent to</color>
<color=#75715e>   * perform locking.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>searchRange</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>searchKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>Comparator</color><color=#f92672><</color><color=#66d9ef>byte</color><color=#f92672>[]></color> <color=#f8f8f2>comparator</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>foundSomething</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>foundExactKey</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>foundLast</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>BINBoundary</color> <color=#f8f8f2>binBoundary</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BINBoundary</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#f8f8f2>Key</color><color=#f8f8f2>.</color><color=#a6e22e>makeKey</color><color=#f8f8f2>(</color><color=#f8f8f2>searchKey</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>bin</color> <color=#f92672>=</color>
          <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>().</color><color=#a6e22e>search</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>Tree</color><color=#f8f8f2>.</color><color=#a6e22e>SearchType</color><color=#f8f8f2>.</color><color=#a6e22e>NORMAL</color><color=#f8f8f2>,</color> <color=#f8f8f2>binBoundary</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>,</color> <color=#f8f8f2>comparator</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>foundSomething</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>comparator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * We must mutate a BIN delta if a non-null comparator is</color>
<color=#75715e>           * used. Otherwise, if we positioned the cursor on the</color>
<color=#75715e>           * delta using the non-null comparator, we would not be</color>
<color=#75715e>           * able to adjust its position correctly later when the</color>
<color=#75715e>           * delta gets mutated for some reason (because at that</color>
<color=#75715e>           * later time, the comparator used here would not be</color>
<color=#75715e>           * known).</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*indicateIfExact*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*exact*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>comparator</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>()</color>
            <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>binBoundary</color><color=#f8f8f2>.</color><color=#a6e22e>isLastBin</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Note: if binBoundary.isLastBin, we must mutate the BIN</color>
<color=#75715e>           * in order to compute the foundLast flag below.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>comparator</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>index</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>foundExactKey</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>index</color> <color=#f92672>&=</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>foundLast</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>binBoundary</color><color=#f8f8f2>.</color><color=#a6e22e>isLastBin</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672>==</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Must call addCursor after mutateToFullBIN() to avoid having</color>
<color=#75715e>         * to reposition "this" inside mutateToFullBIN(), which would</color>
<color=#75715e>         * be both unnecessary and wrong given that this.index could</color>
<color=#75715e>         * have the IN.EXACT_MATCH still on.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>addCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>setInitialized</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Return a multi-part status value */</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>((</color><color=#f8f8f2>foundSomething</color> <color=#f92672>?</color> <color=#f8f8f2>FOUND</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
          <color=#f92672>|</color> <color=#f8f8f2>(</color><color=#f8f8f2>foundExactKey</color> <color=#f92672>?</color> <color=#f8f8f2>EXACT_KEY</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
          <color=#f92672>|</color> <color=#f8f8f2>(</color><color=#f8f8f2>foundLast</color> <color=#f92672>?</color> <color=#f8f8f2>FOUND_LAST</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>));</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Throwable</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>searchExact</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>searchKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>searchExact</color><color=#f8f8f2>(</color><color=#f8f8f2>searchKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Position this cursor on the slot (if any) whose key matches the given search key. If no such</color>
<color=#75715e>   * slot is found or the slot does not hold a "valid" record, return null. Otherwise, lock the</color>
<color=#75715e>   * found record with the specified lock type (which may be NONE) and return the LockStanding obj</color>
<color=#75715e>   * that was created by the locking op. Whether the slot contains a "valid" record or not depends</color>
<color=#75715e>   * on the slot's KD/PD flags and the lockType and dirtyReadAll parameters. Four cases are</color>
<color=#75715e>   * considered; they are described in the lockLNAndCheckDefunct() method.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The cursor must initially be uninitialized.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The method returns with the BIN latched, unless an exception is raised.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>In all cases, the method registers the cursor with the BIN that contains or should contain</color>
<color=#75715e>   * the search key.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the LockStanding for the found record, or null if no record was found.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>LockStanding</color> <color=#a6e22e>searchExact</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>searchKey</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dirtyReadAll</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dataRequested</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>LockStanding</color> <color=#f8f8f2>lockStanding</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#f8f8f2>Key</color><color=#f8f8f2>.</color><color=#a6e22e>makeKey</color><color=#f8f8f2>(</color><color=#f8f8f2>searchKey</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>().</color><color=#a6e22e>search</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*exact*/</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>mayHaveKeyInFullBin</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*exact*/</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>addCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>lockStanding</color> <color=#f92672>=</color> <color=#f8f8f2>lockLNAndCheckDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirtyReadAll</color><color=#f8f8f2>,</color> <color=#f8f8f2>dataRequested</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>setInitialized</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>lockStanding</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Throwable</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Release latch on error. */</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Lock and copy current record into the key and data DatabaseEntry. When calling this method,</color>
<color=#75715e>   * this.bin should not be latched already. On return, this.bin is unlatched.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>OperationResult</color> <color=#a6e22e>lockAndGetCurrent</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>foundKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>foundData</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>lockAndGetCurrent</color><color=#f8f8f2>(</color><color=#f8f8f2>foundKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>foundData</color><color=#f8f8f2>,</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Let S be the slot where this cursor is currently positioned on. If S does not hold a "valid"</color>
<color=#75715e>   * record, return null. Otherwise, lock the record in S with the specified lock type(which may be</color>
<color=#75715e>   * NONE), copy its key and data into the key and data DatabaseEntries, and return SUCCESS. Whether</color>
<color=#75715e>   * the slot contains a "valid" record or not depends on the slot's KD/PD flags, the lockType and</color>
<color=#75715e>   * dirtyReadAll parameters, and whether the record has expired. For details see {@link</color>
<color=#75715e>   * #lockLNAndCheckDefunct}.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>On entry, the isLatched param says whether this.bin is latched or not. On return, this.bin</color>
<color=#75715e>   * is unlatched if the unlatch param is true or an exception is thrown.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return OperationResult, or null if the LN has been cleaned and cannot be fetched.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>OperationResult</color> <color=#a6e22e>lockAndGetCurrent</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>foundKey</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>foundData</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dirtyReadAll</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isLatched</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>unlatch</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Used in the finally to indicate whether exception was raised. */</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>checkAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>dumpToString</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getCursorSet</color><color=#f8f8f2>().</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>=</color> <color=#f8f8f2>getTreeStatsAccumulator</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If we encounter a deleted slot, opportunistically add the BIN</color>
<color=#75715e>       * to the compressor queue. We do not queue expired slots to avoid</color>
<color=#75715e>       * frequent compression, especially in the CRUD path; we rely</color>
<color=#75715e>       * instead on the evictor to perform expired slot compression.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>queueSlotDeletion</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Check the KD flag in the BIN slot and make sure this isn't an</color>
<color=#75715e>       * empty BIN. The BIN could be empty by virtue of the compressor</color>
<color=#75715e>       * running the size of this BIN to 0 but not having yet removed</color>
<color=#75715e>       * it from the tree.</color>
<color=#75715e>       *</color>
<color=#75715e>       * The index may be negative if we're at an intermediate stage in</color>
<color=#75715e>       * an higher level operation (e.g., the starting search for a range</color>
<color=#75715e>       * scan op), and we expect a higher level method to do a next or</color>
<color=#75715e>       * prev operation after this returns KEYEMPTY. [#11700]</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Node is no longer present. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>.</color><color=#a6e22e>incrementDeletedLNCount</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>testHook</color><color=#f8f8f2>);</color>

      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dataRequested</color> <color=#f92672>=</color>
          <color=#f8f8f2>(</color><color=#f8f8f2>foundData</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>foundData</color><color=#f8f8f2>.</color><color=#a6e22e>getPartial</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>foundData</color><color=#f8f8f2>.</color><color=#a6e22e>getPartialLength</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>));</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockLNAndCheckDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirtyReadAll</color><color=#f8f8f2>,</color> <color=#f8f8f2>dataRequested</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>treeStatsAccumulator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>treeStatsAccumulator</color><color=#f8f8f2>.</color><color=#a6e22e>incrementDeletedLNCount</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>OperationResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>getCurrent</color><color=#f8f8f2>(</color><color=#f8f8f2>foundKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>foundData</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>unlatch</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Let S be the slot where this cursor is currently positioned on. The method locks S (i.e. its</color>
<color=#75715e>   * LSN), and depending on S's KD/PD flags and expired status, it returns either null or the</color>
<color=#75715e>   * LockStanding obj that was created by the locking op. The following 4 cases are considered. By</color>
<color=#75715e>   * "defunct" below we mean S is KD/PD or expired.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>1. If S is not defunct, return the LockStanding obj. In this case, we know that S holds a</color>
<color=#75715e>   * valid (non-defunct) record.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>2. If S is defunct, and the lock type is not NONE, return null. In this case, we know that</color>
<color=#75715e>   * the record that used to be in S is definitely defunct.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>3. If S is defunct, the lock kind is NONE, and dirtyReadAll is false, return null. This case</color>
<color=#75715e>   * corresponds to the READ_UNCOMMITTED LockMode. The record in S is defunct, but the deleting txn</color>
<color=#75715e>   * may be active still, and if it aborts later, the record will be restored. To avoid a</color>
<color=#75715e>   * potentially blocking lock, in READ_UNCOMMITTED mode we consider the record to be non-existing</color>
<color=#75715e>   * and return null.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>4. If S is defunct, the lock kind is NONE, and dirtyReadAll is true, lock the record in READ</color>
<color=#75715e>   * mode. This case corresponds to the READ_UNCOMMITTED_ALL LockMode, which requires that we do not</color>
<color=#75715e>   * skip "provisionally defunct" records. There are two sub-cases:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>4a. If dataRequested is true, we wait until the deleting txn finishes. In this case the READ</color>
<color=#75715e>   * lock is blocking. If after the lock is granted S is still defunct, release the lock and return</color>
<color=#75715e>   * null. Otherwise, release the lock and return the LockStanding obj.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>4b. If dataRequested is false, then we check whether the deleting txn is still open by</color>
<color=#75715e>   * requested a non-blocking READ lock. If the lock is granted then the writing txn is closed or</color>
<color=#75715e>   * this cursor's locker is the writer, and we proceed as if the READ lock was granted in 4a. If</color>
<color=#75715e>   * the lock is denied then the deleting txn is still open, and we return the LockStanding obj so</color>
<color=#75715e>   * that the record is not skipped.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The BIN must be latched on entry and is latched on exit.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param dirtyReadAll is true if using LockMode.READ_UNCOMMITTED_ALL.</color>
<color=#75715e>   * @param dataRequested is true if the read operation should return the record data, meaning that</color>
<color=#75715e>   *     a blocking lock must be used for dirtyReadAll. Is ignored if dirtyReadAll is false. Is</color>
<color=#75715e>   *     always false for a dup DB, since data is never requested for dup DB ops at the CursorImpl</color>
<color=#75715e>   *     level.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>LockStanding</color> <color=#a6e22e>lockLNAndCheckDefunct</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dirtyReadAll</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dataRequested</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>dirtyReadAll</color> <color=#f92672>&&</color> <color=#f8f8f2>lockType</color> <color=#f92672>!=</color> <color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>NONE</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>dataRequested</color> <color=#f92672>&&</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>());</color>

    <color=#f8f8f2>LockStanding</color> <color=#f8f8f2>standing</color> <color=#f92672>=</color> <color=#f8f8f2>lockLN</color><color=#f8f8f2>(</color><color=#f8f8f2>lockType</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>recordExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>standing</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* The slot is defunct. */</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockType</color> <color=#f92672>!=</color> <color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>NONE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>revertLock</color><color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The record was committed by another locker, or has been</color>
<color=#75715e>       * performed by this locker.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* We're using dirty-read.  The lockLN above did not actually lock. */</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>dirtyReadAll</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* READ_UNCOMMITTED -- skip defunct records without locking. */</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * READ_UNCOMMITTED_ALL -- get a read lock. Whether we can request a</color>
<color=#75715e>     * no-wait or a blocking lock depends on the dataRequested parameter.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Although there is some redundant processing in the sense that lockLN</color>
<color=#75715e>     * is called more than once (above and below), this is not considered a</color>
<color=#75715e>     * performance issue because accessing defunct records is normally</color>
<color=#75715e>     * infrequent. Deleted slots are normally compressed away quickly.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>standing</color> <color=#f92672>=</color> <color=#f8f8f2>lockLN</color><color=#f8f8f2>(</color><color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>READ</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*allowUncontended*/</color><color=#f8f8f2>,</color> <color=#f92672>!</color><color=#f8f8f2>dataRequested</color> <color=#75715e>/*noWait*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lockResult</color><color=#f8f8f2>.</color><color=#a6e22e>getLockGrant</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>LockGrantType</color><color=#f8f8f2>.</color><color=#a6e22e>DENIED</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The no-wait lock request was denied, which means the data is not</color>
<color=#75715e>       * needed and the writing transaction is still open. The defunct</color>
<color=#75715e>       * record should not be skipped in this case, according to the</color>
<color=#75715e>       * definition of READ_UNCOMMITTED_ALL.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>recordExists</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>standing</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* We have acquired a temporary read lock. */</color>
    <color=#f8f8f2>revertLock</color><color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>recordExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * Another txn aborted the deletion or expiration time change while</color>
<color=#75715e>       * we waited.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>standing</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The write was committed by another locker, or has been performed by</color>
<color=#75715e>     * this locker.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Copy current record into the key and data DatabaseEntry.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return OperationResult, or null if the LN has been cleaned and cannot be fetched.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>OperationResult</color> <color=#a6e22e>getCurrent</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>foundKey</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>foundData</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>());</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>());</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We don't need to fetch the LN if the user has not requested that we</color>
<color=#75715e>     * return the data, or if we know for sure that the LN is empty.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isEmptyLN</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isLNImmediatelyObsolete</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isEmbeddedLN</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dataRequested</color> <color=#f92672>=</color>
        <color=#f8f8f2>(</color><color=#f8f8f2>foundData</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>foundData</color><color=#f8f8f2>.</color><color=#a6e22e>getPartial</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>foundData</color><color=#f8f8f2>.</color><color=#a6e22e>getPartialLength</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>));</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isEmptyLN</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>isEmbeddedLN</color> <color=#f92672>&&</color> <color=#f8f8f2>dataRequested</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>fetchLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* An expired LN was purged. */</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Return the data. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dataRequested</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>data</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isEmptyLN</color> <color=#f92672>||</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isNoDataLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>LogUtils</color><color=#f8f8f2>.</color><color=#a6e22e>ZERO_LENGTH_BYTE_ARRAY</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>isEmbeddedLN</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>LN</color><color=#f8f8f2>.</color><color=#a6e22e>setEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>foundData</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Return the key */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>foundKey</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LN</color><color=#f8f8f2>.</color><color=#a6e22e>setEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>foundKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Cache record version/size for fetch operation. */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>vlsn</color> <color=#f92672>=</color>
        <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>?</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>()</color> <color=#f8f8f2>:</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*allowFetch*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>));</color>

    <color=#f8f8f2>setCurrentVersion</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>setStorageSize</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>makeResult</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>),</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>LN</color> <color=#a6e22e>getCurrentLN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isLatched</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>unlatch</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Used in the finally to indicate whether exception was raised. */</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>checkAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>dumpToString</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getCursorSet</color><color=#f8f8f2>().</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>));</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>fetchLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>ln</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>unlatch</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Retrieve the current LN. BIN is unlatched on entry and exit. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>LN</color> <color=#a6e22e>lockAndGetCurrentLN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>checkAlreadyLatched</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>dumpToString</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getCursorSet</color><color=#f8f8f2>().</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>LockStanding</color> <color=#f8f8f2>lockStanding</color> <color=#f92672>=</color> <color=#f8f8f2>lockLN</color><color=#f8f8f2>(</color><color=#f8f8f2>lockType</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>.</color><color=#a6e22e>recordExists</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>revertLock</color><color=#f8f8f2>(</color><color=#f8f8f2>lockStanding</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>fetchLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the VLSN and LSN for the record at the current position. Must be called when the cursor</color>
<color=#75715e>   * is positioned on a record.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If this method is called on a secondary cursor, the version of the associated primary record</color>
<color=#75715e>   * is returned. In that case, the allowFetch parameter is ignored, and the version is available</color>
<color=#75715e>   * only if the primary record was retrieved (see setPriInfo).</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param allowFetch is true to fetch the LN to get the VLSN, or false to return -1 for the VLSN</color>
<color=#75715e>   *     if both the LN and VLSN are not cached.</color>
<color=#75715e>   * @throws IllegalStateException if the cursor is closed or uninitialized, or this is a secondary</color>
<color=#75715e>   *     cursor and the version is not cached.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>RecordVersion</color> <color=#a6e22e>getCurrentVersion</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>allowFetch</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Ensure cursor is open and initialized. */</color>
    <color=#f8f8f2>checkCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * For a secondary cursor, the cached version is all we have.</color>
<color=#75715e>     * See setPriInfo.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isSecondaryCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentRecordVersion</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalStateException</color><color=#f8f8f2>(</color>
            <color=#e6db74>"Record version is available via a SecondaryCursor only "</color>
                <color=#f92672>+</color> <color=#e6db74>"if the associated primary record was retrieved."</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>currentRecordVersion</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Use cached version if available.  Do not use cached version if it</color>
<color=#75715e>     * does not contain a VLSN, and VLSNs are preserved, and fetching is</color>
<color=#75715e>     * allowed; instead, try to fetch it below.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentRecordVersion</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>currentRecordVersion</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color><color=#f8f8f2>)</color>
          <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>allowFetch</color>
          <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getPreserveVLSN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>currentRecordVersion</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Get the VLSN from the BIN, create the version and cache it. */</color>
    <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>setCurrentVersion</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>allowFetch</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>),</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>currentRecordVersion</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>setCurrentVersion</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>currentRecordVersion</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RecordVersion</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the estimated disk storage size for the record at the current position. The size</color>
<color=#75715e>   * includes an estimation of the JE overhead for the record, in addition to the user key/data</color>
<color=#75715e>   * sizes. But it does not include obsolete overhead related to the record, i.e., space that could</color>
<color=#75715e>   * potentially be reclaimed by the cleaner.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method does not fetch the LN. Must be called when the cursor is positioned on a record.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>When called on a secondary cursor that was used to return the primary data, the size of the</color>
<color=#75715e>   * primary record is returned by this method. Otherwise the size of the record at this cursor</color>
<color=#75715e>   * position is returned.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the estimated storage size, or zero when the size is unknown because a non-embedded LN</color>
<color=#75715e>   *     is not resident and the LN was logged with a JE version prior to 6.0.</color>
<color=#75715e>   * @throws IllegalStateException if the cursor is closed or uninitialized.</color>
<color=#75715e>   * @see StorageSize</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getStorageSize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>priStorageSize</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#f8f8f2>priStorageSize</color> <color=#f8f8f2>:</color> <color=#f8f8f2>storageSize</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>setStorageSize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>storageSize</color> <color=#f92672>=</color> <color=#f8f8f2>StorageSize</color><color=#f8f8f2>.</color><color=#a6e22e>getStorageSize</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * When the primary record is read during a secondary operation, this method is called to copy the</color>
<color=#75715e>   * primary version and storage size here. This allows the secondary cursor API to return the</color>
<color=#75715e>   * version and size of the primary record. Note that a secondary record does not have a version of</color>
<color=#75715e>   * its own.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param sourceCursor contains the primary info, but may be a primary or secondary cursor.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setPriInfo</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>sourceCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>currentRecordVersion</color> <color=#f92672>=</color> <color=#f8f8f2>sourceCursor</color><color=#f8f8f2>.</color><color=#a6e22e>currentRecordVersion</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>priStorageSize</color> <color=#f92672>=</color> <color=#f8f8f2>sourceCursor</color><color=#f8f8f2>.</color><color=#a6e22e>storageSize</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the number of secondary records written by the last put/delete operation at the current</color>
<color=#75715e>   * cursor position.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>NOTE: this method does not work (returns 0) if primary deletions are performed via a</color>
<color=#75715e>   * secondary (SecondaryDatabase/SecondaryCursor.delete).</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return number of writes, or zero if a put/delete operation was not performed.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getNSecondaryWrites</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nSecWrites</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setNSecondaryWrites</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nWrites</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>nSecWrites</color> <color=#f92672>=</color> <color=#f8f8f2>nWrites</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Advance a cursor. Used so that verify can advance a cursor even in the face of an exception</color>
<color=#75715e>   * [12932].</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param key on return contains the key if available, or null.</color>
<color=#75715e>   * @param data on return contains the data if available, or null.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>advanceCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>BIN</color> <color=#f8f8f2>oldBin</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>oldIndex</color> <color=#f92672>=</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>key</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>getNext</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>data</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>NONE</color><color=#f8f8f2>,</color>
          <color=#66d9ef>false</color> <color=#75715e>/*dirtyReadAll*/</color><color=#f8f8f2>,</color>
          <color=#66d9ef>true</color> <color=#75715e>/*forward*/</color><color=#f8f8f2>,</color>
          <color=#66d9ef>false</color> <color=#75715e>/*isLatched*/</color><color=#f8f8f2>,</color>
          <color=#66d9ef>null</color> <color=#75715e>/*rangeConstraint*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>ignored</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Klockwork - ok */</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the position changed, regardless of an exception, then we believe</color>
<color=#75715e>     * that we have advanced the cursor.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#f8f8f2>oldBin</color> <color=#f92672>||</color> <color=#f8f8f2>index</color> <color=#f92672>!=</color> <color=#f8f8f2>oldIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Return the key and data from the BIN entries, if we were not</color>
<color=#75715e>       * able to read it above.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LN</color><color=#f8f8f2>.</color><color=#a6e22e>setEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Move the cursor forward and return the next "valid" record. Whether a slot contains a "valid"</color>
<color=#75715e>   * record or not depends on the slot's KD/PD flags and the lockType and dirtyReadAll parameters.</color>
<color=#75715e>   * Four cases are considered; they are described in the lockLNAndCheckDefunct() method.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This will cross BIN boundaries. On return, no latches are held. If no exceptions, the cursor</color>
<color=#75715e>   * is registered with its new location.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param foundKey DatabaseEntry to use for returning key</color>
<color=#75715e>   * @param foundData DatabaseEntry to use for returning data</color>
<color=#75715e>   * @param forward if true, move forward, else move backwards</color>
<color=#75715e>   * @param isLatched if true, the bin that we're on is already latched.</color>
<color=#75715e>   * @param rangeConstraint if non-null, is called to determine whether a key is out of range.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>OperationResult</color> <color=#a6e22e>getNext</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>foundKey</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>foundData</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>dirtyReadAll</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>isLatched</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RangeConstraint</color> <color=#f8f8f2>rangeConstraint</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*mustBeInitialized*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*mustNotBeInitialized*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>checkAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>dumpToString</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>OperationResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>BIN</color> <color=#f8f8f2>anchorBIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>checkAlreadyLatched</color><color=#f8f8f2>(</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>dumpToString</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>isLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>verifyCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

        <color=#75715e>/* Is there anything left on this BIN? */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>forward</color> <color=#f92672>&&</color> <color=#f92672>++</color><color=#f8f8f2>index</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>())</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>forward</color> <color=#f92672>&&</color> <color=#f92672>--</color><color=#f8f8f2>index</color> <color=#f92672>></color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rangeConstraint</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>rangeConstraint</color><color=#f8f8f2>.</color><color=#a6e22e>inBounds</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>OperationResult</color> <color=#f8f8f2>ret</color> <color=#f92672>=</color>
              <color=#f8f8f2>lockAndGetCurrent</color><color=#f8f8f2>(</color>
                  <color=#f8f8f2>foundKey</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>foundData</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>dirtyReadAll</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>true</color> <color=#75715e>/*isLatched*/</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>false</color> <color=#75715e>/*unlatch*/</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ret</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>incrementLNCount</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * Make sure that the current BIN will not be pruned away</color>
<color=#75715e>           * if it is or becomes empty after it gets unlatched by</color>
<color=#75715e>           * Tree.getNextBin() or Tree.getPrevBin(). The operation</color>
<color=#75715e>           * of these Tree methods relies on the current BIN not</color>
<color=#75715e>           * getting pruned.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>anchorBIN</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>anchorBIN</color><color=#f8f8f2>.</color><color=#a6e22e>pin</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>removeCursor</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

          <color=#66d9ef>final</color> <color=#f8f8f2>Tree</color> <color=#f8f8f2>tree</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>();</color>

          <color=#75715e>/* SR #12736 Try to prune away oldBin */</color>
          <color=#66d9ef>assert</color> <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>testHook</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>getNextBin</color><color=#f8f8f2>(</color><color=#f8f8f2>anchorBIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>getPrevBin</color><color=#f8f8f2>(</color><color=#f8f8f2>anchorBIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>isLatched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>

            <color=#f8f8f2>addCursor</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>anchorBIN</color><color=#f8f8f2>.</color><color=#a6e22e>unpin</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>anchorBIN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>anchorBIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>anchorBIN</color><color=#f8f8f2>.</color><color=#a6e22e>unpin</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Used to detect phantoms during "get next" operations with serializable isolation. If this</color>
<color=#75715e>   * method returns true, the caller should restart the operation from the prior position.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Something may have been added to the original cursor (cursorImpl) while we were getting the</color>
<color=#75715e>   * next BIN. cursorImpl would have been adjusted properly but we would have skipped a BIN in the</color>
<color=#75715e>   * process. This can happen when all INs are unlatched in Tree.getNextBin. It can also happen</color>
<color=#75715e>   * without a split, simply due to inserted entries in the previous BIN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if an unaccounted for insertion happened.</color>
<color=#75715e>   *     <p>TODO: Unfortunately, this method doesn't cover all cases where a phantom may have been</color>
<color=#75715e>   *     inserted. Another case is described below.</color>
<color=#75715e>   *     <p>IN-0 ---------------------- | | 50 | 100 | | ---------------------- / / \ \ / \ /----</color>
<color=#75715e>   *     ----\ IN-1 / \ IN-2 ---------------- ---------------- | 60 | 70 | 80 | | | | |</color>
<color=#75715e>   *     ---------------- ---------------- / | \ / / | \ / ---------------- ----------------- | 81 |</color>
<color=#75715e>   *     83 | 85 | | 110 | | | ---------------- ----------------- BIN-3 BIN-4</color>
<color=#75715e>   *     <p>Initially, the tree looks as above and a cursor (C) is located on the last slot of</color>
<color=#75715e>   *     BIN-3. For simplicity, assume no duplicates and no serializable isolation. Also assume that</color>
<color=#75715e>   *     C is a sticky cursor.</color>
<color=#75715e>   *     <p>1. Thread 1 calls C.getNext(), which calls retrieveNextAllowPhantoms(), which duplicates</color>
<color=#75715e>   *     C's cursorImpl, and calls dup.getNext().</color>
<color=#75715e>   *     <p>dup.getNext() latches BIN-3, sets dup.binToBeRemoved to BIN-3 and then calls</color>
<color=#75715e>   *     Tree.getNextBin(BIN-3).</color>
<color=#75715e>   *     <p>Tree.getNextBin(BIN-3) does the following: - sets searchKey to 85 - calls</color>
<color=#75715e>   *     Tree.getParentINForChildIN(BIN-3). - Tree.getParentINForChildIN(BIN-3) unlatches BIN-3 and</color>
<color=#75715e>   *     searches for BIN-3 parent, thus reaching IN-1. - IN-1.findEntry(85) sets "index" to 2, -</color>
<color=#75715e>   *     "index" is incremented, - "moreEntriesThisIn" is set to false, - "next" is set to IN-1, . -</color>
<color=#75715e>   *     Tree.getParentINForChildIN(IN-1) is called and unlatches IN-1.</color>
<color=#75715e>   *     <p>Assume at this point thread 1 looses the cpu.</color>
<color=#75715e>   *     <p>2. Thread 2 inserts keys 90 and 95, causing a split of both BIN-3 and IN-1. So the tree</color>
<color=#75715e>   *     now looks like this:</color>
<color=#75715e>   *     <p>IN-0 --------------------------- | | 50 | 80 | 100 | | --------------------------- / / |</color>
<color=#75715e>   *     \ \ / | \ /--------- | ----------\ IN-1 / | \ IN-2 / IN-5 | \ ----------- -----------</color>
<color=#75715e>   *     ---------------- | 60 | 70 | | 80 | 90 | | | | | ----------- ----------- ---------------- /</color>
<color=#75715e>   *     | / \ / / | / \ / ---------------- ----------- ----------------- | 81 | 83 | 85 | | 90 | 95</color>
<color=#75715e>   *     | | 110 | | | ---------------- ----------- ----------------- BIN-3 BIN-6 BIN-4</color>
<color=#75715e>   *     <p>Notice that C.cursorImpl still points to the last slot of BIN-3.</color>
<color=#75715e>   *     <p>3. Thread 1 resumes:</color>
<color=#75715e>   *     <p>- Tree.getParentINForChildIN(IN-1) reaches IN-0. - IN-0.findEntry(85) sets "index" to 2,</color>
<color=#75715e>   *     - "index" is incremented, - "nextIN" is set to IN-2, which is latched. -</color>
<color=#75715e>   *     Tree.searchSubTree(IN-2, LEFT) is called, and returns BIN-4. - BIN-4 is the result of</color>
<color=#75715e>   *     Tree.getNextBin(BIN-3), i.e., BIN-6 was skipped</color>
<color=#75715e>   *     <p>Now we are back in dup.getNext(): - dup.bin is set to BIN-4, dup.index to -1, and dup is</color>
<color=#75715e>   *     added to BIN-4 - the while loop repeats, dup.index is set to 0, the 1st slot of BIN-4 is</color>
<color=#75715e>   *     locked, and dup.getNext() returns SUCCESS.</color>
<color=#75715e>   *     <p>Now we are back in C.retrieveNextAllowPhantoms(): - C.checkForInsertion() is called -</color>
<color=#75715e>   *     C.cursorImpl and dup are on different BINs, but the condition: origBIN.getNEntries() - 1 ></color>
<color=#75715e>   *     origCursor.getIndex() is false, so C.checkForInsertion() returns false.</color>
<color=#75715e>   *     <p>The end result is that BIN-6 has been missed. This is not be a "bug" for</color>
<color=#75715e>   *     non-serializable isolation, but the above scenario applies to serializable isolation as</color>
<color=#75715e>   *     well, and in that case, BIN-6 should really not be missed. This could be solved by</color>
<color=#75715e>   *     re-implementing Tree.getNext/PrevBIN() do a more "logical" kind of search.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>checkForInsertion</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>GetMode</color> <color=#f8f8f2>getMode</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>dupCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>origCursor</color> <color=#f92672>=</color> <color=#66d9ef>this</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color> <color=#f92672>=</color> <color=#f8f8f2>getMode</color><color=#f8f8f2>.</color><color=#a6e22e>isForward</color><color=#f8f8f2>();</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>ret</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>origCursor</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color> <color=#f92672>!=</color> <color=#f8f8f2>dupCursor</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We jumped to the next BIN during getNext().</color>
<color=#75715e>       *</color>
<color=#75715e>       * Be sure to operate on the BIN returned by latchBIN, not a cached</color>
<color=#75715e>       * var [#21121].</color>
<color=#75715e>       *</color>
<color=#75715e>       * Note that a cursor BIN can change after the check above, but</color>
<color=#75715e>       * that's not relevant; what we're trying to detect are BIN changes</color>
<color=#75715e>       * during the operation that has already completed.</color>
<color=#75715e>       *</color>
<color=#75715e>       * Note that we can call isDefunct without locking.  If we see a</color>
<color=#75715e>       * non-committed defunct entry, we'll just iterate around in the</color>
<color=#75715e>       * caller. So a false positive is ok.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>origCursor</color><color=#f8f8f2>.</color><color=#a6e22e>latchBIN</color><color=#f8f8f2>();</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>origBIN</color> <color=#f92672>=</color> <color=#f8f8f2>origCursor</color><color=#f8f8f2>.</color><color=#a6e22e>bin</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>origBIN</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>origBIN</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color> <color=#f92672>></color> <color=#f8f8f2>origCursor</color><color=#f8f8f2>.</color><color=#a6e22e>getIndex</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

            <color=#75715e>/*</color>
<color=#75715e>             * We were adjusted to something other than the</color>
<color=#75715e>             * last entry so some insertion happened.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>origCursor</color><color=#f8f8f2>.</color><color=#a6e22e>getIndex</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>origBIN</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>origBIN</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#75715e>/* See comment above about locking. */</color>
                <color=#f8f8f2>ret</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>
              <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>origCursor</color><color=#f8f8f2>.</color><color=#a6e22e>getIndex</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

            <color=#75715e>/*</color>
<color=#75715e>             * We were adjusted to something other than the</color>
<color=#75715e>             * first entry so some insertion happened.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>origCursor</color><color=#f8f8f2>.</color><color=#a6e22e>getIndex</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>origBIN</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#75715e>/* See comment above about locking. */</color>
                <color=#f8f8f2>ret</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>
              <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>origCursor</color><color=#f8f8f2>.</color><color=#a6e22e>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Skips over entries until a boundary condition is satisfied, either because maxCount is reached</color>
<color=#75715e>   * or RangeConstraint.inBounds returns false.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If a maxCount is passed, this allows advancing the cursor quickly by N entries. If a</color>
<color=#75715e>   * rangeConstraint is passed, this allows returning the entry count after advancing until the</color>
<color=#75715e>   * predicate returns false, e.g., the number of entries in a key range. In either case, the number</color>
<color=#75715e>   * of entries advanced is returned.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Optimized to scan using level two of the tree when possible, to avoid calling</color>
<color=#75715e>   * getNextBin/getPrevBin for every BIN of the database. All BINs beneath a level two IN can be</color>
<color=#75715e>   * skipped quickly, with the level two parent IN latched, when all of its children BINs are</color>
<color=#75715e>   * resident and can be latched without waiting. When a child BIN is not resident or latching</color>
<color=#75715e>   * waits, we revert to the getNextBin/getPrevBin approach, to avoid keeping the parent IN latched</color>
<color=#75715e>   * for long time periods.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Although this method positions the cursor on the last non-defunct entry seen (before the</color>
<color=#75715e>   * boundary condition is satisfied), because it does not lock the LN it is possible that it is</color>
<color=#75715e>   * made defunct by another thread after the BIN is unlatched.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param forward is true to skip forward, false to skip backward.</color>
<color=#75715e>   * @param maxCount is the maximum number of non-defunct entries to skip, and may be LTE zero if no</color>
<color=#75715e>   *     maximum is enforced.</color>
<color=#75715e>   * @param rangeConstraint is a predicate that returns false at a position where advancement should</color>
<color=#75715e>   *     stop, or null if no predicate is enforced.</color>
<color=#75715e>   * @return the number of non-defunct entries that were skipped.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>skip</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>maxCount</color><color=#f8f8f2>,</color> <color=#f8f8f2>RangeConstraint</color> <color=#f8f8f2>rangeConstraint</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>c</color> <color=#f92672>=</color> <color=#f8f8f2>cloneCursor</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*samePosition*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>c</color><color=#f8f8f2>.</color><color=#a6e22e>setCacheMode</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>c</color><color=#f8f8f2>.</color><color=#a6e22e>skipInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxCount</color><color=#f8f8f2>,</color> <color=#f8f8f2>rangeConstraint</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Throwable</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * Get more info on dbsim duplicate.conf failure when c.close below</color>
<color=#75715e>       * throws because the BIN latch is already held.  It should have</color>
<color=#75715e>       * been released by skipInternal and therefore an unexpected</color>
<color=#75715e>       * exception must have been throw and the error handling must be</color>
<color=#75715e>       * incorrect.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>e</color><color=#f8f8f2>.</color><color=#a6e22e>printStackTrace</color><color=#f8f8f2>(</color><color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>c</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Use this cursor to reference the current BIN in the traversal, to prevent the current BIN from</color>
<color=#75715e>   * being compressed away. But set the given finalPositionCursor (the 'user' cursor) position only</color>
<color=#75715e>   * at non-defunct entries, since it should be positioned on a valid entry when this method</color>
<color=#75715e>   * returns.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>skipInternal</color><color=#f8f8f2>(</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>maxCount</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RangeConstraint</color> <color=#f8f8f2>rangeConstraint</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>finalPositionCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Start with the entry at the cursor position. */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Tree</color> <color=#f8f8f2>tree</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>BIN</color> <color=#f8f8f2>prevBin</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>BIN</color> <color=#f8f8f2>curBin</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>curIndex</color> <color=#f92672>=</color> <color=#f8f8f2>getIndex</color><color=#f8f8f2>();</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>count</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

        <color=#75715e>/* Skip entries in the current BIN. */</color>
        <color=#f8f8f2>count</color> <color=#f92672>=</color>
            <color=#f8f8f2>skipEntries</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>forward</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxCount</color><color=#f8f8f2>,</color> <color=#f8f8f2>rangeConstraint</color><color=#f8f8f2>,</color> <color=#f8f8f2>finalPositionCursor</color><color=#f8f8f2>,</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>,</color> <color=#f8f8f2>curIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>count</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>count</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f92672>-</color><color=#f8f8f2>count</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Get the parent IN at level two. The BIN is unlatched by</color>
<color=#75715e>         * getParentINForChildIN.  Before releasing the BIN latch, get</color>
<color=#75715e>         * the search key for the last entry.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>idKey</color> <color=#f92672>=</color>
            <color=#f8f8f2>(</color><color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color>
                <color=#f92672>?</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getIdentifierKey</color><color=#f8f8f2>()</color>
                <color=#f8f8f2>:</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color> <color=#f92672>?</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>)));</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>SearchResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color>
            <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>getParentINForChildIN</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>curBin</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#75715e>/*useTargetLevel*/</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#75715e>/*doFetch*/</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>exactParentFound</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#e6db74>"Cannot get parent of BIN id="</color>
                  <color=#f92672>+</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color>
                  <color=#f92672>+</color> <color=#e6db74>" key="</color>
                  <color=#f92672>+</color> <color=#f8f8f2>Arrays</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>(</color><color=#f8f8f2>idKey</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Find and latch previous child BIN by matching idKey rather</color>
<color=#75715e>         * than using result.index, as in Tree.getNextIN (see comments</color>
<color=#75715e>         * there).</color>
<color=#75715e>         */</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>parentIndex</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>idKey</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>curBin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>fetchIN</color><color=#f8f8f2>(</color><color=#f8f8f2>parentIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color> <color=#f92672>?</color> <color=#f8f8f2>(</color><color=#f8f8f2>parentIndex</color> <color=#f92672><</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>(</color><color=#f8f8f2>parentIndex</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * There are more entries in the parent. Skip entries for</color>
<color=#75715e>           * child BINs that are resident and can be latched no-wait.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>incr</color> <color=#f92672>=</color> <color=#f8f8f2>forward</color> <color=#f92672>?</color> <color=#ae81ff>1</color> <color=#f8f8f2>:</color> <color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>

          <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>parentIndex</color> <color=#f92672>+=</color> <color=#f8f8f2>incr</color><color=#f8f8f2>;</color> <color=#f8f8f2>;</color> <color=#f8f8f2>parentIndex</color> <color=#f92672>+=</color> <color=#f8f8f2>incr</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>prevBin</color> <color=#f92672>=</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>curBin</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

            <color=#75715e>/* Break is no more entries in parent. */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>forward</color> <color=#f92672>?</color> <color=#f8f8f2>parentIndex</color> <color=#f92672>>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f8f8f2>:</color> <color=#f8f8f2>parentIndex</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
              <color=#66d9ef>break</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Latch next child BIN, if cached and unlatched.</color>
<color=#75715e>             *</color>
<color=#75715e>             * Note that although 2 BINs are latched here, this</color>
<color=#75715e>             * can't cause deadlocks because the 2nd latch is</color>
<color=#75715e>             * no-wait.</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>curBin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>parentIndex</color><color=#f8f8f2>);</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>curBin</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoWait</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
              <color=#66d9ef>break</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>

            <color=#75715e>/* Unlatch the prev BIN */</color>
            <color=#f8f8f2>prevBin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>prevBin</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

            <color=#75715e>/* Position at new BIN to prevent compression. */</color>
            <color=#f8f8f2>setPosition</color><color=#f8f8f2>(</color><color=#f8f8f2>curBin</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>

            <color=#75715e>/* Skip entries in new child BIN. */</color>
            <color=#f8f8f2>count</color> <color=#f92672>=</color>
                <color=#f8f8f2>skipEntries</color><color=#f8f8f2>(</color>
                    <color=#f8f8f2>forward</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>maxCount</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>rangeConstraint</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>finalPositionCursor</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>curBin</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>forward</color> <color=#f92672>?</color> <color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>(),</color>
                    <color=#f8f8f2>count</color><color=#f8f8f2>);</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>count</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
              <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
              <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
              <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f92672>-</color><color=#f8f8f2>count</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* No more entries in the parent. */</color>
          <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>prevBin</color> <color=#f92672>=</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Only the prevBin is still latched here. Move to the next</color>
<color=#75715e>         * BIN the "hard" way (i.e., via full tree searches).</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>curBin</color> <color=#f92672>=</color>
            <color=#f8f8f2>forward</color>
                <color=#f92672>?</color> <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>getNextBin</color><color=#f8f8f2>(</color><color=#f8f8f2>prevBin</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>:</color> <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>getPrevBin</color><color=#f8f8f2>(</color><color=#f8f8f2>prevBin</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>prevBin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>());</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>curBin</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>count</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>prevBin</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>curIndex</color> <color=#f92672>=</color> <color=#f8f8f2>forward</color> <color=#f92672>?</color> <color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color>

        <color=#75715e>/* Position at new BIN to prevent compression. */</color>
        <color=#f8f8f2>setPosition</color><color=#f8f8f2>(</color><color=#f8f8f2>curBin</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>curBin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatchIfOwner</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevBin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>prevBin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatchIfOwner</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatchIfOwner</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>TRACK_LATCHES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LatchSupport</color><color=#f8f8f2>.</color><color=#a6e22e>expectBtreeLatchesHeld</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Skip entries in curBin from one past curIndex and onward. Returns non-negative count if</color>
<color=#75715e>   * skipping should continue, or negative count if bounds is exceeded.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>skipEntries</color><color=#f8f8f2>(</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>maxCount</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RangeConstraint</color> <color=#f8f8f2>rangeConstraint</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>finalPositionCursor</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>BIN</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>curIndex</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>count</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>());</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>incr</color> <color=#f92672>=</color> <color=#f8f8f2>forward</color> <color=#f92672>?</color> <color=#ae81ff>1</color> <color=#f8f8f2>:</color> <color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>curIndex</color> <color=#f92672>+</color> <color=#f8f8f2>incr</color><color=#f8f8f2>;</color> <color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#f8f8f2>incr</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color> <color=#f92672>?</color> <color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672>>=</color> <color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>())</color> <color=#f8f8f2>:</color> <color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rangeConstraint</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>rangeConstraint</color><color=#f8f8f2>.</color><color=#a6e22e>inBounds</color><color=#f8f8f2>(</color><color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f92672>-</color><color=#f8f8f2>count</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>curBin</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>count</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>finalPositionCursor</color><color=#f8f8f2>.</color><color=#a6e22e>setPosition</color><color=#f8f8f2>(</color><color=#f8f8f2>curBin</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>maxCount</color> <color=#f92672>></color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>count</color> <color=#f92672>>=</color> <color=#f8f8f2>maxCount</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f92672>-</color><color=#f8f8f2>count</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>count</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the stack of ancestor TrackingInfo for the BIN at the cursor, or null if a split occurs</color>
<color=#75715e>   * and the information returned would be inconsistent.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Used by CountEstimator.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>TrackingInfo</color><color=#f92672>></color> <color=#a6e22e>getAncestorPath</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Search for parent of BIN, get TrackingInfo for ancestors.  If the</color>
<color=#75715e>     * exact parent is not found, a split occurred and null is returned.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>TrackingInfo</color><color=#f92672>></color> <color=#f8f8f2>trackingList</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ArrayList</color><color=#f92672><></color><color=#f8f8f2>();</color>

    <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>origBin</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Tree</color> <color=#f8f8f2>tree</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>SearchResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color>
        <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>getParentINForChildIN</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>origBin</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#75715e>/*useTargetLevel*/</color> <color=#66d9ef>true</color> <color=#75715e>/*doFetch*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>,</color> <color=#f8f8f2>trackingList</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>exactParentFound</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Must have been a split. */</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The parent was found and is now latched. If the child BIN does not</color>
<color=#75715e>     * match the cursor's BIN, then a split occurred and null is returned.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>binLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>origBin</color> <color=#f92672>!=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>origBin</color> <color=#f92672>!=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Must have been a split. */</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>binLsn</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The child BIN is now latched. Subtract defunct entries from BIN's</color>
<color=#75715e>     * total entries and adjust the index accordingly.  Add TrackingInfo</color>
<color=#75715e>     * for child BIN.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>binEntries</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>binIndex</color> <color=#f92672>=</color> <color=#f8f8f2>getIndex</color><color=#f8f8f2>();</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>-=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>binEntries</color> <color=#f92672>-=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>binIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>binIndex</color> <color=#f92672>-=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>TrackingInfo</color> <color=#f8f8f2>info</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TrackingInfo</color><color=#f8f8f2>(</color><color=#f8f8f2>binLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>binEntries</color><color=#f8f8f2>,</color> <color=#f8f8f2>binIndex</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>trackingList</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>info</color><color=#f8f8f2>);</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>trackingList</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Search for the next key following the given key, and acquire a range insert lock on it. If</color>
<color=#75715e>   * there are no more records following the given key, lock the special EOF node for the dbImpl.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>lockNextKeyForInsert</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>tempKey</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>(),</color> <color=#f8f8f2>key</color><color=#f8f8f2>.</color><color=#a6e22e>getOffset</color><color=#f8f8f2>(),</color> <color=#f8f8f2>key</color><color=#f8f8f2>.</color><color=#a6e22e>getSize</color><color=#f8f8f2>());</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>lockedNextKey</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>latched</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>searchResult</color> <color=#f92672>=</color> <color=#f8f8f2>searchRange</color><color=#f8f8f2>(</color><color=#f8f8f2>tempKey</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*comparator*/</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>searchResult</color> <color=#f92672>&</color> <color=#f8f8f2>FOUND</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchResult</color> <color=#f92672>&</color> <color=#f8f8f2>FOUND_LAST</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * The search positioned "this" on the BIN that should</color>
<color=#75715e>           * contain K1 and this BIN is now latched. If the BIN does</color>
<color=#75715e>           * contain K1, this.index points to K1's slot. Otherwise,</color>
<color=#75715e>           * this.index points to the right-most slot whose key is</color>
<color=#75715e>           * < K1 (or this.index is -1 if K1 is < than all keys in</color>
<color=#75715e>           * the BIN). Furthermore, "this" is NOT positioned on the</color>
<color=#75715e>           * very last slot of the BTree.</color>
<color=#75715e>           *</color>
<color=#75715e>           * Call getNext() to advance "this" to the next *valid*</color>
<color=#75715e>           * (i.e., not defunct) slot and lock that slot in</color>
<color=#75715e>           * RANGE_INSERT mode. Normally, getNext() will move the</color>
<color=#75715e>           * cursor to the 1st slot with a key K2 > K1. However, it</color>
<color=#75715e>           * is possible that K2 <= K1 (see the comments in</color>
<color=#75715e>           * Cursor.searchRangeAdvanceAndCheckKey() about how this</color>
<color=#75715e>           * can happen. We handle this race condition by restarting</color>
<color=#75715e>           * the search.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>tempData</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>tempData</color><color=#f8f8f2>.</color><color=#a6e22e>setPartial</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>OperationResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color>
              <color=#f8f8f2>getNext</color><color=#f8f8f2>(</color>
                  <color=#f8f8f2>tempKey</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>tempData</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>RANGE_INSERT</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>false</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>true</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>true</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>null</color> <color=#75715e>/*rangeConstraint*/</color><color=#f8f8f2>);</color>

          <color=#f8f8f2>latched</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>Comparator</color><color=#f92672><</color><color=#66d9ef>byte</color><color=#f92672>[]></color> <color=#f8f8f2>comparator</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getKeyComparator</color><color=#f8f8f2>();</color>

            <color=#66d9ef>int</color> <color=#f8f8f2>c</color> <color=#f92672>=</color> <color=#f8f8f2>Key</color><color=#f8f8f2>.</color><color=#a6e22e>compareKeys</color><color=#f8f8f2>(</color><color=#f8f8f2>tempKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>comparator</color><color=#f8f8f2>);</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>c</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>tempKey</color><color=#f8f8f2>.</color><color=#a6e22e>setData</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>(),</color> <color=#f8f8f2>key</color><color=#f8f8f2>.</color><color=#a6e22e>getOffset</color><color=#f8f8f2>(),</color> <color=#f8f8f2>key</color><color=#f8f8f2>.</color><color=#a6e22e>getSize</color><color=#f8f8f2>());</color>
              <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>

            <color=#f8f8f2>lockedNextKey</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>latched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Lock the EOF node if no next key was found. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>lockedNextKey</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lockEof</color><color=#f8f8f2>(</color><color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>RANGE_INSERT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Locking</color>
<color=#75715e>   */</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Holds the result of a lockLN operation. A lock may not actually be held (getLockResult may</color>
<color=#75715e>   * return null) if an uncontended lock is allowed.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>LockStanding</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>defunct</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#f8f8f2>LockResult</color> <color=#f8f8f2>lockResult</color><color=#f8f8f2>;</color>

    <color=#75715e>/** Returns true if the record is not deleted or expired. */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>recordExists</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f92672>!</color><color=#f8f8f2>defunct</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Called by update and delete ops, after lockLN() and before logging the LN and updating the</color>
<color=#75715e>     * BIN. It returns a WriteLockInfo that is meant to be passed to the LN logging method, where</color>
<color=#75715e>     * its info will be included in the LN log entry and also copied into the new WriteLockInfo that</color>
<color=#75715e>     * will be created for the new LSN.</color>
<color=#75715e>     *</color>
<color=#75715e>     * <p>If the locker is not transactional, or the current LSN has not been write-locked before by</color>
<color=#75715e>     * this locker, a new WriteLockInfo is created here and its abortLsn and abortKD fields are set.</color>
<color=#75715e>     * (note: even though lockLN() is called before prepareForUpdate(), it may not actually acquire</color>
<color=#75715e>     * a lock because of the uncontended optimization).</color>
<color=#75715e>     *</color>
<color=#75715e>     * <p>Otherwise, a WriteLockInfo exists already. It may have been created by the lockLN() call</color>
<color=#75715e>     * during the current updating op, or a lockLN() call during an earlier updating op by the same</color>
<color=#75715e>     * txn. In the later case, the abortLsn and abortKD have been set already and should not be</color>
<color=#75715e>     * overwriten here.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#f8f8f2>WriteLockInfo</color> <color=#a6e22e>prepareForUpdate</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>();</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>abortKD</color> <color=#f92672>=</color> <color=#f92672>!</color><color=#f8f8f2>recordExists</color><color=#f8f8f2>();</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>abortKey</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>abortData</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>abortVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>();</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>abortExpiration</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>abortExpirationInHours</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>abortData</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>abortVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*allowFetch*/</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*cacheMode*/</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>allowsKeyUpdates</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>abortKey</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>WriteLockInfo</color> <color=#f8f8f2>wri</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockResult</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>?</color> <color=#66d9ef>null</color> <color=#f8f8f2>:</color> <color=#f8f8f2>lockResult</color><color=#f8f8f2>.</color><color=#a6e22e>getWriteLockInfo</color><color=#f8f8f2>());</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>wri</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>wri</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>WriteLockInfo</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>wri</color><color=#f8f8f2>.</color><color=#a6e22e>setAbortLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>wri</color><color=#f8f8f2>.</color><color=#a6e22e>setAbortKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>abortKD</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>wri</color><color=#f8f8f2>.</color><color=#a6e22e>setAbortKey</color><color=#f8f8f2>(</color><color=#f8f8f2>abortKey</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>wri</color><color=#f8f8f2>.</color><color=#a6e22e>setAbortData</color><color=#f8f8f2>(</color><color=#f8f8f2>abortData</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>wri</color><color=#f8f8f2>.</color><color=#a6e22e>setAbortVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>abortVLSN</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>wri</color><color=#f8f8f2>.</color><color=#a6e22e>setAbortExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>abortExpiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>abortExpirationInHours</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>wri</color><color=#f8f8f2>.</color><color=#a6e22e>setDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>lockResult</color><color=#f8f8f2>.</color><color=#a6e22e>setAbortInfo</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>abortKD</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>abortKey</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>abortData</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>abortVLSN</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>abortExpiration</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>abortExpirationInHours</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>db</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>wri</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates WriteLockInfo that is appropriate for a newly inserted slot. The return value is</color>
<color=#75715e>     * meant to be passed to an LN logging method and copied into the WriteLockInfo for the new LSN.</color>
<color=#75715e>     * This method is static because lockLN is never called prior to logging an LN for a newly</color>
<color=#75715e>     * inserted slot.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>WriteLockInfo</color> <color=#a6e22e>prepareForInsert</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>WriteLockInfo</color> <color=#f8f8f2>wri</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>WriteLockInfo</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>wri</color><color=#f8f8f2>.</color><color=#a6e22e>setDb</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>());</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>wri</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Does not allow uncontended locks. See lockLN(LockType, boolean). */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>LockStanding</color> <color=#a6e22e>lockLN</color><color=#f8f8f2>(</color><color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>LockConflictException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>lockLN</color><color=#f8f8f2>(</color><color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*allowUncontended*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*noWait*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Locks the LN at the cursor position. Attempts to use a non-blocking lock to avoid</color>
<color=#75715e>   * unlatching/relatching.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Retries if necessary, to handle the case where the LSN is changed while the BIN is</color>
<color=#75715e>   * unlatched. Because it re-latches the BIN to check the LSN, this serializes access to the LSN</color>
<color=#75715e>   * for locking, guaranteeing that two lockers cannot obtain conflicting locks on the old and new</color>
<color=#75715e>   * LSNs.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Preconditions: The BIN must be latched.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Postconditions: The BIN is latched.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>LN Locking Rules ---------------- The lock ID for an LN is its LSN in the parent BIN slot.</color>
<color=#75715e>   * Because the LSN changes when logging the LN, only two methods of locking an LN may be used to</color>
<color=#75715e>   * support concurrent access:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>1. This method may be called to lock the old LSN. For read operations, that is all that is</color>
<color=#75715e>   * necessary. For write operations, the new LSN must be locked after logging it, which is done by</color>
<color=#75715e>   * all the LN logging methods. Be sure to pass a non-null locker to the LN logging method to lock</color>
<color=#75715e>   * the LN, unless locking is not desired.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>2. A non-blocking lock may be obtained on the old LSN (using Locker.nonBlockingLock rather</color>
<color=#75715e>   * than this method), as long as the lock is released before the BIN latch is released. In this</color>
<color=#75715e>   * case a null locker is passed to the LN logging method; locking the new LSN is unnecessary</color>
<color=#75715e>   * because no other thread can access the new LSN until the BIN latch is released.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The first method is used for all user operations. The second method is used by the cleaner,</color>
<color=#75715e>   * when flushing dirty deferred-write LNs, and by certain btree operations.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Uncontended Lock Optimization ----------------------------- The allowUncontended param is</color>
<color=#75715e>   * passed as true for update and delete operations as an optimization for the case where no lock</color>
<color=#75715e>   * on the old LSN is held by any locker. In this case we don't need to lock the old LSN at all, as</color>
<color=#75715e>   * long as we log the new LSN before releasing the BIN latch.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>1. Latch BIN 2. Determine that no lock/waiter exists for oldLsn 3. Log LN and get lsn 4.</color>
<color=#75715e>   * Lock lsn 5. Update BIN 6. Release BIN latch</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The oldLsn is never locked, saving operations on the lock table. The assumption is that</color>
<color=#75715e>   * another locker will first have to latch the BIN to get oldLsn, before requesting a lock.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>A potential problem is that the other locker may release the BIN latch before requesting the</color>
<color=#75715e>   * lock.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This Operation Another Operation -------------- ----------------- Latch BIN, get oldLsn,</color>
<color=#75715e>   * release BIN latch Step 1 and 2 Request lock for oldLsn, granted Step 3 and 4</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Both operations now believe they have an exclusive lock, but they have locks on different</color>
<color=#75715e>   * LSNs.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>However, this problem is handled as long as the other lock is performed using a lockLN</color>
<color=#75715e>   * method in this class, which will release the lock and retry if the LSN changes while acquiring</color>
<color=#75715e>   * the lock. Because it re-latches the BIN to check the LSN, this will serialize access to the LSN</color>
<color=#75715e>   * for locking, guaranteeing that two conflicting locks cannot be granted on the old and new LSNs.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Deferred-Write Locking ---------------------- When one of the LN optionalLog methods is</color>
<color=#75715e>   * called, a deferred-write LN is dirtied but not actually logged. In order to lock an LN that has</color>
<color=#75715e>   * been inserted but not yet assigned a true LSN, a transient LSNs is assigned. These LSNs serve</color>
<color=#75715e>   * to lock the LN but never appear in the log. See LN.assignTransientLsn.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>A deferred-write LN is logged when its parent BIN is logged, or when the LN is evicted. This</color>
<color=#75715e>   * will replace transient LSNs with durable LSNs. If a lock is held by a cursor on a</color>
<color=#75715e>   * deferred-write LN when it is logged, the same lock is acquired on the new LSN by the cursor.</color>
<color=#75715e>   * See lockAfterLsnChange.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Cleaner Migration Locking ------------------------- The cleaner takes a non-blocking read</color>
<color=#75715e>   * lock on the old LSN before migrating/logging the LN, while holding the BIN latch. It does not</color>
<color=#75715e>   * take a lock on the new LSN, since it does not need to retain a lock after releasing the BIN</color>
<color=#75715e>   * latch.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Because a read, not write, lock is taken, other read locks may be held during migration.</color>
<color=#75715e>   * After logging, the cleaner calls lockAfterLsnChange to lock the new LSN on behalf of other</color>
<color=#75715e>   * lockers.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>For more info on migration locking, see HandleLocker.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Expired Record Locking ---------------------- To support repeatable-read semantics when a</color>
<color=#75715e>   * record expires after being locked, we must check whether a record was previously locked before</color>
<color=#75715e>   * attempting to lock it. If it was previously locked, then it is treated as not expired, even if</color>
<color=#75715e>   * its expiration time has passed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>By was previously "locked" here we mean that any lock type is held, or shared with its</color>
<color=#75715e>   * owner, by this cursor's locker. Since a read lock will prevent modification of the expiration</color>
<color=#75715e>   * time, any lock type is adequate. A shared lock is considered adequate to account for the case</color>
<color=#75715e>   * where multiple lockers are used internally for a single virtual locker, as seen by the user.</color>
<color=#75715e>   * This is the case when using a read-committed locker or a thread-locker, for example.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>To avoid unnecessary added overhead, we do not check whether a record was previously locked</color>
<color=#75715e>   * except when expiration is imminent, which is defined as expiring within {@link</color>
<color=#75715e>   * EnvironmentParams#ENV_TTL_MAX_TXN_TIME}. The ENV_TTL_MAX_TXN_TIME buffer is used because the</color>
<color=#75715e>   * expiration time may pass while waiting for a lock.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Another case to account for is when the expiration time of the record changes while waiting</color>
<color=#75715e>   * for the lock. This can happen if the record is updated or an update is aborted. In this case we</color>
<color=#75715e>   * can assume that the was not previously locked, since that would have prevented the update.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Note that when an uncontended lock applies, the expiration of the record with the current</color>
<color=#75715e>   * LSN cannot change. It is possible that the update or deletion requesting the uncontended lock</color>
<color=#75715e>   * will be aborted, and the LSN of an expired record will be reinstated in the BIN, but this does</color>
<color=#75715e>   * not create a special case.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Historical Notes ---------------- In JE 4.1 and earlier, each LN had a node ID that was used</color>
<color=#75715e>   * for locking, rather than using the LSN. The node ID changed only if a deleted slot was reused.</color>
<color=#75715e>   * The node ID was stored in the LN, requiring that the LN be fetched when locking the LN. With</color>
<color=#75715e>   * LSN locking a fetch is not needed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>When LN node IDs were used, deferred-write LNs were not assigned an LSN until they were</color>
<color=#75715e>   * actually logged. Deferred-write LNs were initially assigned a null LSN and transient LSNs were</color>
<color=#75715e>   * not needed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param lockType the type of lock requested.</color>
<color=#75715e>   * @param allowUncontended is true to return immediately (no lock is taken) when no locker holds</color>
<color=#75715e>   *     or waits for the lock.</color>
<color=#75715e>   * @param noWait is true to perform a no-wait lock request while keeping the BIN latched. The</color>
<color=#75715e>   *     caller must check the lock result to see whether the lock was granted.</color>
<color=#75715e>   * @return all information about the lock; see LockStanding.</color>
<color=#75715e>   * @throws LockConflictException if the lsn is non-null, the lock is contended, and a lock could</color>
<color=#75715e>   *     not be obtained by blocking.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>LockStanding</color> <color=#a6e22e>lockLN</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>allowUncontended</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>noWait</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>LockConflictException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LockManager</color> <color=#f8f8f2>lockManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLockManager</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LockStanding</color> <color=#f8f8f2>standing</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LockStanding</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Check for a known-deleted null LSN. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>defunct</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>standing</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We can avoid taking a lock if uncontended.  However, we must</color>
<color=#75715e>     * call preLogWithoutLock to prevent logging on a replica, and as</color>
<color=#75715e>     * good measure to prepare for undo.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>allowUncontended</color> <color=#f92672>&&</color> <color=#f8f8f2>lockManager</color><color=#f8f8f2>.</color><color=#a6e22e>isLockUncontended</color><color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>verifyPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>lockType</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>preLogWithoutLock</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>defunct</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>standing</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If wasLockedAndExpiresSoon is true, we will treat the record as not</color>
<color=#75715e>     * expired. If false, we will check for expiration after locking.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>wasLockedAndExpiresSoon</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>prevExpiration</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>prevExpirationInHours</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>expiresWithin</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>prevExpiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>prevExpirationInHours</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getTtlMaxTxnTime</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockManager</color><color=#f8f8f2>.</color><color=#a6e22e>ownsOrSharesLock</color><color=#f8f8f2>(</color><color=#f8f8f2>locker</color><color=#f8f8f2>,</color> <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>wasLockedAndExpiresSoon</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Try a non-blocking lock first, to avoid unlatching.  If the default</color>
<color=#75715e>     * is no-wait, use the standard lock method so</color>
<color=#75715e>     * LockNotAvailableException is thrown; there is no need to try a</color>
<color=#75715e>     * non-blocking lock twice.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Even for dirty-read (LockType.NONE) we must call Locker.lock() since</color>
<color=#75715e>     * it checks the locker state and may throw LockPreemptedException.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>getDefaultNoWait</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lockResult</color> <color=#f92672>=</color> <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>lock</color><color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*noWait*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>LockNotAvailableException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>LockConflictException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedException</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lockResult</color> <color=#f92672>=</color>
          <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>nonBlockingLock</color><color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*jumpAheadOfWaiters*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lockResult</color><color=#f8f8f2>.</color><color=#a6e22e>getLockGrant</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>LockGrantType</color><color=#f8f8f2>.</color><color=#a6e22e>DENIED</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/* Lock was granted whiled latched, no need to check LSN. */</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>verifyPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>lockType</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>defunct</color> <color=#f92672>=</color> <color=#f8f8f2>wasLockedAndExpiresSoon</color> <color=#f92672>?</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>standing</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>noWait</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* We did not acquire the lock. */</color>

      <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>defunct</color> <color=#f92672>=</color> <color=#f8f8f2>wasLockedAndExpiresSoon</color> <color=#f92672>?</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>standing</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Unlatch, get a blocking lock, latch, and get the current LSN from</color>
<color=#75715e>     * the slot.  If the LSN changes while unlatched, revert the lock and</color>
<color=#75715e>     * repeat.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/* Request a blocking lock. */</color>
      <color=#f8f8f2>releaseBIN</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lockResult</color> <color=#f92672>=</color> <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>lock</color><color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*noWait*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>latchBIN</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Check current LSN after locking. */</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newLsn</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color> <color=#f92672>==</color> <color=#f8f8f2>newLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If the expiration time changes while unlatched, then it</color>
<color=#75715e>         * could not have been previously locked.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevExpiration</color> <color=#f92672>!=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color>
            <color=#f92672>||</color> <color=#f8f8f2>prevExpirationInHours</color> <color=#f92672>!=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>wasLockedAndExpiresSoon</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>defunct</color> <color=#f92672>=</color> <color=#f8f8f2>wasLockedAndExpiresSoon</color> <color=#f92672>?</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>verifyPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>lockType</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>standing</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* The LSN changed, revert the lock and try again. */</color>
      <color=#f8f8f2>revertLock</color><color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>newLsn</color><color=#f8f8f2>;</color>

      <color=#75715e>/* Check for a known-deleted null LSN. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>defunct</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>standing</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * After logging a deferred-write LN during eviction/checkpoint or a migrated LN during cleaning,</color>
<color=#75715e>   * for every existing lock on the old LSN held by another locker, we must lock the new LSN on</color>
<color=#75715e>   * behalf of that locker.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This is done while holding the BIN latch so that the new LSN does not change during the</color>
<color=#75715e>   * locking process. The BIN must be latched on entry and is left latched by this method.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>We release the lock on the oldLsn to prevent locks from accumulating over time on a</color>
<color=#75715e>   * HandleLocker, as the cleaner migrates LNs, because Database handle locks are legitimately very</color>
<color=#75715e>   * long-lived. It is important to first acquire all lsn locks and then release the oldLsn locks.</color>
<color=#75715e>   * Releasing an oldLsn lock might allow another locker to acquire it, and then acquiring another</color>
<color=#75715e>   * lsn lock may encounter a conflict. [#20617]</color>
<color=#75715e>   *</color>
<color=#75715e>   * @see com.sleepycat.je.txn.HandleLocker</color>
<color=#75715e>   * @see #lockLN</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>lockAfterLsnChange</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>oldLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>newLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>Locker</color> <color=#f8f8f2>excludeLocker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LockManager</color> <color=#f8f8f2>lockManager</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getTxnManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLockManager</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>LockInfo</color><color=#f92672>></color> <color=#f8f8f2>owners</color> <color=#f92672>=</color> <color=#f8f8f2>lockManager</color><color=#f8f8f2>.</color><color=#a6e22e>getOwners</color><color=#f8f8f2>(</color><color=#f8f8f2>oldLsn</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>owners</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#75715e>/* Acquire lsn locks. */</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>LockInfo</color> <color=#f8f8f2>lockInfo</color> <color=#f8f8f2>:</color> <color=#f8f8f2>owners</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#f8f8f2>lockInfo</color><color=#f8f8f2>.</color><color=#a6e22e>getLocker</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>locker</color> <color=#f92672>!=</color> <color=#f8f8f2>excludeLocker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>lockAfterLsnChange</color><color=#f8f8f2>(</color><color=#f8f8f2>oldLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>newLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#75715e>/* Release oldLsn locks. */</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>LockInfo</color> <color=#f8f8f2>lockInfo</color> <color=#f8f8f2>:</color> <color=#f8f8f2>owners</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#f8f8f2>lockInfo</color><color=#f8f8f2>.</color><color=#a6e22e>getLocker</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>locker</color> <color=#f92672>!=</color> <color=#f8f8f2>excludeLocker</color> <color=#f92672>&&</color> <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>allowReleaseLockAfterLsnChange</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLock</color><color=#f8f8f2>(</color><color=#f8f8f2>oldLsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** For debugging. Verify that a BINs cursor set refers to the BIN. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>verifyCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getCursorSet</color><color=#f8f8f2>().</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>UNEXPECTED_STATE</color><color=#f8f8f2>,</color>
          <color=#e6db74>"BIN cursorSet is inconsistent"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Calls checkCursorState and asserts false if an exception is thrown. Otherwise returns true, so</color>
<color=#75715e>   * it can be called under an assertion.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>assertCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>mustBeInitialized</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>mustNotBeInitialized</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>checkCursorState</color><color=#f8f8f2>(</color><color=#f8f8f2>mustBeInitialized</color><color=#f8f8f2>,</color> <color=#f8f8f2>mustNotBeInitialized</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>RuntimeException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#66d9ef>false</color> <color=#f8f8f2>:</color> <color=#f8f8f2>e</color> <color=#f92672>+</color> <color=#e6db74>" "</color> <color=#f92672>+</color> <color=#f8f8f2>dumpToString</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color> <color=#75715e>// for compiler</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Check that the cursor is open and optionally if it is initialized or uninitialized.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws IllegalStateException via all Cursor methods that call Cursor.checkState (all get and</color>
<color=#75715e>   *     put methods, plus more).</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>checkCursorState</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>mustBeInitialized</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>mustNotBeInitialized</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>CURSOR_NOT_INITIALIZED</color><color=#f8f8f2>:</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mustBeInitialized</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalStateException</color><color=#f8f8f2>(</color><color=#e6db74>"Cursor not initialized."</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>CURSOR_INITIALIZED</color><color=#f8f8f2>:</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mustNotBeInitialized</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"Cursor is initialized."</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>verifyCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>CURSOR_CLOSED</color><color=#f8f8f2>:</color>
        <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalStateException</color><color=#f8f8f2>(</color><color=#e6db74>"Cursor has been closed."</color><color=#f8f8f2>);</color>
      <color=#66d9ef>default</color><color=#f8f8f2>:</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"Unknown cursor status: "</color> <color=#f92672>+</color> <color=#f8f8f2>status</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Checks that LN deletedness matches KD/PD flag state, at least when the LN is resident. Should</color>
<color=#75715e>   * only be called under an assertion.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>verifyPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Cannot verify deletedness if LN is not locked. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockType</color> <color=#f92672>==</color> <color=#f8f8f2>LockType</color><color=#f8f8f2>.</color><color=#a6e22e>NONE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Cannot verify deletedness if cursor is not intialized. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>index</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Cannot verify deletedness if LN is not resident. */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the LN is deleted then KD or PD must be set.  If the LN is not</color>
<color=#75715e>     * deleted then PD must not be set, but KD may or may not be set since</color>
<color=#75715e>     * it used for various purposes (see IN.java).</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>kd</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pd</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEntryPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>lnDeleted</color> <color=#f92672>=</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>((</color><color=#f8f8f2>lnDeleted</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>kd</color> <color=#f92672>||</color> <color=#f8f8f2>pd</color><color=#f8f8f2>))</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>lnDeleted</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>pd</color><color=#f8f8f2>))</color>
        <color=#f8f8f2>:</color> <color=#e6db74>"Deleted state mismatch LNDeleted = "</color> <color=#f92672>+</color> <color=#f8f8f2>lnDeleted</color> <color=#f92672>+</color> <color=#e6db74>" PD = "</color> <color=#f92672>+</color> <color=#f8f8f2>pd</color> <color=#f92672>+</color> <color=#e6db74>" KD = "</color> <color=#f92672>+</color> <color=#f8f8f2>kd</color><color=#f8f8f2>;</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>revertLock</color><color=#f8f8f2>(</color><color=#f8f8f2>LockStanding</color> <color=#f8f8f2>standing</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lockResult</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>revertLock</color><color=#f8f8f2>(</color><color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lockResult</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>standing</color><color=#f8f8f2>.</color><color=#a6e22e>lockResult</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return this lock to its prior status. If the lock was just obtained, release it. If it was</color>
<color=#75715e>   * promoted, demote it.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>revertLock</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockResult</color> <color=#f8f8f2>lockResult</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>LockGrantType</color> <color=#f8f8f2>lockStatus</color> <color=#f92672>=</color> <color=#f8f8f2>lockResult</color><color=#f8f8f2>.</color><color=#a6e22e>getLockGrant</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>lockStatus</color> <color=#f92672>==</color> <color=#f8f8f2>LockGrantType</color><color=#f8f8f2>.</color><color=#a6e22e>NEW</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockStatus</color> <color=#f92672>==</color> <color=#f8f8f2>LockGrantType</color><color=#f8f8f2>.</color><color=#a6e22e>WAIT_NEW</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLock</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>lockStatus</color> <color=#f92672>==</color> <color=#f8f8f2>LockGrantType</color><color=#f8f8f2>.</color><color=#a6e22e>PROMOTION</color><color=#f8f8f2>)</color>
        <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>lockStatus</color> <color=#f92672>==</color> <color=#f8f8f2>LockGrantType</color><color=#f8f8f2>.</color><color=#a6e22e>WAIT_PROMOTION</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>demoteLock</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Locks the logical EOF node for the dbImpl. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>lockEof</color><color=#f8f8f2>(</color><color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>lock</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEofLsn</color><color=#f8f8f2>(),</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*noWait*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @throws EnvironmentFailureException if the underlying environment is invalid. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>checkEnv</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>checkIfInvalid</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Callback object for traverseDbWithCursor. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>interface</color> <color=#a6e22e>WithCursor</color> <color=#f8f8f2>{</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Called for each record in the dbImpl.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return true to continue or false to stop the enumeration.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>boolean</color> <color=#a6e22e>withCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Enumerates all records in a dbImpl non-transactionally and calls the withCursor method for each</color>
<color=#75715e>   * record. Stops the enumeration if the callback returns false.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param db DatabaseImpl to traverse.</color>
<color=#75715e>   * @param lockType non-null LockType for reading records.</color>
<color=#75715e>   * @param allowEviction should normally be true to evict when performing multiple operations, but</color>
<color=#75715e>   *     may be false if eviction is disallowed in a particular context.</color>
<color=#75715e>   * @param withCursor callback object.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>traverseDbWithCursor</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockType</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>allowEviction</color><color=#f8f8f2>,</color> <color=#f8f8f2>WithCursor</color> <color=#f8f8f2>withCursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#f8f8f2>LockerFactory</color><color=#f8f8f2>.</color><color=#a6e22e>getInternalReadOperationLocker</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>CursorImpl</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>locker</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>setAllowEviction</color><color=#f8f8f2>(</color><color=#f8f8f2>allowEviction</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>positionFirstOrLast</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*first*/</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>OperationResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color>
            <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>lockAndGetCurrent</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*dirtyReadAll*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*isLatched*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*unlatch*/</color><color=#f8f8f2>);</color>

        <color=#66d9ef>boolean</color> <color=#f8f8f2>done</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>done</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * lockAndGetCurrent may have returned non-SUCCESS if the</color>
<color=#75715e>           * first record is defunct, but we can call getNext below</color>
<color=#75715e>           * to move forward.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>withCursor</color><color=#f8f8f2>.</color><color=#a6e22e>withCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>done</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>done</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color>
                <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>(</color>
                    <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>data</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>lockType</color><color=#f8f8f2>,</color>
                    <color=#66d9ef>false</color> <color=#75715e>/*dirtyReadAll*/</color><color=#f8f8f2>,</color>
                    <color=#66d9ef>true</color> <color=#75715e>/*forward*/</color><color=#f8f8f2>,</color>
                    <color=#66d9ef>false</color> <color=#75715e>/*isLatched*/</color><color=#f8f8f2>,</color>
                    <color=#66d9ef>null</color> <color=#75715e>/*rangeConstraint*/</color><color=#f8f8f2>);</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>done</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>releaseBIN</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>locker</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>operationEnd</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Dump the cursor for debugging purposes. Dump the bin that the cursor refers to if verbose is</color>
<color=#75715e>   * true.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>dump</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>verbose</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#f8f8f2>dumpToString</color><color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** dump the cursor for debugging purposes. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>dump</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#f8f8f2>dumpToString</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * dumper</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>String</color> <color=#a6e22e>statusToString</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color> <color=#f8f8f2>status</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>CURSOR_NOT_INITIALIZED</color><color=#f8f8f2>:</color>
        <color=#66d9ef>return</color> <color=#e6db74>"CURSOR_NOT_INITIALIZED"</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>CURSOR_INITIALIZED</color><color=#f8f8f2>:</color>
        <color=#66d9ef>return</color> <color=#e6db74>"CURSOR_INITIALIZED"</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>CURSOR_CLOSED</color><color=#f8f8f2>:</color>
        <color=#66d9ef>return</color> <color=#e6db74>"CURSOR_CLOSED"</color><color=#f8f8f2>;</color>
      <color=#66d9ef>default</color><color=#f8f8f2>:</color>
        <color=#66d9ef>return</color> <color=#e6db74>"UNKNOWN ("</color> <color=#f92672>+</color> <color=#f8f8f2>status</color> <color=#f92672>+</color> <color=#e6db74>")"</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * dumper</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>dumpToString</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>verbose</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"<Cursor idx=\""</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\""</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" status=\""</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>statusToString</color><color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>)).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\""</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>">\n"</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>((</color><color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#e6db74>""</color> <color=#f8f8f2>:</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>dumpString</color><color=#f8f8f2>(</color><color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\n</Cursor>"</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * For unit tests</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>StatGroup</color> <color=#a6e22e>getLockStats</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>collectStats</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Send trace messages to the java.util.logger. Don't rely on the logger alone to conditionalize</color>
<color=#75715e>   * whether we send this message, we don't even want to construct the message if the level is not</color>
<color=#75715e>   * enabled.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>trace</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Level</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>changeType</color><color=#f8f8f2>,</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>theBin</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>lnIndex</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>oldLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>newLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>().</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>changeType</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" bin="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>theBin</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" lnIdx="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>lnIndex</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" oldLnLsn="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>oldLsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" newLnLsn="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>newLsn</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>(),</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Send trace messages to the java.util.logger. Don't rely on the logger alone to conditionalize</color>
<color=#75715e>   * whether we send this message, we don't even want to construct the message if the level is not</color>
<color=#75715e>   * enabled.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>traceInsert</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>insertingBin</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lnLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>().</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>TRACE_INSERT</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" bin="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>insertingBin</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" lnLsn="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>lnLsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" index="</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>(),</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit testing only. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setTestHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>testHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* Check that the target bin is latched. For use in assertions. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>checkAlreadyLatched</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isLatched</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>