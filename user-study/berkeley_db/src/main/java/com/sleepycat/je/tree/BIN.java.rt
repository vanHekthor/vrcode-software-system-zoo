<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.tree</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.CacheMode</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentFailureException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.LocalUtilizationTracker</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.evictor.OffHeapCache</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogEntryType</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogItem</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.ReplicationContext</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.txn.LockManager</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.*</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.util.Arrays</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Collections</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Iterator</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Set</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * A BIN represents a Bottom Internal Node in the JE tree.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>BIN-deltas ========== A BIN-delta is a BIN with the non-dirty slots omitted. A "full BIN",</color>
<color=#75715e> * OTOH contains all slots. On disk and in memory, the format of a BIN-delta is the same as that of</color>
<color=#75715e> * a BIN. In memory, a BIN object is actually a BIN-delta when the BIN-delta flag is set</color>
<color=#75715e> * (IN.isBINDelta). On disk, the NewBINDelta log entry type (class BINDeltaLogEntry) is the only</color>
<color=#75715e> * thing that distinguishes it from a full BIN, which has the BIN log entry type.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>BIN-deltas provides two benefits: Reduced writing and reduced memory usage.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Reduced Writing --------------- Logging a BIN-delta rather a full BIN reduces writing</color>
<color=#75715e> * significantly. The cost, however, is that two reads are necessary to reconstruct a full BIN from</color>
<color=#75715e> * scratch. The reduced writing is worth this cost, particularly because less writing means less log</color>
<color=#75715e> * cleaning.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>A BIN-delta is logged when 25% or less (configured with EnvironmentConfig TREE_BIN_DELTA) of</color>
<color=#75715e> * the slots in a BIN are dirty. When a BIN-delta is logged, the dirty flag is cleared on the the</color>
<color=#75715e> * BIN in cache. If more slots are dirtied and another BIN-delta is logged, it will contain all</color>
<color=#75715e> * entries dirtied since the last full BIN was logged. In other words, BIN-deltas are cumulative and</color>
<color=#75715e> * not chained, to avoid reading many (more than two) log entries to reconstruct a full BIN. The</color>
<color=#75715e> * dirty flag on each slot is cleared only when a full BIN is logged.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>In addition to the cost of fetching two entries on a BIN cache miss, another drawback of the</color>
<color=#75715e> * current approach is that dirtiness propagates upward in the Btree due to BIN-delta logging,</color>
<color=#75715e> * causing repeated logging of upper INs. The slot of the parent IN contains the LSN of the most</color>
<color=#75715e> * recent BIN-delta or full BIN that was logged. A BINDeltaLogEntry in turn contains the LSN of the</color>
<color=#75715e> * last full BIN logged.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Historical note: The pre-JE 5 implementation of OldBINDeltas worked differently and had a</color>
<color=#75715e> * different cost/benefit trade-off. When an OldBINDelta was logged, its dirty flag was not cleared,</color>
<color=#75715e> * causing it to be logged repeatedly at every checkpoint. A full BIN was logged after 10 deltas, to</color>
<color=#75715e> * prevent endless logging of the same BIN. One benefit of this approach is that the BIN's parent IN</color>
<color=#75715e> * was not dirtied when logging the OldBINDelta, preventing dirtiness from propagating upward.</color>
<color=#75715e> * Another benefit is that the OldBINDelta was only processed by recovery, and did not have to be</color>
<color=#75715e> * fetched to reconstruct a full BIN from scratch on a cache miss. But the cost (the logging of an</color>
<color=#75715e> * OldBINDelta every checkpoint, even when it hadn't changed since the last time logged) outweighed</color>
<color=#75715e> * the benefits. When the current approach was implemented in JE 5, performance improved due to less</color>
<color=#75715e> * logging.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>In JE 6, deltas were also maintained in the Btree cache. This was done to provide the reduced</color>
<color=#75715e> * memory benefits described in the next section. The log format for a delta was also changed. The</color>
<color=#75715e> * OldBINDelta log format is different (not the same as the BIN format) and is supported for</color>
<color=#75715e> * backward compatibility as the OldBINDeltaLogEntry. Its log entry type name is still BINDelta,</color>
<color=#75715e> * which is why the new type is named NewBINDelta (for backward compatibility, log entry type names</color>
<color=#75715e> * cannot be changed.) This is also why the spelling "BIN-delta" is used to refer to deltas in the</color>
<color=#75715e> * new approach. The old BINDelta class was renamed to OldBINDelta and there is no longer a class</color>
<color=#75715e> * named BINDelta.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Reduced Memory Usage -------------------- In the Btree cache, a BIN may be represented as a</color>
<color=#75715e> * full BIN or a BIN-delta. Eviction will mutate a full BIN to a BIN-delta in preference to</color>
<color=#75715e> * discarding the entire BIN. A BIN-delta in cache occupies less memory than a full BIN, and can be</color>
<color=#75715e> * exploited as follows:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- When a full BIN is needed, it can be constructed with only one fetch rather than two,</color>
<color=#75715e> * reducing IO overall. IN.fetchIN implements this optimization.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Certain operations can sometimes be performed using the BIN-delta alone, allowing such</color>
<color=#75715e> * operations on a given data set to take place using less less IO (for a given cache size).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The latter benefit is not yet implemented. No user CRUD operations are currently implemented</color>
<color=#75715e> * using BIN-deltas. In the future we plan to implement the following operations using the BIN-delta</color>
<color=#75715e> * alone.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Consider recording deletions in a BIN-delta. Currently, slot deletion prohibits a BIN-delta</color>
<color=#75715e> * from being logged. To record deletion in BIN-deltas, slot deletion will have to be deferred until</color>
<color=#75715e> * a full BIN is logged.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- User reads by key, updates and deletions can be implemented if the key happens to appear in</color>
<color=#75715e> * the BIN-delta.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- The Cleaner can migrate an LN if its key happens to appear in the BIN-delta. This is similar</color>
<color=#75715e> * to a user update operation, but in a different code path.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Insertions, deletions and updates can always be performed in a BIN-delta during replica</color>
<color=#75715e> * replay, since the Master operation has already determined whether the key exists.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Recovery LN redo could also apply insertions, updates and inserts in the manner described.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Add idempotent put/delete operations, which can always be applied in a BIN-delta.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Store a hash of the keys in the full BIN in the BIN-delta and use it to perform the</color>
<color=#75715e> * following in the delta: - putIfAbsent (true insertion) - get/delete/putIfPresent operations that</color>
<color=#75715e> * return NOTFOUND - to avoid accumulating unnecessary deletions</color>
<color=#75715e> *</color>
<color=#75715e> * <p>However, some internal operations do currently exploit BIN-deltas to avoid unnecessary IO. The</color>
<color=#75715e> * following are currently implemented.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- The Evictor and Checkpointer log a BIN-delta that is present in the cache, without having to</color>
<color=#75715e> * fetch the full BIN.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- The Cleaner can use the BIN-delta to avoid fetching when processing a BIN log entry (delta</color>
<color=#75715e> * or full) and the BIN is not present in cache,</color>
<color=#75715e> *</color>
<color=#75715e> * <p>To support BIB-delta-aware operations, the IN.fetchIN() and IN.getTarget() methods may return</color>
<color=#75715e> * a BIN delta. IN.getTarget() will return whatever object is cached under the parent IN, and</color>
<color=#75715e> * IN.fetchIN() will do a single I/O to fetch the most recently log record for the requested BIN,</color>
<color=#75715e> * which may be a full BIN or a delta. Callers of these methods must be prepared to handle a BIN</color>
<color=#75715e> * delta; either doing their operation directly on the delta, if possible, or mutating the delta to</color>
<color=#75715e> * a full BIN by calling BIN.mutateToFullBIN().</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>BIN</color> <color=#66d9ef>extends</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>{</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>BEGIN_TAG</color> <color=#f92672>=</color> <color=#e6db74>"<bin>"</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>END_TAG</color> <color=#f92672>=</color> <color=#e6db74>"</bin>"</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Used as the "empty rep" for the INLongRep lastLoggedSizes field.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>minLength is 1 because log sizes are unpredictable.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>allowSparseRep is false because all slots have log sizes and less mutation is better.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>INLongRep</color><color=#f8f8f2>.</color><color=#a6e22e>EmptyRep</color> <color=#f8f8f2>EMPTY_LAST_LOGGED_SIZES</color> <color=#f92672>=</color>
      <color=#66d9ef>new</color> <color=#f8f8f2>INLongRep</color><color=#f8f8f2>.</color><color=#a6e22e>EmptyRep</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Used as the "empty rep" for the INLongRep vlsnCache field.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>minLength is 5 because VLSNS grow that large fairly quickly, and less mutation is better.</color>
<color=#75715e>   * The value 5 accomodates data set sizes up to 100 billion. If we want to improve memory</color>
<color=#75715e>   * utilization for smaller data sets or reduce mutation for larger data sets, we could dynamically</color>
<color=#75715e>   * determine a value based on the last assigned VLSN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>allowSparseRep is false because either all slots typically have VLSNs, or none do, and less</color>
<color=#75715e>   * mutation is better.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>INLongRep</color><color=#f8f8f2>.</color><color=#a6e22e>EmptyRep</color> <color=#f8f8f2>EMPTY_VLSNS</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>INLongRep</color><color=#f8f8f2>.</color><color=#a6e22e>EmptyRep</color><color=#f8f8f2>(</color><color=#ae81ff>5</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Used as the "empty rep" for the INLongRep offHeapLNIds field.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>minLength is 8 because memory IDs are 64-bit pointers.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>allowSparseRep is true because some workloads will only load LN IDs for a subset of the LNs</color>
<color=#75715e>   * in the BIN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>INLongRep</color><color=#f8f8f2>.</color><color=#a6e22e>EmptyRep</color> <color=#f8f8f2>EMPTY_OFFHEAP_LN_IDS</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>INLongRep</color><color=#f8f8f2>.</color><color=#a6e22e>EmptyRep</color><color=#f8f8f2>(</color><color=#ae81ff>8</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Used as the "empty rep" for the INLongRep expirationValues field.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>minLength is 1 because we expect most expiration values, which are an offset from a base</color>
<color=#75715e>   * day/hour, to fit in one byte.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>allowSparseRep is true because some workloads only set TTLs on some of the LNs in a BIN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>INLongRep</color><color=#f8f8f2>.</color><color=#a6e22e>EmptyRep</color> <color=#f8f8f2>EMPTY_EXPIRATION</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>INLongRep</color><color=#f8f8f2>.</color><color=#a6e22e>EmptyRep</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The set of cursors that are currently referring to this BIN.</color>
<color=#75715e>   * This field is set to null when there are no cursors on this BIN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TinyHashSet</color><color=#f92672><</color><color=#f8f8f2>CursorImpl</color><color=#f92672>></color> <color=#f8f8f2>cursorSet</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Support for logging BIN deltas. (Partial BIN logging)</color>
<color=#75715e>   */</color>

  <color=#75715e>/*</color>
<color=#75715e>   * If this is a delta, fullBinNEntries stores the number of entries</color>
<color=#75715e>   * in the full version of the BIN. This is a persistent field for</color>
<color=#75715e>   * BIN-delta logrecs only, and for log versions >= 10.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>fullBinNEntries</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * If this is a delta, fullBinMaxEntries stores the max number of</color>
<color=#75715e>   * entries (capacity) in the full version of the BIN. This is a</color>
<color=#75715e>   * persistent field for BIN-delta logrecs only, and for log versions >= 10.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>fullBinMaxEntries</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * If "this" is a BIN-delta, bloomFilter is a bloom-filter representation</color>
<color=#75715e>   * of the set of keys in the clean slots of the full version of the same</color>
<color=#75715e>   * BIN. It is used to allow blind put operations in deltas, by answering</color>
<color=#75715e>   * the question whether the put key is in the full BIN or not. See the</color>
<color=#75715e>   * javadoc of the  TREE_BIN_DELTA_BLIND_PUTS config param for more info.</color>
<color=#75715e>   * This is a persistent field for BIN-delta logrecs only, and for log</color>
<color=#75715e>   * versions >= 10.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>bloomFilter</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * See comment in IN.java, right after the lastFullVersion data field.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastDeltaVersion</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Caches the VLSN sequence for the LN entries in a BIN, when VLSN</color>
<color=#75715e>   * preservation and caching are configured.</color>
<color=#75715e>   *</color>
<color=#75715e>   * A VLSN is added to the cache when an LN is evicted from a BIN. When the</color>
<color=#75715e>   * LN is resident, there is no need for caching because the LN contains the</color>
<color=#75715e>   * VLSN. See BIN.setTarget.  This strategy works because an LN is always</color>
<color=#75715e>   * cached during a read or write operation, and only evicted after that,</color>
<color=#75715e>   * based on eviction policies.</color>
<color=#75715e>   *</color>
<color=#75715e>   * For embedded LNs a VLSN is added to the cache every time the record is</color>
<color=#75715e>   * logged. Furthermore, the vlsn cache is made persistent for such LNs.</color>
<color=#75715e>   *</color>
<color=#75715e>   * An EMPTY_REP is used initially until the need arises to add a non-zero</color>
<color=#75715e>   * value.  The cache will remain empty if LNs are never evicted or version</color>
<color=#75715e>   * caching is not configured, which is always the case for standalone JE.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>INLongRep</color> <color=#f8f8f2>vlsnCache</color> <color=#f92672>=</color> <color=#f8f8f2>EMPTY_VLSNS</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Stores the size of the most recently written logrec of each LN, or zero</color>
<color=#75715e>   * if the size is unknown.</color>
<color=#75715e>   *</color>
<color=#75715e>   * We use INLongRep in spite of the fact that sizes are int not long;</color>
<color=#75715e>   * INLongRep will store the minimum number of bytes. An EMPTY_REP is</color>
<color=#75715e>   * used initially until the need arises to add a non-zero value.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>INLongRep</color> <color=#f8f8f2>lastLoggedSizes</color> <color=#f92672>=</color> <color=#f8f8f2>EMPTY_LAST_LOGGED_SIZES</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * When some LNs are in the off-heap cache, the offHeapLruId is this BIN's index in the off-heap</color>
<color=#75715e>   * LRU list.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>INLongRep</color> <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>EMPTY_OFFHEAP_LN_IDS</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>offHeapLruId</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * An expirationValues slot value is one more than the number of days/hours to add to the</color>
<color=#75715e>   * expirationBase to get the true expiration days/hours. A slot value of zero means no expiration,</color>
<color=#75715e>   * and a non-zero slot value is one greater than the actual offset to be added. The base is the</color>
<color=#75715e>   * smallest non-zero offset that has been encountered.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>INLongRep</color> <color=#f8f8f2>expirationValues</color> <color=#f92672>=</color> <color=#f8f8f2>EMPTY_EXPIRATION</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>expirationBase</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

  <color=#75715e>/** Can be set to true by tests to prevent last logged sizes from being stored. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>TEST_NO_LAST_LOGGED_SIZES</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#66d9ef>public</color> <color=#a6e22e>BIN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{}</color>

  <color=#66d9ef>public</color> <color=#a6e22e>BIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>identifierKey</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>capacity</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>level</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>identifierKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>capacity</color><color=#f8f8f2>,</color> <color=#f8f8f2>level</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** For Sizeof. */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>BIN</color><color=#f8f8f2>(</color><color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"unused"</color><color=#f8f8f2>)</color> <color=#f8f8f2>SizeofMarker</color> <color=#f8f8f2>marker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>marker</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Create a new BIN. Need this because we can't call newInstance() without getting a 0 for nodeId.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>protected</color> <color=#f8f8f2>IN</color> <color=#a6e22e>createNewInstance</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>identifierKey</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxEntries</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>level</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BIN</color><color=#f8f8f2>(</color><color=#f8f8f2>getDatabase</color><color=#f8f8f2>(),</color> <color=#f8f8f2>identifierKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxEntries</color><color=#f8f8f2>,</color> <color=#f8f8f2>level</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>BINReference</color> <color=#a6e22e>createReference</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BINReference</color><color=#f8f8f2>(</color><color=#f8f8f2>getNodeId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>getId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>getIdentifierKey</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isBIN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Return whether the shared latch for this kind of node should be of the</color>
<color=#75715e>   * "always exclusive" variety.  Presently, only IN's are actually latched</color>
<color=#75715e>   * shared.  BINs are latched exclusive only.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>boolean</color> <color=#a6e22e>isAlwaysLatchedExclusively</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>shortClassName</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#e6db74>"BIN"</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>beginTag</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>BEGIN_TAG</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>endTag</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>END_TAG</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>boolean</color> <color=#a6e22e>isVLSNCachingEnabled</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getCacheVLSN</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setCachedVLSN</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We do not cache the VLSN for dup DBs, because dup DBs are typically</color>
<color=#75715e>     * used only for indexes, and the overhead of VLSN maintenance would be</color>
<color=#75715e>     * wasted.  Plus, although technically VLSN preservation might apply to</color>
<color=#75715e>     * dup DBs, the VLSNs are not reliably available since the LNs are</color>
<color=#75715e>     * immediately obsolete.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isVLSNCachingEnabled</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>setCachedVLSNUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>setCachedVLSNUnconditional</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>vlsnCache</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnCache</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color> <color=#f92672>==</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color> <color=#f92672>?</color> <color=#ae81ff>0</color> <color=#f8f8f2>:</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>),</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>long</color> <color=#a6e22e>getCachedVLSN</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>vlsn</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnCache</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color> <color=#f92672>==</color> <color=#ae81ff>0</color> <color=#f92672>?</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color> <color=#f8f8f2>:</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the VLSN. VLSN.NULL_VLSN_SEQUENCE (-1) is returned in two cases: 1) This is a</color>
<color=#75715e>   * standalone environment. 2) The VLSN is not cached (perhaps VLSN caching is not configured), and</color>
<color=#75715e>   * the allowFetch param is false.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>WARNING: Because the vlsnCache is only updated when an LN is evicted, it is critical that</color>
<color=#75715e>   * getVLSN returns the VLSN for a resident LN before getting the VLSN from the cache.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getVLSN</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>allowFetch</color><color=#f8f8f2>,</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Must return the VLSN from the LN, if it is resident. */</color>
    <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Next try the vlsnCache. */</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>vlsn</color> <color=#f92672>=</color> <color=#f8f8f2>getCachedVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Next try the off-heap cache. */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>OffHeapCache</color> <color=#f8f8f2>ohCache</color> <color=#f92672>=</color> <color=#f8f8f2>getOffHeapCache</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>isEnabled</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>vlsn</color> <color=#f92672>=</color> <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>loadVLSN</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>idx</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* As the last resort, fetch the LN if fetching is allowed. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>allowFetch</color> <color=#f92672>||</color> <color=#f8f8f2>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>fetchLN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** For unit testing. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>INLongRep</color> <color=#a6e22e>getVLSNCache</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>vlsnCache</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The last logged size is never needed when the LN is counted obsolete immediately, since it is</color>
<color=#75715e>   * only needed for counting an LN obsolete during an update or deletion.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method may not be called until after the database is initialized, i,e., it may not be</color>
<color=#75715e>   * called during readFromLog.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>boolean</color> <color=#a6e22e>isLastLoggedSizeStored</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>mayHaveLastLoggedSizeStored</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>boolean</color> <color=#a6e22e>mayHaveLastLoggedSizeStored</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Check final static first so all test code is optimized away. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseUtil</color><color=#f8f8f2>.</color><color=#a6e22e>TEST</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Don't skew test measurements with internal DBs. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>TEST_NO_LAST_LOGGED_SIZES</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbType</color><color=#f8f8f2>().</color><color=#a6e22e>isInternal</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f92672>!</color><color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isLNImmediatelyObsolete</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Sets last logged size if necessary.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method does not dirty the IN because the caller methods dirty it, for example, when</color>
<color=#75715e>   * setting the LSN, key, or node.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method is sometimes called to add the logged size for a pre log version 9 BIN, for</color>
<color=#75715e>   * example, during fetchTarget and preload. This makes the logged size available for obsolete</color>
<color=#75715e>   * counting but does not dirty the IN, since that could cause an unexpected write of the IN being</color>
<color=#75715e>   * read.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param lastLoggedSize is positive if the size is known, zero if the size is unknown, or -1 if</color>
<color=#75715e>   *     the size should not be changed because logging of the LN was deferred.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setLastLoggedSize</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>lastLoggedSize</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>isLastLoggedSizeStored</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>setLastLoggedSizeUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>clearLastLoggedSize</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>setLastLoggedSizeUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Sets the size without checking whether it is necessary.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method is used when reading from the log because the databaseImpl is not yet</color>
<color=#75715e>   * initialized and isLastLoggedSizeStored cannot be called. It is also called for efficiency</color>
<color=#75715e>   * reasons when it is known that storing the logged size is necessary, for example, when copying</color>
<color=#75715e>   * values between slots.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>void</color> <color=#a6e22e>setLastLoggedSizeUnconditional</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>lastLoggedSizes</color> <color=#f92672>=</color> <color=#f8f8f2>lastLoggedSizes</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return a positive value if the size is known, or zero if unknown. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isLastLoggedSizeStored</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>lastLoggedSizes</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Sets the expiration time for a slot in days or hours. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setExpiration</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>value</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>hours</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* This slot has no expiration. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>value</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>expirationValues</color> <color=#f92672>=</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If this is the first slot with an expiration, initialize the base to</color>
<color=#75715e>     * the value and set the offset (slot value) to one.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expirationBase</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color> <color=#f92672>||</color> <color=#f8f8f2>nEntries</color> <color=#f92672>==</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>expirationBase</color> <color=#f92672>=</color> <color=#f8f8f2>value</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>setExpirationOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>setExpirationInHours</color><color=#f8f8f2>(</color><color=#f8f8f2>hours</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>hours</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Convert existing values to hours if necessary. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isExpirationInHours</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>expirationBase</color> <color=#f92672>*=</color> <color=#ae81ff>24</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>setExpirationInHours</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>nEntries</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672>==</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>offset</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>setExpirationOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>((</color><color=#f8f8f2>offset</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f92672>*</color> <color=#ae81ff>24</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* If values are stored in hours, convert days to hours. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isExpirationInHours</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>value</color> <color=#f92672>*=</color> <color=#ae81ff>24</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Slot's expiration must not be less than the base. If it is, decrease</color>
<color=#75715e>     * the base and increase the offset in other slots accordingly.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>value</color> <color=#f92672><</color> <color=#f8f8f2>expirationBase</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>adjustment</color> <color=#f92672>=</color> <color=#f8f8f2>expirationBase</color> <color=#f92672>-</color> <color=#f8f8f2>value</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>expirationBase</color> <color=#f92672>=</color> <color=#f8f8f2>value</color><color=#f8f8f2>;</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>nEntries</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672>==</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>offset</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>setExpirationOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#f8f8f2>adjustment</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>setExpirationOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>value</color> <color=#f92672>-</color> <color=#f8f8f2>expirationBase</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>hasExpirationValues</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f92672>!</color><color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the expiration time for a slot. The return value is in days or hours, depending on</color>
<color=#75715e>   * isExpirationTimeInHours.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>offset</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>offset</color> <color=#f92672>-</color> <color=#ae81ff>1</color> <color=#f92672>+</color> <color=#f8f8f2>expirationBase</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>int</color> <color=#a6e22e>getExpirationBase</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>expirationBase</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>int</color> <color=#a6e22e>getExpirationOffset</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>setExpirationBase</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>base</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>expirationBase</color> <color=#f92672>=</color> <color=#f8f8f2>base</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>setExpirationOffset</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>expirationValues</color> <color=#f92672>=</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns whether the slot is known-deleted, pending-deleted, or expired. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isDefunct</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>isDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>isExpired</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns whether the slot is known-deleted or pending-deleted. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isDeleted</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>isEntryPendingDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns whether the slot is expired. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isExpired</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>isExpired</color><color=#f8f8f2>(</color><color=#f8f8f2>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>),</color> <color=#f8f8f2>isExpirationInHours</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isProbablyExpired</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>getEnv</color><color=#f8f8f2>()</color>
        <color=#f8f8f2>.</color><color=#a6e22e>expiresWithin</color><color=#f8f8f2>(</color><color=#f8f8f2>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>),</color> <color=#f8f8f2>isExpirationInHours</color><color=#f8f8f2>(),</color> <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getTtlClockTolerance</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getLastLoggedSizeUnconditional</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>lastLoggedSizes</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setOffHeapLNId</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>clearOffHeapLNIds</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>EMPTY_OFFHEAP_LN_IDS</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getOffHeapLNIdsMemorySize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>hasOffHeapLNs</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f92672>!</color><color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setOffHeapLruId</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>id</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>id</color> <color=#f92672>>=</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>hasOffHeapLNs</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>offHeapLruId</color> <color=#f92672>=</color> <color=#f8f8f2>id</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>offHeapLruId</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>freeOffHeapLN</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>getOffHeapCache</color><color=#f8f8f2>().</color><color=#a6e22e>freeLN</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Updates the vlsnCache when an LN target is evicted. See vlsnCache. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>void</color> <color=#a6e22e>setTarget</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>target</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>target</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>oldTarget</color> <color=#f92672>=</color> <color=#f8f8f2>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>oldTarget</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>setCachedVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>((</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>oldTarget</color><color=#f8f8f2>).</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>setTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>target</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Overridden to account for BIN-specific slot info. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>void</color> <color=#a6e22e>appendEntryFromOtherNode</color><color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>from</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>fromIdx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>appendEntryFromOtherNode</color><color=#f8f8f2>(</color><color=#f8f8f2>from</color><color=#f8f8f2>,</color> <color=#f8f8f2>fromIdx</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>fromBin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>from</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>idx</color> <color=#f92672>=</color> <color=#f8f8f2>nEntries</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>setCachedVLSNUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>fromBin</color><color=#f8f8f2>.</color><color=#a6e22e>getCachedVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>fromIdx</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>setLastLoggedSizeUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>from</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>fromIdx</color><color=#f8f8f2>));</color>

    <color=#f8f8f2>setExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>fromBin</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>fromIdx</color><color=#f8f8f2>),</color> <color=#f8f8f2>fromBin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>());</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>OffHeapCache</color> <color=#f8f8f2>ohCache</color> <color=#f92672>=</color> <color=#f8f8f2>getOffHeapCache</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>isEnabled</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>fromBin</color><color=#f8f8f2>.</color><color=#a6e22e>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>fromIdx</color><color=#f8f8f2>),</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>ensureOffHeapLNsInLRU</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Overridden to account for BIN-specific slot info. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>void</color> <color=#a6e22e>copyEntries</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>from</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>to</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>copyEntries</color><color=#f8f8f2>(</color><color=#f8f8f2>from</color><color=#f8f8f2>,</color> <color=#f8f8f2>to</color><color=#f8f8f2>,</color> <color=#f8f8f2>n</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>vlsnCache</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnCache</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>from</color><color=#f8f8f2>,</color> <color=#f8f8f2>to</color><color=#f8f8f2>,</color> <color=#f8f8f2>n</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>lastLoggedSizes</color> <color=#f92672>=</color> <color=#f8f8f2>lastLoggedSizes</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>from</color><color=#f8f8f2>,</color> <color=#f8f8f2>to</color><color=#f8f8f2>,</color> <color=#f8f8f2>n</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>expirationValues</color> <color=#f92672>=</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>from</color><color=#f8f8f2>,</color> <color=#f8f8f2>to</color><color=#f8f8f2>,</color> <color=#f8f8f2>n</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>from</color><color=#f8f8f2>,</color> <color=#f8f8f2>to</color><color=#f8f8f2>,</color> <color=#f8f8f2>n</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Overridden to account for BIN-specific slot info. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>void</color> <color=#a6e22e>clearEntry</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>clearEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>setCachedVLSNUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>setLastLoggedSizeUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>setExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Cursors</color>
<color=#75715e>   */</color>

  <color=#75715e>/* public for the test suite. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>CursorImpl</color><color=#f92672>></color> <color=#a6e22e>getCursorSet</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursorSet</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>Collections</color><color=#f8f8f2>.</color><color=#a6e22e>emptySet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>cursorSet</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Register a cursor with this BIN. Caller has this BIN already latched.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param cursor Cursor to register.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>addCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursorSet</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>cursorSet</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TinyHashSet</color><color=#f92672><</color><color=#f8f8f2>CursorImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>cursorSet</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Unregister a cursor with this bin. Caller has this BIN already latched.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param cursor Cursor to unregister.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>removeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursorSet</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>cursorSet</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursorSet</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>cursorSet</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return the number of cursors currently referring to this BIN. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>nCursors</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Use a local var to concurrent assignment to the cursorSet field by</color>
<color=#75715e>     * another thread. This method is called via eviction without latching.</color>
<color=#75715e>     * LRU-TODO: with the new evictor this method is called with the node</color>
<color=#75715e>     * EX-latched. So, cleanup after the old evictor is scrapped.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>TinyHashSet</color><color=#f92672><</color><color=#f8f8f2>CursorImpl</color><color=#f92672>></color> <color=#f8f8f2>cursors</color> <color=#f92672>=</color> <color=#f8f8f2>cursorSet</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursors</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>cursors</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adjust any cursors that are referring to this BIN. This method is called during a split</color>
<color=#75715e>   * operation. "this" is the BIN being split. newSibling is the new BIN into which the entries from</color>
<color=#75715e>   * "this" between newSiblingLow and newSiblingHigh have been copied.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param newSibling - the newSibling into which "this" has been split.</color>
<color=#75715e>   * @param newSiblingLow</color>
<color=#75715e>   * @param newSiblingHigh - the low and high entry of "this" that were moved into newSibling.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>void</color> <color=#a6e22e>adjustCursors</color><color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>newSibling</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>newSiblingLow</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>newSiblingHigh</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>newSibling</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursorSet</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>adjustmentDelta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>newSiblingHigh</color> <color=#f92672>-</color> <color=#f8f8f2>newSiblingLow</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Iterator</color><color=#f92672><</color><color=#f8f8f2>CursorImpl</color><color=#f92672>></color> <color=#f8f8f2>iter</color> <color=#f92672>=</color> <color=#f8f8f2>cursorSet</color><color=#f8f8f2>.</color><color=#a6e22e>iterator</color><color=#f8f8f2>();</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>hasNext</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f8f8f2>();</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>cIdx</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getIndex</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>assertBIN</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>newSibling</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BIN</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * There are four cases to consider for cursor adjustments,</color>
<color=#75715e>       * depending on (1) how the existing node gets split, and (2) where</color>
<color=#75715e>       * the cursor points to currently.  In cases 1 and 2, the id key of</color>
<color=#75715e>       * the node being split is to the right of the splitindex so the</color>
<color=#75715e>       * new sibling gets the node entries to the left of that index.</color>
<color=#75715e>       * This is indicated by "new sibling" to the left of the vertical</color>
<color=#75715e>       * split line below.  The right side of the node contains entries</color>
<color=#75715e>       * that will remain in the existing node (although they've been</color>
<color=#75715e>       * shifted to the left).  The vertical bar (^) indicates where the</color>
<color=#75715e>       * cursor currently points.</color>
<color=#75715e>       *</color>
<color=#75715e>       * case 1:</color>
<color=#75715e>       *</color>
<color=#75715e>       *   We need to set the cursor's "bin" reference to point at the</color>
<color=#75715e>       *   new sibling, but we don't need to adjust its index since that</color>
<color=#75715e>       *   continues to be correct post-split.</color>
<color=#75715e>       *</color>
<color=#75715e>       *   +=======================================+</color>
<color=#75715e>       *   |  new sibling        |  existing node  |</color>
<color=#75715e>       *   +=======================================+</color>
<color=#75715e>       *         cursor ^</color>
<color=#75715e>       *</color>
<color=#75715e>       * case 2:</color>
<color=#75715e>       *</color>
<color=#75715e>       *   We only need to adjust the cursor's index since it continues</color>
<color=#75715e>       *   to point to the current BIN post-split.</color>
<color=#75715e>       *</color>
<color=#75715e>       *   +=======================================+</color>
<color=#75715e>       *   |  new sibling        |  existing node  |</color>
<color=#75715e>       *   +=======================================+</color>
<color=#75715e>       *                              cursor ^</color>
<color=#75715e>       *</color>
<color=#75715e>       * case 3:</color>
<color=#75715e>       *</color>
<color=#75715e>       *   Do nothing.  The cursor continues to point at the correct BIN</color>
<color=#75715e>       *   and index.</color>
<color=#75715e>       *</color>
<color=#75715e>       *   +=======================================+</color>
<color=#75715e>       *   |  existing Node        |  new sibling  |</color>
<color=#75715e>       *   +=======================================+</color>
<color=#75715e>       *         cursor ^</color>
<color=#75715e>       *</color>
<color=#75715e>       * case 4:</color>
<color=#75715e>       *</color>
<color=#75715e>       *   Adjust the "bin" pointer to point at the new sibling BIN and</color>
<color=#75715e>       *   also adjust the index.</color>
<color=#75715e>       *</color>
<color=#75715e>       *   +=======================================+</color>
<color=#75715e>       *   |  existing Node        |  new sibling  |</color>
<color=#75715e>       *   +=======================================+</color>
<color=#75715e>       *                                 cursor ^</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>BIN</color> <color=#f8f8f2>ns</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>newSibling</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newSiblingLow</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cIdx</color> <color=#f92672><</color> <color=#f8f8f2>newSiblingHigh</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* case 1 */</color>
          <color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>setBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>ns</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>ns</color><color=#f8f8f2>.</color><color=#a6e22e>addCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* case 2 */</color>
          <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>setIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>cIdx</color> <color=#f92672>-</color> <color=#f8f8f2>adjustmentDelta</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cIdx</color> <color=#f92672>>=</color> <color=#f8f8f2>newSiblingLow</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* case 4 */</color>
          <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>setIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>cIdx</color> <color=#f92672>-</color> <color=#f8f8f2>newSiblingLow</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>setBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>ns</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>ns</color><color=#f8f8f2>.</color><color=#a6e22e>addCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For each cursor in this BIN's cursor set, ensure that the cursor is actually referring to this</color>
<color=#75715e>   * BIN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>verifyCursors</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursorSet</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>cursor</color> <color=#f8f8f2>:</color> <color=#f8f8f2>cursorSet</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>assertBIN</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adjust cursors referring to this BIN following an insert.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param insertIndex - The index of the new entry.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>void</color> <color=#a6e22e>adjustCursorsForInsert</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>insertIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursorSet</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>cursor</color> <color=#f8f8f2>:</color> <color=#f8f8f2>cursorSet</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>cIdx</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getIndex</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>insertIndex</color> <color=#f92672><=</color> <color=#f8f8f2>cIdx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>setIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>cIdx</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called when we know we are about to split on behalf of a key that is the minimum (leftSide) or</color>
<color=#75715e>   * maximum (!leftSide) of this node. This is achieved by just forcing the split to occur either</color>
<color=#75715e>   * one element in from the left or the right (i.e. splitIndex is 1 or nEntries - 1).</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#f8f8f2>IN</color> <color=#a6e22e>splitSpecial</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>parentIndex</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>IN</color> <color=#f8f8f2>grandParent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>maxEntriesPerNode</color><color=#f8f8f2>,</color>
      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>leftSide</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>nEntries</color> <color=#f92672>=</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>exact</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>index</color> <color=#f92672>&=</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>leftSide</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>splitInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>parentIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>grandParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxEntriesPerNode</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>leftSide</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>exact</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672>==</color> <color=#f8f8f2>(</color><color=#f8f8f2>nEntries</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>splitInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>parentIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>grandParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxEntriesPerNode</color><color=#f8f8f2>,</color> <color=#f8f8f2>nEntries</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>split</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>parentIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>grandParent</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxEntriesPerNode</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Compress a full BIN by removing any slots that are deleted or expired.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This must not be a BIN-delta. No cursors can be present on the BIN. Caller is responsible</color>
<color=#75715e>   * for latching and unlatching this node.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If the slot containing the identifier is removed, the identifier key will be changed to the</color>
<color=#75715e>   * key in the first remaining slot.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Normally when a slot is removed, the IN is dirtied. However, during compression the BIN is</color>
<color=#75715e>   * not dirtied when a slot is removed. This is safe for the reasons described below. Note that the</color>
<color=#75715e>   * BIN being compressed is always a full BIN, not a delta.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>+ If the BIN is not dirty and it does not become dirty before shutdown, i.e., it is not</color>
<color=#75715e>   * logged, then it is possible that this compression will be "lost". However, the state of the</color>
<color=#75715e>   * slot on disk is expired/deleted, and when the BIN is later fetched from disk, this state will</color>
<color=#75715e>   * be restored and the compression will be performed again.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>+ If the slot is dirty, the BIN may also be dirty or may become dirty later, and be logged.</color>
<color=#75715e>   * Logging a delta would cause the information in the dirty slot to be lost. Therefore, when a</color>
<color=#75715e>   * dirty slot is removed, we set a flag that prohibits the next BIN logged from being a delta.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This optimization (that we don't dirty the BIN and we allow logging a delta after removing a</color>
<color=#75715e>   * non-dirty slot) has one minor and one major impact:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>1. When a slot is removed for a deleted record, normally the slot and the BIN will be dirty.</color>
<color=#75715e>   * Although it is unusual, we may encounter a non-dirty slot for a deleted record. This happens if</color>
<color=#75715e>   * the slot could not be removed by this method when a full BIN is logged, due to a lock or a</color>
<color=#75715e>   * cursor, and we compress the full BIN later.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>2. When a slot is removed for an expired record, it is common that the slot will not be be</color>
<color=#75715e>   * dirty. In this case, without the optimization, the removal of expired slots would cause more</color>
<color=#75715e>   * logging and less deltas would be logged.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param localTracker is used only for temporary DBs, and may be specified to consolidate</color>
<color=#75715e>   *     multiple tracking operations. If null, the tracking is performed immediately in this</color>
<color=#75715e>   *     method.</color>
<color=#75715e>   * @return true if all deleted and expired slots were compressed, or false if one or more slots</color>
<color=#75715e>   *     could not be compressed because we were unable to obtain a lock. A false return value means</color>
<color=#75715e>   *     "try again later".</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>compress</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>compressDirtySlots</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>LocalUtilizationTracker</color> <color=#f8f8f2>localTracker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the environment is not yet recovered we can't rely on locks</color>
<color=#75715e>     * being set up to safeguard active data and so we can't compress</color>
<color=#75715e>     * safely.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>isValid</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nCursors</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>getDatabase</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LockManager</color> <color=#f8f8f2>lockManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLockManager</color><color=#f8f8f2>();</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>setNewIdKey</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>anyLocked</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>compressDirtySlots</color> <color=#f92672>&&</color> <color=#f8f8f2>isDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>expired</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isExpired</color><color=#f8f8f2>(</color><color=#f8f8f2>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#f8f8f2>isExpirationInHours</color><color=#f8f8f2>());</color>

      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>deleted</color> <color=#f92672>=</color> <color=#f8f8f2>isDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>deleted</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>expired</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We have to be able to lock the LN before we can compress the</color>
<color=#75715e>       * entry. If we can't, then skip over it. For a deleted record, a</color>
<color=#75715e>       * read lock is sufficient because it means the deletion has been</color>
<color=#75715e>       * committed, and other lockers don't hold read locks on a deleted</color>
<color=#75715e>       * record. For an expired record, a write lock is needed to prevent</color>
<color=#75715e>       * removal of a slot for a record that is read-locked elsewhere.</color>
<color=#75715e>       * In both cases it is more efficient to call isLockUncontended</color>
<color=#75715e>       * than to actually lock the LN, since we would release the lock</color>
<color=#75715e>       * immediately.</color>
<color=#75715e>       *</color>
<color=#75715e>       * We must be able to lock the LN even if isKnownDeleted is true,</color>
<color=#75715e>       * because locks protect the aborts. (Aborts may execute multiple</color>
<color=#75715e>       * operations, where each operation latches and unlatches. It's the</color>
<color=#75715e>       * LN lock that protects the integrity of the whole multi-step</color>
<color=#75715e>       * process.)</color>
<color=#75715e>       *</color>
<color=#75715e>       * For example, during abort, there may be cases where we have</color>
<color=#75715e>       * deleted and then added an LN during the same txn.  This means</color>
<color=#75715e>       * that to undo/abort it, we first delete the LN (leaving</color>
<color=#75715e>       * knownDeleted set), and then add it back into the tree.  We want</color>
<color=#75715e>       * to make sure the entry is in the BIN when we do the insert back</color>
<color=#75715e>       * in.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Can discard a NULL_LSN entry without locking. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>lockManager</color><color=#f8f8f2>.</color><color=#a6e22e>isLockUncontended</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>anyLocked</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* At this point, we know we can remove the slot. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entryKeys</color><color=#f8f8f2>.</color><color=#a6e22e>compareKeys</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>getIdentifierKey</color><color=#f8f8f2>(),</color> <color=#f8f8f2>keyPrefix</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>haveEmbeddedData</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#f8f8f2>getKeyComparator</color><color=#f8f8f2>())</color>
          <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We're about to remove the entry with the idKey so the</color>
<color=#75715e>         * node will need a new idkey.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>setNewIdKey</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * When we compress a deleted slot in a deferred-write DB, we</color>
<color=#75715e>       * must either log a dirty LN or count it obsolete. However, if</color>
<color=#75715e>       * we compress an expired slot, neither is necessary; see TTL.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>expired</color> <color=#f92672>&&</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>isDirty</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>isTransient</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isTemporary</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

            <color=#75715e>/*</color>
<color=#75715e>             * When a previously logged LN in a temporary DB is</color>
<color=#75715e>             * dirty, we can count the LSN of the last logged LN as</color>
<color=#75715e>             * obsolete without logging. There is no requirement</color>
<color=#75715e>             * for the dirty deleted LN to be durable past</color>
<color=#75715e>             * recovery.  There is no danger of the last logged LN</color>
<color=#75715e>             * being accessed again (after log cleaning, for</color>
<color=#75715e>             * example), since temp DBs do not survive recovery.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>localTracker</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>localTracker</color><color=#f8f8f2>.</color><color=#a6e22e>countObsoleteNode</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getGenericLogType</color><color=#f8f8f2>(),</color> <color=#f8f8f2>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#f8f8f2>db</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>envImpl</color>
                  <color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>()</color>
                  <color=#f8f8f2>.</color><color=#a6e22e>countObsoleteNode</color><color=#f8f8f2>(</color>
                      <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getGenericLogType</color><color=#f8f8f2>(),</color> <color=#f8f8f2>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*countExact*/</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

            <color=#75715e>/*</color>
<color=#75715e>             * When a previously logged deferred-write LN is dirty,</color>
<color=#75715e>             * we log the dirty deleted LN to make the deletion</color>
<color=#75715e>             * durable. The act of logging will also count the last</color>
<color=#75715e>             * logged LSN as obsolete.</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>logDirtyLN</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*allowEviction*/</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>deleteEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*makeDirty*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*validate*/</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Since we're deleting the current entry, decrement the index. */</color>
      <color=#f8f8f2>i</color><color=#f92672>--</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>setNewIdKey</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>setIdentifierKey</color><color=#f8f8f2>(</color><color=#f8f8f2>getKey</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>),</color> <color=#66d9ef>false</color> <color=#75715e>/*makeDirty*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* This BIN is empty and expendable. */</color>
      <color=#f8f8f2>updateLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>MAKE_COLD</color><color=#f8f8f2>);</color> <color=#75715e>// TODO actually make cold</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Reduce capacity if this BIN is larger than the configured capacity,</color>
<color=#75715e>     * and has less entries then the configured capacity. This could be due</color>
<color=#75715e>     * to enlarging the BIN during recovery (see reconstituteBIN) or</color>
<color=#75715e>     * because the configured capacity was changed.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>configuredCapacity</color> <color=#f92672>=</color> <color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeMaxTreeEntries</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>getMaxEntries</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#f8f8f2>configuredCapacity</color> <color=#f92672>&&</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672><</color> <color=#f8f8f2>configuredCapacity</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>configuredCapacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f92672>!</color><color=#f8f8f2>anyLocked</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * This method is called opportunistically at certain places where a deleted slot is observed</color>
<color=#75715e>   * (when the slot's PendingDeleted or KnownDeleted flag is set), to ensure that the slot is</color>
<color=#75715e>   * compressed away. This is an attempt to process slots that were not compressed during the</color>
<color=#75715e>   * mainstream record deletion process because of cursors on the BIN during compress, or a crash</color>
<color=#75715e>   * prior to compression.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>queueSlotDeletion</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the next logrec for this BIN should be a BIN-delta, don't queue</color>
<color=#75715e>     * the BIN if the deleted slot is dirty, because removing dirty BIN</color>
<color=#75715e>     * slots prevents logging a delta.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>shouldLogDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>addToCompressorQueue</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For debugging.  Overrides method in IN. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>boolean</color> <color=#a6e22e>validateSubtreeBeforeDelete</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>());</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Check if this node fits the qualifications for being part of a deletable subtree. It may not</color>
<color=#75715e>   * have any LN children.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>We assume that this is only called under an assert.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>boolean</color> <color=#a6e22e>isValidForDelete</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>isLatchExclusiveOwner</color><color=#f8f8f2>());</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>numValidEntries</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isEntryKnownDeleted</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>numValidEntries</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>numValidEntries</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color> <color=#75715e>// any valid entries, not eligible</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
      <color=#75715e>// cursors on BIN, not eligible</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>nCursors</color><color=#f8f8f2>()</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color><color=#75715e>// 0 entries, no cursors</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>compactMemory</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>oldSize</color> <color=#f92672>=</color> <color=#f8f8f2>inMemorySize</color><color=#f8f8f2>;</color>
    <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>compactMemory</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>compact</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>EMPTY_OFFHEAP_LN_IDS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>expirationValues</color> <color=#f92672>=</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>compact</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>EMPTY_EXPIRATION</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>oldSize</color> <color=#f92672>-</color> <color=#f8f8f2>inMemorySize</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Adds vlsnCache size to computed memory size. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>computeMemorySize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>computeMemorySize</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * vlsnCache, lastLoggedSizes, etc, are null only when this method is</color>
<color=#75715e>     * called by the superclass constructor, i.e., before this class</color>
<color=#75715e>     * constructor has run. Luckily the initial representations have a</color>
<color=#75715e>     * memory size of zero, so we can ignore them in this case.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnCache</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>vlsnCache</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastLoggedSizes</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>lastLoggedSizes</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expirationValues</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>offHeapLNIds</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>BINDeltaBloomFilter</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* Utility method used during unit testing. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#a6e22e>printMemorySize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>inTotal</color> <color=#f92672>=</color> <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>printMemorySize</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>vlsnCacheOverhead</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnCache</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>logSizesOverhead</color> <color=#f92672>=</color> <color=#f8f8f2>lastLoggedSizes</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>expirationOverhead</color> <color=#f92672>=</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>offHeapLNIdOverhead</color> <color=#f92672>=</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>binTotal</color> <color=#f92672>=</color> <color=#f8f8f2>inTotal</color> <color=#f92672>+</color> <color=#f8f8f2>vlsnCacheOverhead</color> <color=#f92672>+</color> <color=#f8f8f2>logSizesOverhead</color> <color=#f92672>+</color> <color=#f8f8f2>offHeapLNIdOverhead</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>format</color><color=#f8f8f2>(</color>
        <color=#e6db74>"BIN: %d vlsns: %d logSizes: %d expiration: %d offHeapLNIds: %d %n"</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>binTotal</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnCacheOverhead</color><color=#f8f8f2>,</color> <color=#f8f8f2>logSizesOverhead</color><color=#f8f8f2>,</color> <color=#f8f8f2>expirationOverhead</color><color=#f8f8f2>,</color> <color=#f8f8f2>offHeapLNIdOverhead</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>binTotal</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#a6e22e>getFixedMemoryOverhead</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>BIN_FIXED_OVERHEAD</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the treeAdmin memory in objects referenced by this BIN. Specifically, this refers to</color>
<color=#75715e>   * the DbFileSummaryMap held by MapLNs</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getTreeAdminMemorySize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>getId</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>DbTree</color><color=#f8f8f2>.</color><color=#a6e22e>ID_DB_ID</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>treeAdminMem</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>getMaxEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>Node</color> <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#f8f8f2>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>MapLN</color> <color=#f8f8f2>mapLN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>MapLN</color><color=#f8f8f2>)</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>treeAdminMem</color> <color=#f92672>+=</color> <color=#f8f8f2>mapLN</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>getTreeAdminMemory</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>treeAdminMem</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Reduce memory consumption. Note that evicting deferred-write LNs may require logging them,</color>
<color=#75715e>   * which will mark this BIN dirty. Compression of deleted slots will also mark the BIN dirty.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The BIN should be latched by the caller.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return a long number encoding (a) the number of evicted bytes, and (b) whether this BIN is</color>
<color=#75715e>   *     evictable. (b) will be false if the BIN has any cursors on it, or has any non-evictable</color>
<color=#75715e>   *     children.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>partialEviction</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Try compressing non-dirty slots. */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>oldMemSize</color> <color=#f92672>=</color> <color=#f8f8f2>inMemorySize</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>lazyCompress</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>oldMemSize</color> <color=#f92672>></color> <color=#f8f8f2>inMemorySize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>oldMemSize</color> <color=#f92672>-</color> <color=#f8f8f2>inMemorySize</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Try LN eviction. Return if any were evicted. */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lnBytesAndStatus</color> <color=#f92672>=</color> <color=#f8f8f2>evictLNs</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>lnBytesAndStatus</color> <color=#f92672>&</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>NON_EVICTABLE_IN</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>lnBytesAndStatus</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Try discarding the VLSNCache. Return bytes and evictable status. */</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>discardVLSNCache</color><color=#f8f8f2>()</color> <color=#f92672>|</color> <color=#f8f8f2>lnBytesAndStatus</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>discardVLSNCache</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>vlsnBytes</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnCache</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySize</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnBytes</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>int</color> <color=#f8f8f2>numEntries</color> <color=#f92672>=</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>numEntries</color><color=#f8f8f2>;</color> <color=#f92672>++</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>vlsnCache</color> <color=#f92672>=</color> <color=#f8f8f2>EMPTY_VLSNS</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>updateMemorySize</color><color=#f8f8f2>(</color><color=#ae81ff>0</color> <color=#f92672>-</color> <color=#f8f8f2>vlsnBytes</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>vlsnBytes</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Reduce memory consumption by evicting all LN targets. Note that this may cause LNs to be</color>
<color=#75715e>   * logged, which will mark this BIN dirty.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The BIN should be latched by the caller.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return a long number encoding (a) the number of evicted bytes, and (b) whether this BIN is</color>
<color=#75715e>   *     evictable. (b) will be false if the BIN has any cursors on it, or has any non-evictable</color>
<color=#75715e>   *     children.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>evictLNs</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>isLatchExclusiveOwner</color><color=#f8f8f2>()</color> <color=#f8f8f2>:</color> <color=#e6db74>"BIN must be latched before evicting LNs"</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We can't evict an LN which is pointed to by a cursor, in case that</color>
<color=#75715e>     * cursor has a reference to the LN object. We'll take the cheap choice</color>
<color=#75715e>     * and avoid evicting any LNs if there are cursors on this BIN. We</color>
<color=#75715e>     * could do a more expensive, precise check to see entries have which</color>
<color=#75715e>     * cursors. This is something we might move to later.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nCursors</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>NON_EVICTABLE_IN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Try to evict each child LN. */</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>totalRemoved</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>numLNsEvicted</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>haveNonEvictableLN</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>long</color> <color=#f8f8f2>lnRemoved</color> <color=#f92672>=</color> <color=#f8f8f2>evictLNInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*ifFetchedCold*/</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnRemoved</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>haveNonEvictableLN</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>totalRemoved</color> <color=#f92672>+=</color> <color=#f8f8f2>lnRemoved</color><color=#f8f8f2>;</color>
        <color=#f92672>++</color><color=#f8f8f2>numLNsEvicted</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * compactMemory() may decrease the memory footprint by mutating the</color>
<color=#75715e>     * representations of the target and key sets.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>totalRemoved</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>updateMemorySize</color><color=#f8f8f2>(</color><color=#f8f8f2>totalRemoved</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>totalRemoved</color> <color=#f92672>+=</color> <color=#f8f8f2>compactMemory</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>getEvictor</color><color=#f8f8f2>().</color><color=#a6e22e>incNumLNsEvicted</color><color=#f8f8f2>(</color><color=#f8f8f2>numLNsEvicted</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>haveNonEvictableLN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>totalRemoved</color> <color=#f92672>|</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>NON_EVICTABLE_IN</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>totalRemoved</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>evictLN</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>evictLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*ifFetchedCold*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>evictLN</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>ifFetchedCold</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>removed</color> <color=#f92672>=</color> <color=#f8f8f2>evictLNInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>ifFetchedCold</color><color=#f8f8f2>);</color>

    <color=#75715e>/* May decrease the memory footprint by changing the INTargetRep. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>removed</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>updateMemorySize</color><color=#f8f8f2>(</color><color=#f8f8f2>removed</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>compactMemory</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Evict a single LN if allowed. The amount of memory freed is returned and must be subtracted</color>
<color=#75715e>   * from the memory budget by the caller.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param ifFetchedCold If true, evict the LN only if it has the FetchedCold flag set.</color>
<color=#75715e>   * @return number of evicted bytes or -1 if the LN is not evictable.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>evictLNInternal</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>ifFetchedCold</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#f8f8f2>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>n</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>LN</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ifFetchedCold</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getFetchedCold</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Don't evict MapLNs for open databases (LN.isEvictable) [#13415].</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>isEvictable</color><color=#f8f8f2>(</color><color=#f8f8f2>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Log target if necessary. Do not allow eviction since we evict</color>
<color=#75715e>     * here and that would cause double-counting of the memory freed.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>logDirtyLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*allowEviction*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Clear target. */</color>
    <color=#f8f8f2>setTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>releaseMemoryBudget</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>OffHeapCache</color> <color=#f8f8f2>ohCache</color> <color=#f92672>=</color> <color=#f8f8f2>getOffHeapCache</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>isEnabled</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>storeEvictedLN</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getMemorySizeIncludedByParent</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @see IN#logDirtyChildren */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>logDirtyChildren</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Look for LNs that are dirty or have never been logged before. */</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>Node</color> <color=#f8f8f2>node</color> <color=#f92672>=</color> <color=#f8f8f2>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>logDirtyLN</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>node</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*allowEviction*/</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Logs the LN at the given index if it is dirty. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>logDirtyLN</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>allowEviction</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>currLsn</color> <color=#f92672>=</color> <color=#f8f8f2>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>force</color> <color=#f92672>=</color> <color=#f8f8f2>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>isTransientOrNull</color><color=#f8f8f2>(</color><color=#f8f8f2>currLsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>force</color> <color=#f92672>||</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>isDirty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color> <color=#f92672>=</color> <color=#f8f8f2>getDatabase</color><color=#f8f8f2>();</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Only deferred write databases should have dirty LNs. */</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>ln</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>MapLN</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Do not lock while logging.  Locking of new LSN is performed by</color>
<color=#75715e>       * lockAfterLsnChange. This should never be part of the replication</color>
<color=#75715e>       * stream, because this is a deferred-write DB.</color>
<color=#75715e>       *</color>
<color=#75715e>       * No reason to include the previous record version in this logrec</color>
<color=#75715e>       * because this logrec will never be undone (DW databases are</color>
<color=#75715e>       * non-transactional)</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LogItem</color> <color=#f8f8f2>logItem</color> <color=#f92672>=</color>
          <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>log</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color>
              <color=#66d9ef>null</color> <color=#75715e>/*locker*/</color><color=#f8f8f2>,</color>
              <color=#66d9ef>null</color> <color=#75715e>/*writeLockInfo*/</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>),</color>
              <color=#f8f8f2>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>),</color>
              <color=#f8f8f2>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>),</color>
              <color=#f8f8f2>isExpirationInHours</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>),</color>
              <color=#f8f8f2>currLsn</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>),</color>
              <color=#66d9ef>false</color> <color=#75715e>/*isInsertion*/</color><color=#f8f8f2>,</color>
              <color=#66d9ef>true</color> <color=#75715e>/*backgroundIO*/</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>ReplicationContext</color><color=#f8f8f2>.</color><color=#a6e22e>NO_REPLICATE</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>updateEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Lock new LSN on behalf of existing lockers. */</color>
      <color=#f8f8f2>CursorImpl</color><color=#f8f8f2>.</color><color=#a6e22e>lockAfterLsnChange</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>currLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*excludeLocker*/</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * It is desirable to evict a non-dirty LN that is immediately</color>
<color=#75715e>       * obsolete, because it will never be fetched again.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>allowEviction</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isLNImmediatelyObsolete</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>evictLN</color><color=#f8f8f2>(</color><color=#f8f8f2>idx</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Logging support</color>
<color=#75715e>   */</color>

  <color=#75715e>/** @see IN#getLogType */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>LogEntryType</color> <color=#a6e22e>getLogType</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_BIN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Overrides the IN method to account for deltas. Public for unit testing. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getLastDeltaLsn</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>lastDeltaVersion</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setLastDeltaLsn</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>lastDeltaVersion</color> <color=#f92672>=</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * BIN delta support</color>
<color=#75715e>   */</color>

  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getFullBinNEntries</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>fullBinNEntries</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>nEntries</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setFullBinNEntries</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>fullBinNEntries</color> <color=#f92672>=</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>incFullBinNEntries</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>());</color>
    <color=#f92672>++</color><color=#f8f8f2>fullBinNEntries</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getFullBinMaxEntries</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>fullBinMaxEntries</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>getMaxEntries</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setFullBinMaxEntries</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>fullBinMaxEntries</color> <color=#f92672>=</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>int</color> <color=#a6e22e>getDeltaCapacity</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>numDirtyEntries</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>blindOps</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>allowBlindOps</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>allowBlindPuts</color><color=#f8f8f2>());</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>getMaxEntries</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>blindOps</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getBinDeltaPercent</color><color=#f8f8f2>())</color> <color=#f92672>/</color> <color=#ae81ff>100</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>numDirtyEntries</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>boolean</color> <color=#a6e22e>allowBlindPuts</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>res</color> <color=#f92672>=</color> <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>allowBlindPuts</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>res</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>res</color> <color=#f92672>=</color> <color=#f8f8f2>res</color> <color=#f92672>&&</color> <color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>hasBtreeBinaryEqualityComparator</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>res</color> <color=#f92672>=</color> <color=#f8f8f2>res</color> <color=#f92672>&&</color> <color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>hasDuplicateBinaryEqualityComparator</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>res</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * It is called in 3 cases listed below. In all cases, if blind puts are</color>
<color=#75715e>   * not allowed, the method returns null.</color>
<color=#75715e>   *</color>
<color=#75715e>   * 1. A full BIN is being mutated to an in-memory delta. A new filter will</color>
<color=#75715e>   *    be created here and will be stored in the delta by the caller.</color>
<color=#75715e>   * 2. A full BIN is being logged as a delta. A new filter will be created</color>
<color=#75715e>   *    here and will be written in the delta logrec by the caller.</color>
<color=#75715e>   * 3. An in-memory BIN-delta is being logged. If the delta has a bloom</color>
<color=#75715e>   *    filter already, that filter will be returned and written into the</color>
<color=#75715e>   *    logrec. The delta may not have a filter already because it was read</color>
<color=#75715e>   *    from an older-version logfile; in this case we return null.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#a6e22e>createBloomFilter</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>isBINDelta</color><color=#f8f8f2>());</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>blindPuts</color> <color=#f92672>=</color> <color=#f8f8f2>allowBlindPuts</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>blindPuts</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * We are here because we are logging a delta that has a filter</color>
<color=#75715e>       * already. We just need to log the existing filter.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>bloomFilter</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>numKeys</color> <color=#f92672>=</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>getNDeltas</color><color=#f8f8f2>();</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>nbytes</color> <color=#f92672>=</color> <color=#f8f8f2>BINDeltaBloomFilter</color><color=#f8f8f2>.</color><color=#a6e22e>getByteSize</color><color=#f8f8f2>(</color><color=#f8f8f2>numKeys</color><color=#f8f8f2>);</color>

    <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>bf</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>nbytes</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>BINDeltaBloomFilter</color><color=#f8f8f2>.</color><color=#a6e22e>HashContext</color> <color=#f8f8f2>hc</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BINDeltaBloomFilter</color><color=#f8f8f2>.</color><color=#a6e22e>HashContext</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>keyPrefix</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>hc</color><color=#f8f8f2>.</color><color=#a6e22e>hashKeyPrefix</color><color=#f8f8f2>(</color><color=#f8f8f2>keyPrefix</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color> <color=#f92672>++</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>suffix</color> <color=#f92672>=</color> <color=#f8f8f2>entryKeys</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>haveEmbeddedData</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>));</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>suffix</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>suffix</color> <color=#f92672>=</color> <color=#f8f8f2>Key</color><color=#f8f8f2>.</color><color=#a6e22e>EMPTY_KEY</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>BINDeltaBloomFilter</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>bf</color><color=#f8f8f2>,</color> <color=#f8f8f2>suffix</color><color=#f8f8f2>,</color> <color=#f8f8f2>hc</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>bf</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>mayHaveKeyInFullBin</color><color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>());</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>BINDeltaBloomFilter</color><color=#f8f8f2>.</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Used in IN.getLogSize() only</color>
<color=#75715e>   */</color>
  <color=#66d9ef>int</color> <color=#a6e22e>getBloomFilterLogSize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>allowBlindPuts</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>BINDeltaBloomFilter</color><color=#f8f8f2>.</color><color=#a6e22e>getLogSize</color><color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>bloomFilter</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>numKeys</color> <color=#f92672>=</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>getNDeltas</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>BINDeltaBloomFilter</color><color=#f8f8f2>.</color><color=#a6e22e>getLogSize</color><color=#f8f8f2>(</color><color=#f8f8f2>numKeys</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>boolean</color> <color=#a6e22e>isDeltaProhibited</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>getProhibitNextDelta</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#f8f8f2>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#f8f8f2>getLastFullLsn</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Decide whether to log a full or partial BIN, depending on the ratio of the delta size to full</color>
<color=#75715e>   * BIN size.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Other factors are taken into account: + a delta cannot be logged if the BIN has never been</color>
<color=#75715e>   * logged before + deltas are not currently supported for DeferredWrite databases + this</color>
<color=#75715e>   * particular delta may have been prohibited because the cleaner is migrating the BIN or a dirty</color>
<color=#75715e>   * slot has been removed + if there are no dirty slots, we might as well log a full BIN</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The restriction on using BIN-deltas for deferred-write DBs is for reasons that are probably</color>
<color=#75715e>   * no longer relevant. However, we have not tested deltas with DW, so we still prohibit them.</color>
<color=#75715e>   * Because BIN-deltas may be in cache at the time a DB is opened in DW mode, a workaround is</color>
<color=#75715e>   * currently necessary: see Database.mutateDeferredWriteBINDeltas.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if we should log the deltas of this BIN</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>shouldLogDelta</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * Cannot assert that db is not in DeferredWrite mode.</color>
<color=#75715e>       * See Database.mutateDeferredWriteBINDeltas.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>getProhibitNextDelta</color><color=#f8f8f2>();</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>getLastFullLsn</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Cheapest checks first. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isDeltaProhibited</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Must count deltas to check further. */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>numDeltas</color> <color=#f92672>=</color> <color=#f8f8f2>getNDeltas</color><color=#f8f8f2>();</color>

    <color=#75715e>/* A delta with zero items is not valid. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>numDeltas</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Check the configured BinDeltaPercent. */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>deltaLimit</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>databaseImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getBinDeltaPercent</color><color=#f8f8f2>())</color> <color=#f92672>/</color> <color=#ae81ff>100</color><color=#f8f8f2>;</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>numDeltas</color> <color=#f92672><=</color> <color=#f8f8f2>deltaLimit</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns whether mutateToBINDelta can be called. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>canMutateToBINDelta</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>shouldLogDelta</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>nCursors</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Mutate to a delta (discard non-dirty entries and resize arrays).</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method must be called with this node latched exclusively, and canMutateToBINDelta must</color>
<color=#75715e>   * return true.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the number of bytes freed.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>mutateToBINDelta</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>canMutateToBINDelta</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>getInListResident</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>().</color><color=#a6e22e>updateBINDeltaStat</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>oldSize</color> <color=#f92672>=</color> <color=#f8f8f2>getInMemorySize</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nDeltas</color> <color=#f92672>=</color> <color=#f8f8f2>getNDeltas</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>capacity</color> <color=#f92672>=</color> <color=#f8f8f2>getDeltaCapacity</color><color=#f8f8f2>(</color><color=#f8f8f2>nDeltas</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>bloomFilter</color> <color=#f92672>=</color> <color=#f8f8f2>createBloomFilter</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>initBINDelta</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>nDeltas</color><color=#f8f8f2>,</color> <color=#f8f8f2>capacity</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>oldSize</color> <color=#f92672>-</color> <color=#f8f8f2>getInMemorySize</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * This method assumes that "this" BIN is a delta and creates a clone of it. It is currently used</color>
<color=#75715e>   * by the DiskOrderedScanner only. The method does not clone the targets array.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>cloneBINDelta</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>());</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BIN</color><color=#f8f8f2>(</color><color=#f8f8f2>databaseImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>getIdentifierKey</color><color=#f8f8f2>(),</color> <color=#ae81ff>0</color> <color=#75715e>/*capacity*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>getLevel</color><color=#f8f8f2>());</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>nodeId</color> <color=#f92672>=</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>flags</color> <color=#f92672>=</color> <color=#f8f8f2>flags</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>lastFullVersion</color> <color=#f92672>=</color> <color=#f8f8f2>lastFullVersion</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nDeltas</color> <color=#f92672>=</color> <color=#f8f8f2>getNDeltas</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>initBINDelta</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>nDeltas</color><color=#f8f8f2>,</color> <color=#f8f8f2>nDeltas</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Replaces the contents of destBIN with the deltas in this BIN. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>initBINDelta</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>destBIN</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nDeltas</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>capacity</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>copyTargets</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>longLSNs</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>compactLSNs</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entryLsnLongArray</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>compactLSNs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>nDeltas</color> <color=#f92672>*</color> <color=#ae81ff>4</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>longLSNs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>long</color><color=#f92672>[</color><color=#f8f8f2>nDeltas</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>vlsns</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>long</color><color=#f92672>[</color><color=#f8f8f2>nDeltas</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>sizes</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[</color><color=#f8f8f2>nDeltas</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[][]</color> <color=#f8f8f2>keys</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>nDeltas</color><color=#f92672>][]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>states</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>nDeltas</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>memIds</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>Node</color><color=#f92672>[]</color> <color=#f8f8f2>targets</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>expiration</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>copyTargets</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>targets</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Node</color><color=#f92672>[</color><color=#f8f8f2>nDeltas</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>memIds</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>long</color><color=#f92672>[</color><color=#f8f8f2>nDeltas</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expirationBase</color> <color=#f92672>!=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>expiration</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[</color><color=#f8f8f2>nDeltas</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>j</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>freeOffHeapLN</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entryLsnLongArray</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>doff</color> <color=#f92672>=</color> <color=#f8f8f2>j</color> <color=#f92672><<</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>soff</color> <color=#f92672>=</color> <color=#f8f8f2>i</color> <color=#f92672><<</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>compactLSNs</color><color=#f92672>[</color><color=#f8f8f2>doff</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>entryLsnByteArray</color><color=#f92672>[</color><color=#f8f8f2>soff</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>compactLSNs</color><color=#f92672>[</color><color=#f8f8f2>doff</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>entryLsnByteArray</color><color=#f92672>[</color><color=#f8f8f2>soff</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>compactLSNs</color><color=#f92672>[</color><color=#f8f8f2>doff</color> <color=#f92672>+</color> <color=#ae81ff>2</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>entryLsnByteArray</color><color=#f92672>[</color><color=#f8f8f2>soff</color> <color=#f92672>+</color> <color=#ae81ff>2</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>compactLSNs</color><color=#f92672>[</color><color=#f8f8f2>doff</color> <color=#f92672>+</color> <color=#ae81ff>3</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>entryLsnByteArray</color><color=#f92672>[</color><color=#f8f8f2>soff</color> <color=#f92672>+</color> <color=#ae81ff>3</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>longLSNs</color><color=#f92672>[</color><color=#f8f8f2>j</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>keys</color><color=#f92672>[</color><color=#f8f8f2>j</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>entryKeys</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>states</color><color=#f92672>[</color><color=#f8f8f2>j</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>getState</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targets</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>targets</color><color=#f92672>[</color><color=#f8f8f2>j</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memIds</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>memIds</color><color=#f92672>[</color><color=#f8f8f2>j</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>vlsns</color><color=#f92672>[</color><color=#f8f8f2>j</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>getCachedVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sizes</color><color=#f92672>[</color><color=#f8f8f2>j</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expiration</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>expiration</color><color=#f92672>[</color><color=#f8f8f2>j</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>j</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Do this before resetContent() because destBIN and "this" may be the</color>
<color=#75715e>     * same java obj</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>destBIN</color><color=#f8f8f2>.</color><color=#a6e22e>fullBinNEntries</color> <color=#f92672>=</color> <color=#f8f8f2>getFullBinNEntries</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>destBIN</color><color=#f8f8f2>.</color><color=#a6e22e>fullBinMaxEntries</color> <color=#f92672>=</color> <color=#f8f8f2>getFullBinMaxEntries</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>destBIN</color><color=#f8f8f2>.</color><color=#a6e22e>resetContent</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>capacity</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>nDeltas</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>baseFileNumber</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>compactLSNs</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>longLSNs</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>states</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>keyPrefix</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>keys</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>targets</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>sizes</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>memIds</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>vlsns</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>isExpirationInHours</color><color=#f8f8f2>());</color>

    <color=#f8f8f2>destBIN</color><color=#f8f8f2>.</color><color=#a6e22e>setBINDelta</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>destBIN</color><color=#f8f8f2>.</color><color=#a6e22e>compactMemory</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Replaces the contents of this BIN with the given contents. Used in mutating a full BIN to a</color>
<color=#75715e>   * BIN-delta or for creating a new BIN delta with the given content.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>resetContent</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>capacity</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>newNEntries</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>baseFileNumber</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>compactLSNs</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>longLSNs</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>states</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>keyPrefix</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[][]</color> <color=#f8f8f2>keys</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Node</color><color=#f92672>[]</color> <color=#f8f8f2>targets</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>loggedSizes</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>memIds</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>vlsns</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>updateRepCacheStats</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>nEntries</color> <color=#f92672>=</color> <color=#f8f8f2>newNEntries</color><color=#f8f8f2>;</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>baseFileNumber</color> <color=#f92672>=</color> <color=#f8f8f2>baseFileNumber</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>longLSNs</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>entryLsnByteArray</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>capacity</color> <color=#f92672><<</color> <color=#ae81ff>2</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>entryLsnLongArray</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>entryLsnByteArray</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>entryLsnLongArray</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>long</color><color=#f92672>[</color><color=#f8f8f2>capacity</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>keyPrefix</color> <color=#f92672>=</color> <color=#f8f8f2>keyPrefix</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>entryKeys</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>INKeyRep</color><color=#f8f8f2>.</color><color=#a6e22e>Default</color><color=#f8f8f2>(</color><color=#f8f8f2>capacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>entryTargets</color> <color=#f92672>=</color> <color=#f8f8f2>INTargetRep</color><color=#f8f8f2>.</color><color=#a6e22e>NONE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>vlsnCache</color> <color=#f92672>=</color> <color=#f8f8f2>EMPTY_VLSNS</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>lastLoggedSizes</color> <color=#f92672>=</color> <color=#f8f8f2>EMPTY_LAST_LOGGED_SIZES</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>expirationValues</color> <color=#f92672>=</color> <color=#f8f8f2>EMPTY_EXPIRATION</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>expirationBase</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>EMPTY_OFFHEAP_LN_IDS</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>updateRepCacheStats</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>entryStates</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>capacity</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>newNEntries</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>longLSNs</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>off</color> <color=#f92672>=</color> <color=#f8f8f2>i</color> <color=#f92672><<</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>entryLsnByteArray</color><color=#f92672>[</color><color=#f8f8f2>off</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>compactLSNs</color><color=#f92672>[</color><color=#f8f8f2>off</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>entryLsnByteArray</color><color=#f92672>[</color><color=#f8f8f2>off</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>compactLSNs</color><color=#f92672>[</color><color=#f8f8f2>off</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>entryLsnByteArray</color><color=#f92672>[</color><color=#f8f8f2>off</color> <color=#f92672>+</color> <color=#ae81ff>2</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>compactLSNs</color><color=#f92672>[</color><color=#f8f8f2>off</color> <color=#f92672>+</color> <color=#ae81ff>2</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>entryLsnByteArray</color><color=#f92672>[</color><color=#f8f8f2>off</color> <color=#f92672>+</color> <color=#ae81ff>3</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>compactLSNs</color><color=#f92672>[</color><color=#f8f8f2>off</color> <color=#f92672>+</color> <color=#ae81ff>3</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>entryLsnLongArray</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>longLSNs</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>entryKeys</color> <color=#f92672>=</color> <color=#f8f8f2>entryKeys</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>keys</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>entryStates</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>states</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targets</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>entryTargets</color> <color=#f92672>=</color> <color=#f8f8f2>entryTargets</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>targets</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memIds</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>setOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>memIds</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expiration</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>setExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>expiration</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>,</color> <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>setLastLoggedSizeUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>loggedSizes</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>setCachedVLSNUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsns</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>updateMemorySize</color><color=#f8f8f2>(</color><color=#f8f8f2>inMemorySize</color><color=#f8f8f2>,</color> <color=#f8f8f2>computeMemorySize</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Fetch the full BIN and apply the deltas in this BIN to it, then use the merged result to</color>
<color=#75715e>   * replace the contents of this BIN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method must be called with this node latched exclusively. If 'this' is not a delta,</color>
<color=#75715e>   * this method does nothing.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>leaveFreeSlot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isBINDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>fullBIN</color> <color=#f92672>=</color> <color=#f8f8f2>fetchFullBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>databaseImpl</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>fullBIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>leaveFreeSlot</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>getEvictor</color><color=#f8f8f2>().</color><color=#a6e22e>incFullBINMissStats</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Mutates this delta to a full BIN by applying this delta to the fullBIN param and then replacing</color>
<color=#75715e>   * this BIN's contents with it.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method must be called with this node latched exclusively. 'this' must be a delta.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>After mutation, the full BIN is compressed and compacted. The compression is particularly</color>
<color=#75715e>   * important, since BIN-deltas in cache cannot be compressed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The method is public because it is called directly from FileProcessor when it finds a BIN</color>
<color=#75715e>   * that must be migrated. In that case, fullBIN is a full BIN that has just been read from the</color>
<color=#75715e>   * log, and it is not part of the memory-resident tree.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>mutateToFullBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>BIN</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>leaveFreeSlot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>isBINDelta</color><color=#f8f8f2>()</color> <color=#f8f8f2>:</color> <color=#66d9ef>this</color><color=#f8f8f2>;</color>

    <color=#66d9ef>byte</color><color=#f92672>[][]</color> <color=#f8f8f2>keys</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursorSet</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>keys</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>cursorSet</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color><color=#f92672>][]</color><color=#f8f8f2>;</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>cursor</color> <color=#f8f8f2>:</color> <color=#f8f8f2>cursorSet</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getIndex</color><color=#f8f8f2>();</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>keys</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getCurrentKey</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*isLatched*/</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f92672>++</color><color=#f8f8f2>i</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>reconstituteBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>databaseImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>leaveFreeSlot</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>resetContent</color><color=#f8f8f2>(</color><color=#f8f8f2>fullBIN</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>setBINDelta</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The fullBIN identifierKey may have changed when reconstituteBIN</color>
<color=#75715e>     * called BIN.compress. We cannot call setIdentifierKey in resetContent</color>
<color=#75715e>     * because assert(!isBINDelta()) will fail, so call it here.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>setIdentifierKey</color><color=#f8f8f2>(</color><color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>getIdentifierKey</color><color=#f8f8f2>(),</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursorSet</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>CursorImpl</color> <color=#f8f8f2>cursor</color> <color=#f8f8f2>:</color> <color=#f8f8f2>cursorSet</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>keys</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * Do not ask for an exact match from findEntry because if</color>
<color=#75715e>           * the cursor was on a KD slot, findEntry would return -1.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>keys</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>index</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>getEnv</color><color=#f8f8f2>(),</color>
                <color=#e6db74>"Failed to reposition cursor during "</color> <color=#f92672>+</color> <color=#e6db74>"mutation of a BIN delta to a full BIN"</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>index</color> <color=#f92672>&=</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>;</color>

          <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>index</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>setIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f92672>++</color><color=#f8f8f2>i</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>lazyCompress</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>compactMemory</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>getInListResident</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>().</color><color=#a6e22e>updateBINDeltaStat</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>fetchFullBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>getLastFullLsn</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>getEntryHandleFileNotFound</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentFailureException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>e</color><color=#f8f8f2>.</color><color=#a6e22e>addErrorMessage</color><color=#f8f8f2>(</color><color=#f8f8f2>makeFetchErrorMsg</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>));</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>RuntimeException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_INTEGRITY</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>makeFetchErrorMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>(),</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>),</color>
          <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Replaces the contents of this BIN with the contents of the given BIN, including lsns, states,</color>
<color=#75715e>   * keys and targets. Key prefixing and key/target representations will also be those of the given</color>
<color=#75715e>   * BIN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>resetContent</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>other</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>updateRepCacheStats</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>nEntries</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>nEntries</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>baseFileNumber</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>baseFileNumber</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>entryLsnByteArray</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>entryLsnByteArray</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>entryLsnLongArray</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>entryLsnLongArray</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>keyPrefix</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>keyPrefix</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>entryKeys</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>entryKeys</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>entryTargets</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>entryTargets</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>entryStates</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>entryStates</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>lastLoggedSizes</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>lastLoggedSizes</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>expirationValues</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>expirationValues</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>expirationBase</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>expirationBase</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>offHeapLNIds</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>getOffHeapLruId</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>hasOffHeapLNs</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>vlsnCache</color> <color=#f92672>=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>vlsnCache</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>bloomFilter</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>updateMemorySize</color><color=#f8f8f2>(</color><color=#f8f8f2>inMemorySize</color><color=#f8f8f2>,</color> <color=#f8f8f2>computeMemorySize</color><color=#f8f8f2>());</color>

    <color=#f8f8f2>updateRepCacheStats</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>newCapacity</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>newCapacity</color> <color=#f92672>>=</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>updateRepCacheStats</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entryLsnByteArray</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>entryLsnByteArray</color> <color=#f92672>=</color> <color=#f8f8f2>Arrays</color><color=#f8f8f2>.</color><color=#a6e22e>copyOfRange</color><color=#f8f8f2>(</color><color=#f8f8f2>entryLsnByteArray</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>newCapacity</color> <color=#f92672>*</color> <color=#ae81ff>4</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entryLsnLongArray</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>entryLsnLongArray</color> <color=#f92672>=</color> <color=#f8f8f2>Arrays</color><color=#f8f8f2>.</color><color=#a6e22e>copyOfRange</color><color=#f8f8f2>(</color><color=#f8f8f2>entryLsnLongArray</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>newCapacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entryStates</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>entryStates</color> <color=#f92672>=</color> <color=#f8f8f2>Arrays</color><color=#f8f8f2>.</color><color=#a6e22e>copyOfRange</color><color=#f8f8f2>(</color><color=#f8f8f2>entryStates</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>newCapacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>entryKeys</color> <color=#f92672>=</color> <color=#f8f8f2>entryKeys</color><color=#f8f8f2>.</color><color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>newCapacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>entryTargets</color> <color=#f92672>=</color> <color=#f8f8f2>entryTargets</color><color=#f8f8f2>.</color><color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>newCapacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>lastLoggedSizes</color> <color=#f92672>=</color> <color=#f8f8f2>lastLoggedSizes</color><color=#f8f8f2>.</color><color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>newCapacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>expirationValues</color> <color=#f92672>=</color> <color=#f8f8f2>expirationValues</color><color=#f8f8f2>.</color><color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>newCapacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>offHeapLNIds</color> <color=#f92672>=</color> <color=#f8f8f2>offHeapLNIds</color><color=#f8f8f2>.</color><color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>newCapacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>vlsnCache</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnCache</color><color=#f8f8f2>.</color><color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>newCapacity</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>updateMemorySize</color><color=#f8f8f2>(</color><color=#f8f8f2>inMemorySize</color><color=#f8f8f2>,</color> <color=#f8f8f2>computeMemorySize</color><color=#f8f8f2>());</color>

    <color=#f8f8f2>updateRepCacheStats</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Create a BIN by fetching its most recent full version from the log and applying to it the</color>
<color=#75715e>   * deltas in this BIN delta. The new BIN is not added to the INList or the BTree.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Called from DiskOrderedScanner.fetchAndProcessBINs() and DiskOrderedScanner.accumulateLNs()</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the full BIN with deltas applied.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>reconstituteBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>fullBIN</color> <color=#f92672>=</color> <color=#f8f8f2>fetchFullBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>reconstituteBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*leaveFreeSlot*/</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Given a full version BIN, apply to it the deltas in this BIN delta. The fullBIN will then be</color>
<color=#75715e>   * complete, but its memory will not be compacted.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Called from mutateToFullBIN() above and from SortedLSNTreewalker.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param leaveFreeSlot should be true if a slot will be inserted into the resulting full BIN,</color>
<color=#75715e>   *     without first checking whether the full BIN must be split, and performing the split if</color>
<color=#75715e>   *     necessary. If this param is true, the returned BIN will contain at least one free slot. If</color>
<color=#75715e>   *     this param is false, a BIN with no free slots may be returned. For example, it is important</color>
<color=#75715e>   *     that false is passed when a split will be performed, since if true were passed, the BIN</color>
<color=#75715e>   *     would grow beyond its bounds unnecessarily.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>reconstituteBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>leaveFreeSlot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>setDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>databaseImpl</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>setDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>()</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>hasOffHeapLNs</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The BIN's lastFullLsn is set here, while its lastLoggedLsn is</color>
<color=#75715e>       * set by postFetchInit or postRecoveryInit.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>setLastFullLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>getLastFullLsn</color><color=#f8f8f2>());</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Compress the full BIN before applying deltas, to handle the</color>
<color=#75715e>       * following scenario: Non-dirty slots were compressed away</color>
<color=#75715e>       * earlier, leaving room for inserted records, and a delta was</color>
<color=#75715e>       * logged with the inserted records. The full version of the BIN</color>
<color=#75715e>       * (after compression) was not logged, because the BIN is not</color>
<color=#75715e>       * dirtied when non-dirty slots were compressed away. If we don't</color>
<color=#75715e>       * compress here, there may not be room in the original BIN for the</color>
<color=#75715e>       * slots inserted when applying the deltas.</color>
<color=#75715e>       *</color>
<color=#75715e>       * However, during recovery we can't compress because locking is</color>
<color=#75715e>       * not used during recovery, and the compressor may delete a slot</color>
<color=#75715e>       * for a record that is part of an active transaction. In addition,</color>
<color=#75715e>       * even when compression is performed here, it is possible that it</color>
<color=#75715e>       * doesn't compress all deleted/expired slots that were compressed</color>
<color=#75715e>       * originally in the scenario described, for one of the following</color>
<color=#75715e>       * reasons:</color>
<color=#75715e>       *</color>
<color=#75715e>       *  + The record is locked temporarily by a read operation that</color>
<color=#75715e>       *    will skip the record. Note that the compressor uses</color>
<color=#75715e>       *    non-blocking locking.</color>
<color=#75715e>       *</color>
<color=#75715e>       *  + If expiration has been disabled, or the system clock has been</color>
<color=#75715e>       *    changed, slots that were expired originally may not be</color>
<color=#75715e>       *    expired now.</color>
<color=#75715e>       *</color>
<color=#75715e>       * Therefore, in all cases we enlarge the BIN if necessary to hold</color>
<color=#75715e>       * all slots to be inserted when applying the delta. An extra slot</color>
<color=#75715e>       * is added if leaveFreeSlot is true, to handle cases</color>
<color=#75715e>       * where mutation to a full BIN is performed after calling</color>
<color=#75715e>       * Tree.searchSplitsAllowed, or one of the methods that calls it</color>
<color=#75715e>       * such as Tree.findBinForInsert and Tree.getParentBINForChildLN.</color>
<color=#75715e>       * If the search returns a BIN-delta without splitting, and then we</color>
<color=#75715e>       * must mutate to full BIN in order to insert, because blind</color>
<color=#75715e>       * insertions do not apply, then the scenario described can occur.</color>
<color=#75715e>       *</color>
<color=#75715e>       * If the BIN is enlarged, we add it to the compressor queue so it</color>
<color=#75715e>       * will be shrunk back down to the Database's configured maxEntries</color>
<color=#75715e>       * during normal compression.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>isInInit</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>compress</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*compressDirtySlots*/</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/*localTracker*/</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>nInsertions</color> <color=#f92672>=</color> <color=#f8f8f2>leaveFreeSlot</color> <color=#f92672>?</color> <color=#ae81ff>1</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>foundIndex</color> <color=#f92672>=</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>nInsertions</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxEntries</color> <color=#f92672>=</color> <color=#f8f8f2>nInsertions</color> <color=#f92672>+</color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>maxEntries</color> <color=#f92672>></color> <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>getMaxEntries</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>maxEntries</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>addToCompressorQueue</color><color=#f8f8f2>(</color><color=#f8f8f2>fullBIN</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Process each delta. */</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>isDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#66d9ef>this</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>applyDelta</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>getData</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>getState</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>getLastLoggedSize</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>getCachedVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
            <color=#f8f8f2>isExpirationInHours</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The applied deltas will leave some slots dirty, which is</color>
<color=#75715e>       * necessary as a record of changes that will be included in the</color>
<color=#75715e>       * next delta.  However, the BIN itself should not be dirty,</color>
<color=#75715e>       * because this delta is a persistent record of those changes.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>setDirty</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>fullBIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Apply (insert, update) a given delta slot in this full BIN. Note: also called from OldBINDelta</color>
<color=#75715e>   * class.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>applyDelta</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color> <color=#f8f8f2>state</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>ohLnId</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Node</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The delta is the authoritative version of the entry. In all cases,</color>
<color=#75715e>     * it should supersede the entry in the full BIN.  This is true even if</color>
<color=#75715e>     * the BIN Delta's entry is knownDeleted or if the full BIN's version</color>
<color=#75715e>     * is knownDeleted. Therefore we use the flavor of findEntry that will</color>
<color=#75715e>     * return a knownDeleted entry if the entry key matches (i.e. true,</color>
<color=#75715e>     * false) but still indicates exact matches with the return index.</color>
<color=#75715e>     * findEntry only returns deleted entries if third arg is false, but we</color>
<color=#75715e>     * still need to know if it's an exact match or not so indicateExact is</color>
<color=#75715e>     * true.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>foundIndex</color> <color=#f92672>=</color> <color=#f8f8f2>findEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color> <color=#f92672>>=</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>foundIndex</color> <color=#f92672>&=</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>EXACT_MATCH</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The entry exists in the full version, update it with the delta</color>
<color=#75715e>       * info.  Note that all state flags should be restored [#22848].</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>applyDeltaSlot</color><color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>state</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The entry doesn't exist, insert the delta entry. We insert the</color>
<color=#75715e>       * entry even when it is known or pending deleted, since the</color>
<color=#75715e>       * deleted (and dirty) entry will be needed to log the next delta.</color>
<color=#75715e>       * [#20737]</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>insertEntry1</color><color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>state</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*blindInsertion*/</color><color=#f8f8f2>);</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color> <color=#f92672>&</color> <color=#f8f8f2>INSERT_SUCCESS</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>foundIndex</color> <color=#f92672>=</color> <color=#f8f8f2>result</color> <color=#f92672>&</color> <color=#f92672>~</color><color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>INSERT_SUCCESS</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>setLastLoggedSizeUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLoggedSize</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>setCachedVLSNUnconditional</color><color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>setOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>ohLnId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>setExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>foundIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>expiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>expirationInHours</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * DbStat support.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>void</color> <color=#a6e22e>accumulateStats</color><color=#f8f8f2>(</color><color=#f8f8f2>TreeWalkerStatsAccumulator</color> <color=#f8f8f2>acc</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>acc</color><color=#f8f8f2>.</color><color=#a6e22e>processBIN</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>valueOf</color><color=#f8f8f2>(</color><color=#f8f8f2>getNodeId</color><color=#f8f8f2>()),</color> <color=#f8f8f2>getLevel</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>