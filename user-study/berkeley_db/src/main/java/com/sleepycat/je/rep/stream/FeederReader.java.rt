<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>
<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.rep.stream</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentFailureException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentFailureReason</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.vlsn.VLSNIndex</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.vlsn.VLSNIndex.ForwardVLSNScanner</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.vlsn.VLSNIndex.WaitTimeOutException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.vlsn.VLSNRange</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.DbLsn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.VLSN</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.io.FileNotFoundException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.io.IOException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.nio.ByteBuffer</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * The FeederReader is a flavor of VLSNReader which supports replication stream feeding. It assumes</color>
<color=#75715e> * that reading will always go forward in the log. Special features are:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- The reader can read either from a log buffer or from the file. Sometimes log entries are</color>
<color=#75715e> * logged but are not yet available on disk. In general, it's better to read from the log buffers</color>
<color=#75715e> * rather then the file.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- The reader can block for a given time period, waiting for the next vlsn to appear</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>FeederReader</color> <color=#66d9ef>extends</color> <color=#f8f8f2>VLSNReader</color> <color=#f8f8f2>{</color>

  <color=#75715e>/* The scanner is a cursor over the VLSNIndex. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ForwardVLSNScanner</color> <color=#f8f8f2>scanner</color><color=#f8f8f2>;</color>

  <color=#75715e>/* The reader has never been used before, it needs to be initialized. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>initDone</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * A constantly resetting counter of hits in the log item cache. This</color>
<color=#75715e>   * serves as state that lets the FeederReader know that its position in the</color>
<color=#75715e>   * log files might have become stale, due to cache hits. Because it's reset</color>
<color=#75715e>   * midstream, it is not an accurate statistics for cache hits.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>prevCacheHits</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * If true, the FeederReader will always read directly from the log, and</color>
<color=#75715e>   * will not use the vlsnIndex LogItem cache. Should only be used for</color>
<color=#75715e>   * unit tests!</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>bypassCache</color><color=#f8f8f2>;</color>

  <color=#66d9ef>public</color> <color=#a6e22e>FeederReader</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSNIndex</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>this</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*bypassCache*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @param bypassCache For unit testing only!! Bypass the VLSNIndex cache. */</color>
  <color=#f8f8f2>FeederReader</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>VLSNIndex</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>bypassCache</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>super</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>,</color>
        <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#75715e>// forward</color>
        <color=#f8f8f2>startLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color> <color=#75715e>// finishLsn</color>

    <color=#f8f8f2>scanner</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ForwardVLSNScanner</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>);</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>bypassCache</color> <color=#f92672>=</color> <color=#f8f8f2>bypassCache</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Use a ReadWindow which can read from LogBuffers as well as the physical file.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>protected</color> <color=#f8f8f2>ReadWindow</color> <color=#a6e22e>makeWindow</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>SwitchWindow</color><color=#f8f8f2>(</color><color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Set up the FeederReader to start scanning from this VLSN. If we find a mapping for this VLSN,</color>
<color=#75715e>   * we'll start precisely at its LSN, else we'll have to start from an earlier location. This</color>
<color=#75715e>   * initialization can't be done in the constructor, because the Feeder is set up to require the</color>
<color=#75715e>   * construction of the source before we know where to start.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws IOException</color>
<color=#75715e>   * @return the startLsn</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>initScan</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>startVLSN</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>startVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"startVLSN can't be null"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>currentRange</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>startPoint</color> <color=#f92672>=</color> <color=#f8f8f2>startVLSN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentRange</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>startVLSN</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * When feeding, we may be starting at the VLSN following the last</color>
<color=#75715e>       * VLSN in the node.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>startPoint</color> <color=#f92672>=</color> <color=#f8f8f2>currentRange</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>startLsn</color> <color=#f92672>=</color> <color=#f8f8f2>scanner</color><color=#f8f8f2>.</color><color=#a6e22e>getStartingLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>startPoint</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>startLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>initAtFileStart</color><color=#f8f8f2>(</color><color=#f8f8f2>startLsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nextEntryOffset</color> <color=#f92672>=</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>getEndOffset</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>currentVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>startVLSN</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>initDone</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Get file number of the last log entry returned. */</color>
  <color=#66d9ef>long</color> <color=#a6e22e>getLastFile</color><color=#f8f8f2>(</color><color=#f8f8f2>OutputWireRecord</color> <color=#f8f8f2>record</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#75715e>/*</color>
<color=#75715e>     * If the record has a LogItem (from the tip cache), then its LSN is</color>
<color=#75715e>     * the most current log position.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>record</color><color=#f8f8f2>.</color><color=#a6e22e>getLogItemLSN</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#75715e>/* Otherwise, the current log position is the FileReader position. */</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Forward scanning for feeding the replica: get the log record for this VLSN. If the log record</color>
<color=#75715e>   * hasn't been created yet, wait for a period specified by "waitTime".</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Where possible, the FeederReader fetches the log record from the cache within the VLSNIndex.</color>
<color=#75715e>   * (See the VLSNIndex for a description of this two level cache). If the requested VLSN is not</color>
<color=#75715e>   * available from the cache, the reader fetches the item from the JE log -- either from the log</color>
<color=#75715e>   * buffers or from disk.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The FeederReader is like a cursor on the log, and retains a position in the log. When there</color>
<color=#75715e>   * are log item cache hits, the FeederReader's position can fall behind, because it is being</color>
<color=#75715e>   * bypassed. It is possible for log cleaning to take place between the point of the FeederReader's</color>
<color=#75715e>   * stale position and the end of the log. If so, the FeederReader must not attempt to scan from</color>
<color=#75715e>   * its current position, because it might run afoul of gap created by the cleaned and delete log</color>
<color=#75715e>   * files. When there have been log item cache hits, the FeederReader must jump its position</color>
<color=#75715e>   * forward using the vlsnIndex mappings to safely skip over any cleaned gaps in the log.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>OutputWireRecord</color> <color=#a6e22e>scanForwards</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>waitTime</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>InterruptedException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>initDone</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>LogItem</color> <color=#f8f8f2>logItem</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>logItem</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>waitForVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>waitTime</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>WaitTimeOutException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* This vlsn not yet available */</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>currentVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>logItem</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bypassCache</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#75715e>/* We've found the requested log item in the cache. */</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>header</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>prevCacheHits</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>OutputWireRecord</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We must go to the log for this requested VLSN. Use the VLSNIndex for</color>
<color=#75715e>     * the closest position in the log file to find the next replicated log</color>
<color=#75715e>     * entry.</color>
<color=#75715e>     *</color>
<color=#75715e>     * If there are no cache hits and the reader has been supplying log</color>
<color=#75715e>     * entries sequentially, we know that it is already positioned at the</color>
<color=#75715e>     * immediately preceding log entry and that we can scan from there to</color>
<color=#75715e>     * the current requested record. In that case, we are only hoping that</color>
<color=#75715e>     * the VLSNIndex can supply the exact location of the current requested</color>
<color=#75715e>     * record in order to reduce the scanning.</color>
<color=#75715e>     *</color>
<color=#75715e>     * If there have been cache hits, the reader's current position is some</color>
<color=#75715e>     * unknown distance back. In that case, scanning from the current</color>
<color=#75715e>     * position could run into a cleaned gap in the log files, and could</color>
<color=#75715e>     * fail. Because of that, we must reposition to a VLSN that is <= to</color>
<color=#75715e>     * the current requested VLSN. We know that such a VLSN must exist and</color>
<color=#75715e>     * have a valid lsn mapping, because the begin and end point in the</color>
<color=#75715e>     * vlsn range always exists.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>repositionLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevCacheHits</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>repositionLsn</color> <color=#f92672>=</color> <color=#f8f8f2>scanner</color><color=#f8f8f2>.</color><color=#a6e22e>getApproximateLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Guard against sliding the window backwards. This could happen if</color>
<color=#75715e>       * by dint of previous scans, the reader is fortuitously positioned</color>
<color=#75715e>       * at a point in the log that is before the current target VLSN,</color>
<color=#75715e>       * but after any available mappings. For example, suppose the</color>
<color=#75715e>       * VLSNIndex has VLSNs 10, 50, 100. Suppose the reader is</color>
<color=#75715e>       * positioned at VLSN 20, and we have supplied VLSNs 21->40 from</color>
<color=#75715e>       * the cache.  VLSN 41 has not hit in the cache, and we must fetch</color>
<color=#75715e>       * the log record from disk. We do not want to slide the</color>
<color=#75715e>       * FeederReader from its current position at 21 back to VLSN 10.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>getLastLsn</color><color=#f8f8f2>(),</color> <color=#f8f8f2>repositionLsn</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>repositionLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>repositionLsn</color> <color=#f92672>=</color> <color=#f8f8f2>scanner</color><color=#f8f8f2>.</color><color=#a6e22e>getPreciseLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We're going to start scanning, so reset the prevCacheHits field, and</color>
<color=#75715e>     * position the reader at the optimal spot.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>prevCacheHits</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* setPosition is a noop if repositionLsn is null. */</color>
      <color=#f8f8f2>setPosition</color><color=#f8f8f2>(</color><color=#f8f8f2>repositionLsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>ChecksumException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_CHECKSUM</color><color=#f8f8f2>,</color>
          <color=#e6db74>"trying to reposition FeederReader to "</color>
              <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>repositionLsn</color><color=#f8f8f2>)</color>
              <color=#f92672>+</color> <color=#e6db74>" prevWindow="</color>
              <color=#f92672>+</color> <color=#f8f8f2>window</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>FileNotFoundException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_FILE_NOT_FOUND</color><color=#f8f8f2>,</color>
          <color=#e6db74>"Trying to reposition FeederReader to "</color>
              <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>repositionLsn</color><color=#f8f8f2>)</color>
              <color=#f92672>+</color> <color=#e6db74>" for vlsn:"</color>
              <color=#f92672>+</color> <color=#f8f8f2>vlsn</color>
              <color=#f92672>+</color> <color=#e6db74>" prevWindow="</color>
              <color=#f92672>+</color> <color=#f8f8f2>window</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>readNextEntry</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>currentFeedRecord</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
        <color=#e6db74>"VLSN="</color> <color=#f92672>+</color> <color=#f8f8f2>vlsn</color> <color=#f92672>+</color> <color=#e6db74>" repositionLsn = "</color> <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>repositionLsn</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#f8f8f2>window</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * @throw an EnvironmentFailureException if we were scanning for a particular VLSN and we have</color>
<color=#75715e>   *     passed it by.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>checkForPassingTarget</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>compareResult</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>compareResult</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Hey, we passed the VLSN we wanted. */</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"want to read "</color> <color=#f92672>+</color> <color=#f8f8f2>currentVLSN</color> <color=#f92672>+</color> <color=#e6db74>" but reader at "</color> <color=#f92672>+</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Return true if this entry is replicated and its VLSN is currentVLSN. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isTargetEntry</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>nScanned</color><color=#f92672>++</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>isInvisible</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entryIsReplicated</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>VLSN</color> <color=#f8f8f2>entryVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>();</color>

      <color=#66d9ef>int</color> <color=#f8f8f2>compareResult</color> <color=#f92672>=</color> <color=#f8f8f2>entryVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>currentVLSN</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>checkForPassingTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>compareResult</color><color=#f8f8f2>);</color>

      <color=#75715e>/* return true if this is the entry we want. */</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>compareResult</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** The SwitchWindow can fill itself from either the log file or the log buffers. */</color>
  <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>SwitchWindow</color> <color=#66d9ef>extends</color> <color=#f8f8f2>ReadWindow</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LogManager</color> <color=#f8f8f2>logManager</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>SwitchWindow</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>logManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Reposition to the specified file, and fill starting at</color>
<color=#75715e>     * targetOffset. For this use case, we are always going forwards, and</color>
<color=#75715e>     * windowStartOffset should == targetOffset. Position the window's</color>
<color=#75715e>     * buffer to point at the log entry indicated by targetOffset</color>
<color=#75715e>     */</color>
    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>slideAndFill</color><color=#f8f8f2>(</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>windowFileNum</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>windowStartOffset</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>)</color>
        <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>FileNotFoundException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>fillFromLogBuffer</color><color=#f8f8f2>(</color><color=#f8f8f2>windowFileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* The entry was not in the LogBufferPool. */</color>
        <color=#66d9ef>super</color><color=#f8f8f2>.</color><color=#a6e22e>slideAndFill</color><color=#f8f8f2>(</color><color=#f8f8f2>windowFileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>windowStartOffset</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>,</color> <color=#f8f8f2>forward</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Fill the read window's buffer from a LogBuffer.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return true if the read window was filled.</color>
<color=#75715e>     * @throws DatabaseException</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>fillFromLogBuffer</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>windowFileNum</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>)</color>
        <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>LogBuffer</color> <color=#f8f8f2>logBuffer</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>fileLocation</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>windowFileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>logBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>logManager</color><color=#f8f8f2>.</color><color=#a6e22e>getReadBufferByLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>fileLocation</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logBuffer</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Copy at much as we can of the logBuffer into the window's</color>
<color=#75715e>         * readBuffer. We don't call ByteBuffer.put(ByteBuffer) because</color>
<color=#75715e>         * the logBuffer may be larger than the window readBuffer, and</color>
<color=#75715e>         * we don't want to get an overflow. Instead, we convert to an</color>
<color=#75715e>         * array and carefully size the copy. A LogBuffer is positioned</color>
<color=#75715e>         * for writing, and hasn't yet been flipped.  LogManager.get()</color>
<color=#75715e>         * does an absolute retrieval of bytes from the buffer, because</color>
<color=#75715e>         * it knows that the log entry exists, and is only reading one</color>
<color=#75715e>         * entry. We need to flip the buffer, because we don't know</color>
<color=#75715e>         * apriori how much is in the buffer, and we want to scan it.</color>
<color=#75715e>         */</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Put the logBuffer's contents into wholeContents, and</color>
<color=#75715e>         * position wholeContents at the desired target offset. If</color>
<color=#75715e>         * this logBuffer had been the currentWriteBuffer, it's</color>
<color=#75715e>         * positioned for writing and must be flipped for reading.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>wholeContents</color> <color=#f92672>=</color> <color=#f8f8f2>logBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>getDataBuffer</color><color=#f8f8f2>().</color><color=#a6e22e>duplicate</color><color=#f8f8f2>();</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>wholeContents</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>wholeContents</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>firstOffset</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>logBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>getFirstLsn</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>wholeContents</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>((</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetOffset</color> <color=#f92672>-</color> <color=#f8f8f2>firstOffset</color><color=#f8f8f2>));</color>

        <color=#75715e>/* Make a buffer which starts at target. */</color>
        <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>startAtTarget</color> <color=#f92672>=</color> <color=#f8f8f2>wholeContents</color><color=#f8f8f2>.</color><color=#a6e22e>slice</color><color=#f8f8f2>();</color>
        <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>startAtTarget</color><color=#f8f8f2>.</color><color=#a6e22e>array</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>availableContentLen</color> <color=#f92672>=</color> <color=#f8f8f2>startAtTarget</color><color=#f8f8f2>.</color><color=#a6e22e>limit</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>copyLength</color> <color=#f92672>=</color>
            <color=#f8f8f2>(</color><color=#f8f8f2>availableContentLen</color> <color=#f92672>></color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>capacity</color><color=#f8f8f2>())</color>
                <color=#f92672>?</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>capacity</color><color=#f8f8f2>()</color>
                <color=#f8f8f2>:</color> <color=#f8f8f2>availableContentLen</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>startAtTarget</color><color=#f8f8f2>.</color><color=#a6e22e>arrayOffset</color><color=#f8f8f2>(),</color> <color=#f8f8f2>copyLength</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>

        <color=#75715e>/* LogBuffers were just written and use the current version. */</color>
        <color=#f8f8f2>setFileNum</color><color=#f8f8f2>(</color><color=#f8f8f2>windowFileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_VERSION</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>startOffset</color> <color=#f92672>=</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>endOffset</color> <color=#f92672>=</color> <color=#f8f8f2>startOffset</color> <color=#f92672>+</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>limit</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logBuffer</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>logBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Fill up the read buffer with more data, moving along to the following file (next largest</color>
<color=#75715e>     * number) if needed. Unlike other file readers, we are reading log files that are concurrently</color>
<color=#75715e>     * growing, so this read window must also know to look in the log buffers.</color>
<color=#75715e>     *</color>
<color=#75715e>     * <p>The contract between the feeder reader and the VLSNIndex lets us assume that the feeder</color>
<color=#75715e>     * reader is only active when it is sure that there is more data available somewhere -- whether</color>
<color=#75715e>     * it's in the log buffers, write queue, or on disk.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return true if the fill moved us to a new file.</color>
<color=#75715e>     * @see ReadWindow#fillNext</color>
<color=#75715e>     */</color>
    <color=#a6e22e>@Override</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>boolean</color> <color=#a6e22e>fillNext</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>singleFile</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>)</color>
        <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color><color=#f8f8f2>,</color> <color=#f8f8f2>EOFException</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The SwitchReadWindow should only be used for feeding, and</color>
<color=#75715e>       * singleFile should never be true.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>singleFile</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>adjustReadBufferSize</color><color=#f8f8f2>(</color><color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Try to fill the window by asking for the next offset from</color>
<color=#75715e>       * the log buffers.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fillFromLogBuffer</color><color=#f8f8f2>(</color><color=#f8f8f2>currentFileNum</color><color=#f8f8f2>(),</color> <color=#f8f8f2>endOffset</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Didn't move to a new file. */</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If that didn't work, there are these possible reasons why:</color>
<color=#75715e>       * a - it's a valid offset, but it's no longer in a log buffer, it</color>
<color=#75715e>       *     was written to disk.</color>
<color=#75715e>       * b - it's not a valid offset, because the log file flipped.</color>
<color=#75715e>       * In both cases, go to the FileManager and see if there's more log</color>
<color=#75715e>       * to be found.</color>
<color=#75715e>       */</color>

      <color=#f8f8f2>FileHandle</color> <color=#f8f8f2>fileHandle</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* Get a file handle to read in more log. */</color>
        <color=#f8f8f2>fileHandle</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFileHandle</color><color=#f8f8f2>(</color><color=#f8f8f2>currentFileNum</color><color=#f8f8f2>());</color>

        <color=#75715e>/* Attempt to read more from this file. */</color>
        <color=#f8f8f2>startOffset</color> <color=#f92672>=</color> <color=#f8f8f2>endOffset</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fillFromFile</color><color=#f8f8f2>(</color><color=#f8f8f2>fileHandle</color><color=#f8f8f2>,</color> <color=#f8f8f2>startOffset</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * Successfully filled the read buffer, but didn't move to</color>
<color=#75715e>           * a new file.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>fileHandle</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

        <color=#75715e>/* This file is done -- can we read in the next file? */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>singleFile</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Remember that the nextFile may not be fileNum + 1 if</color>
<color=#75715e>         * there has been log cleaning.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>Long</color> <color=#f8f8f2>nextFile</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFollowingFileNum</color><color=#f8f8f2>(</color><color=#f8f8f2>currentFileNum</color><color=#f8f8f2>(),</color> <color=#66d9ef>true</color> <color=#75715e>/* forward */</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * But if there's no next file, let's assume that the desired</color>
<color=#75715e>         * data is still in the log buffers, and the next lsn is the</color>
<color=#75715e>         * first entry in the subsequent file number.  Start the read</color>
<color=#75715e>         * from the first real log entry, because the file header entry</color>
<color=#75715e>         * is not in the log buffers.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>nextFile</color> <color=#f92672>=</color> <color=#f8f8f2>currentFileNum</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fillFromLogBuffer</color><color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color><color=#f8f8f2>,</color> <color=#f8f8f2>FileManager</color><color=#f8f8f2>.</color><color=#a6e22e>firstLogEntryOffset</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * We filled the read buffer, and jumped to a new</color>
<color=#75715e>           * file.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Didn't find the next bytes in the log buffer, go look on</color>
<color=#75715e>         * disk.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>fileHandle</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFileHandle</color><color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>setFileNum</color><color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color><color=#f8f8f2>,</color> <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>getLogVersion</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>startOffset</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>moreData</color> <color=#f92672>=</color> <color=#f8f8f2>fillFromFile</color><color=#f8f8f2>(</color><color=#f8f8f2>fileHandle</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>moreData</color> <color=#f8f8f2>:</color> <color=#e6db74>"FeederReader should find more data in next file"</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>IOException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>e</color><color=#f8f8f2>.</color><color=#a6e22e>printStackTrace</color><color=#f8f8f2>();</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedException</color><color=#f8f8f2>(</color>
            <color=#e6db74>"Problem in ReadWindow.fill, reading from  = "</color> <color=#f92672>+</color> <color=#f8f8f2>currentFileNum</color><color=#f8f8f2>(),</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fileHandle</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For debugging */</color>
  <color=#f8f8f2>String</color> <color=#a6e22e>dumpState</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#e6db74>"prevCacheHits="</color> <color=#f92672>+</color> <color=#f8f8f2>prevCacheHits</color> <color=#f92672>+</color> <color=#e6db74>" "</color> <color=#f92672>+</color> <color=#f8f8f2>window</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>