<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.log</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentFailureException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DbConfigManager</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentFailureReason</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.DbLsn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.LoggerUtils</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.io.FileNotFoundException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.nio.ByteBuffer</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Logger</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * A FileReader is an abstract class that traverses the log files, reading-in chunks of the file at</color>
<color=#75715e> * a time. The class provides a iterator interface, via its readNextEntry() method. Concrete</color>
<color=#75715e> * subclasses must (a) provide the public methods that allow their users to examine the contents of</color>
<color=#75715e> * the logrec that the iterator is currently positioned at, and (b) implement the (non-public)</color>
<color=#75715e> * isTarget() and processEntry() methods that may filter-out logrecs that do not need to be seen by</color>
<color=#75715e> * the caller of readNextEntry(), or perform specific actions before each logrec is "returned" to</color>
<color=#75715e> * the caller of readNextEntry().</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>abstract</color> <color=#66d9ef>class</color> <color=#a6e22e>FileReader</color> <color=#f8f8f2>{</color>

  <color=#66d9ef>protected</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>

  <color=#66d9ef>protected</color> <color=#66d9ef>final</color> <color=#f8f8f2>FileManager</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The ReadWindow is a data buffer that acts as a sliding window view</color>
<color=#75715e>   * of the log. It is positioned against the log and filled up with data.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>final</color> <color=#f8f8f2>ReadWindow</color> <color=#f8f8f2>window</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * For piecing together a log entry that is read from multiple read buffer</color>
<color=#75715e>   * calls.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>saveBuffer</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>singleFile</color><color=#f8f8f2>;</color> <color=#75715e>// if true, do not read across files</color>

  <color=#75715e>/*</color>
<color=#75715e>   * true if at end of the log.</color>
<color=#75715e>   * TODO: assess whether this is redundant  with the EOFException, and</color>
<color=#75715e>   * could be streamlined.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>eof</color><color=#f8f8f2>;</color>

  <color=#75715e>/* if true, we're reading forward; otherwise backwards */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>;</color>

  <color=#75715e>/* num entries we've seen */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>nRead</color><color=#f8f8f2>;</color>

  <color=#75715e>/* The log entry header for the entry that was just read. */</color>
  <color=#66d9ef>protected</color> <color=#f8f8f2>LogEntryHeader</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The log entry before the current entry. In general,</color>
<color=#75715e>   * currentEntryPrevOffset is the same as</color>
<color=#75715e>   * currentEntryHeader.getPrevOffset(), but it's initialized and used before</color>
<color=#75715e>   * a header is read. Only used for backward scanning.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * nextEntryOffset is used to set the currentEntryOffset after we've read</color>
<color=#75715e>   * an entry. Only used for forward scanning.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#f8f8f2>currentEntryOffset</color><color=#f8f8f2>;</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#f8f8f2>nextEntryOffset</color><color=#f8f8f2>;</color>

  <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>;</color> <color=#75715e>// We start reading from this LSN.</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>finishLsn</color><color=#f8f8f2>;</color> <color=#75715e>// If going backwards, read up to this LSN.</color>

  <color=#75715e>/* For checking checksum on the read. */</color>
  <color=#66d9ef>protected</color> <color=#f8f8f2>ChecksumValidator</color> <color=#f8f8f2>cksumValidator</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>doChecksumOnRead</color><color=#f8f8f2>;</color> <color=#75715e>// Validate checksums</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>alwaysValidateChecksum</color><color=#f8f8f2>;</color> <color=#75715e>// Validate for all entry types</color>

  <color=#66d9ef>protected</color> <color=#66d9ef>final</color> <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * A FileReader just needs to know what size chunks to read in.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param endOfFileLsn indicates the end of the log file</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>FileReader</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Long</color> <color=#f8f8f2>singleFileNumber</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>endOfFileLsn</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>finishLsn</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>fileManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>();</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>singleFile</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>singleFileNumber</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>forward</color> <color=#f92672>=</color> <color=#f8f8f2>forward</color><color=#f8f8f2>;</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>doChecksumOnRead</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>getChecksumOnRead</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>doChecksumOnRead</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>cksumValidator</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ChecksumValidator</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>window</color> <color=#f92672>=</color> <color=#f8f8f2>makeWindow</color><color=#f8f8f2>(</color><color=#f8f8f2>readBufferSize</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>saveBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>allocate</color><color=#f8f8f2>(</color><color=#f8f8f2>readBufferSize</color><color=#f8f8f2>);</color>

    <color=#75715e>/* stats */</color>
    <color=#f8f8f2>nRead</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Determine the starting position. */</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>startLsn</color> <color=#f92672>=</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>finishLsn</color> <color=#f92672>=</color> <color=#f8f8f2>finishLsn</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>logger</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>initStartingPosition</color><color=#f8f8f2>(</color><color=#f8f8f2>endOfFileLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>singleFileNumber</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * May be overridden by other FileReaders.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#f8f8f2>ReadWindow</color> <color=#a6e22e>makeWindow</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>ReadWindow</color><color=#f8f8f2>(</color><color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Helper for determining the starting position and opening up a file at the desired location. */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>void</color> <color=#a6e22e>initStartingPosition</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>endOfFileLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>Long</color> <color=#f8f8f2>ignoreSingleFileNumber</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>eof</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Start off at the startLsn. If that's null, start at the</color>
<color=#75715e>       * beginning of the log. If there are no log files, set eof.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>startLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>initAtFileStart</color><color=#f8f8f2>(</color><color=#f8f8f2>startLsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>Long</color> <color=#f8f8f2>firstNum</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFirstFileNum</color><color=#f8f8f2>();</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstNum</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>eof</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>initAtFileStart</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>firstNum</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * After we read the first entry, the currentEntry will point here.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>nextEntryOffset</color> <color=#f92672>=</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>getEndOffset</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Make the read buffer look like it's positioned off the end of</color>
<color=#75715e>       * the file. Initialize the first LSN we want to read. When</color>
<color=#75715e>       * traversing the log backwards, we always start at the very end.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>startLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>initAtFileStart</color><color=#f8f8f2>(</color><color=#f8f8f2>endOfFileLsn</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * currentEntryPrevOffset points to the entry we want to start out</color>
<color=#75715e>       * reading when going backwards. If it's 0, the entry we want to</color>
<color=#75715e>       * read is in a different file.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>startLsn</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>endOfFileLsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>currentEntryPrevOffset</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>startLsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>currentEntryPrevOffset</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>currentEntryOffset</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>endOfFileLsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Whether to always validate the checksum, even for non-target entries. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setAlwaysValidateChecksum</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>validate</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>alwaysValidateChecksum</color> <color=#f92672>=</color> <color=#f8f8f2>validate</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return the number of entries processed by this reader. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getNumRead</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nRead</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Get LSN of the last entry read. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getLastLsn</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>(),</color> <color=#f8f8f2>currentEntryOffset</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns the total size (including header) of the last entry read. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getLastEntrySize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getEntrySize</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Scans the log files until either it has reached the end of the log or has hit an invalid</color>
<color=#75715e>   * portion.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if an element has been read, false at end-of-log.</color>
<color=#75715e>   * @throws EnvironmentFailureException if a ChecksumException, FileNotFoundException, or another</color>
<color=#75715e>   *     internal problem occurs.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>readNextEntry</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>readNextEntryAllowExceptions</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>FileNotFoundException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_FILE_NOT_FOUND</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>ChecksumException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_CHECKSUM</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Variant of readNextEntry that throws FileNotFoundException and ChecksumException, rather than</color>
<color=#75715e>   * wrapping them in an EnvironmentFailureException and invalidating the enviornment. This allows</color>
<color=#75715e>   * users of this class (see cleaner.FileProcessor), and subclasses that override readNextEntry</color>
<color=#75715e>   * (see ScavengerFileReader and LastFileReader), to handle these exceptions specially.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#a6e22e>readNextEntryAllowExceptions</color><color=#f8f8f2>()</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>FileNotFoundException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ChecksumException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>foundEntry</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>savedCurrentEntryOffset</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryOffset</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>savedNextEntryOffset</color> <color=#f92672>=</color> <color=#f8f8f2>nextEntryOffset</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>((</color><color=#f92672>!</color><color=#f8f8f2>eof</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>foundEntry</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* Read the invariant portion of the next header. */</color>
        <color=#f8f8f2>getLogEntryInReadBuffer</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>dataBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>readData</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>MIN_HEADER_SIZE</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color> <color=#75715e>// collectData</color>

        <color=#f8f8f2>readBasicHeader</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>);</color>

        <color=#66d9ef>boolean</color> <color=#f8f8f2>isTarget</color><color=#f8f8f2>;</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>isChecksumTarget</color><color=#f8f8f2>;</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>collectData</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>isVariableLength</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * For all variable length entries, init the checksum w/the</color>
<color=#75715e>           * invariant portion of the header, before we know whether</color>
<color=#75715e>           * the entry is a target for this reader.  This has</color>
<color=#75715e>           * to be done before we read the variable portion of the</color>
<color=#75715e>           * header, because readData() only guarantees that it</color>
<color=#75715e>           * returns a dataBuffer that contains the next bytes that</color>
<color=#75715e>           * are needed, and has no guarantee that it holds any bytes</color>
<color=#75715e>           * that were previously read. The act of calling</color>
<color=#75715e>           * readData() to obtain the optional portion may reset the</color>
<color=#75715e>           * dataBuffer, and nudge the invariant part of the header</color>
<color=#75715e>           * out of the buffer returned by readData()</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>startChecksum</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>);</color>

          <color=#66d9ef>int</color> <color=#f8f8f2>optionalPortionLen</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getVariablePortionSize</color><color=#f8f8f2>();</color>

          <color=#75715e>/* Load the optional part of the header into a buffer. */</color>
          <color=#f8f8f2>dataBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>readData</color><color=#f8f8f2>(</color><color=#f8f8f2>optionalPortionLen</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Add to checksum while the buffer is positioned at</color>
<color=#75715e>           * the start of the new bytes.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>addToChecksum</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>optionalPortionLen</color><color=#f8f8f2>);</color>

          <color=#75715e>/* Now read the optional bytes. */</color>
          <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>readVariablePortion</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We've read the header of the next logrec. Move up our</color>
<color=#75715e>         * offsets if we're moving forward. If we're moving</color>
<color=#75715e>         * backwards, we set our offset before we read the header,</color>
<color=#75715e>         * because we knew where the entry started.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>currentEntryOffset</color> <color=#f92672>=</color> <color=#f8f8f2>nextEntryOffset</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>nextEntryOffset</color> <color=#f92672>+=</color>
              <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getSize</color><color=#f8f8f2>()</color>
                  <color=#f92672>+</color> <color=#75715e>// header size</color>
                  <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getItemSize</color><color=#f8f8f2>();</color> <color=#75715e>// item size</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>isTarget</color> <color=#f92672>=</color> <color=#f8f8f2>isTargetEntry</color><color=#f8f8f2>();</color>

          <color=#f8f8f2>isChecksumTarget</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>isTarget</color> <color=#f92672>||</color> <color=#f8f8f2>alwaysValidateChecksum</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>isVariableLength</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>startChecksum</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>isChecksumTarget</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>collectData</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>isChecksumTarget</color> <color=#f92672>&&</color> <color=#f8f8f2>doChecksumOnRead</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>isTarget</color><color=#f8f8f2>;</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Read in the body of the next entry. Note that even if</color>
<color=#75715e>           * this isn't a targeted entry, we have to move the buffer</color>
<color=#75715e>           * position along.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>dataBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>readData</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getItemSize</color><color=#f8f8f2>(),</color> <color=#f8f8f2>collectData</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Throwable</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>currentEntryOffset</color> <color=#f92672>=</color> <color=#f8f8f2>savedCurrentEntryOffset</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>nextEntryOffset</color> <color=#f92672>=</color> <color=#f8f8f2>savedNextEntryOffset</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Validate the log entry checksum. */</color>
        <color=#f8f8f2>validateChecksum</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>isChecksumTarget</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isTarget</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * For a target entry, call the subclass reader's</color>
<color=#75715e>           * processEntry method to do whatever we need with the</color>
<color=#75715e>           * entry.  It returns true if this entry is one that should</color>
<color=#75715e>           * be returned.  Note that some entries, although targeted</color>
<color=#75715e>           * and read, are not returned.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>processEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>foundEntry</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>nRead</color><color=#f92672>++</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>collectData</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * For a non-target entry that was validated, the buffer is</color>
<color=#75715e>           * positioned at the start of the entry; skip over it.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>skipEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>EOFException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>eof</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>eof</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#75715e>/* Report on error. */</color>
      <color=#f8f8f2>reportProblem</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>foundEntry</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * May be called by processEntry when it determines that the entry does not need to be</color>
<color=#75715e>   * read/de-serialized.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>void</color> <color=#a6e22e>skipEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>entryBuffer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>entryBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>(</color><color=#f8f8f2>entryBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getItemSize</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>reportProblem</color><color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"Halted log file reading at file 0x"</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>toHexString</color><color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>()))</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" offset 0x"</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>toHexString</color><color=#f8f8f2>(</color><color=#f8f8f2>nextEntryOffset</color><color=#f8f8f2>))</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" offset(decimal)="</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>nextEntryOffset</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" prev=0x"</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>toHexString</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>));</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LogEntryType</color> <color=#f8f8f2>problemType</color> <color=#f92672>=</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>findType</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>":\nentry="</color><color=#f8f8f2>)</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>problemType</color><color=#f8f8f2>)</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"type="</color><color=#f8f8f2>)</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>())</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>",version="</color><color=#f8f8f2>)</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getVersion</color><color=#f8f8f2>())</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>")\nprev=0x"</color><color=#f8f8f2>)</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>toHexString</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>))</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\nsize="</color><color=#f8f8f2>)</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getItemSize</color><color=#f8f8f2>())</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\nNext entry should be at 0x"</color><color=#f8f8f2>)</color>
          <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>toHexString</color><color=#f8f8f2>(</color>
                  <color=#f8f8f2>nextEntryOffset</color>
                      <color=#f92672>+</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getSize</color><color=#f8f8f2>()</color>
                      <color=#f92672>+</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getItemSize</color><color=#f8f8f2>()));</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLogException</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"FileReader"</color><color=#f8f8f2>,</color> <color=#e6db74>"readNextEntry"</color><color=#f8f8f2>,</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>(),</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Make sure that the start of the target log entry is in the header. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>getLogEntryInReadBuffer</color><color=#f8f8f2>()</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>,</color> <color=#f8f8f2>FileNotFoundException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If we're going forward, because we read every byte sequentially,</color>
<color=#75715e>     * we're always sure the read buffer is positioned at the right spot.</color>
<color=#75715e>     * If we go backwards, we need to jump the buffer position. These</color>
<color=#75715e>     * methods may be overridden by subclasses.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>setForwardPosition</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>setBackwardPosition</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Ensure that the next target is in the window. The default behavior is that the next target is</color>
<color=#75715e>   * the next, following entry, so we can assume that it's in the window. All we have to do is to</color>
<color=#75715e>   * check if we've gone past the specified end point.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   * @throws FileNotFoundException</color>
<color=#75715e>   * @throws ChecksumException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>void</color> <color=#a6e22e>setForwardPosition</color><color=#f8f8f2>()</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>FileNotFoundException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>finishLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* The next log entry has passed the end LSN. */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>nextLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>(),</color> <color=#f8f8f2>nextEntryOffset</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>nextLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>finishLsn</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Ensure that the next target is in the window. The default behavior is that the next target is</color>
<color=#75715e>   * the next previous entry.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>void</color> <color=#a6e22e>setBackwardPosition</color><color=#f8f8f2>()</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>FileNotFoundException</color><color=#f8f8f2>,</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * currentEntryPrevOffset is the entry before the current entry.</color>
<color=#75715e>     * currentEntryOffset is the entry we just read (or the end of the</color>
<color=#75715e>     * file if we're starting out.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>currentEntryPrevOffset</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>containsOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#75715e>/* The next log entry has passed the start LSN. */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>nextLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>(),</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>finishLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>nextLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>finishLsn</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>(</color>
              <color=#e6db74>"finish="</color>
                  <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>finishLsn</color><color=#f8f8f2>)</color>
                  <color=#f92672>+</color> <color=#e6db74>"next="</color>
                  <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>nextLsn</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* This log entry starts in this buffer, just reposition. */</color>
      <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>positionBuffer</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The start of the log entry is not in this read buffer so</color>
<color=#75715e>       * we must fill the buffer again.</color>
<color=#75715e>       *</color>
<color=#75715e>       * 1) The target log entry is in a different file from the</color>
<color=#75715e>       * current window's file. Move the window to the previous</color>
<color=#75715e>       * file and start the read from the target LSN.</color>
<color=#75715e>       *</color>
<color=#75715e>       * 2) The target log entry is the same file but the log entry</color>
<color=#75715e>       * is larger than the read chunk size. Start the next read</color>
<color=#75715e>       * buffer from the target LSN. It's going to take multiple</color>
<color=#75715e>       * reads to get the log entry, and we might as well get as</color>
<color=#75715e>       * much as possible.</color>
<color=#75715e>       *</color>
<color=#75715e>       * 3) In the same file, and the log entry fits within one</color>
<color=#75715e>       * read buffer. Try to position the next buffer chunk so the</color>
<color=#75715e>       * target entry is held within the buffer, all the way at the</color>
<color=#75715e>       * end. That way, since we're reading backwards, there will be</color>
<color=#75715e>       * more buffered data available for following reads.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>nextFile</color><color=#f8f8f2>;</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>nextWindowStart</color><color=#f8f8f2>;</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>nextTarget</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentEntryPrevOffset</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Case 1: Go to another file. */</color>
        <color=#f8f8f2>currentEntryPrevOffset</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFileHeaderPrevOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>());</color>

        <color=#f8f8f2>Long</color> <color=#f8f8f2>prevFileNum</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFollowingFileNum</color><color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>(),</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevFileNum</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>(</color><color=#e6db74>"No file following "</color> <color=#f92672>+</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         *  Check finishLSN  before proceeding, in case we should stop</color>
<color=#75715e>         *  the search before attempting to set the file reader to a</color>
<color=#75715e>         *  position in the previous file. In  [#22407] we threw a</color>
<color=#75715e>         *  spurious EFE complaining that we cannot read backwards over</color>
<color=#75715e>         *  a cleaned file because the previous file had  been cleaned</color>
<color=#75715e>         *  away.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>finishLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#f92672>&&</color> <color=#f8f8f2>prevFileNum</color> <color=#f92672><</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>finishLsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>(</color>
              <color=#e6db74>"finish="</color>
                  <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>finishLsn</color><color=#f8f8f2>)</color>
                  <color=#f92672>+</color> <color=#e6db74>" nextFile=0x"</color>
                  <color=#f92672>+</color> <color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>toHexString</color><color=#f8f8f2>(</color><color=#f8f8f2>prevFileNum</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>prevFileNum</color><color=#f8f8f2>.</color><color=#a6e22e>longValue</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>handleGapInBackwardsScan</color><color=#f8f8f2>(</color><color=#f8f8f2>prevFileNum</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>nextFile</color> <color=#f92672>=</color> <color=#f8f8f2>prevFileNum</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>nextWindowStart</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>nextTarget</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>currentEntryOffset</color> <color=#f92672>-</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>capacity</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Case 2: The entry is in the same file, but is bigger</color>
<color=#75715e>         * than one buffer. Position it at the front of the buffer.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>nextFile</color> <color=#f92672>=</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>nextWindowStart</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>nextTarget</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Case 3: In same file, but not in this buffer. The target</color>
<color=#75715e>         * entry will fit in one buffer.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>nextFile</color> <color=#f92672>=</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>();</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>newPosition</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryOffset</color> <color=#f92672>-</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>capacity</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>nextWindowStart</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>newPosition</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#ae81ff>0</color> <color=#f8f8f2>:</color> <color=#f8f8f2>newPosition</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>nextTarget</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* The next log entry has passed the start LSN. */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>nextLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color><color=#f8f8f2>,</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>finishLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>nextLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>finishLsn</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>(</color>
              <color=#e6db74>"finish="</color>
                  <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>finishLsn</color><color=#f8f8f2>)</color>
                  <color=#f92672>+</color> <color=#e6db74>" next="</color>
                  <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>nextLsn</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>slideAndFill</color><color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color><color=#f8f8f2>,</color> <color=#f8f8f2>nextWindowStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>nextTarget</color><color=#f8f8f2>,</color> <color=#f8f8f2>forward</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* The current entry will start at this offset. */</color>
    <color=#f8f8f2>currentEntryOffset</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryPrevOffset</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Read the basic log entry header, leaving the buffer mark at the beginning of the checksummed</color>
<color=#75715e>   * header data.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>readBasicHeader</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>dataBuffer</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Read the header for this entry. */</color>
    <color=#f8f8f2>currentEntryHeader</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LogEntryHeader</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>logVersion</color><color=#f8f8f2>,</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>getCurrentLsn</color><color=#f8f8f2>());</color>

    <color=#75715e>/*</color>
<color=#75715e>     * currentEntryPrevOffset is a separate field, and is not obtained</color>
<color=#75715e>     * directly from the currentEntryHeader, because it is initialized and</color>
<color=#75715e>     * used before any log entry was read.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>currentEntryPrevOffset</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getPrevOffset</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Reset the checksum validator and add the new header bytes. Assumes that the data buffer is</color>
<color=#75715e>   * positioned just past the end of the invariant portion of the log entry header.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>startChecksum</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>dataBuffer</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>startChecksum</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/* isChecksumTarget */</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>startChecksum</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isChecksumTarget</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>doChecksumOnRead</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isChecksumTarget</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Clear out any previous data. */</color>
    <color=#f8f8f2>cksumValidator</color><color=#f8f8f2>.</color><color=#a6e22e>reset</color><color=#f8f8f2>();</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>originalPosition</color> <color=#f92672>=</color> <color=#f8f8f2>dataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>isInvisible</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Turn off invisibility so that the checksum will succeed. When</color>
<color=#75715e>       * entries are made invisible, the checksum is not adjusted. Note</color>
<color=#75715e>       * that the dataBuffer can leave the invisible bit transformed,</color>
<color=#75715e>       * because the header has already been initialized, and this data</color>
<color=#75715e>       * will never be read again.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>LogEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>turnOffInvisible</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>originalPosition</color> <color=#f92672>-</color> <color=#f8f8f2>LogEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>MIN_HEADER_SIZE</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Position the buffer at the start of the data, after the checksum. */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>headerSizeMinusChecksum</color> <color=#f92672>=</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getInvariantSizeMinusChecksum</color><color=#f8f8f2>();</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>entryTypeStart</color> <color=#f92672>=</color> <color=#f8f8f2>originalPosition</color> <color=#f92672>-</color> <color=#f8f8f2>headerSizeMinusChecksum</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>dataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>(</color><color=#f8f8f2>entryTypeStart</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Load the validate with the header bytes. */</color>
    <color=#f8f8f2>cksumValidator</color><color=#f8f8f2>.</color><color=#a6e22e>update</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>headerSizeMinusChecksum</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Move the data buffer back to the original position. */</color>
    <color=#f8f8f2>dataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>(</color><color=#f8f8f2>originalPosition</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>addToChecksum</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>length</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>doChecksumOnRead</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>cksumValidator</color><color=#f8f8f2>.</color><color=#a6e22e>update</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>length</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Add the entry bytes to the checksum and check the value. This method must be called with the</color>
<color=#75715e>   * buffer positioned at the start of the entry.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>validateChecksum</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isChecksumTarget</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>doChecksumOnRead</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isChecksumTarget</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>cksumValidator</color><color=#f8f8f2>.</color><color=#a6e22e>update</color><color=#f8f8f2>(</color><color=#f8f8f2>dataBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getItemSize</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>cksumValidator</color><color=#f8f8f2>.</color><color=#a6e22e>validate</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getChecksum</color><color=#f8f8f2>(),</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>(),</color> <color=#f8f8f2>currentEntryOffset</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Try to read a specified number of bytes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param amountToRead is the number of bytes we need</color>
<color=#75715e>   * @param collectData is true if we need to actually look at the data. If false, we know we're</color>
<color=#75715e>   *     skipping this entry, and all we need to do is to count until we get to the right spot.</color>
<color=#75715e>   * @return a byte buffer positioned at the head of the desired portion, or null if we reached eof.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>ByteBuffer</color> <color=#a6e22e>readData</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>amountToRead</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>collectData</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>,</color> <color=#f8f8f2>FileNotFoundException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>alreadyRead</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>completeBuffer</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>saveBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>((</color><color=#f8f8f2>alreadyRead</color> <color=#f92672><</color> <color=#f8f8f2>amountToRead</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>eof</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>int</color> <color=#f8f8f2>bytesNeeded</color> <color=#f92672>=</color> <color=#f8f8f2>amountToRead</color> <color=#f92672>-</color> <color=#f8f8f2>alreadyRead</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>hasRemaining</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* There's data in the window, process it. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>collectData</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Save data in a buffer for processing.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>alreadyRead</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>()</color> <color=#f92672><</color> <color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

            <color=#75715e>/* We need to piece an entry together. */</color>
            <color=#f8f8f2>copyToSaveBuffer</color><color=#f8f8f2>(</color><color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>alreadyRead</color> <color=#f92672>=</color> <color=#f8f8f2>saveBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>completeBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>saveBuffer</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

            <color=#75715e>/* A complete entry is available in this buffer. */</color>
            <color=#f8f8f2>completeBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>getBuffer</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>alreadyRead</color> <color=#f92672>=</color> <color=#f8f8f2>amountToRead</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * We're not processing the data, so need to save it. just</color>
<color=#75715e>           * move buffer positions.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>int</color> <color=#f8f8f2>positionIncrement</color> <color=#f92672>=</color>
              <color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#f8f8f2>bytesNeeded</color> <color=#f8f8f2>:</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>();</color>

          <color=#f8f8f2>alreadyRead</color> <color=#f92672>+=</color> <color=#f8f8f2>positionIncrement</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>incrementBufferPosition</color><color=#f8f8f2>(</color><color=#f8f8f2>positionIncrement</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>completeBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>getBuffer</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Look for more data.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>fillNext</color><color=#f8f8f2>(</color><color=#f8f8f2>singleFile</color><color=#f8f8f2>,</color> <color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* This call to fillNext slid the window to a new file. */</color>
          <color=#f8f8f2>nextEntryOffset</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Flip the save buffer just in case we've been accumulating in it. */</color>
    <color=#f8f8f2>saveBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>completeBuffer</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* Try to skip over a specified number of bytes. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>skipData</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>amountToSkip</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>,</color> <color=#f8f8f2>FileNotFoundException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>readData</color><color=#f8f8f2>(</color><color=#f8f8f2>amountToSkip</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>reportProblem</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Copy the required number of bytes into the save buffer. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>copyToSaveBuffer</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#75715e>/* How much can we get from this current read buffer? */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>bytesFromThisBuffer</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bytesNeeded</color> <color=#f92672><=</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bytesFromThisBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bytesFromThisBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Gather it all into this save buffer. */</color>
    <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>temp</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Make sure the save buffer is big enough. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>saveBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>capacity</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>saveBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672><</color> <color=#f8f8f2>bytesFromThisBuffer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Grow the save buffer. */</color>
      <color=#f8f8f2>temp</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>allocate</color><color=#f8f8f2>(</color><color=#f8f8f2>saveBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>capacity</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#f8f8f2>bytesFromThisBuffer</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>saveBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>saveBuffer</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>saveBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>temp</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Bulk copy only the required section from the read buffer into the</color>
<color=#75715e>     * save buffer. We need from readBuffer.position() to</color>
<color=#75715e>     * readBuffer.position() + bytesFromThisBuffer</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>temp</color> <color=#f92672>=</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>getBuffer</color><color=#f8f8f2>().</color><color=#a6e22e>slice</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>limit</color><color=#f8f8f2>(</color><color=#f8f8f2>bytesFromThisBuffer</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>saveBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>temp</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>incrementBufferPosition</color><color=#f8f8f2>(</color><color=#f8f8f2>bytesFromThisBuffer</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns the number of reads since the last time this method was called. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getAndResetNReads</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>getAndResetNReads</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * This method is called by readNextEntry() after the header of the current logrec has been</color>
<color=#75715e>   * de-serialized, but not the body. Based on header info only, it may perform some actions and</color>
<color=#75715e>   * then decide whether the rest of the logrec should be de-serialized or just skipped.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if this reader should process the current logrec further, via the processEntry()</color>
<color=#75715e>   *     method. A logrec must be passed to processEntry if the full logrec (not just the header)</color>
<color=#75715e>   *     must be de-serialized for further processing. Return false if no further processing is</color>
<color=#75715e>   *     needed, in which case the current logrec will be skipped (i.e, not returned to the caller</color>
<color=#75715e>   *     of readNextEntry().</color>
<color=#75715e>   * @throws DatabaseException from subclasses.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isTargetEntry</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Each file reader implements this method to process the entry data.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param entryBuffer A ByteBuffer that the logrec data and is positioned at the start of the</color>
<color=#75715e>   *     logrec body (i.e., just after the logrec header).</color>
<color=#75715e>   * @return true if this entry should be returned to the caller of readNextEntry().</color>
<color=#75715e>   */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>abstract</color> <color=#66d9ef>boolean</color> <color=#a6e22e>processEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>entryBuffer</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color><color=#f8f8f2>;</color>

  <color=#75715e>/** Never seen by user, used to indicate that the file reader should stop. */</color>
  <color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"serial"</color><color=#f8f8f2>)</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>EOFException</color> <color=#66d9ef>extends</color> <color=#f8f8f2>Exception</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>public</color> <color=#a6e22e>EOFException</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * @param message The message is used to hold debugging</color>
<color=#75715e>     * information.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#a6e22e>EOFException</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>message</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>message</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return true if the current entry is part of replication stream. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>entryIsReplicated</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"entryIsReplicated should not be used before reader is "</color> <color=#f92672>+</color> <color=#e6db74>"initialized"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getReplicated</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** TBW */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>void</color> <color=#a6e22e>handleGapInBackwardsScan</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>prevFileNum</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>EnvironmentFailureReason</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_INTEGRITY</color><color=#f8f8f2>,</color>
        <color=#e6db74>"Cannot read backward over cleaned file"</color>
            <color=#f92672>+</color> <color=#e6db74>" from 0x"</color>
            <color=#f92672>+</color> <color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>toHexString</color><color=#f8f8f2>(</color><color=#f8f8f2>window</color><color=#f8f8f2>.</color><color=#a6e22e>currentFileNum</color><color=#f8f8f2>())</color>
            <color=#f92672>+</color> <color=#e6db74>" to 0x"</color>
            <color=#f92672>+</color> <color=#f8f8f2>Long</color><color=#f8f8f2>.</color><color=#a6e22e>toHexString</color><color=#f8f8f2>(</color><color=#f8f8f2>prevFileNum</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** A ReadWindow provides a swath of data read from the JE log. */</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>ReadWindow</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * fileNum, startOffset and endOffset indicate how the read buffer maps</color>
<color=#75715e>     * to the JE log. For example, if the read buffer size is 200 and the</color>
<color=#75715e>     * read buffer was filled from file 9, starting at byte 100, then:</color>
<color=#75715e>     *          fileNum = 9</color>
<color=#75715e>     *          startOffset = 100</color>
<color=#75715e>     *          endOffset = 300</color>
<color=#75715e>     * Note that the end point is not inclusive; endOffset is > the</color>
<color=#75715e>     * readBuffer's end.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>fileNum</color><color=#f8f8f2>;</color> <color=#75715e>// file number we're pointing to</color>
    <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>logVersion</color><color=#f8f8f2>;</color> <color=#75715e>// log version for fileNum/readBuffer</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#f8f8f2>startOffset</color><color=#f8f8f2>;</color> <color=#75715e>// file offset that maps to buf start</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#f8f8f2>endOffset</color><color=#f8f8f2>;</color> <color=#75715e>// file offset that maps to buf end</color>
    <color=#66d9ef>protected</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>;</color> <color=#75715e>// buffer for reading from the file</color>

    <color=#75715e>/* read buffer can't grow larger than this */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxReadBufferSize</color><color=#f8f8f2>;</color>

    <color=#66d9ef>protected</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>final</color> <color=#f8f8f2>FileManager</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The number of times we've tried to read in a log entry that was too</color>
<color=#75715e>     * large for the read buffer.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>nRepeatIteratorReads</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Number of reads since the last time getAndResetNReads was called. */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>nReadOperations</color><color=#f8f8f2>;</color>

    <color=#66d9ef>protected</color> <color=#a6e22e>ReadWindow</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>configManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>maxReadBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_ITERATOR_MAX_SIZE</color><color=#f8f8f2>);</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>fileManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>readBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>allocate</color><color=#f8f8f2>(</color><color=#f8f8f2>readBufferSize</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Position this window at this LSN, but leave it empty, it has no data</color>
<color=#75715e>     * yet.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>initAtFileStart</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>setFileNum</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>startLsn</color><color=#f8f8f2>),</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>UNKNOWN_FILE_HEADER_VERSION</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>startOffset</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>startLsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>endOffset</color> <color=#f92672>=</color> <color=#f8f8f2>startOffset</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getEndOffset</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>endOffset</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Ensure that whenever we change the fileNum, the logVersion is also updated. The fileNum and</color>
<color=#75715e>     * logVersion fields should be kept private.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>void</color> <color=#a6e22e>setFileNum</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>fileNum</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>logVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>fileNum</color> <color=#f92672>=</color> <color=#f8f8f2>fileNum</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>logVersion</color> <color=#f92672>=</color> <color=#f8f8f2>logVersion</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>currentFileNum</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>fileNum</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Return true if this offset is contained with the readBuffer. */</color>
    <color=#66d9ef>boolean</color> <color=#a6e22e>containsOffset</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetOffset</color> <color=#f92672>>=</color> <color=#f8f8f2>startOffset</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetOffset</color> <color=#f92672><</color> <color=#f8f8f2>endOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Return true if this lsn  is contained with the readBuffer. */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>containsLsn</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>targetFileNumber</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>((</color><color=#f8f8f2>fileNum</color> <color=#f92672>==</color> <color=#f8f8f2>targetFileNumber</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>containsOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>targetOffset</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Position the readBuffer to the targetOffset. */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>positionBuffer</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>containsOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>targetOffset</color><color=#f8f8f2>)</color>
          <color=#f8f8f2>:</color> <color=#66d9ef>this</color> <color=#f92672>+</color> <color=#e6db74>" doesn't contain "</color> <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>targetOffset</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>((</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetOffset</color> <color=#f92672>-</color> <color=#f8f8f2>startOffset</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Move the readBuffer position up by the given increment. */</color>
    <color=#66d9ef>void</color> <color=#a6e22e>incrementBufferPosition</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>increment</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>currentPosition</color> <color=#f92672>=</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>(</color><color=#f8f8f2>currentPosition</color> <color=#f92672>+</color> <color=#f8f8f2>increment</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Reposition to the specified file, and fill starting at</color>
<color=#75715e>     * startOffset. Position the window's buffer to point at the log entry</color>
<color=#75715e>     * indicated by targetOffset</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>slideAndFill</color><color=#f8f8f2>(</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>windowfileNum</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>windowStartOffset</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>)</color>
        <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>FileNotFoundException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>FileHandle</color> <color=#f8f8f2>fileHandle</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFileHandle</color><color=#f8f8f2>(</color><color=#f8f8f2>windowfileNum</color><color=#f8f8f2>);</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>startOffset</color> <color=#f92672>=</color> <color=#f8f8f2>windowStartOffset</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>setFileNum</color><color=#f8f8f2>(</color><color=#f8f8f2>windowfileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>getLogVersion</color><color=#f8f8f2>());</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>foundData</color> <color=#f92672>=</color> <color=#f8f8f2>fillFromFile</color><color=#f8f8f2>(</color><color=#f8f8f2>fileHandle</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * When reading backwards, we need to guarantee there is no log</color>
<color=#75715e>         * gap, throws out an EnvironmentFailreException if it exists.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>foundData</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#e6db74>"Detected a log file gap when reading backwards. "</color>
                  <color=#f92672>+</color> <color=#e6db74>"Target position = "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>windowfileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>))</color>
                  <color=#f92672>+</color> <color=#e6db74>" starting position = "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>windowfileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>windowStartOffset</color><color=#f8f8f2>))</color>
                  <color=#f92672>+</color> <color=#e6db74>" end position = "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>windowfileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>endOffset</color><color=#f8f8f2>)));</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Fill up the read buffer with more data, moving along to the following file (next largest</color>
<color=#75715e>     * number) if needed.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return true if the fill moved us to a new file.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>boolean</color> <color=#a6e22e>fillNext</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>singleFile</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>)</color>
        <color=#66d9ef>throws</color> <color=#f8f8f2>ChecksumException</color><color=#f8f8f2>,</color> <color=#f8f8f2>FileNotFoundException</color><color=#f8f8f2>,</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>adjustReadBufferSize</color><color=#f8f8f2>(</color><color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>FileHandle</color> <color=#f8f8f2>fileHandle</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Get a file handle to read in more log. */</color>
        <color=#f8f8f2>fileHandle</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFileHandle</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNum</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Check to see if we've come to the end of the file.  If so,</color>
<color=#75715e>         * get the next file.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>startOffset</color> <color=#f92672>=</color> <color=#f8f8f2>endOffset</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fillFromFile</color><color=#f8f8f2>(</color><color=#f8f8f2>fileHandle</color><color=#f8f8f2>,</color> <color=#f8f8f2>startOffset</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * Successfully filled the read buffer, but didn't move to</color>
<color=#75715e>           * a new file.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* This file is done -- can we read in the next file? */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>singleFile</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>(</color><color=#e6db74>"Single file only"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>Long</color> <color=#f8f8f2>nextFile</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFollowingFileNum</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNum</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/* forward */</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>EOFException</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>fileHandle</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>fileHandle</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getFileHandle</color><color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>setFileNum</color><color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color><color=#f8f8f2>,</color> <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>getLogVersion</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>startOffset</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>fillFromFile</color><color=#f8f8f2>(</color><color=#f8f8f2>fileHandle</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fileHandle</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Assume that the window is properly positioned. Try to fill the read</color>
<color=#75715e>     * buffer with data from this file handle, starting at the location</color>
<color=#75715e>     * indicated by the starting offset field. If this file contains more</color>
<color=#75715e>     * data, return true. If this file doesn't contain more data, return</color>
<color=#75715e>     * false.</color>
<color=#75715e>     *</color>
<color=#75715e>     * In all cases, leave the the read buffer pointing at the target</color>
<color=#75715e>     * offset and in a state that's ready to support reads, even if there</color>
<color=#75715e>     * is nothing in the buffer. Note that the target offset, which may not</color>
<color=#75715e>     * be the same as starting offset.</color>
<color=#75715e>     * @return true if more data was read, false if not.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>boolean</color> <color=#a6e22e>fillFromFile</color><color=#f8f8f2>(</color><color=#f8f8f2>FileHandle</color> <color=#f8f8f2>fileHandle</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>targetOffset</color><color=#f8f8f2>)</color>
        <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>boolean</color> <color=#f8f8f2>foundData</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>readFromFile</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>getFile</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>readBuffer</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>startOffset</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>getFileNum</color><color=#f8f8f2>(),</color>
          <color=#66d9ef>false</color> <color=#75715e>/* dataKnownToBeInFile */</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>foundData</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>nReadOperations</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#75715e>/*</color>
<color=#75715e>         * Ensure that fileNum and logVersion are in sync.  setFileNum</color>
<color=#75715e>         * handles changes in the file number.  But we must also update</color>
<color=#75715e>         * the logVersion here to handle the first read after we</color>
<color=#75715e>         * initialize fileNum and logVersion is unknown.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>logVersion</color> <color=#f92672>=</color> <color=#f8f8f2>fileHandle</color><color=#f8f8f2>.</color><color=#a6e22e>getLogVersion</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * In all cases, setup read buffer for valid reading. If the buffer</color>
<color=#75715e>       * has no data, it will be positioned at the beginning, and will be</color>
<color=#75715e>       * able to correctly return the fact that there is no data present.</color>
<color=#75715e>       */</color>

      <color=#f8f8f2>endOffset</color> <color=#f92672>=</color> <color=#f8f8f2>startOffset</color> <color=#f92672>+</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>((</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetOffset</color> <color=#f92672>-</color> <color=#f8f8f2>startOffset</color><color=#f8f8f2>));</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>foundData</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Change the read buffer size if we start hitting large log entries so we don't get into an</color>
<color=#75715e>     * expensive cycle of multiple reads and piecing together of log entries.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>void</color> <color=#a6e22e>adjustReadBufferSize</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>amountToRead</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>capacity</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We need to read something larger than the current buffer</color>
<color=#75715e>       * size.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>amountToRead</color> <color=#f92672>></color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* We're not at the max yet. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>readBufferSize</color> <color=#f92672><</color> <color=#f8f8f2>maxReadBufferSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Make the buffer the minimum of amountToRead or a</color>
<color=#75715e>           * maxReadBufferSize.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>amountToRead</color> <color=#f92672><</color> <color=#f8f8f2>maxReadBufferSize</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>readBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>amountToRead</color><color=#f8f8f2>;</color>
            <color=#75715e>/* Make it a multiple of 1K. */</color>
            <color=#66d9ef>int</color> <color=#f8f8f2>remainder</color> <color=#f92672>=</color> <color=#f8f8f2>readBufferSize</color> <color=#f92672>%</color> <color=#ae81ff>1024</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>readBufferSize</color> <color=#f92672>+=</color> <color=#ae81ff>1024</color> <color=#f92672>-</color> <color=#f8f8f2>remainder</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>readBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>min</color><color=#f8f8f2>(</color><color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxReadBufferSize</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>readBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>maxReadBufferSize</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>readBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>allocate</color><color=#f8f8f2>(</color><color=#f8f8f2>readBufferSize</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>amountToRead</color> <color=#f92672>></color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>capacity</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>nRepeatIteratorReads</color><color=#f92672>++</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#a6e22e>capacity</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>capacity</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#a6e22e>remaining</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>hasRemaining</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>hasRemaining</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>ByteBuffer</color> <color=#a6e22e>getBuffer</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/** Returns the number of reads since the last time this method was called. */</color>
    <color=#66d9ef>int</color> <color=#a6e22e>getAndResetNReads</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>tmp</color> <color=#f92672>=</color> <color=#f8f8f2>nReadOperations</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>nReadOperations</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>tmp</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#a6e22e>getNRepeatIteratorReads</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>nRepeatIteratorReads</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>toString</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>start</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>startOffset</color><color=#f8f8f2>);</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>end</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>endOffset</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"window covers "</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>start</color><color=#f8f8f2>)).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" to "</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>end</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" positioned at "</color><color=#f8f8f2>);</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>target</color> <color=#f92672>=</color> <color=#f8f8f2>getCurrentLsn</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>));</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#a6e22e>getCurrentLsn</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>startOffset</color> <color=#f92672>+</color> <color=#f8f8f2>readBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>