<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>
<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.rep.stream</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentFailureException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.FileProtector.ProtectedFileSet</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DbConfigManager</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.impl.RepImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.impl.RepParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.impl.node.RepNode</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.impl.node.Replay</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.impl.node.Replica.HardRecoveryElectionException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.impl.node.cbvlsn.LocalCBVLSNTracker</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.stream.BaseProtocol.AlternateMatchpoint</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.stream.BaseProtocol.Entry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.stream.BaseProtocol.EntryNotFound</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.stream.BaseProtocol.RestoreResponse</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.stream.ReplicaSyncupReader.SkipGapException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.utilint.BinaryProtocol.Message</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.utilint.NamedChannel</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.vlsn.VLSNIndex</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.vlsn.VLSNRange</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.DbLsn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.LoggerUtils</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.TestHookExecute</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.VLSN</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.io.IOException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Arrays</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.HashSet</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Level</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Logger</color><color=#f8f8f2>;</color>

<color=#f92672>import static</color> <color=#f8f8f2>com.sleepycat.je.utilint.VLSN.NULL_VLSN</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * Establish where the replication stream should start for a replica and feeder pair. The replica</color>
<color=#75715e> * compares what is in its log with what the feeder has, to determine the latest common log entry</color>
<color=#75715e> * matchpoint</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- If the replica has applied log entries after that matchpoint, roll them back - If a common</color>
<color=#75715e> * matchpoint can't be found, the replica will need to do a network restore.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>ReplicaFeederSyncup</color> <color=#f8f8f2>{</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>NamedChannel</color> <color=#f8f8f2>namedChannel</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Protocol</color> <color=#f8f8f2>protocol</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>RepNode</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>VLSNIndex</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Replay</color> <color=#f8f8f2>replay</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>RepImpl</color> <color=#f8f8f2>repImpl</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>ReplicaSyncupReader</color> <color=#f8f8f2>backwardsReader</color><color=#f8f8f2>;</color>

  <color=#75715e>/* The VLSN, lsn and log entry at which a match was made. */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>matchpointVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>NULL_VLSN</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>Long</color> <color=#f8f8f2>matchedVLSNTime</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>L</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>hardRecoveryNeedsElection</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * searchResults are the bundled outputs from the backwards scan by the</color>
<color=#75715e>   * ReplicaSyncReader during its search for a matchpoint.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>MatchpointSearchResults</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>;</color>

  <color=#75715e>/** For unit tests only. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>TestHook</color><color=#f92672><</color><color=#f8f8f2>Object</color><color=#f92672>></color> <color=#f8f8f2>globalSyncupEndHook</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>TestHook</color><color=#f92672><</color><color=#f8f8f2>Object</color><color=#f92672>></color> <color=#f8f8f2>syncupEndHook</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>com</color><color=#f8f8f2>.</color><color=#a6e22e>sleepycat</color><color=#f8f8f2>.</color><color=#a6e22e>je</color><color=#f8f8f2>.</color><color=#a6e22e>utilint</color><color=#f8f8f2>.</color><color=#a6e22e>TestHook</color><color=#f92672><</color><color=#f8f8f2>ReplicaFeederSyncup</color><color=#f92672>></color> <color=#f8f8f2>rollbackHook</color><color=#f8f8f2>;</color>

  <color=#66d9ef>public</color> <color=#a6e22e>ReplicaFeederSyncup</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>RepNode</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Replay</color> <color=#f8f8f2>replay</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>NamedChannel</color> <color=#f8f8f2>namedChannel</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>Protocol</color> <color=#f8f8f2>protocol</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>hardRecoveryNeedsElection</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>replay</color> <color=#f92672>=</color> <color=#f8f8f2>replay</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>logger</color> <color=#f92672>=</color> <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>(</color><color=#f8f8f2>getClass</color><color=#f8f8f2>());</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>repNode</color> <color=#f92672>=</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>vlsnIndex</color> <color=#f92672>=</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNIndex</color><color=#f8f8f2>();</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>namedChannel</color> <color=#f92672>=</color> <color=#f8f8f2>namedChannel</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>protocol</color> <color=#f92672>=</color> <color=#f8f8f2>protocol</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>repImpl</color> <color=#f92672>=</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getRepImpl</color><color=#f8f8f2>();</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>hardRecoveryNeedsElection</color> <color=#f92672>=</color> <color=#f8f8f2>hardRecoveryNeedsElection</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>searchResults</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>MatchpointSearchResults</color><color=#f8f8f2>(</color><color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getRepImpl</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>syncupEndHook</color> <color=#f92672>=</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>replica</color><color=#f8f8f2>().</color><color=#a6e22e>getReplicaFeederSyncupHook</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getMatchedVLSNTime</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>matchedVLSNTime</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>VLSN</color> <color=#a6e22e>getMatchedVLSN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The replica's side of the protocol.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws InterruptedException</color>
<color=#75715e>   * @throws InsufficientLogException</color>
<color=#75715e>   * @throws HardRecoveryElectionException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>execute</color><color=#f8f8f2>(</color><color=#f8f8f2>LocalCBVLSNTracker</color> <color=#f8f8f2>cbvlsnTracker</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color><color=#f8f8f2>,</color> <color=#f8f8f2>InterruptedException</color><color=#f8f8f2>,</color> <color=#f8f8f2>InsufficientLogException</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>HardRecoveryElectionException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>startTime</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>String</color> <color=#f8f8f2>feederName</color> <color=#f92672>=</color> <color=#f8f8f2>namedChannel</color><color=#f8f8f2>.</color><color=#a6e22e>getNameIdPair</color><color=#f8f8f2>().</color><color=#a6e22e>getName</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
        <color=#e6db74>"Replica-feeder "</color>
            <color=#f92672>+</color> <color=#f8f8f2>feederName</color>
            <color=#f92672>+</color> <color=#e6db74>" syncup started. Replica range: "</color>
            <color=#f92672>+</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNIndex</color><color=#f8f8f2>().</color><color=#a6e22e>getRange</color><color=#f8f8f2>());</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Prevent the VLSNIndex range from being changed and protect all files</color>
<color=#75715e>     * in the range. To search the index and read files within this range</color>
<color=#75715e>     * safely, VLSNIndex.getRange must be called after syncupStarted.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>ProtectedFileSet</color> <color=#f8f8f2>protectedFileSet</color> <color=#f92672>=</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>syncupStarted</color><color=#f8f8f2>(</color><color=#f8f8f2>namedChannel</color><color=#f8f8f2>.</color><color=#a6e22e>getNameIdPair</color><color=#f8f8f2>());</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Find a replication stream matchpoint and a place to start</color>
<color=#75715e>       * the replication stream. If the feeder cannot service this</color>
<color=#75715e>       * protocol because it has run out of replication stream,</color>
<color=#75715e>       * findMatchpoint will throw a InsufficientLogException. If the</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>range</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>findMatchpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If we can't rollback to the found matchpoint, verifyRollback</color>
<color=#75715e>       * will throw the appropriate exception.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>verifyRollback</color><color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>replay</color><color=#f8f8f2>.</color><color=#a6e22e>rollback</color><color=#f8f8f2>(</color><color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>getMatchpointLSN</color><color=#f8f8f2>());</color>

      <color=#75715e>/* Update the vlsnIndex, it will commit synchronously. */</color>
      <color=#f8f8f2>VLSN</color> <color=#f8f8f2>startVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>truncateFromTail</color><color=#f8f8f2>(</color><color=#f8f8f2>startVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>getMatchpointLSN</color><color=#f8f8f2>());</color>

      <color=#f8f8f2>protocol</color><color=#f8f8f2>.</color><color=#a6e22e>write</color><color=#f8f8f2>(</color><color=#f8f8f2>protocol</color><color=#f8f8f2>.</color><color=#a6e22e>new</color> <color=#a6e22e>StartStream</color><color=#f8f8f2>(</color><color=#f8f8f2>startVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>repImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFeederFilter</color><color=#f8f8f2>()),</color> <color=#f8f8f2>namedChannel</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Replica-feeder "</color> <color=#f92672>+</color> <color=#f8f8f2>feederName</color> <color=#f92672>+</color> <color=#e6db74>" start stream at VLSN: "</color> <color=#f92672>+</color> <color=#f8f8f2>startVLSN</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If the GlobalCBVLSN is not defunct, we initialize this node's</color>
<color=#75715e>       * local CBVLSN while the entire VLSN range is protected. The</color>
<color=#75715e>       * idea is to hang onto the vlsn at the matchpoint -- don't</color>
<color=#75715e>       * let that be cleaned, because it may be of use for other replicas</color>
<color=#75715e>       * who need to sync up. Right now, this seems to be the best</color>
<color=#75715e>       * matchpoint in the group.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>cbvlsnTracker</color><color=#f8f8f2>.</color><color=#a6e22e>registerMatchpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>

      <color=#75715e>/* For unit test support only. */</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>runHook</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>syncupEnded</color><color=#f8f8f2>(</color><color=#f8f8f2>protectedFileSet</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>String</color><color=#f8f8f2>.</color><color=#a6e22e>format</color><color=#f8f8f2>(</color>
              <color=#e6db74>"Replica-feeder "</color> <color=#f92672>+</color> <color=#f8f8f2>feederName</color> <color=#f92672>+</color> <color=#e6db74>" syncup ended. Elapsed time: %,dms"</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>(</color><color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>startTime</color><color=#f8f8f2>)));</color>

      <color=#f8f8f2>repImpl</color><color=#f8f8f2>.</color><color=#a6e22e>setSyncupProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>SyncupProgress</color><color=#f8f8f2>.</color><color=#a6e22e>END</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * A matchpoint has been found. What happens next depends on the position of the matchpoint and</color>
<color=#75715e>   * its relationship to the last transaction end record.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>In following table, M = some non-null matchpoint VLSN value, T = some non-null last txn end</color>
<color=#75715e>   * value S = some non-null last sync value</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Note that currently T == S, since a sync points is always a txn end.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>txn end last sync found action VLSN VLSN matchpoint ---------- --------- ---------</color>
<color=#75715e>   * ------------------------ NULL_VLSN NULL_VLSN NULL_VLSN rollback everything NULL_VLSN NULL_VLSN</color>
<color=#75715e>   * M can't occur NULL_VLSN S NULL_VLSN rollback everything NULL_VLSN S M rollback to M T NULL_VLSN</color>
<color=#75715e>   * NULL_VLSN can't occur T NULL_VLSN M can't occur T S NULL_VLSN network restore, though could</color>
<color=#75715e>   * also do hard recov T <= M S M rollback to matchpoint T > M, truncate not ok S M network restore</color>
<color=#75715e>   * T > M, rollback limit exceeded or S M throw RollbackProhibited disabled T > M, truncate ok S M</color>
<color=#75715e>   * hard recovery</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws IOException</color>
<color=#75715e>   * @throws HardRecoveryElectionException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>verifyRollback</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>range</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>RollbackException</color><color=#f8f8f2>,</color> <color=#f8f8f2>InsufficientLogException</color><color=#f8f8f2>,</color> <color=#f8f8f2>HardRecoveryElectionException</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>repImpl</color><color=#f8f8f2>.</color><color=#a6e22e>setSyncupProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>SyncupProgress</color><color=#f8f8f2>.</color><color=#a6e22e>CHECK_FOR_ROLLBACK</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastTxnEnd</color> <color=#f92672>=</color> <color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getLastTxnEnd</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastSync</color> <color=#f92672>=</color> <color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getLastSync</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>finest</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
        <color=#e6db74>"verify rollback"</color> <color=#f92672>+</color> <color=#e6db74>" vlsn range="</color> <color=#f92672>+</color> <color=#f8f8f2>range</color> <color=#f92672>+</color> <color=#e6db74>" searchResults="</color> <color=#f92672>+</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Test a rollback exception is thrown when sync up */</color>
    <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>rollbackHook</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the lastTxnEnd VLSN is null, we don't have to worry about hard</color>
<color=#75715e>     * recovery. See truth table above.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastTxnEnd</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getLastSync</color><color=#f8f8f2>().</color><color=#a6e22e>isNull</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getRepImpl</color><color=#f8f8f2>(),</color>
            <color=#e6db74>"Shouldn't be possible to find a "</color>
                <color=#f92672>+</color> <color=#e6db74>"matchpoint of "</color>
                <color=#f92672>+</color> <color=#f8f8f2>matchpointVLSN</color>
                <color=#f92672>+</color> <color=#e6db74>" when the sync VLSN is null. Range="</color>
                <color=#f92672>+</color> <color=#f8f8f2>range</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* We'll be doing a normal rollback. */</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>fine</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"normal rollback, no txn end"</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastSync</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getRepImpl</color><color=#f8f8f2>(),</color>
          <color=#e6db74>"Shouldn't be possible to have a null sync VLSN when the "</color>
              <color=#f92672>+</color> <color=#e6db74>" lastTxnVLSN "</color>
              <color=#f92672>+</color> <color=#f8f8f2>lastTxnEnd</color>
              <color=#f92672>+</color> <color=#e6db74>" is not null. Range="</color>
              <color=#f92672>+</color> <color=#f8f8f2>range</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * There is a non-null lastTxnEnd VLSN, so check if the found</color>
<color=#75715e>     * matchpoint precedes it. If it doesn't, we can't rollback.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We could actually also try to do a hard recovery and truncate</color>
<color=#75715e>       * all committed txns, but for now, let's assume that it will cost</color>
<color=#75715e>       * less to copy the log files.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"This node had a txn end at vlsn = "</color> <color=#f92672>+</color> <color=#f8f8f2>lastTxnEnd</color> <color=#f92672>+</color> <color=#e6db74>"but no matchpoint found."</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>setupLogRefresh</color><color=#f8f8f2>(</color><color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The matchpoint is after or equal to the last txn end, no problem</color>
<color=#75715e>     * with doing a normal rollback.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>lastTxnEnd</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>)</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>getNumPassedCommits</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>fine</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"txn end vlsn of "</color>
              <color=#f92672>+</color> <color=#f8f8f2>lastTxnEnd</color>
              <color=#f92672>+</color> <color=#e6db74>"<= matchpointVLSN of "</color>
              <color=#f92672>+</color> <color=#f8f8f2>matchpointVLSN</color>
              <color=#f92672>+</color> <color=#e6db74>", normal rollback"</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Rolling back past a commit or abort. */</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>hardRecoveryNeedsElection</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>HardRecoveryElectionException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getMasterStatus</color><color=#f8f8f2>().</color><color=#a6e22e>getNodeMasterNameId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>lastTxnEnd</color><color=#f8f8f2>,</color> <color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We're planning on rolling back past a commit or abort. The more</color>
<color=#75715e>     * optimal course of action is to truncate the log and run a hard</color>
<color=#75715e>     * recovery, but if the matchpoint precedes a checkpoint that deleted</color>
<color=#75715e>     * log files, the truncation is not permissible because the resulting</color>
<color=#75715e>     * log might be missing needed files. Instead, we have to do a network</color>
<color=#75715e>     * restore.</color>
<color=#75715e>     *</color>
<color=#75715e>     * A checkpoint that resulted in deleted log files will have flushed</color>
<color=#75715e>     * references to entries migrated from the deleted file, and the</color>
<color=#75715e>     * original entries might still be referenced if we truncate the log</color>
<color=#75715e>     * prior to the CkptEnd. For example:</color>
<color=#75715e>     *</color>
<color=#75715e>     *    3/100 LN-A</color>
<color=#75715e>     *    4/100 BIN parent of LN-1 at 3/100</color>
<color=#75715e>     *    5/100 cleaning of file 3 begins</color>
<color=#75715e>     *    5/200 LN-A migrated from 3/100, parent BIN is dirtied</color>
<color=#75715e>     *    5/300 CkptStart</color>
<color=#75715e>     *    5/400 matchpoint</color>
<color=#75715e>     *    5/500 BIN parent of LN-A at 5/200</color>
<color=#75715e>     *    5/600 CkptEnd, after which file 3 is deleted</color>
<color=#75715e>     *</color>
<color=#75715e>     * If we truncate the log at the matchpoint, the BIN at 5/500 is</color>
<color=#75715e>     * truncated. The BIN at 4/100 will be used, which refers to an LN in a</color>
<color=#75715e>     * now deleted file. Note that the cleaner guarantees that a checkpoint</color>
<color=#75715e>     * occurs after migration and before file deletion.</color>
<color=#75715e>     *</color>
<color=#75715e>     * However, because files become reserved after a checkpoint and are</color>
<color=#75715e>     * not deleted immediately, we could trucate at a matchpoint that</color>
<color=#75715e>     * precedes such a checkpoint, when these reserved files have not yet</color>
<color=#75715e>     * been deleted. In the future we could enable such a feature by</color>
<color=#75715e>     * keeping track (persistently) of the earliest point at which the log</color>
<color=#75715e>     * can be truncated, taking into account the deletion of reserved</color>
<color=#75715e>     * files. Then we could use this information to validate a matchpoint.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>getPassedCheckpointEnd</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"matchpointVLSN of "</color>
              <color=#f92672>+</color> <color=#f8f8f2>matchpointVLSN</color>
              <color=#f92672>+</color> <color=#e6db74>" precedes a checkpoint end, "</color>
              <color=#f92672>+</color> <color=#e6db74>"needs network restore."</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>setupLogRefresh</color><color=#f8f8f2>(</color><color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Likewise, if we skipped over a gap in the log files, we can't be</color>
<color=#75715e>     * sure if we passed a ckpt with deleted log files. Do a network</color>
<color=#75715e>     * restore rather than a hard recovery.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>getSkippedGap</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"matchpointVLSN of "</color>
              <color=#f92672>+</color> <color=#f8f8f2>matchpointVLSN</color>
              <color=#f92672>+</color> <color=#e6db74>" was found in a replica log "</color>
              <color=#f92672>+</color> <color=#e6db74>"with gaps. Since we can't be sure if it "</color>
              <color=#f92672>+</color> <color=#e6db74>"precedes a checkpoint end, do network restore."</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>setupLogRefresh</color><color=#f8f8f2>(</color><color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We're planning on rolling back past a commit or abort, and we know</color>
<color=#75715e>     * that we have not passed a barrier checkpoint. See if we have</color>
<color=#75715e>     * exceeded the number of rolledback commits limit.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getRepImpl</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>configMgr</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>rollbackTxnLimit</color> <color=#f92672>=</color> <color=#f8f8f2>configMgr</color><color=#f8f8f2>.</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>RepParams</color><color=#f8f8f2>.</color><color=#a6e22e>TXN_ROLLBACK_LIMIT</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>rollbackDisabled</color> <color=#f92672>=</color> <color=#f8f8f2>configMgr</color><color=#f8f8f2>.</color><color=#a6e22e>getBoolean</color><color=#f8f8f2>(</color><color=#f8f8f2>RepParams</color><color=#f8f8f2>.</color><color=#a6e22e>TXN_ROLLBACK_DISABLED</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>numPassedDurableCommits</color> <color=#f92672>=</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>getNumPassedDurableCommits</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>numPassedCommits</color> <color=#f92672>=</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>getNumPassedCommits</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>dtvlsn</color> <color=#f92672>=</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>getDTVLSN</color><color=#f8f8f2>().</color><color=#a6e22e>getSequence</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>String</color><color=#f8f8f2>.</color><color=#a6e22e>format</color><color=#f8f8f2>(</color>
            <color=#e6db74>"Rollback info. "</color>
                <color=#f92672>+</color> <color=#e6db74>"Number of passed commits:%,d. "</color>
                <color=#f92672>+</color> <color=#e6db74>"(durable commits:%,d). "</color>
                <color=#f92672>+</color> <color=#e6db74>"Durable commit VLSN:%,d "</color>
                <color=#f92672>+</color> <color=#e6db74>"Rollback transaction limit:%,d"</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>numPassedCommits</color><color=#f8f8f2>,</color> <color=#f8f8f2>numPassedDurableCommits</color><color=#f8f8f2>,</color> <color=#f8f8f2>dtvlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>rollbackTxnLimit</color><color=#f8f8f2>));</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>numPassedDurableCommits</color> <color=#f92672>></color> <color=#f8f8f2>rollbackTxnLimit</color> <color=#f92672>||</color> <color=#f8f8f2>rollbackDisabled</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>severe</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"Limited list of transactions that would "</color>
              <color=#f92672>+</color> <color=#e6db74>" be truncated for hard recovery:\n"</color>
              <color=#f92672>+</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>dumpPassedTxns</color><color=#f8f8f2>());</color>

      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>RollbackProhibitedException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getRepImpl</color><color=#f8f8f2>(),</color> <color=#f8f8f2>rollbackTxnLimit</color><color=#f8f8f2>,</color> <color=#f8f8f2>rollbackDisabled</color><color=#f8f8f2>,</color> <color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * After passing all the earlier qualifications, do a truncation and</color>
<color=#75715e>     * hard recovery.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>throw</color> <color=#f8f8f2>setupHardRecovery</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Find a matchpoint, which is a log entry in the replication stream which is the same on feeder</color>
<color=#75715e>   * and replica. Assign the matchpointVLSN field. The matchpoint log entry must be be tagged with</color>
<color=#75715e>   * an environment id. If no matching entry is found, the matchpoint is effectively the NULL_VLSN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>To determine the matchpoint, exchange messages with the feeder and compare log entries. If</color>
<color=#75715e>   * the feeder does not have enough log entries, throw InsufficientLogException.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws InsufficientLogException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>findMatchpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>range</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color><color=#f8f8f2>,</color> <color=#f8f8f2>InsufficientLogException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>matchCounter</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>repImpl</color><color=#f8f8f2>.</color><color=#a6e22e>setSyncupProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>SyncupProgress</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_MATCHPOINT</color><color=#f8f8f2>,</color> <color=#f8f8f2>matchCounter</color><color=#f92672>++</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>candidateMatchpoint</color> <color=#f92672>=</color> <color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getLastSync</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>NULL_VLSN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If the replica has no sync-able log entries at all, the</color>
<color=#75715e>       * matchpoint is the NULL_VLSN, and we should start the replication</color>
<color=#75715e>       * stream at VLSN 1. Check if the feeder has the VLSN 1. If it</color>
<color=#75715e>       * doesn't, getFeederRecord() will throw a</color>
<color=#75715e>       * InsufficientLogException. We can assume that a non-cleaned</color>
<color=#75715e>       * feeder always has VLSN 1, because a ReplicatedEnvironment always</color>
<color=#75715e>       * creates a few replicated vlsns, such as the name db, at</color>
<color=#75715e>       * initial startup.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>getFeederRecord</color><color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>FIRST_VLSN</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*acceptAlternative*/</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * CandidateMatchpoint is not null, so ask the feeder for the log</color>
<color=#75715e>     * record at that vlsn.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>InputWireRecord</color> <color=#f8f8f2>feederRecord</color> <color=#f92672>=</color>
        <color=#f8f8f2>getFeederRecord</color><color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>,</color> <color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*acceptAlternative*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The feeder may have suggested an alternative matchpoint, so reset</color>
<color=#75715e>     * candidate matchpoint.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>candidateMatchpoint</color> <color=#f92672>=</color> <color=#f8f8f2>feederRecord</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINE</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>fine</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"first candidate matchpoint: "</color> <color=#f92672>+</color> <color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#75715e>/*</color>
<color=#75715e>     * Start comparing feeder records to replica records. Instead of using</color>
<color=#75715e>     * the VLSNIndex to direct our search, we must scan from the end of the</color>
<color=#75715e>     * log, recording entries that have an impact on our ability to</color>
<color=#75715e>     * rollback, like checkpoints.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Start by finding the candidate matchpoint in the Replica.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>backwardsReader</color> <color=#f92672>=</color>
        <color=#f8f8f2>setupBackwardsReader</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>,</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getRepImpl</color><color=#f8f8f2>().</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLastUsedLsn</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>OutputWireRecord</color> <color=#f8f8f2>replicaRecord</color> <color=#f92672>=</color> <color=#f8f8f2>getReplicaRecord</color><color=#f8f8f2>(</color><color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>);</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>replicaRecord</color><color=#f8f8f2>.</color><color=#a6e22e>match</color><color=#f8f8f2>(</color><color=#f8f8f2>feederRecord</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>repImpl</color><color=#f8f8f2>.</color><color=#a6e22e>setSyncupProgress</color><color=#f8f8f2>(</color><color=#f8f8f2>SyncupProgress</color><color=#f8f8f2>.</color><color=#a6e22e>FIND_MATCHPOINT</color><color=#f8f8f2>,</color> <color=#f8f8f2>matchCounter</color><color=#f92672>++</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * That first bid didn't match, now just keep looking at all</color>
<color=#75715e>       * potential matchpoints.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>replicaRecord</color> <color=#f92672>=</color> <color=#f8f8f2>scanMatchpointEntries</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>replicaRecord</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * The search for the previous sync log entry went past our</color>
<color=#75715e>         * available contiguous VLSN range, so there is no</color>
<color=#75715e>         * matchpoint.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
            <color=#e6db74>"Looking at candidate matchpoint vlsn "</color>
                <color=#f92672>+</color> <color=#f8f8f2>candidateMatchpoint</color>
                <color=#f92672>+</color> <color=#e6db74>" but this node went past its available"</color>
                <color=#f92672>+</color> <color=#e6db74>" contiguous VLSN range, need network"</color>
                <color=#f92672>+</color> <color=#e6db74>" restore."</color><color=#f8f8f2>);</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>setupLogRefresh</color><color=#f8f8f2>(</color><color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Ask the feeder for the record. If the feeder doesn't have</color>
<color=#75715e>       * it, we'll throw out and do a network restore.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>candidateMatchpoint</color> <color=#f92672>=</color> <color=#f8f8f2>replicaRecord</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINE</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>fine</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Next candidate matchpoint: "</color> <color=#f92672>+</color> <color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>feederRecord</color> <color=#f92672>=</color> <color=#f8f8f2>getFeederRecord</color><color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>,</color> <color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* We've found the matchpoint. */</color>
    <color=#f8f8f2>matchedVLSNTime</color> <color=#f92672>=</color> <color=#f8f8f2>replicaRecord</color><color=#f8f8f2>.</color><color=#a6e22e>getTimeStamp</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>matchpointVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>setMatchpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>backwardsReader</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>finest</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"after setting  matchpoint, searchResults="</color> <color=#f92672>+</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>ReplicaSyncupReader</color> <color=#a6e22e>setupBackwardsReader</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>startScanVLSN</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>startScanLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getRepImpl</color><color=#f8f8f2>();</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color> <color=#f92672>=</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_ITERATOR_READ_SIZE</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>ReplicaSyncupReader</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNIndex</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>startScanLsn</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>startScanVLSN</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getProtectedRangeStartFile</color><color=#f8f8f2>(),</color> <color=#ae81ff>0</color><color=#f8f8f2>),</color>
        <color=#f8f8f2>searchResults</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Search backwards for the replica's log record at this target VLSN. The target record is either</color>
<color=#75715e>   * the replica's first suggestion for a matchpoint, or feeder's counter offer. We have checked</color>
<color=#75715e>   * earlier that the counter offer is within the replica's vlsn range.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>OutputWireRecord</color> <color=#a6e22e>getReplicaRecord</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>OutputWireRecord</color> <color=#f8f8f2>replicaRecord</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>replicaRecord</color> <color=#f92672>=</color> <color=#f8f8f2>backwardsReader</color><color=#f8f8f2>.</color><color=#a6e22e>scanBackwards</color><color=#f8f8f2>(</color><color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We're hunting for a VLSN that should be in the VLSN range,</color>
<color=#75715e>         * and it should exist.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>replicaRecord</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
              <color=#e6db74>"Searching for candidate matchpoint "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>candidateMatchpoint</color>
                  <color=#f92672>+</color> <color=#e6db74>" but got null record back "</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* We've found the record at candidateMatchpoint */</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>replicaRecord</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>SkipGapException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * The ReplicaSyncupReader will throw a SkipGapException if it</color>
<color=#75715e>         * encounters a cleaned files gap in the log. There can be</color>
<color=#75715e>         * multiple gaps on its way toward finding the candidate</color>
<color=#75715e>         * vlsn. The ReplicaSyncupReader is obliged to traverse the</color>
<color=#75715e>         * log, in order to note checkpoints, rather than simply using</color>
<color=#75715e>         * the vlsn index. When a gap is detected, the vlsn on the left</color>
<color=#75715e>         * side of the gap is used to re-init a new reader. For</color>
<color=#75715e>         * example, suppose the log looks like this:</color>
<color=#75715e>         *</color>
<color=#75715e>         * file 100 has vlsns 41-50</color>
<color=#75715e>         * file 200 has vlsns 51-60</color>
<color=#75715e>         * file 300 has vlsns 61-70</color>
<color=#75715e>         *</color>
<color=#75715e>         * and the candidate matchpoint is 45, the search will start at</color>
<color=#75715e>         * vlsn 70.</color>
<color=#75715e>         *  t1: SkipGapException thrown at gap between file 200 & 300,</color>
<color=#75715e>         *      create new reader positioned at vlsn 60</color>
<color=#75715e>         *  t2: SkipGapException thrown at gap between file 100 & 200,</color>
<color=#75715e>         *      create new reader positioned at vlsn 50</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>VLSN</color> <color=#f8f8f2>gapRepositionVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>e</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>();</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>gapRepositionVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#e6db74>"Gap reposition point of "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>gapRepositionVLSN</color>
                  <color=#f92672>+</color> <color=#e6db74>" should always be >= candidate matchpoint VLSN of "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>long</color> <color=#f8f8f2>startScanLsn</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getGTELsn</color><color=#f8f8f2>(</color><color=#f8f8f2>gapRepositionVLSN</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>backwardsReader</color> <color=#f92672>=</color> <color=#f8f8f2>setupBackwardsReader</color><color=#f8f8f2>(</color><color=#f8f8f2>candidateMatchpoint</color><color=#f8f8f2>,</color> <color=#f8f8f2>startScanLsn</color><color=#f8f8f2>);</color>
        <color=#75715e>/*</color>
<color=#75715e>         * If we skip a gap, there is a chance that we will have passed</color>
<color=#75715e>         * a checkpoint which had deleted log files. This has no impact</color>
<color=#75715e>         * if we are doing a soft rollback, but if we do a hard</color>
<color=#75715e>         * recovery, it would prevent us from truncating the log. It</color>
<color=#75715e>         * would require doing a network restore if we need to rollback</color>
<color=#75715e>         * committed txns.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>noteSkippedGap</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Search backwards for potential matchpoints in the replica log, accounting for potential gaps.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>OutputWireRecord</color> <color=#a6e22e>scanMatchpointEntries</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>OutputWireRecord</color> <color=#f8f8f2>replicaRecord</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>firstAttempt</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * The first time around, when firstAttempt is true, ask the</color>
<color=#75715e>         * reader to search for the vlsn before the currentVLSN,</color>
<color=#75715e>         * because we entered this method having searched to a given</color>
<color=#75715e>         * target matchpoint. All subsequent times, we are in search of</color>
<color=#75715e>         * the reader's currentVLSN, but haven't found it yet, because</color>
<color=#75715e>         * we hit a gap, so leave the currentVLSN alone.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>replicaRecord</color> <color=#f92672>=</color> <color=#f8f8f2>backwardsReader</color><color=#f8f8f2>.</color><color=#a6e22e>findPrevSyncEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>firstAttempt</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Either se've found a possible matchpoint, or we've come to</color>
<color=#75715e>         * the end and the replicaRecord is null. One way or another,</color>
<color=#75715e>         * return the results of the scan.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>replicaRecord</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>SkipGapException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * The ReplicaSyncupReader will throw a SkipGapException if it</color>
<color=#75715e>         * encounters a cleaned files gap in the log. There can be</color>
<color=#75715e>         * multiple gaps on its way toward finding the next potential</color>
<color=#75715e>         * matchpoint. The ReplicaSyncupReader is obliged to traverse</color>
<color=#75715e>         * the log, in order to note checkpoints, rather than simply</color>
<color=#75715e>         * using the vlsn index. When a gap is detected, the vlsn on</color>
<color=#75715e>         * the left side of the gap is used to re-init a new</color>
<color=#75715e>         * reader. For example, suppose the log looks like this and the</color>
<color=#75715e>         * search starts at vlsn 70</color>
<color=#75715e>         *</color>
<color=#75715e>         * file 100 has vlsns 51-60</color>
<color=#75715e>         * file 200 has no vlsns</color>
<color=#75715e>         * file 300 has no vlsns</color>
<color=#75715e>         * file 400 has vlsns 61-70</color>
<color=#75715e>         *</color>
<color=#75715e>         *  SkipGapException thrown at gap between file 300 & 400,</color>
<color=#75715e>         *  when the reader's currentVLSN is 60. Create a new reader,</color>
<color=#75715e>         *  positioned at vlsn 60, skipping over files 200 and 300.</color>
<color=#75715e>         */</color>

        <color=#f8f8f2>VLSN</color> <color=#f8f8f2>gapRepositionVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>e</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>backwardsReader</color> <color=#f92672>=</color>
            <color=#f8f8f2>setupBackwardsReader</color><color=#f8f8f2>(</color><color=#f8f8f2>gapRepositionVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getGTELsn</color><color=#f8f8f2>(</color><color=#f8f8f2>gapRepositionVLSN</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>firstAttempt</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>noteSkippedGap</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Ask the feeder for information to add to InsufficientLogException, and then throw the</color>
<color=#75715e>   * exception.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The endVLSN marks the last VLSN that this node will want from the network restore. That</color>
<color=#75715e>   * information helps ensure that the restore source has enough vlsns to satisfy this replica.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The replication node list identifies possible log provider members.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws IOException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>InsufficientLogException</color> <color=#a6e22e>setupLogRefresh</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>failedMatchpoint</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>protocol</color><color=#f8f8f2>.</color><color=#a6e22e>write</color><color=#f8f8f2>(</color><color=#f8f8f2>protocol</color><color=#f8f8f2>.</color><color=#a6e22e>new</color> <color=#a6e22e>RestoreRequest</color><color=#f8f8f2>(</color><color=#f8f8f2>failedMatchpoint</color><color=#f8f8f2>),</color> <color=#f8f8f2>namedChannel</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>RestoreResponse</color> <color=#f8f8f2>response</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>RestoreResponse</color><color=#f8f8f2>)</color> <color=#f8f8f2>protocol</color><color=#f8f8f2>.</color><color=#a6e22e>read</color><color=#f8f8f2>(</color><color=#f8f8f2>namedChannel</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>InsufficientLogException</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>repNode</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>ReplicationNode</color><color=#f92672>></color><color=#f8f8f2>(</color><color=#f8f8f2>Arrays</color><color=#f8f8f2>.</color><color=#a6e22e>asList</color><color=#f8f8f2>(</color><color=#f8f8f2>response</color><color=#f8f8f2>.</color><color=#a6e22e>getLogProviders</color><color=#f8f8f2>())));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Hard recovery: truncate the files, repeat recovery. If this hard recovery came about before the</color>
<color=#75715e>   * ReplicatedEnvironment was fully instantiated, we will recreate the environment under the</color>
<color=#75715e>   * covers. If this came while the replica was up and supporting existing Environment handles, we</color>
<color=#75715e>   * must invalidate the environment, and ask the application to reopen.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>RollbackException</color> <color=#a6e22e>setupHardRecovery</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Creating the exception invalidates the environment. */</color>
    <color=#f8f8f2>RollbackException</color> <color=#f8f8f2>r</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RollbackException</color><color=#f8f8f2>(</color><color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>matchpointVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>severe</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
        <color=#e6db74>"Limited list of transactions truncated for "</color>
            <color=#f92672>+</color> <color=#e6db74>"hard recovery:\n"</color>
            <color=#f92672>+</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>dumpPassedTxns</color><color=#f8f8f2>());</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Truncate after the environment is invalidated, which happens</color>
<color=#75715e>     * when we instantiate RollbackException.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>matchpointLSN</color> <color=#f92672>=</color> <color=#f8f8f2>searchResults</color><color=#f8f8f2>.</color><color=#a6e22e>getMatchpointLSN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>repImpl</color>
        <color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>()</color>
        <color=#f8f8f2>.</color><color=#a6e22e>truncateLog</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>matchpointLSN</color><color=#f8f8f2>),</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>matchpointLSN</color><color=#f8f8f2>));</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>r</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Request a log entry from the feeder at this VLSN. The Feeder will only return the log record or</color>
<color=#75715e>   * say that it isn't available.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws InsufficientLogException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>InputWireRecord</color> <color=#a6e22e>getFeederRecord</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>range</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>requestVLSN</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>acceptAlternative</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color><color=#f8f8f2>,</color> <color=#f8f8f2>InsufficientLogException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Ask the feeder for the matchpoint log record. */</color>
    <color=#f8f8f2>protocol</color><color=#f8f8f2>.</color><color=#a6e22e>write</color><color=#f8f8f2>(</color><color=#f8f8f2>protocol</color><color=#f8f8f2>.</color><color=#a6e22e>new</color> <color=#a6e22e>EntryRequest</color><color=#f8f8f2>(</color><color=#f8f8f2>requestVLSN</color><color=#f8f8f2>),</color> <color=#f8f8f2>namedChannel</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Expect</color>
<color=#75715e>     *  a) the requested log record</color>
<color=#75715e>     *  b) message that says this feeder doesn't have RequestVLSN</color>
<color=#75715e>     *  c) if acceptAlternative == true and the feeder didn't have</color>
<color=#75715e>     *     requestVLSN, but had an earlier entry, the feeder may send an</color>
<color=#75715e>     *      earlier, alternative matchpoint</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>Message</color> <color=#f8f8f2>message</color> <color=#f92672>=</color> <color=#f8f8f2>protocol</color><color=#f8f8f2>.</color><color=#a6e22e>read</color><color=#f8f8f2>(</color><color=#f8f8f2>namedChannel</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>message</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>Entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>Entry</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>Entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>message</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>entry</color><color=#f8f8f2>.</color><color=#a6e22e>getWireRecord</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>message</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>EntryNotFound</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>repImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"Requested "</color>
              <color=#f92672>+</color> <color=#f8f8f2>requestVLSN</color>
              <color=#f92672>+</color> <color=#e6db74>" from "</color>
              <color=#f92672>+</color> <color=#f8f8f2>namedChannel</color><color=#f8f8f2>.</color><color=#a6e22e>getNameIdPair</color><color=#f8f8f2>()</color>
              <color=#f92672>+</color> <color=#e6db74>" but that node did not have that vlsn."</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>setupLogRefresh</color><color=#f8f8f2>(</color><color=#f8f8f2>requestVLSN</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>acceptAlternative</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>message</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>AlternateMatchpoint</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>AlternateMatchpoint</color> <color=#f8f8f2>alt</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>AlternateMatchpoint</color><color=#f8f8f2>)</color> <color=#f8f8f2>message</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>InputWireRecord</color> <color=#f8f8f2>feederRecord</color> <color=#f92672>=</color> <color=#f8f8f2>alt</color><color=#f8f8f2>.</color><color=#a6e22e>getAlternateWireRecord</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>VLSN</color> <color=#f8f8f2>altMatchpoint</color> <color=#f92672>=</color> <color=#f8f8f2>feederRecord</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>altMatchpoint</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * The feeder suggest a different matchpoint, but it's outside</color>
<color=#75715e>         * the replica's range. Give up and do a network restore.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>setupLogRefresh</color><color=#f8f8f2>(</color><color=#f8f8f2>altMatchpoint</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>feederRecord</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>repNode</color><color=#f8f8f2>.</color><color=#a6e22e>getRepImpl</color><color=#f8f8f2>(),</color> <color=#e6db74>"Sent EntryRequest, got unexpected response of "</color> <color=#f92672>+</color> <color=#f8f8f2>message</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>setGlobalSyncupEndHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color><color=#f92672><</color><color=#f8f8f2>Object</color><color=#f92672>></color> <color=#f8f8f2>syncupEndHook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>ReplicaFeederSyncup</color><color=#f8f8f2>.</color><color=#a6e22e>globalSyncupEndHook</color> <color=#f92672>=</color> <color=#f8f8f2>syncupEndHook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>runHook</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>InterruptedException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>syncupEndHook</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>syncupEndHook</color><color=#f8f8f2>.</color><color=#a6e22e>doHook</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>globalSyncupEndHook</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>globalSyncupEndHook</color><color=#f8f8f2>.</color><color=#a6e22e>doHook</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * This interface is used instead of com.sleepycat.je.utilint.TestHook because the doHook method</color>
<color=#75715e>   * needs to throw InterruptedException.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>interface</color> <color=#a6e22e>TestHook</color><color=#f92672><</color><color=#f8f8f2>T</color><color=#f92672>></color> <color=#f8f8f2>{</color>
    <color=#66d9ef>void</color> <color=#a6e22e>doHook</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>InterruptedException</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* Setup the static rollback test hook, test use only */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>setRollbackTestHook</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>com</color><color=#f8f8f2>.</color><color=#a6e22e>sleepycat</color><color=#f8f8f2>.</color><color=#a6e22e>je</color><color=#f8f8f2>.</color><color=#a6e22e>utilint</color><color=#f8f8f2>.</color><color=#a6e22e>TestHook</color><color=#f92672><</color><color=#f8f8f2>ReplicaFeederSyncup</color><color=#f92672>></color> <color=#f8f8f2>rollbackHook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>ReplicaFeederSyncup</color><color=#f8f8f2>.</color><color=#a6e22e>rollbackHook</color> <color=#f92672>=</color> <color=#f8f8f2>rollbackHook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>