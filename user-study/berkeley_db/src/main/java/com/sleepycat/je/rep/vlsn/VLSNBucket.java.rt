<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.rep.vlsn</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.bind.tuple.LongBinding</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.bind.tuple.TupleBinding</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.bind.tuple.TupleInput</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.bind.tuple.TupleOutput</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DatabaseImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.FileReader</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.txn.Txn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.DbLsn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.VLSN</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.io.PrintStream</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.nio.ByteBuffer</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.ArrayList</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.List</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * A VLSNBucket instance represents a set of VLSN->LSN mappings. Buckets are usually not updated,</color>
<color=#75715e> * except at times when the replication stream may have been reduced in size, by log cleaning or</color>
<color=#75715e> * syncup. The VLSNBuckets in the VLSNIndex's VLSNTracker are written to disk and are persistent.</color>
<color=#75715e> * There are also VLSNBuckets in the temporary recovery-time tracker that are used for collecting</color>
<color=#75715e> * mappings found in the log during recovery.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>VLSNBuckets only hold mappings from a single log file. A single log file may be mapped by</color>
<color=#75715e> * multiple VLSNBuckets though.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>As a tradeoff in space vs time, a VLSNBucket only stores a sparse set of mappings and the</color>
<color=#75715e> * caller must use a VLSNReader to scan the log file and find any log entries not mapped directly by</color>
<color=#75715e> * the bucket. In addition, the VLSN is not actually stored. Only the offset portion of the LSN is</color>
<color=#75715e> * stored, and the VLSN is intuited by a stride field. Each VLSNBucket only maps a single file,</color>
<color=#75715e> * though a single file may be mapped by several VLSNBuckets.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>For example, suppose a node had these VLSN->LSN mappings:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>VLSN LSN (file/offset) 9 10/100 10 10/110 11 10/120 12 10/130 13 10/140 14 11/100 15 11/120</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The mappings in file 10 could be represented by a VLSNBucket with a stride of 4. That means</color>
<color=#75715e> * the bucket would hold the mappings for 9 10/100, 13 10/140</color>
<color=#75715e> *</color>
<color=#75715e> * <p>And since the target log file number and the stride is known, the mappings can be represented</color>
<color=#75715e> * in by the offset alone in this array: {100, 140}, rather than storing the whole lsn.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Each bucket can also provide the mapping for the first and last VLSN it covers, even if the</color>
<color=#75715e> * lastVLSN is not divisible by the stride. This is done to support forward and backward scanning.</color>
<color=#75715e> * From the example above, the completed bucket can provide 9->10/100, 13->10/140, 15 -> 10/160 even</color>
<color=#75715e> * though 15 is not a stride's worth away from 13.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Because registering a VLSN->LSN mapping is done outside the log write latch, any inserts into</color>
<color=#75715e> * the VLSNBucket may not be in order. However, when any VLSN is registered, we can assume that all</color>
<color=#75715e> * VLSNs < that value do exist in the log. It's just an accident of timing that they haven't yet</color>
<color=#75715e> * been registered. Note that out of order inserts into the buckets can create holes in the bucket's</color>
<color=#75715e> * offset array, or cause the array to be shorter than anticipated.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>For example, if the insertion order into the bucket is vlsns 9, 15, we'll actually only keep</color>
<color=#75715e> * an offset array of size 1. We have to be able to handle holes in the bucket, and can't count on</color>
<color=#75715e> * filling them in when the lagging vlsn arrives, because it is possible that a reading thread will</color>
<color=#75715e> * access the bucket before the laggard inserter arrives, or that the bucket might be flushed to</color>
<color=#75715e> * disk, and become immutable.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>VLSNBucket</color> <color=#f8f8f2>{</color>

  <color=#75715e>/* On-disk version. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>VERSION</color> <color=#f92672>=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

  <color=#75715e>/* File number for target file. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>fileNumber</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Interval between VLSN values that are mapped. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>stride</color><color=#f8f8f2>;</color>

  <color=#66d9ef>protected</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>firstVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>;</color>
  <color=#66d9ef>protected</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The file offsets are really unsigned ints. The calls to put() are</color>
<color=#75715e>   * implemented to let us assume that the list is fully populated.  A</color>
<color=#75715e>   * subclass of truncateableList has been used in order to provide access to</color>
<color=#75715e>   * the ArrayList.removeFromRange method.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TruncateableList</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The max number of offsets and maxDistance help guide when to close the</color>
<color=#75715e>   * bucket and start a new one. Not persistent.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxMappings</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxDistance</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>NO_OFFSET</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#75715e>/* True if there are changes to the bucket that are not on disk. */</color>
  <color=#66d9ef>boolean</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * True if the VLSNBucket will not accept any more modifications; used to</color>
<color=#75715e>   * safeguard the bucket while the index is being written to disk.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>closed</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>fileNumber</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>stride</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxMappings</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxDistance</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>fileNumber</color> <color=#f92672>=</color> <color=#f8f8f2>fileNumber</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>stride</color> <color=#f92672>=</color> <color=#f8f8f2>stride</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>maxMappings</color> <color=#f92672>=</color> <color=#f8f8f2>maxMappings</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>maxDistance</color> <color=#f92672>=</color> <color=#f8f8f2>maxDistance</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The VLSNs in the bucket are initialized to indicate what range</color>
<color=#75715e>     * should be covered by this bucket. But there may not be any offsets</color>
<color=#75715e>     * recorded either in the lastLsn or the fileOffset.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>firstVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lastVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Initialize the file offsets with a -1 value to correspond to</color>
<color=#75715e>     * firstVLSN.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>fileOffsets</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TruncateableList</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>NO_OFFSET</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For reading from disk. */</color>
  <color=#66d9ef>private</color> <color=#a6e22e>VLSNBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>TupleInput</color> <color=#f8f8f2>ti</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>fileNumber</color> <color=#f92672>=</color> <color=#f8f8f2>ti</color><color=#f8f8f2>.</color><color=#a6e22e>readPackedLong</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>stride</color> <color=#f92672>=</color> <color=#f8f8f2>ti</color><color=#f8f8f2>.</color><color=#a6e22e>readPackedInt</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>firstVLSN</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>ti</color><color=#f8f8f2>.</color><color=#a6e22e>readPackedLong</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>lastVLSN</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>ti</color><color=#f8f8f2>.</color><color=#a6e22e>readPackedLong</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>lastLsn</color> <color=#f92672>=</color> <color=#f8f8f2>ti</color><color=#f8f8f2>.</color><color=#a6e22e>readPackedLong</color><color=#f8f8f2>();</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#f8f8f2>ti</color><color=#f8f8f2>.</color><color=#a6e22e>readPackedInt</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>fileOffsets</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TruncateableList</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f92672>></color><color=#f8f8f2>(</color><color=#f8f8f2>size</color><color=#f8f8f2>);</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffsetAsInt</color><color=#f8f8f2>(</color><color=#f8f8f2>ti</color><color=#f8f8f2>.</color><color=#a6e22e>readUnsignedInt</color><color=#f8f8f2>()));</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Record the LSN location for this VLSN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>One key issue is that puts() are not synchronized, and the VLSNs may arrive out of order. If</color>
<color=#75715e>   * an out of order VLSN does arrive, we can still assume that the earlier VLSNs have been</color>
<color=#75715e>   * successfully logged. If a VLSN arrives that is divisible by the stride, and should be recorded</color>
<color=#75715e>   * in the fileOffsets, but is not the next VLSN that should be recorded, we'll pad out the</color>
<color=#75715e>   * fileOffsets list with placeholders.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>For example, suppose the stride is 3, and the first VLSN is 2. Then this bucket should</color>
<color=#75715e>   * record VLSN 2, 5, 8, ... etc. If VLSN 8 arrives before VLSN 5, VLSN 8 will be recorded, and</color>
<color=#75715e>   * VLSN 5 will have an offset placeholder of NO_OFFSET. It is a non-issue if VLSNs 3, 4, 6, 7</color>
<color=#75715e>   * arrive out of order, because they would not have been recorded anyway. This should not happen</color>
<color=#75715e>   * often, because the stride should be fairly large, and the calls to put() should be close</color>
<color=#75715e>   * together. If the insertion order is vlsn 2, 5, 9, then the file offsets array will be a little</color>
<color=#75715e>   * short, and will only have 2 elements, instead of 3.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>We follow this policy because we must always have a valid begin and end point for the range.</color>
<color=#75715e>   * We must handle placeholders in all cases, and can't count of later vlsn inserts, because a</color>
<color=#75715e>   * bucket can become immutable at any time if it is flushed to disk.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return false if this bucket will not accept this VLSN. Generally, a refusal might happen</color>
<color=#75715e>   *     because the bucket was full or the mapping is too large a distance away from the previous</color>
<color=#75715e>   *     mapping. In that case, the tracker will start another bucket.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>synchronized</color> <color=#66d9ef>boolean</color> <color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>closed</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>belongs</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Add it to the fileOffset if it's on a stride boundary and is the</color>
<color=#75715e>     * next mapping in the fileOffset list.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isModulo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>getIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>listLen</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672><</color> <color=#f8f8f2>listLen</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffsetAsInt</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>==</color> <color=#f8f8f2>listLen</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffsetAsInt</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>listLen</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>NO_OFFSET</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffsetAsInt</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>dirty</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* If the lastLsn is less, or not initialized, set it to this VLSN. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lastVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>lastLsn</color> <color=#f92672>=</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>dirty</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Return true if this VLSN is on a stride boundary.  Assumes</color>
<color=#75715e>   * !firstVLSN.isNull()</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isModulo</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(((</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>())</color> <color=#f92672>%</color> <color=#f8f8f2>stride</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>getIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>isModulo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#e6db74>"Don't call getIndex on non-modulo VLSN "</color> <color=#f92672>+</color> <color=#f8f8f2>vlsn</color> <color=#f92672>+</color> <color=#e6db74>" bucket="</color> <color=#f92672>+</color> <color=#66d9ef>this</color><color=#f8f8f2>;</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>((</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>())</color> <color=#f92672>/</color> <color=#f8f8f2>stride</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return true if this VLSN->LSN mapping should go into this bucket. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>belongs</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color>
        <color=#f8f8f2>:</color> <color=#e6db74>"firstVLSN = "</color> <color=#f92672>+</color> <color=#f8f8f2>firstVLSN</color> <color=#f92672>+</color> <color=#e6db74>" should not be greater than "</color> <color=#f92672>+</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>fileNumber</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Mappings must be for same file. */</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>emptyInternal</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Some other thread beat us to the put() call and inserted a later</color>
<color=#75715e>     * mapping, so we know for sure that we fit in this bucket</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>onStrideBoundary</color> <color=#f92672>=</color> <color=#f8f8f2>isModulo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>onStrideBoundary</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#f8f8f2>maxMappings</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Too full. */</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Will this VLSN be next one recorded in the fileOffsets? If so,</color>
<color=#75715e>     * calculate the scan distance.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>onStrideBoundary</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>getIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()))</color>
        <color=#f92672>||</color> <color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* This VLSN is going in at the tail of the bucket. */</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>lastOffset</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#75715e>/* The scan distance is exceeded. */</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffset</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f92672>-</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>convertIntFileOffsetToLong</color><color=#f8f8f2>(</color><color=#f8f8f2>lastOffset</color><color=#f8f8f2>))</color> <color=#f92672><=</color> <color=#f8f8f2>maxDistance</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @return true if this bucket contains this mapping. */</color>
  <color=#66d9ef>synchronized</color> <color=#66d9ef>boolean</color> <color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>synchronized</color> <color=#f8f8f2>VLSN</color> <color=#a6e22e>getFirst</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>synchronized</color> <color=#f8f8f2>VLSN</color> <color=#a6e22e>getLast</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>lastVLSN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return a file number that is less or equal to the first lsn mapped by this bucket. In standard</color>
<color=#75715e>   * VLSNBuckets, only one file is covered, so there is only one possible value. In GhostBuckets,</color>
<color=#75715e>   * multiple files could be covered.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return</color>
<color=#75715e>   */</color>
  <color=#66d9ef>long</color> <color=#a6e22e>getLTEFileNumber</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>fileNumber</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Similar to getLTEFileNumber, for this implementation there's only one</color>
<color=#75715e>   * possible file.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>long</color> <color=#a6e22e>getGTEFileNumber</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>fileNumber</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>synchronized</color> <color=#66d9ef>boolean</color> <color=#a6e22e>empty</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>emptyInternal</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>emptyInternal</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>boolean</color> <color=#a6e22e>follows</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>boolean</color> <color=#a6e22e>precedes</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the mapping whose VLSN is >= the VLSN parameter. For example, if the bucket holds</color>
<color=#75715e>   * mappings for vlsn 10, 13, 16,</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>- the greater than or equal mapping for VLSN 10 is 10/lsn - the greater than or equal</color>
<color=#75715e>   * mapping for VLSN 11 is 13/lsn - the greater than or equal mapping for VLSN 13 is 13/lsn</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>File offsets may be null in the middle of the file offsets array because of out of order</color>
<color=#75715e>   * mappings. This method must return a non-null lsn, and must account for null offsets.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the mapping whose VLSN is >= the VLSN parameter. Will never return NULL_LSN, because</color>
<color=#75715e>   *     the VLSNRange begin and end point are always mapped.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>long</color> <color=#a6e22e>getGTELsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * It's possible for vlsn to be < the firstVLSN if vlsn</color>
<color=#75715e>       * falls between two buckets. For example, if the buckets are:</color>
<color=#75715e>       *    bucketA = vlsn 10-> 20</color>
<color=#75715e>       *    bucketB = vlsn 22->30</color>
<color=#75715e>       * then vlsn 21 will fall between two buckets, and will get bucketB</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>getGTEIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This should never happen. Throw this exception to make debugging</color>
<color=#75715e>     * info available.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"index="</color> <color=#f92672>+</color> <color=#f8f8f2>index</color> <color=#f92672>+</color> <color=#e6db74>" vlsn="</color> <color=#f92672>+</color> <color=#f8f8f2>vlsn</color> <color=#f92672>+</color> <color=#e6db74>" bucket="</color> <color=#f92672>+</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>useIndex</color> <color=#f92672>=</color> <color=#f8f8f2>findPopulatedIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/* forward */</color><color=#f8f8f2>);</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>offset</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>useIndex</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>offset</color> <color=#f92672>==</color> <color=#f8f8f2>NO_OFFSET</color> <color=#f92672>?</color> <color=#f8f8f2>lastLsn</color> <color=#f8f8f2>:</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNumber</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return the index for the mapping >= this VLSN. Note that this is just a stride calculation, and</color>
<color=#75715e>   * a non-existent file offset index might be returned.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>getGTEIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>diff</color> <color=#f92672>=</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>();</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>((</color><color=#f8f8f2>diff</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>stride</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>))</color> <color=#f92672>/</color> <color=#f8f8f2>stride</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * We'd like to return the mapping at startIndex for the get{LTE, GTE} Mapping methods, but the</color>
<color=#75715e>   * offsets may not be populated if put() calls have come out of order. Search for the next</color>
<color=#75715e>   * populated offset.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>findPopulatedIndex</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>startIndex</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>forward</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>startIndex</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>NO_OFFSET</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>i</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>startIndex</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>--</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>NO_OFFSET</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>i</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>startIndex</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the lsn whose VLSN is <= the VLSN parameter. For example, if the bucket holds mappings</color>
<color=#75715e>   * for vlsn 10, 13, 16,</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>- the less than or equal mapping for VLSN 10 is 10/lsn - the less than or equal mapping for</color>
<color=#75715e>   * VLSN 11 is 10/lsn - the less than or equal mapping for VLSN 13 is 13/lsn</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>File offsets may be null in the middle of the file offsets array because of out of order</color>
<color=#75715e>   * mappings. This method must return a non-null lsn, and must account for null offsets.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the lsn whose VLSN is <= the VLSN parameter. Will never return NULL_LSN, because the</color>
<color=#75715e>   *     VLSNRange begin and end points are always mapped.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>synchronized</color> <color=#66d9ef>long</color> <color=#a6e22e>getLTELsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * It's possible for vlsn to be greater than lastVLSN if vlsn falls</color>
<color=#75715e>     * between two buckets.</color>
<color=#75715e>     * For example, if the buckets are:</color>
<color=#75715e>     *    bucketA = vlsn 10-> 20</color>
<color=#75715e>     *    bucketB = vlsn 22->30</color>
<color=#75715e>     * then vlsn 21 will fall between two buckets, and will get bucketA</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>diff</color> <color=#f92672>=</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Make sure that the file offset array isn't unexpectedly short due to</color>
<color=#75715e>     * out of order inserts.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>diff</color> <color=#f92672>/</color> <color=#f8f8f2>stride</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>useIndex</color> <color=#f92672>=</color> <color=#f8f8f2>findPopulatedIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/* forward */</color><color=#f8f8f2>);</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>offset</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>useIndex</color><color=#f8f8f2>);</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>offset</color> <color=#f92672>!=</color> <color=#f8f8f2>NO_OFFSET</color>
        <color=#f8f8f2>:</color> <color=#e6db74>"bucket should always have a non-null "</color>
            <color=#f92672>+</color> <color=#e6db74>"first offset. vlsn= "</color>
            <color=#f92672>+</color> <color=#f8f8f2>vlsn</color>
            <color=#f92672>+</color> <color=#e6db74>" bucket="</color>
            <color=#f92672>+</color> <color=#66d9ef>this</color><color=#f8f8f2>;</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNumber</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * @return the lsn whose VLSN is == the VLSN parameter or DbLsn.NULL_LSN if there is no mapping.</color>
<color=#75715e>   *     Note that because of out of order puts, there may be missing mappings that appear later on.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>long</color> <color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#e6db74>"vlsn="</color> <color=#f92672>+</color> <color=#f8f8f2>vlsn</color> <color=#f92672>+</color> <color=#e6db74>" "</color> <color=#f92672>+</color> <color=#66d9ef>this</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isModulo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>getIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>offset</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>offset</color> <color=#f92672>==</color> <color=#f8f8f2>NO_OFFSET</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNumber</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>synchronized</color> <color=#66d9ef>long</color> <color=#a6e22e>getLastLsn</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Remove the mappings from this bucket that are for VLSNs <= lastDuplicate. If this results in a</color>
<color=#75715e>   * broken stride interval, package all those mappings into their own bucket and return it as a</color>
<color=#75715e>   * remainder bucket.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>For example, suppose this bucket has a stride of 5 and maps VLSN 10-23. Then it has mappings</color>
<color=#75715e>   * for 10, 15, 20, 23.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If we need to remove mappings <= 16, we'll end up without a bucket that serves as a home</color>
<color=#75715e>   * base for vlsns 17,18,19. Those will be spun out into their own bucket, and this bucket will be</color>
<color=#75715e>   * adjusted to start at VLSN 20. This bucket should end up with</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>- firstVLSN = 20 - fileOffset is an array of size 1, for the LSN for VLSN 20 - lastVLSN = 23</color>
<color=#75715e>   * - lastLsn = the same as before</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The spun-off bucket should be: - firstVLSN = 17 - fileOffset is an array of size 1, for the</color>
<color=#75715e>   * LSN for VLSN 17 - lastVLSN = 19 - lastLsn = lsn for 19</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the newly created bucket that holds mappings from a broken stride interval, or null if</color>
<color=#75715e>   *     there was no need to create such a bucket.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>VLSNBucket</color> <color=#a6e22e>removeFromHead</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastDuplicate</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>empty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * No overlap, this bucket owns mappngs that follow the duplicate</color>
<color=#75715e>     * range.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastDuplicate</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This whole bucket is to be deleted, all its mappings are <= the</color>
<color=#75715e>     * lastDuplicate.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>lastDuplicate</color><color=#f8f8f2>)</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>fileOffsets</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>firstVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>lastVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>lastLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>indexVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>newFirstIndex</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Find the mappings that still belong. Using the example above, we</color>
<color=#75715e>     * should find that we can delete fileOffset[0] and fileOffset[1] and</color>
<color=#75715e>     * preserve fileOffset[2]</color>
<color=#75715e>     */</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>indexVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>lastDuplicate</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>NO_OFFSET</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>newFirstIndex</color> <color=#f92672>=</color> <color=#f8f8f2>i</color><color=#f8f8f2>;</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>indexVLSN</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>indexVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#f8f8f2>stride</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>remainder</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>lastOffset</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newFirstIndex</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * None of the VLSNs represented by the strided file offsets are</color>
<color=#75715e>       * needed anymore. This bucket consists solely of the last</color>
<color=#75715e>       * VLSN->LSN pair.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>lastOffset</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>fileOffsets</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TruncateableList</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f92672>></color><color=#f8f8f2>();</color>
      <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileOffsetAsInt</color><color=#f8f8f2>(</color><color=#f8f8f2>lastLsn</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>firstVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>lastVLSN</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Move the still-valid mappings to a new list. */</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>newFirstIndex</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>lastOffset</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>newFirstIndex</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>TruncateableList</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#f8f8f2>newFileOffsets</color> <color=#f92672>=</color>
          <color=#66d9ef>new</color> <color=#f8f8f2>TruncateableList</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f92672>></color><color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>subList</color><color=#f8f8f2>(</color><color=#f8f8f2>newFirstIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()));</color>
      <color=#f8f8f2>fileOffsets</color> <color=#f92672>=</color> <color=#f8f8f2>newFileOffsets</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>firstVLSN</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>((</color><color=#f8f8f2>newFirstIndex</color> <color=#f92672>*</color> <color=#f8f8f2>stride</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>lastDuplicate</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If lastDuplicate was not on the same stride boundary as our old</color>
<color=#75715e>       * bucket, we may have a broken bucket of mappings to preserve.</color>
<color=#75715e>       * Using our example numbers above, we still need to make sure</color>
<color=#75715e>       * there's a bucket that matches VLSNs 17, 18 19.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>scanStart</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNumber</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastOffset</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>remainder</color> <color=#f92672>=</color>
          <color=#f8f8f2>scanForNewBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastDuplicate</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>(),</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getPrev</color><color=#f8f8f2>(),</color> <color=#f8f8f2>scanStart</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>dirty</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>remainder</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Scan the log fle for VLSN->LSN mappings for creating a new bucket. */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>VLSNBucket</color> <color=#a6e22e>scanForNewBucket</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>first</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>last</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>newBucket</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNumber</color><color=#f8f8f2>,</color> <color=#f8f8f2>stride</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxMappings</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxDistance</color><color=#f8f8f2>,</color> <color=#f8f8f2>first</color><color=#f8f8f2>);</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_ITERATOR_MAX_SIZE</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>NewBucketReader</color> <color=#f8f8f2>scanner</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>NewBucketReader</color><color=#f8f8f2>(</color><color=#f8f8f2>newBucket</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>first</color><color=#f8f8f2>,</color> <color=#f8f8f2>last</color><color=#f8f8f2>,</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>scanner</color><color=#f8f8f2>.</color><color=#a6e22e>isDone</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>scanner</color><color=#f8f8f2>.</color><color=#a6e22e>readNextEntry</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>scanner</color><color=#f8f8f2>.</color><color=#a6e22e>isDone</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>newBucket</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Remove the mappings from this bucket that are for VLSNs >= startOfDelete. Unlike removing from</color>
<color=#75715e>   * the head, we need not worry about breaking a bucket stride interval.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If prevLsn is NULL_VLSN, we don't have a good value to cap the bucket. Instead, we'll have</color>
<color=#75715e>   * to delete the bucket back to whatever was the next available lsn. For example, suppose the</color>
<color=#75715e>   * bucket has these mappings. This strange bucket (stride 25 is missing) is possible if vlsn 26</color>
<color=#75715e>   * arrived early, out of order.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>in fileOffset: 10 -> 101 in fileOffset: 15 -> no offset in fileOffset: 20 -> 201</color>
<color=#75715e>   * lastVLSN->lastnLsn mapping 26 -> 250</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If we have a prevLsn and the startOfDelete is 17, then we can create a new mapping in</color>
<color=#75715e>   * fileOffset: 10 -> 101 in fileOffset: 15 -> no offset lastVLSN->lastnLsn mapping 17 -> 190</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If we don't have a prevLsn, then we know that we have to cut the bucket back to the largest</color>
<color=#75715e>   * known mapping, losing many mappings along the way. in fileOffset: 10 -> 101 lastVLSN->lastnLsn</color>
<color=#75715e>   * mapping 10 -> 101</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If we are deleting in the vlsn area between the last stride and the last offset, (i.e. vlsn</color>
<color=#75715e>   * 23 is the startOfDelete) the with and without prevLSn cases would look like this:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>(there is a prevLsn, and 23 is startDelete. No need to truncate anything) in fileOffset: 10</color>
<color=#75715e>   * -> 101 in fileOffset: 15 -> no offset in fileOffset: 20 -> 201 lastVLSN->lastnLsn mapping 23 -></color>
<color=#75715e>   * prevLsn</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>(there is no prevLsn, and 23 is startDelete) in fileOffset: 10 -> 101 in fileOffset: 15 -></color>
<color=#75715e>   * no offset in fileOffset: 20 -> 201 lastVLSN->lastnLsn mapping 20 -> 201</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param startOfDelete is the VLSN that begins the range to delete, inclusive</color>
<color=#75715e>   * @param prevLsn is the lsn of startOfDelete.getPrev(). We'll be using it to cap off the end of</color>
<color=#75715e>   *     the bucket, by assigning it to the lastLsn field.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>removeFromTail</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>startOfDelete</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>prevLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>empty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>startOfDelete</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Delete all the mappings. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>startOfDelete</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lastVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>lastLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Delete some of the mappings. */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>deleteIndex</color> <color=#f92672>=</color> <color=#f8f8f2>getGTEIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>startOfDelete</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This should never happen, because the startOfDelete should be a vlsn</color>
<color=#75715e>     * that is >= the first vlsn and we handled the case where</color>
<color=#75715e>     * startOfDelete == firstVLSN already.)  Throw this exception to make</color>
<color=#75715e>     * debugging info available.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>deleteIndex</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"deleteIndex="</color> <color=#f92672>+</color> <color=#f8f8f2>deleteIndex</color> <color=#f92672>+</color> <color=#e6db74>" startOfDelete="</color> <color=#f92672>+</color> <color=#f8f8f2>startOfDelete</color> <color=#f92672>+</color> <color=#e6db74>" bucket="</color> <color=#f92672>+</color> <color=#66d9ef>this</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* See if there are any fileoffsets to prune off. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>deleteIndex</color> <color=#f92672><</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The startOfDeleteVLSN is a value between the firstVLSN and</color>
<color=#75715e>       * the last file offset.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>lastPopulatedIndex</color> <color=#f92672>=</color> <color=#f8f8f2>findPopulatedIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteIndex</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastPopulatedIndex</color> <color=#f92672>!=</color> <color=#f8f8f2>(</color><color=#f8f8f2>deleteIndex</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>deleteIndex</color> <color=#f92672>=</color> <color=#f8f8f2>lastPopulatedIndex</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>truncate</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteIndex</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * The startOfDelete vlsn is somewhere between the last file offset</color>
<color=#75715e>       * and the lastVLSN.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>lastIndex</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>lastPopulatedIndex</color> <color=#f92672>=</color> <color=#f8f8f2>findPopulatedIndex</color><color=#f8f8f2>(</color><color=#f8f8f2>lastIndex</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastPopulatedIndex</color> <color=#f92672><</color> <color=#f8f8f2>lastIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>truncate</color><color=#f8f8f2>(</color><color=#f8f8f2>lastPopulatedIndex</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Now set the lastVLSN -> lastLSN mapping. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lastVLSN</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>(((</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f92672>*</color> <color=#f8f8f2>stride</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>Integer</color> <color=#f8f8f2>lastOffset</color> <color=#f92672>=</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>lastOffset</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>lastLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNumber</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lastVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>startOfDelete</color><color=#f8f8f2>.</color><color=#a6e22e>getPrev</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>lastLsn</color> <color=#f92672>=</color> <color=#f8f8f2>prevLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>dirty</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit tests */</color>
  <color=#66d9ef>int</color> <color=#a6e22e>getNumOffsets</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>close</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>closed</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Write this bucket to the mapping database. */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>writeToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>bucketDbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Txn</color> <color=#f8f8f2>txn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>dirty</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>Cursor</color> <color=#f8f8f2>c</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>c</color> <color=#f92672>=</color> <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>makeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>bucketDbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>txn</color><color=#f8f8f2>,</color> <color=#f8f8f2>CursorConfig</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>writeToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>c</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>c</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>c</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Write this bucket to the mapping database using a cursor. Note that this method must disable</color>
<color=#75715e>   * critical eviction. Critical eviction makes the calling thread search for a target IN node to</color>
<color=#75715e>   * evict. That target IN node may or may not be in the internal VLSN db.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>For example, when a new, replicated LN is inserted or modified, a new VLSN is allocated. To</color>
<color=#75715e>   * do so, the app thread that is executing the operation A1. Takes a BIN latch on a BIN in a</color>
<color=#75715e>   * replicated db A2. Takes the VLSNINdex mutex</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Anyone calling writeDatabase() has to take these steps: B1. Take the VLSNIndex mutex B2. Get</color>
<color=#75715e>   * a BIN latch for a BIN in the internal vlsn db.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This difference in locking hierarchy could cause a deadlock except for the fact that A1 and</color>
<color=#75715e>   * B2 are guaranteed to be in different databases. If writeDatabase() also did critical eviction,</color>
<color=#75715e>   * it would have a step where it tried to get a BIN latch on a replicated db, and we'd have a</color>
<color=#75715e>   * deadlock. [#18475]</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>writeToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>dirty</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>longToEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>key</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>VLSNBucketBinding</color> <color=#f8f8f2>bucketBinding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSNBucketBinding</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>bucketBinding</color><color=#f8f8f2>.</color><color=#a6e22e>objectToEntry</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>getCursorImpl</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>).</color><color=#a6e22e>setAllowEviction</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>!=</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Unable to write VLSNBucket for file "</color> <color=#f92672>+</color> <color=#f8f8f2>fileNumber</color> <color=#f92672>+</color> <color=#e6db74>" status="</color> <color=#f92672>+</color> <color=#f8f8f2>status</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>dirty</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Instantiate this from the database. Assumes that this bucket will not be used for insertion in</color>
<color=#75715e>   * the future.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>VLSNBucket</color> <color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>VLSNBucketBinding</color> <color=#f8f8f2>mapperBinding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSNBucketBinding</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>mapperBinding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToObject</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>fillDataEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>VLSNBucketBinding</color> <color=#f8f8f2>binding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSNBucketBinding</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>binding</color><color=#f8f8f2>.</color><color=#a6e22e>objectToEntry</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @see Object#toString() */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>toString</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>String</color><color=#f8f8f2>.</color><color=#a6e22e>format</color><color=#f8f8f2>(</color>
        <color=#e6db74>"<VLSNBucket fileNum=%d(0x%x) numOffsets=%d "</color>
            <color=#f92672>+</color> <color=#e6db74>"stride=%d firstVLSN=%s lastVLSN=%s lastLsn=%s/>"</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>fileNumber</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>fileNumber</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#ae81ff>0</color> <color=#f8f8f2>:</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>stride</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>lastVLSN</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>lastLsn</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** For debugging and tracing. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>dump</color><color=#f8f8f2>(</color><color=#f8f8f2>PrintStream</color> <color=#f8f8f2>out</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>vlsnVal</color> <color=#f92672>=</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>();</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>newlineCounter</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>Integer</color> <color=#f8f8f2>offset</color> <color=#f8f8f2>:</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>printf</color><color=#f8f8f2>(</color><color=#e6db74>" [%d 0x%x]"</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnVal</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>convertIntFileOffsetToLong</color><color=#f8f8f2>(</color><color=#f8f8f2>offset</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>vlsnVal</color> <color=#f92672>+=</color> <color=#f8f8f2>stride</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>++</color><color=#f8f8f2>newlineCounter</color> <color=#f92672>></color> <color=#ae81ff>6</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"\n"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>newlineCounter</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>printf</color><color=#f8f8f2>(</color><color=#e6db74>"\n---------Last: VLSN=%s LSN=%s"</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>lastLsn</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>boolean</color> <color=#a6e22e>isGhost</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>writeToTupleOutput</color><color=#f8f8f2>(</color><color=#f8f8f2>TupleOutput</color> <color=#f8f8f2>to</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>to</color><color=#f8f8f2>.</color><color=#a6e22e>writePackedLong</color><color=#f8f8f2>(</color><color=#f8f8f2>fileNumber</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>to</color><color=#f8f8f2>.</color><color=#a6e22e>writePackedInt</color><color=#f8f8f2>(</color><color=#f8f8f2>stride</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>to</color><color=#f8f8f2>.</color><color=#a6e22e>writePackedLong</color><color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>to</color><color=#f8f8f2>.</color><color=#a6e22e>writePackedLong</color><color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>to</color><color=#f8f8f2>.</color><color=#a6e22e>writePackedLong</color><color=#f8f8f2>(</color><color=#f8f8f2>lastLsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>to</color><color=#f8f8f2>.</color><color=#a6e22e>writePackedInt</color><color=#f8f8f2>(</color><color=#f8f8f2>fileOffsets</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>());</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>Integer</color> <color=#f8f8f2>offset</color> <color=#f8f8f2>:</color> <color=#f8f8f2>fileOffsets</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>to</color><color=#f8f8f2>.</color><color=#a6e22e>writeUnsignedInt</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>convertIntFileOffsetToLong</color><color=#f8f8f2>(</color><color=#f8f8f2>offset</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Marshals a VLSNBucket to a byte buffer to store in the database. Doesn't persist the file</color>
<color=#75715e>   * number, because that's the key of the database. A number of the fields are transient and are</color>
<color=#75715e>   * also not stored.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>VLSNBucketBinding</color> <color=#66d9ef>extends</color> <color=#f8f8f2>TupleBinding</color><color=#f92672><</color><color=#f8f8f2>VLSNBucket</color><color=#f92672>></color> <color=#f8f8f2>{</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#f8f8f2>VLSNBucket</color> <color=#a6e22e>entryToObject</color><color=#f8f8f2>(</color><color=#f8f8f2>TupleInput</color> <color=#f8f8f2>ti</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>int</color> <color=#f8f8f2>onDiskVersion</color> <color=#f92672>=</color> <color=#f8f8f2>ti</color><color=#f8f8f2>.</color><color=#a6e22e>readPackedInt</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>onDiskVersion</color> <color=#f92672>!=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>VERSION</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
            <color=#e6db74>"Don't expect version diff on_disk="</color> <color=#f92672>+</color> <color=#f8f8f2>onDiskVersion</color> <color=#f92672>+</color> <color=#e6db74>" source="</color> <color=#f92672>+</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>VERSION</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>isGhost</color> <color=#f92672>=</color> <color=#f8f8f2>ti</color><color=#f8f8f2>.</color><color=#a6e22e>readBoolean</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isGhost</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>GhostBucket</color><color=#f8f8f2>.</color><color=#a6e22e>makeNewInstance</color><color=#f8f8f2>(</color><color=#f8f8f2>ti</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>ti</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>objectToEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>,</color> <color=#f8f8f2>TupleOutput</color> <color=#f8f8f2>to</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>to</color><color=#f8f8f2>.</color><color=#a6e22e>writePackedInt</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>VERSION</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>to</color><color=#f8f8f2>.</color><color=#a6e22e>writeBoolean</color><color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>isGhost</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>writeToTupleOutput</color><color=#f8f8f2>(</color><color=#f8f8f2>to</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Scan a specific section of log and generate a new VLSNBucket for this section. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>NewBucketReader</color> <color=#66d9ef>extends</color> <color=#f8f8f2>FileReader</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>remainderBucket</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>done</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>first</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>last</color><color=#f8f8f2>;</color>

    <color=#66d9ef>public</color> <color=#a6e22e>NewBucketReader</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>remainderBucket</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>VLSN</color> <color=#f8f8f2>first</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>VLSN</color> <color=#f8f8f2>last</color><color=#f8f8f2>,</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>startLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>readBufferSize</color><color=#f8f8f2>,</color>
          <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#75715e>// forward</color>
          <color=#f8f8f2>startLsn</color><color=#f8f8f2>,</color>
          <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#75715e>// singleFileNumber</color>
          <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color> <color=#75715e>// endOfFileLsn</color>
          <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color> <color=#75715e>// finishLsn</color>

      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>remainderBucket</color> <color=#f92672>=</color> <color=#f8f8f2>remainderBucket</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>first</color> <color=#f92672>=</color> <color=#f8f8f2>first</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>last</color> <color=#f92672>=</color> <color=#f8f8f2>last</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Return true if this entry is replicated and its VLSN >= the firstVLSN and the entry is not</color>
<color=#75715e>     * invisible. These entries will be used to bring the VLSNIndex up to speed.</color>
<color=#75715e>     */</color>
    <color=#a6e22e>@Override</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isTargetEntry</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>isInvisible</color><color=#f8f8f2>()</color>
          <color=#f92672>&&</color> <color=#f8f8f2>entryIsReplicated</color><color=#f8f8f2>()</color>
          <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>first</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>boolean</color> <color=#a6e22e>processEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>entryBuffer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>last</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>done</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>remainderBucket</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>(),</color> <color=#f8f8f2>getLastLsn</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>entryBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>(</color><color=#f8f8f2>entryBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#f8f8f2>currentEntryHeader</color><color=#f8f8f2>.</color><color=#a6e22e>getItemSize</color><color=#f8f8f2>());</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>isDone</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>done</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"serial"</color><color=#f8f8f2>)</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>TruncateableList</color><color=#f92672><</color><color=#f8f8f2>T</color><color=#f92672>></color> <color=#66d9ef>extends</color> <color=#f8f8f2>ArrayList</color><color=#f92672><</color><color=#f8f8f2>T</color><color=#f92672>></color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>TruncateableList</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>TruncateableList</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>capacity</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>capacity</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>TruncateableList</color><color=#f8f8f2>(</color><color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>T</color><color=#f92672>></color> <color=#f8f8f2>list</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>list</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>void</color> <color=#a6e22e>truncate</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>fromIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>removeRange</color><color=#f8f8f2>(</color><color=#f8f8f2>fromIndex</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>