<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.recovery</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.Cleaner</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.FileSelector.CheckpointStartCleanerState</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.evictor.OffHeapCache</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogEntryType</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogManager</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.Provisional</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.ReplicationContext</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.INLogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.SingleItemEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.*</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.util.ArrayList</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.HashMap</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.List</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Map</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Level</color><color=#f8f8f2>;</color>

<color=#f92672>import static</color> <color=#f8f8f2>com.sleepycat.je.recovery.CheckpointStatDefinition.*</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * The Checkpointer looks through the tree for internal nodes that must be flushed to the log.</color>
<color=#75715e> * Checkpoint flushes must be done in ascending order from the bottom of the tree up.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Checkpoint and IN Logging Rules ------------------------------- The checkpoint must log, and</color>
<color=#75715e> * make accessible via non-provisional ancestors, all INs that are dirty at CkptStart. If we crash</color>
<color=#75715e> * and recover from that CkptStart onward, any IN that became dirty (before the crash) after the</color>
<color=#75715e> * CkptStart must become dirty again as the result of replaying the action that caused it to</color>
<color=#75715e> * originally become dirty.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Therefore, when an IN is dirtied at some point in the checkpoint interval, but is not logged</color>
<color=#75715e> * by the checkpoint, the log entry representing the action that dirtied the IN must follow either</color>
<color=#75715e> * the CkptStart or the FirstActiveLSN that is recorded in the CkptEnd entry. The FirstActiveLSN is</color>
<color=#75715e> * less than or equal to the CkptStart LSN. Recovery will process LNs between the FirstActiveLSN and</color>
<color=#75715e> * the end of the log. Other entries are only processed from the CkptStart forward. And provisional</color>
<color=#75715e> * entries are not processed.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Example: Non-transactional LN logging. We take two actions: 1) log the LN and then 2) dirty</color>
<color=#75715e> * the parent BIN. What if the LN is logged before CkptStart and the BIN is dirtied after CkptStart?</color>
<color=#75715e> * How do we avoid breaking the rules? The answer is that we log the LN while holding the latch on</color>
<color=#75715e> * the parent BIN, and we don't release the latch until after we dirty the BIN. The construction of</color>
<color=#75715e> * the checkpoint dirty map requires latching the BIN. Since the LN was logged before CkptStart, the</color>
<color=#75715e> * BIN will be dirtied before the checkpointer latches it during dirty map construction. So the BIN</color>
<color=#75715e> * will always be included in the dirty map and logged by the checkpoint.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Example: Abort. We take two actions: 1) log the abort and then 2) undo the changes, which</color>
<color=#75715e> * modifies (dirties) the BIN parents of the undone LNs. There is nothing to prevent logging</color>
<color=#75715e> * CkptStart in between these two actions, so how do we avoid breaking the rules? The answer is that</color>
<color=#75715e> * we do not unregister the transaction until after the undo phase. So although the BINs may be</color>
<color=#75715e> * dirtied by the undo after CkptStart is logged, the FirstActiveLSN will be prior to CkptStart.</color>
<color=#75715e> * Therefore, we will process the Abort and replay the action that modifies the BINs.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Exception: Lazy migration. The log cleaner will make an IN dirty without logging an action</color>
<color=#75715e> * that makes it dirty. This is an exception to the general rule that actions should be logged when</color>
<color=#75715e> * they cause dirtiness. The reasons this is safe are: 1. The IN contents are not modified, so there</color>
<color=#75715e> * is no information lost if the IN is never logged, or is logged provisionally and no ancestor is</color>
<color=#75715e> * logged non-provisionally. 2. If the IN is logged non-provisionally, this will have the side</color>
<color=#75715e> * effect of recording the old LSN as being obsolete. However, the general rules for checkpointing</color>
<color=#75715e> * and recovery will ensure that the new version is used in the Btree. The new version will either</color>
<color=#75715e> * be replayed by recovery or referenced in the active Btree via a non-provisional ancestor.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Checkpoint Algorithm TODO update this -------------------- The final checkpointDirtyMap field</color>
<color=#75715e> * is used to hold (in addition to the dirty INs) the state of the checkpoint and highest flush</color>
<color=#75715e> * levels. Access to this object is synchronized so that eviction and checkpointing can access it</color>
<color=#75715e> * concurrently. When a checkpoint is not active, the state is CkptState.NONE and the dirty map is</color>
<color=#75715e> * empty. When a checkpoint runs, we do this:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>1. Get set of files from cleaner that can be deleted after this checkpoint. 2. Set</color>
<color=#75715e> * checkpointDirtyMap state to DIRTY_MAP_INCOMPLETE, meaning that dirty map construction is in</color>
<color=#75715e> * progress. 3. Log CkptStart 4. Construct dirty map, organized by Btree level, from dirty INs in</color>
<color=#75715e> * INList. The highest flush levels are calculated during dirty map construction. Set</color>
<color=#75715e> * checkpointDirtyMap state to DIRTY_MAP_COMPLETE. 5. Flush INs in dirty map. + First, flush the</color>
<color=#75715e> * bottom two levels a sub-tree at a time, where a sub-tree is one IN at level two and all its BIN</color>
<color=#75715e> * children. Higher levels (above level two) are logged strictly by level, not using subtrees. o If</color>
<color=#75715e> * je.checkpointer.highPriority=false, we log one IN at a time, whether or not the IN is logged as</color>
<color=#75715e> * part of a subtree, and do a Btree search for the parent of each IN. o If</color>
<color=#75715e> * je.checkpointer.highPriority=true, for the bottom two levels we log each sub-tree in a single</color>
<color=#75715e> * call to the LogManager with the parent IN latched, and we only do one Btree search for each level</color>
<color=#75715e> * two IN. Higher levels are logged one IN at a time as with highPriority=false. + The Provisional</color>
<color=#75715e> * property is set as follows, depending on the level of the IN: o level is max flush level:</color>
<color=#75715e> * Provisional.NO o level is bottom level: Provisional.YES o Otherwise (middle levels):</color>
<color=#75715e> * Provisional.BEFORE_CKPT_END 6. Flush VLSNIndex cache to make VLSNIndex recoverable. 7. Flush</color>
<color=#75715e> * UtilizationTracker (write FileSummaryLNs) to persist all tracked obsolete offsets and utilization</color>
<color=#75715e> * summary info, to make this info recoverable. 8. Log CkptEnd 9. Delete cleaned files from step 1.</color>
<color=#75715e> * 10. Set checkpointDirtyMap state to NONE.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Per-DB Highest Flush Level -------------------------- As mentioned above, when the dirty map</color>
<color=#75715e> * is constructed we also determine the highest flush level for each database. This is the maximum</color>
<color=#75715e> * Btree level at which a dirty node exists in the DB.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When logging a node below the maxFlushLevel, we add the parent to the dirty map. It may or may</color>
<color=#75715e> * not have been added when the dirty map was constructed. The idea is to flush all ancestors of all</color>
<color=#75715e> * nodes in the dirty map, up to and including the maxFlushLevel, even if those ancestors were not</color>
<color=#75715e> * dirty when the dirty map was constructed.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>This is done to avoid orphaning a dirty node as shown in this example.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>IN-A (root level=4) / \ (d) IN-B IN-C (maxFlushLevel=3) \ (d) IN-D</color>
<color=#75715e> *</color>
<color=#75715e> * <p>IN-C is not dirty (d) when the dirty map is constructed, but it will be logged because its</color>
<color=#75715e> * child (IN-D) is dirty, and it is not above maxFlushLevel.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>If IN-C were not logged, and there were a crash after the checkpoint, the changes to IN-D</color>
<color=#75715e> * would be lost. IN-D would not be replayed by recovery because it is logged provisionally, and it</color>
<color=#75715e> * would not be accessible via its parent. This is because only nodes at maxFlushLevel are logged</color>
<color=#75715e> * non-provisionally. The actions that led to the changes in IN-D may not be replayed either,</color>
<color=#75715e> * because they may appear before the firstActiveLsn associated with the checkpoint.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When log files are to be deleted at the end of the checkpoint (after being processed by the</color>
<color=#75715e> * log cleaner), the maxFlushLevel is increased by one. This is to ensure that LSNs in deleted files</color>
<color=#75715e> * will not be fetched during recovery. Such files are in the FileSelector.CLEANED state, which</color>
<color=#75715e> * means they have been processed by the cleaner since the last checkpoint.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>TODO: Document circumstances and motivation for the extra flush level.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Lastly, for Database.sync or a checkpoint with MinimizeRecoveryTime configured, we will flush</color>
<color=#75715e> * all the way to the root rather than using the maxFlushLevel computed as described above.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Provisional.BEFORE_CKPT_END --------------------------- See Provisional.java for a description</color>
<color=#75715e> * of the relationship between the checkpoint algorithm above and the BEFORE_CKPT_END property.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Coordination of Eviction and Checkpointing ------------------------------------------ Eviction</color>
<color=#75715e> * can proceed concurrently with all phases of a checkpoint, and eviction may take place</color>
<color=#75715e> * concurrently in multiple threads. This concurrency is crucial to avoid blocking application</color>
<color=#75715e> * threads that perform eviction and to reduce the amount of eviction required in application</color>
<color=#75715e> * threads.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Eviction calls Checkpointer.coordinateEvictionWithCheckpoint, which calls</color>
<color=#75715e> * DirtyINMap.coordinateEvictionWithCheckpoint, just before logging an IN.</color>
<color=#75715e> * coordinateEvictionWithCheckpoint returns whether the IN should be logged provisionally</color>
<color=#75715e> * (Provisional.YES) or non-provisionally (Provisional.NO).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Other coordination necessary depends on the state of the checkpoint: + NONE: No additional</color>
<color=#75715e> * action. o return Provisional.NO + DIRTY_MAP_INCOMPLETE: The parent IN is added to the dirty map,</color>
<color=#75715e> * exactly as if it were encountered as dirty in the INList during dirty map construction. o IN is</color>
<color=#75715e> * root: return Provisional.NO o IN is not root: return Provisional.YES + DIRTY_MAP_COMPLETE: o IN</color>
<color=#75715e> * level GTE highest flush level: return Provisional.NO o IN level LT highest flush level: return</color>
<color=#75715e> * Provisional.YES</color>
<color=#75715e> *</color>
<color=#75715e> * <p>In general this is designed so that eviction will use the same provisional value that would be</color>
<color=#75715e> * used by the checkpoint, as if the checkpoint itself were logging the IN. However, there are</color>
<color=#75715e> * several conditions where this is not exactly the case.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>1. Eviction may log an IN with Provisional.YES when the IN was not dirty at the time of dirty</color>
<color=#75715e> * map creation, if it became dirty afterwards. In this case, the checkpointer would not have logged</color>
<color=#75715e> * the IN at all. This is safe because the actions that made that IN dirty are logged in the</color>
<color=#75715e> * recovery period. 2. Eviction may log an IN with Provisional.YES after the checkpoint has logged</color>
<color=#75715e> * it, if it becomes dirty again. In this case the IN is logged twice, which would not have been</color>
<color=#75715e> * done by the checkpoint alone. This is safe because the actions that made that IN dirty are logged</color>
<color=#75715e> * in the recovery period. 3. An intermediate level IN (not bottom most and not the highest flush</color>
<color=#75715e> * level) will be logged by the checkpoint with Provisional.BEFORE_CKPT_END but will be logged by</color>
<color=#75715e> * eviction with Provisional.YES. See below for why this is safe. 4. Between checkpoint step 8 (log</color>
<color=#75715e> * CkptEnd) and 10 (set checkpointDirtyMap state to NONE), eviction may log an IN with</color>
<color=#75715e> * Provisional.YES, although a checkpoint is not strictly active during this interval. See below for</color>
<color=#75715e> * why this is safe.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>It is safe for eviction to log an IN as Provisional.YES for the last two special cases,</color>
<color=#75715e> * because this does not cause incorrect recovery behavior. For recovery to work properly, it is</color>
<color=#75715e> * only necessary that:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>+ Provisional.NO is used for INs at the max flush level during an active checkpoint. +</color>
<color=#75715e> * Provisional.YES or BEFORE_CKPT_END is used for INs below the max flush level, to avoid replaying</color>
<color=#75715e> * an IN during recovery that may depend on a file deleted as the result of the checkpoint.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>You may ask why we don't use Provisional.YES for eviction when a checkpoint is not active.</color>
<color=#75715e> * There are two reason, both related to performance:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>1. This would be wasteful when an IN is evicted in between checkpoints, and that portion of</color>
<color=#75715e> * the log is processed by recovery later, in the event of a crash. The evicted INs would be ignored</color>
<color=#75715e> * by recovery, but the actions that caused them to be dirty would be replayed and the INs would be</color>
<color=#75715e> * logged again redundantly. 2. Logging a IN provisionally will not count the old LSN as obsolete</color>
<color=#75715e> * immediately, so cleaner utilization will be inaccurate until the a non-provisional parent is</color>
<color=#75715e> * logged, typically by the next checkpoint. It is always important to keep the cleaner from</color>
<color=#75715e> * stalling and spiking, to keep latency and throughput as level as possible.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Therefore, it is safe to log with Provisional.YES in between checkpoints, but not desirable.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Although we don't do this, it would be safe and optimal to evict with BEFORE_CKPT_END in</color>
<color=#75715e> * between checkpoints, because it would be treated by recovery as if it were Provisional.NO. This</color>
<color=#75715e> * is because the interval between checkpoints is only processed by recovery if it follows the last</color>
<color=#75715e> * CkptEnd, and BEFORE_CKPT_END is treated as Provisional.NO if the IN follows the last CkptEnd.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>However, it would not be safe to evict an IN with BEFORE_CKPT_END during a checkpoint, when</color>
<color=#75715e> * logging of the IN's ancestors does not occur according to the rules of the checkpoint. If this</color>
<color=#75715e> * were done, then if the checkpoint completes and is used during a subsequent recovery, an obsolete</color>
<color=#75715e> * offset for the old version of the IN will mistakenly be recorded. Below are two cases where</color>
<color=#75715e> * BEFORE_CKPT_END is used correctly and one showing how it could be used incorrectly.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>1. Correct use of BEFORE_CKPT_END when the checkpoint does not complete.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>050 BIN-A 060 IN-B parent of BIN-A 100 CkptStart 200 BIN-A logged with BEFORE_CKPT_END 300</color>
<color=#75715e> * FileSummaryLN with obsolete offset for BIN-A at 050 Crash and recover</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Recovery will process BIN-A at 200 (it will be considered non-provisional) because there is no</color>
<color=#75715e> * following CkptEnd. It is therefore correct that BIN-A at 050 is obsolete.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>2. Correct use of BEFORE_CKPT_END when the checkpoint does complete.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>050 BIN-A 060 IN-B parent of BIN-A 100 CkptStart 200 BIN-A logged with BEFORE_CKPT_END 300</color>
<color=#75715e> * FileSummaryLN with obsolete offset for BIN-A at 050 400 IN-B parent of BIN-A, non-provisional 500</color>
<color=#75715e> * CkptEnd Crash and recover</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Recovery will not process BIN-A at 200 (it will be considered provisional) because there is a</color>
<color=#75715e> * following CkptEnd, but it will process its parent IN-B at 400, and therefore the BIN-A at 200</color>
<color=#75715e> * will be active in the tree. It is therefore correct that BIN-A at 050 is obsolete.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>3. Incorrect use of BEFORE_CKPT_END when the checkpoint does complete.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>050 BIN-A 060 IN-B parent of BIN-A 100 CkptStart 200 BIN-A logged with BEFORE_CKPT_END 300</color>
<color=#75715e> * FileSummaryLN with obsolete offset for BIN-A at 050 400 CkptEnd Crash and recover</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Recovery will not process BIN-A at 200 (it will be considered provisional) because there is a</color>
<color=#75715e> * following CkptEnd, but no parent IN-B is logged, and therefore the IN-B at 060 and BIN-A at 050</color>
<color=#75715e> * will be active in the tree. It is therefore incorrect that BIN-A at 050 is obsolete.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>This last case is what caused the LFNF in SR [#19422], when BEFORE_CKPT_END was mistakenly</color>
<color=#75715e> * used for logging evicted BINs via CacheMode.EVICT_BIN. During the checkpoint, we evict BIN-A and</color>
<color=#75715e> * log it with BEFORE_CKPT_END, yet neither it nor its parent are part of the checkpoint. After</color>
<color=#75715e> * being counted obsolete, we crash and recover. Then the file containing the BIN (BIN-A at 050</color>
<color=#75715e> * above) is cleaned and deleted. During cleaning, it is not migrated because an obsolete offset was</color>
<color=#75715e> * previously recorded. The LFNF occurs when trying to access this BIN during a user operation.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>CacheMode.EVICT_BIN ------------------- Unlike in JE 4.0 where EVICT_BIN was first introduced,</color>
<color=#75715e> * in JE 4.1 and later we do not use special rules when an IN is evicted. Since concurrent eviction</color>
<color=#75715e> * and checkpointing are supported in JE 4.1, the above rules apply to EVICT_BIN as well as all</color>
<color=#75715e> * other types of eviction.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>Checkpointer</color> <color=#66d9ef>extends</color> <color=#f8f8f2>DaemonThread</color> <color=#66d9ef>implements</color> <color=#f8f8f2>EnvConfigObserver</color> <color=#f8f8f2>{</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For unit testing only. Called before we flush the max level. This field is static because it is</color>
<color=#75715e>   * called from the static flushIN method.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>TestHook</color><color=#f92672><?></color> <color=#f8f8f2>maxFlushLevelHook</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>TestHook</color><color=#f92672><?></color> <color=#f8f8f2>beforeFlushHook</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

  <color=#66d9ef>static</color> <color=#f8f8f2>TestHook</color><color=#f92672><</color><color=#f8f8f2>IN</color><color=#f92672>></color> <color=#f8f8f2>examineINForCheckpointHook</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Checkpoint sequence, initialized at recovery. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>checkpointId</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * How much the log should grow between checkpoints. If 0, we're using time</color>
<color=#75715e>   * based checkpointing.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>logSizeBytesInterval</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>logFileMax</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>timeInterval</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastCheckpointMillis</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>wakeupAfterNoWrites</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Configured to true to minimize checkpoint duration. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>highPriority</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>nCheckpoints</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastCheckpointStart</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastCheckpointEnd</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastCheckpointInterval</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>FlushStats</color> <color=#f8f8f2>flushStats</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The DirtyINMap for checkpointing is created once and is reset after each checkpoint is</color>
<color=#75715e>   * complete. Access to this object is synchronized so that eviction and checkpointing can access</color>
<color=#75715e>   * it concurrently.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>DirtyINMap</color> <color=#f8f8f2>checkpointDirtyMap</color><color=#f8f8f2>;</color>

  <color=#66d9ef>public</color> <color=#a6e22e>Checkpointer</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>waitTime</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>name</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>waitTime</color><color=#f8f8f2>,</color> <color=#f8f8f2>name</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>logSizeBytesInterval</color> <color=#f92672>=</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINTER_BYTES_INTERVAL</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>logFileMax</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_FILE_MAX</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>timeInterval</color> <color=#f92672>=</color> <color=#f8f8f2>waitTime</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>lastCheckpointMillis</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>nCheckpoints</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>flushStats</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>FlushStats</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>checkpointDirtyMap</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DirtyINMap</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Initialize mutable properties and register for notifications. */</color>
    <color=#f8f8f2>envConfigUpdate</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>(),</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>addConfigObserver</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Process notifications of mutable property changes. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>envConfigUpdate</color><color=#f8f8f2>(</color><color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>cm</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentMutableConfig</color> <color=#f8f8f2>ignore</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>highPriority</color> <color=#f92672>=</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>getBoolean</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINTER_HIGH_PRIORITY</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Initializes the checkpoint intervals when no checkpoint is performed while opening the</color>
<color=#75715e>   * environment.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>initIntervals</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lastCheckpointStart</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastCheckpointEnd</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastCheckpointMillis</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lastCheckpointStart</color> <color=#f92672>=</color> <color=#f8f8f2>lastCheckpointStart</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lastCheckpointEnd</color> <color=#f92672>=</color> <color=#f8f8f2>lastCheckpointEnd</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lastCheckpointMillis</color> <color=#f92672>=</color> <color=#f8f8f2>lastCheckpointMillis</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Coordinates an eviction with an in-progress checkpoint and returns whether provisional logging</color>
<color=#75715e>   * is needed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the provisional status to use for logging the target.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Provisional</color> <color=#a6e22e>coordinateEvictionWithCheckpoint</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>checkpointDirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>coordinateEvictionWithCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Coordinates a split with an in-progress checkpoint.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param newSibling the sibling IN created by the split.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>coordinateSplitWithCheckpoint</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>newSibling</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>checkpointDirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>coordinateSplitWithCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>newSibling</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Figure out the wakeup period. Supplied through this static method because we need to pass</color>
<color=#75715e>   * wakeup period to the superclass and need to do the calcuation outside this constructor.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws IllegalArgumentException via Environment ctor and setMutableConfig.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>long</color> <color=#a6e22e>getWakeupPeriod</color><color=#f8f8f2>(</color><color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>wakeupPeriod</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getDuration</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINTER_WAKEUP_INTERVAL</color><color=#f8f8f2>);</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>bytePeriod</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINTER_BYTES_INTERVAL</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Checkpointing period must be set either by time or by log size. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>wakeupPeriod</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>bytePeriod</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINTER_BYTES_INTERVAL</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>()</color>
              <color=#f92672>+</color> <color=#e6db74>" and "</color>
              <color=#f92672>+</color> <color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINTER_WAKEUP_INTERVAL</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>()</color>
              <color=#f92672>+</color> <color=#e6db74>" cannot both be 0. "</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Checkpointing by log size takes precendence over time based period.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bytePeriod</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>wakeupPeriod</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Set checkpoint id -- can only be done after recovery. */</color>
  <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>setCheckpointId</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lastCheckpointId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>checkpointId</color> <color=#f92672>=</color> <color=#f8f8f2>lastCheckpointId</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Load stats. */</color>
  <color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"unused"</color><color=#f8f8f2>)</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>StatGroup</color> <color=#a6e22e>loadStats</color><color=#f8f8f2>(</color><color=#f8f8f2>StatsConfig</color> <color=#f8f8f2>config</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>StatGroup</color> <color=#f8f8f2>stats</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StatGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>GROUP_NAME</color><color=#f8f8f2>,</color> <color=#f8f8f2>GROUP_DESC</color><color=#f8f8f2>);</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CKPT_LAST_CKPTID</color><color=#f8f8f2>,</color> <color=#f8f8f2>checkpointId</color><color=#f8f8f2>);</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CKPT_CHECKPOINTS</color><color=#f8f8f2>,</color> <color=#f8f8f2>nCheckpoints</color><color=#f8f8f2>);</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CKPT_LAST_CKPT_INTERVAL</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastCheckpointInterval</color><color=#f8f8f2>);</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LSNStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CKPT_LAST_CKPT_START</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastCheckpointStart</color><color=#f8f8f2>);</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LSNStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CKPT_LAST_CKPT_END</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastCheckpointEnd</color><color=#f8f8f2>);</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CKPT_FULL_IN_FLUSH</color><color=#f8f8f2>,</color> <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullINFlush</color><color=#f8f8f2>);</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CKPT_FULL_BIN_FLUSH</color><color=#f8f8f2>,</color> <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullBINFlush</color><color=#f8f8f2>);</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CKPT_DELTA_IN_FLUSH</color><color=#f8f8f2>,</color> <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nDeltaINFlush</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getClear</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nCheckpoints</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullINFlush</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullBINFlush</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nDeltaINFlush</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>stats</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Return the number of retries when a deadlock exception occurs. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>long</color> <color=#a6e22e>nDeadlockRetries</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINTER_RETRY</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Called whenever the DaemonThread wakes up from a sleep. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>protected</color> <color=#66d9ef>void</color> <color=#a6e22e>onWakeup</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isClosing</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>doCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>CheckpointConfig</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>,</color> <color=#e6db74>"daemon"</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*invokedFromDaemon*/</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>wakeupAfterNoWrites</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Wakes up the checkpointer if a checkpoint log interval is configured and the number of bytes</color>
<color=#75715e>   * written since the last checkpoint exceeds the size of the interval.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>wakeupAfterWrite</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>logSizeBytesInterval</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>isRunning</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>long</color> <color=#f8f8f2>nextLsn</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>getNextLsn</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoCleaningDistance</color><color=#f8f8f2>(</color><color=#f8f8f2>nextLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastCheckpointStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>logFileMax</color><color=#f8f8f2>)</color>
          <color=#f92672>>=</color> <color=#f8f8f2>logSizeBytesInterval</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>wakeup</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Wakes up the checkpointer if a checkpoint is needed to reclaim disk space for already cleaned</color>
<color=#75715e>   * files. This method is called after an idle period with no writes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>wakeupAfterNoWrites</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isRunning</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>needCheckpointForCleanedFiles</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>wakeupAfterNoWrites</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>wakeup</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>needCheckpointForCleanedFiles</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCleaner</color><color=#f8f8f2>().</color><color=#a6e22e>getFileSelector</color><color=#f8f8f2>().</color><color=#a6e22e>isCheckpointNeeded</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Determine whether a checkpoint should be run. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isRunnable</color><color=#f8f8f2>(</color><color=#f8f8f2>CheckpointConfig</color> <color=#f8f8f2>config</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#75715e>/* Figure out if we're using log size or time to determine interval.*/</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>useBytesInterval</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>useTimeInterval</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>nextLsn</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>runnable</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getForce</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>runnable</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>wakeupAfterNoWrites</color> <color=#f92672>&&</color> <color=#f8f8f2>needCheckpointForCleanedFiles</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>runnable</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getKBytes</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>useBytesInterval</color> <color=#f92672>=</color> <color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getKBytes</color><color=#f8f8f2>()</color> <color=#f92672><<</color> <color=#ae81ff>10</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getMinutes</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Convert to millis. */</color>
        <color=#f8f8f2>useTimeInterval</color> <color=#f92672>=</color> <color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getMinutes</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#ae81ff>60</color> <color=#f92672>*</color> <color=#ae81ff>1000</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logSizeBytesInterval</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>useBytesInterval</color> <color=#f92672>=</color> <color=#f8f8f2>logSizeBytesInterval</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>useTimeInterval</color> <color=#f92672>=</color> <color=#f8f8f2>timeInterval</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If our checkpoint interval is defined by log size, check on how</color>
<color=#75715e>       * much log has grown since the last checkpoint.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useBytesInterval</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nextLsn</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>getNextLsn</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoCleaningDistance</color><color=#f8f8f2>(</color><color=#f8f8f2>nextLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastCheckpointStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>logFileMax</color><color=#f8f8f2>)</color>
            <color=#f92672>>=</color> <color=#f8f8f2>useBytesInterval</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#f8f8f2>runnable</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useTimeInterval</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Our checkpoint is determined by time.  If enough time has</color>
<color=#75715e>         * passed and some log data has been written, do a checkpoint.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastUsedLsn</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLastUsedLsn</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(((</color><color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>lastCheckpointMillis</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#f8f8f2>useTimeInterval</color><color=#f8f8f2>)</color>
            <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>lastUsedLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastCheckpointEnd</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

          <color=#f8f8f2>runnable</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>runnable</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINEST</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"size interval="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>useBytesInterval</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nextLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" nextLsn="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>nextLsn</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastCheckpointEnd</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" lastCkpt="</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>lastCheckpointEnd</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" time interval="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>useTimeInterval</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" force="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getForce</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" runnable="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>runnable</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>finest</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The real work to do a checkpoint. This may be called by the checkpoint thread when waking up,</color>
<color=#75715e>   * or it may be invoked programatically through the api.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param invokingSource a debug aid, to indicate who invoked this checkpoint. (i.e. recovery, the</color>
<color=#75715e>   *     checkpointer daemon, the cleaner, programatically)</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>doCheckpoint</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>CheckpointConfig</color> <color=#f8f8f2>config</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>invokingSource</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>invokedFromDaemon</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isReadOnly</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isRunnable</color><color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Stop if we cannot write because of a disk limit violation. */</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>checkDiskLimitViolation</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DiskLimitException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>invokedFromDaemon</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If minimizing recovery time is desired, then flush all the way to</color>
<color=#75715e>     * the top of the dbtree instead of stopping at the highest level last</color>
<color=#75715e>     * modified, so that only the root INs are processed by recovery.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>flushAll</color> <color=#f92672>=</color> <color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getMinimizeRecoveryTime</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If there are cleaned files to be deleted, flush an extra level to</color>
<color=#75715e>     * write out the parents of cleaned nodes.  This ensures that no node</color>
<color=#75715e>     * will contain the LSN of a cleaned file.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Note that we don't currently distinguish between files in the</color>
<color=#75715e>     * CLEANED and FULLY_PROCESSED states.  For a FULLY_PROCESSED file, a</color>
<color=#75715e>     * pending LN may have been processed since the prior checkpoint.</color>
<color=#75715e>     * However, the BIN containing the LSN of the LN is guaranteed to be</color>
<color=#75715e>     * logged, so there is no need to increment maxFlushLevel.  So we could</color>
<color=#75715e>     * optimize in the future and only set flushExtraLevel when some files</color>
<color=#75715e>     * are CLEANED (i.e., do not set flushExtraLevel when all files are</color>
<color=#75715e>     * FULLY_PROCESSED or cleanerState.isEmpty()).</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Cleaner</color> <color=#f8f8f2>cleaner</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCleaner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointStartCleanerState</color> <color=#f8f8f2>cleanerState</color> <color=#f92672>=</color> <color=#f8f8f2>cleaner</color><color=#f8f8f2>.</color><color=#a6e22e>getFilesAtCheckpointStart</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>flushExtraLevel</color> <color=#f92672>=</color> <color=#f92672>!</color><color=#f8f8f2>cleanerState</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>lastCheckpointMillis</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>resetPerRunCounters</color><color=#f8f8f2>();</color>

    <color=#75715e>/* Get the next checkpoint id. */</color>
    <color=#f8f8f2>checkpointId</color><color=#f92672>++</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>nCheckpoints</color><color=#f92672>++</color><color=#f8f8f2>;</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>traced</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LogManager</color> <color=#f8f8f2>logManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Set the checkpoint state so that concurrent eviction can be</color>
<color=#75715e>     * coordinated.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>checkpointDirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>beginCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>flushAll</color><color=#f8f8f2>,</color> <color=#f8f8f2>flushExtraLevel</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Log the checkpoint start. */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>SingleItemEntry</color><color=#f92672><</color><color=#f8f8f2>CheckpointStart</color><color=#f92672>></color> <color=#f8f8f2>startEntry</color> <color=#f92672>=</color>
          <color=#f8f8f2>SingleItemEntry</color><color=#f8f8f2>.</color><color=#a6e22e>create</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_CKPT_START</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#f8f8f2>CheckpointStart</color><color=#f8f8f2>(</color><color=#f8f8f2>checkpointId</color><color=#f8f8f2>,</color> <color=#f8f8f2>invokingSource</color><color=#f8f8f2>));</color>

      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>checkpointStart</color> <color=#f92672>=</color> <color=#f8f8f2>logManager</color><color=#f8f8f2>.</color><color=#a6e22e>log</color><color=#f8f8f2>(</color><color=#f8f8f2>startEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>ReplicationContext</color><color=#f8f8f2>.</color><color=#a6e22e>NO_REPLICATE</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Note the first active LSN point. The definition of</color>
<color=#75715e>       * firstActiveLsn is that all log entries for active transactions</color>
<color=#75715e>       * are equal to or after that LSN.  This is the starting point for</color>
<color=#75715e>       * replaying LNs during recovery and will be stored in the CkptEnd</color>
<color=#75715e>       * entry.</color>
<color=#75715e>       *</color>
<color=#75715e>       * Use the checkpointStart as the firstActiveLsn if firstActiveLsn</color>
<color=#75715e>       * is null, meaning that no txns are active.</color>
<color=#75715e>       *</color>
<color=#75715e>       * The current value must be retrieved from TxnManager after</color>
<color=#75715e>       * logging CkptStart. If it were instead retrieved before logging</color>
<color=#75715e>       * CkptStart, the following failure could occur.  [#20270]</color>
<color=#75715e>       *</color>
<color=#75715e>       *  ... getFirstActiveLsn returns NULL_LSN, will use 200 CkptStart</color>
<color=#75715e>       *  100 LN-A in Txn-1</color>
<color=#75715e>       *  200 CkptStart</color>
<color=#75715e>       *  300 BIN-B refers to 100 LN-A</color>
<color=#75715e>       *  400 CkptEnd</color>
<color=#75715e>       *  ... Crash and recover.  Recovery does not undo 100 LN-A.</color>
<color=#75715e>       *  ... Txn-1 is uncommitted, yet 100 LN-A takes effect.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>firstActiveLsn</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnManager</color><color=#f8f8f2>().</color><color=#a6e22e>getFirstActiveLsn</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstActiveLsn</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>firstActiveLsn</color> <color=#f92672>=</color> <color=#f8f8f2>checkpointStart</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * In a replicated system, the checkpointer will be flushing out</color>
<color=#75715e>       * the VLSNIndex, which is HA metadata. Check that the in-memory</color>
<color=#75715e>       * version encompasses all metadata up to the point of the</color>
<color=#75715e>       * CheckpointStart record. This is no-op for non-replicated</color>
<color=#75715e>       * systems. [#19754]</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>awaitVLSNConsistency</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Find the set of dirty INs that must be logged. */</color>
      <color=#f8f8f2>checkpointDirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>selectDirtyINsForCheckpoint</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Call hook after dirty map creation and before flushing. */</color>
      <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>beforeFlushHook</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Flush IN nodes. */</color>
      <color=#f8f8f2>flushDirtyNodes</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>checkpointDirtyMap</color><color=#f8f8f2>,</color> <color=#f8f8f2>checkpointStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>highPriority</color><color=#f8f8f2>,</color> <color=#f8f8f2>flushStats</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DirtyINMap</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_SET_DEBUG_TRACE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>(),</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>INFO</color><color=#f8f8f2>,</color>
            <color=#e6db74>"Ckpt flushed"</color>
                <color=#f92672>+</color> <color=#e6db74>" nFullINFlushThisRun = "</color>
                <color=#f92672>+</color> <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullINFlushThisRun</color>
                <color=#f92672>+</color> <color=#e6db74>" nFullBINFlushThisRun = "</color>
                <color=#f92672>+</color> <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullBINFlushThisRun</color>
                <color=#f92672>+</color> <color=#e6db74>" nDeltaINFlushThisRun = "</color>
                <color=#f92672>+</color> <color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nDeltaINFlushThisRun</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Flush MapLNs if not already done by flushDirtyNodes.  Only flush</color>
<color=#75715e>       * a database if it has not already been flushed since checkpoint</color>
<color=#75715e>       * start.  Lastly, flush the DB mapping tree root.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>checkpointDirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>flushMapLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>checkpointStart</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>checkpointDirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>flushRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>checkpointStart</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Flush replication information if necessary so that the VLSNIndex</color>
<color=#75715e>       * cache is flushed and is recoverable.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>preCheckpointEndFlush</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Flush utilization info AFTER flushing IN nodes to reduce the</color>
<color=#75715e>       * inaccuracies caused by the sequence FileSummaryLN-LN-BIN.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>envImpl</color>
          <color=#f8f8f2>.</color><color=#a6e22e>getUtilizationProfile</color><color=#f8f8f2>()</color>
          <color=#f8f8f2>.</color><color=#a6e22e>flushFileUtilization</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getUtilizationTracker</color><color=#f8f8f2>().</color><color=#a6e22e>getTrackedFiles</color><color=#f8f8f2>());</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>willDeleteFiles</color> <color=#f92672>=</color> <color=#f92672>!</color><color=#f8f8f2>cleanerState</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>();</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointEnd</color> <color=#f8f8f2>ckptEnd</color> <color=#f92672>=</color>
          <color=#66d9ef>new</color> <color=#f8f8f2>CheckpointEnd</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>invokingSource</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>checkpointStart</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getRootLsn</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>firstActiveLsn</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeSequence</color><color=#f8f8f2>().</color><color=#a6e22e>getLastLocalNodeId</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeSequence</color><color=#f8f8f2>().</color><color=#a6e22e>getLastReplicatedNodeId</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLocalDbId</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getLastReplicatedDbId</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLastLocalTxnId</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getTxnManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLastReplicatedTxnId</color><color=#f8f8f2>(),</color>
              <color=#f8f8f2>checkpointId</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>willDeleteFiles</color><color=#f8f8f2>);</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>SingleItemEntry</color><color=#f92672><</color><color=#f8f8f2>CheckpointEnd</color><color=#f92672>></color> <color=#f8f8f2>endEntry</color> <color=#f92672>=</color>
          <color=#f8f8f2>SingleItemEntry</color><color=#f8f8f2>.</color><color=#a6e22e>create</color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_CKPT_END</color><color=#f8f8f2>,</color> <color=#f8f8f2>ckptEnd</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Log checkpoint end and update state kept about the last</color>
<color=#75715e>       * checkpoint location. Send a trace message *before* the</color>
<color=#75715e>       * checkpoint end log entry. This is done so that the normal trace</color>
<color=#75715e>       * message doesn't affect the time-based isRunnable() calculation,</color>
<color=#75715e>       * which only issues a checkpoint if a log record has been written</color>
<color=#75715e>       * since the last checkpoint.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>trace</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>invokingSource</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>traced</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>lastCheckpointInterval</color> <color=#f92672>=</color>
          <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoCleaningDistance</color><color=#f8f8f2>(</color><color=#f8f8f2>checkpointStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastCheckpointStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>logFileMax</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We must flush and fsync to ensure that cleaned files are not</color>
<color=#75715e>       * referenced. This also ensures that this checkpoint is not wasted</color>
<color=#75715e>       * if we crash.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>lastCheckpointEnd</color> <color=#f92672>=</color>
          <color=#f8f8f2>logManager</color><color=#f8f8f2>.</color><color=#a6e22e>logForceFlush</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>endEntry</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*fsyncRequired*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>ReplicationContext</color><color=#f8f8f2>.</color><color=#a6e22e>NO_REPLICATE</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>lastCheckpointStart</color> <color=#f92672>=</color> <color=#f8f8f2>checkpointStart</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>cleaner</color><color=#f8f8f2>.</color><color=#a6e22e>updateFilesAtCheckpointEnd</color><color=#f8f8f2>(</color><color=#f8f8f2>cleanerState</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DiskLimitException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>WARNING</color><color=#f8f8f2>,</color>
          <color=#e6db74>"Ckpt id="</color>
              <color=#f92672>+</color> <color=#f8f8f2>checkpointId</color>
              <color=#f92672>+</color> <color=#e6db74>" success="</color>
              <color=#f92672>+</color> <color=#f8f8f2>success</color>
              <color=#f92672>+</color> <color=#e6db74>" aborted because of disk limit violation: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>invokedFromDaemon</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLogException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Checkpointer"</color><color=#f8f8f2>,</color> <color=#e6db74>"doCheckpoint"</color><color=#f8f8f2>,</color> <color=#e6db74>"checkpointId="</color> <color=#f92672>+</color> <color=#f8f8f2>checkpointId</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Reset the checkpoint state so evictor activity knows there's no</color>
<color=#75715e>       * further requirement for provisional logging. SR 11163.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>checkpointDirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>reset</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>traced</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>trace</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>invokingSource</color><color=#f8f8f2>,</color> <color=#f8f8f2>success</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>trace</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>invokingSource</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"Checkpoint "</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>checkpointId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>": source="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>invokingSource</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" success="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>success</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" nFullINFlushThisRun="</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullINFlushThisRun</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" nDeltaINFlushThisRun="</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>flushStats</color><color=#f8f8f2>.</color><color=#a6e22e>nDeltaINFlushThisRun</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>CONFIG</color><color=#f8f8f2>,</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Flush a given database to disk. Like checkpoint, log from the bottom up so that parents</color>
<color=#75715e>   * properly represent their children.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>syncDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>flushLog</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isReadOnly</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>checkDiskLimitViolation</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DirtyINMap</color> <color=#f8f8f2>dirtyMap</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DirtyINMap</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>FlushStats</color> <color=#f8f8f2>fstats</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>FlushStats</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Find the dirty set. */</color>
      <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>selectDirtyINsForDbSync</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>getNumEntries</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Write all dirtyINs out.*/</color>
        <color=#f8f8f2>flushDirtyNodes</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color> <color=#75715e>/*ckptStart*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*highPriority*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>fstats</color><color=#f8f8f2>);</color>

        <color=#75715e>/* Make changes durable. [#15254] */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>flushLog</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>flushSync</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DiskLimitException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLogException</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Checkpointer"</color><color=#f8f8f2>,</color> <color=#e6db74>"syncDatabase"</color><color=#f8f8f2>,</color> <color=#e6db74>"of "</color> <color=#f92672>+</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDebugName</color><color=#f8f8f2>(),</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>e</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>reset</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit testing only. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>setMaxFlushLevelHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color><color=#f92672><?></color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>maxFlushLevelHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit testing only. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>setBeforeFlushHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color><color=#f92672><?></color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>beforeFlushHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Flush the nodes in order, from the lowest level to highest level. As a flush dirties its</color>
<color=#75715e>   * parent, add it to the dirty map, thereby cascading the writes up the tree. If flushAll wasn't</color>
<color=#75715e>   * specified, we need only cascade up to the highest level set at the start of checkpointing.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Note that all but the top level INs are logged provisionally. That's because we don't need</color>
<color=#75715e>   * to process lower INs during recovery because the higher INs will end up pointing at them.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>flushDirtyNodes</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>DirtyINMap</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>,</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>checkpointStart</color><color=#f8f8f2>,</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>highPriority</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>FlushStats</color> <color=#f8f8f2>fstats</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseImpl</color><color=#f92672>></color> <color=#f8f8f2>dbCache</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>getNumLevels</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Work on one level's worth of nodes in ascending level order.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>Integer</color> <color=#f8f8f2>currentLevel</color> <color=#f92672>=</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>getLowestLevelSet</color><color=#f8f8f2>();</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>currentLevelVal</color> <color=#f92672>=</color> <color=#f8f8f2>currentLevel</color><color=#f8f8f2>;</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Flush MapLNs just prior to flushing the first level of the</color>
<color=#75715e>         * mapping tree.  Only flush a database if it has not already</color>
<color=#75715e>         * been flushed since checkpoint start.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentLevelVal</color> <color=#f92672>==</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>DBMAP_LEVEL</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>flushMapLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>checkpointStart</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Flush the nodes at the current level. */</color>
        <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>targetRef</color> <color=#f92672>=</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>removeNextNode</color><color=#f8f8f2>(</color><color=#f8f8f2>currentLevel</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetRef</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>checkDiskLimitViolation</color><color=#f8f8f2>();</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Check to make sure the DB was not deleted after putting</color>
<color=#75715e>           * it in the dirty map, and prevent the DB from being</color>
<color=#75715e>           * deleted while we're working with it.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>dbId</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color> <color=#75715e>/*lockTimeout*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbCache</color><color=#f8f8f2>);</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

            <color=#75715e>/* Flush if we're below maxFlushLevel. */</color>
            <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxFlushLevel</color> <color=#f92672>=</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>getHighestFlushLevel</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentLevelVal</color> <color=#f92672><=</color> <color=#f8f8f2>maxFlushLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

              <color=#f8f8f2>flushIN</color><color=#f8f8f2>(</color>
                  <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>targetRef</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>maxFlushLevel</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>highPriority</color><color=#f8f8f2>,</color>
                  <color=#f8f8f2>fstats</color><color=#f8f8f2>,</color>
                  <color=#66d9ef>true</color> <color=#75715e>/*allowLogSubtree*/</color><color=#f8f8f2>);</color>

              <color=#75715e>/*</color>
<color=#75715e>               * Sleep if background read/write limit was</color>
<color=#75715e>               * exceeded.</color>
<color=#75715e>               */</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>sleepAfterBackgroundIO</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/*</color>
<color=#75715e>           * If the environment was invalidated by other activity,</color>
<color=#75715e>           * get out of this loop, and re-throw the invalidating</color>
<color=#75715e>           * exception to indicate that the checkpoint did not</color>
<color=#75715e>           * succeed.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>checkIfInvalid</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* We're done with this level. */</color>
        <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>removeLevel</color><color=#f8f8f2>(</color><color=#f8f8f2>currentLevel</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDbs</color><color=#f8f8f2>(</color><color=#f8f8f2>dbCache</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Do not flush FileSummaryLNs/MapLNs (do not call</color>
<color=#75715e>     * UtilizationProfile.flushLocalTracker) here because that flushing is</color>
<color=#75715e>     * already done by the checkpoint.</color>
<color=#75715e>     */</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Flush the target IN.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Where applicable, also attempt to flush the subtree that houses this target, which means we</color>
<color=#75715e>   * flush the siblings of this target to promote better cleaning throughput. The problem lies in</color>
<color=#75715e>   * the fact that provisionally logged nodes are not available for log cleaning until their parent</color>
<color=#75715e>   * is logged non-provisionally. On the other hand, we want to log nodes in provisional mode as</color>
<color=#75715e>   * much as possible, both for recovery performance, and for correctness to avoid fetches against</color>
<color=#75715e>   * cleaned log files. (See [#16037].) These conflicting goals are reconciled by flushing nodes in</color>
<color=#75715e>   * subtree grouping, because writing the non-provisional parent of a set of provisionally written</color>
<color=#75715e>   * nodes frees the cleaner to work on that set of provisional nodes as soon as possible. For</color>
<color=#75715e>   * example, if a tree consists of:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>INa +------+-------+ INb INc +-----+----+ +-----+ BINd BINe BINf BINg BINh</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>It is more efficient for cleaning throughput to log in this order: BINd, BINe, BINf, INb,</color>
<color=#75715e>   * BINg, BINh, INc, INa rather than: BINd, BINe, BINf, BINg, BINh, INb, INc, INa</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Suppose the subtree in question is INb->{BINd, BINe, BINf}</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Suppose we see BINd in the dirty map first, before BINe and BINf. - flushIN(BINd) is called</color>
<color=#75715e>   * - we fetch and latch its parent, INb</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If this is a high priority checkpoint, we'll hold the INb latch across the time it takes to</color>
<color=#75715e>   * flush all three children. In flushIN(BINd), we walk through INb, create a local map of all the</color>
<color=#75715e>   * siblings that can be found in the dirty map, and then call logSiblings with that local map.</color>
<color=#75715e>   * Then we'll write out INb.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If high priority is false, we will not hold the INb latch across multiple IOs. Instead, we -</color>
<color=#75715e>   * write BINd out, using logSiblings - while still holding the INb latch, we create a list of</color>
<color=#75715e>   * dirty siblings - release the INb latch - call flushIN() recursively on each entry in the local</color>
<color=#75715e>   * sibling map, which will result in a search and write of each sibling. These recursive calls to</color>
<color=#75715e>   * flushIN are called with the allowLogSubtree parameter of false to halt the recursion and</color>
<color=#75715e>   * prevent a repeat of the sibling examination. - write INb</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>flushIN</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>targetRef</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DirtyINMap</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxFlushLevel</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>highPriority</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>FlushStats</color> <color=#f8f8f2>fstats</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>allowLogSubtree</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Tree</color> <color=#f8f8f2>tree</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getTree</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetLevel</color> <color=#f92672>=</color> <color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>nodeLevel</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Call test hook when we reach the max level. */</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetLevel</color> <color=#f92672><</color> <color=#f8f8f2>maxFlushLevel</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>maxFlushLevelHook</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>RootFlusher</color> <color=#f8f8f2>flusher</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RootFlusher</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>nodeId</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>withRootLatchedExclusive</color><color=#f8f8f2>(</color><color=#f8f8f2>flusher</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Update the tree's owner, whether it's the env root or the</color>
<color=#75715e>       * db-mapping tree.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>flusher</color><color=#f8f8f2>.</color><color=#a6e22e>getFlushed</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>modifyDbRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>fstats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullINFlushThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>fstats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullINFlush</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If this target isn't the root anymore, we'll have to handle it</color>
<color=#75715e>       * like a regular node.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>flusher</color><color=#f8f8f2>.</color><color=#a6e22e>stillRoot</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The following applies to two cases:</color>
<color=#75715e>     * (1) the target was not ever the root</color>
<color=#75715e>     * (2) the target was the root, when the checkpoint dirty set was</color>
<color=#75715e>     * assembled but is not the root now.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>SearchResult</color> <color=#f8f8f2>result</color> <color=#f92672>=</color>
        <color=#f8f8f2>tree</color><color=#f8f8f2>.</color><color=#a6e22e>getParentINForChildIN</color><color=#f8f8f2>(</color>
            <color=#f92672>-</color><color=#ae81ff>1</color> <color=#75715e>/*nodeId*/</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>treeKey</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>nodeLevel</color> <color=#75715e>/*targetLevel*/</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>nodeLevel</color> <color=#f92672>+</color> <color=#ae81ff>1</color> <color=#75715e>/*exclusiveLevel*/</color><color=#f8f8f2>,</color>
            <color=#66d9ef>false</color> <color=#75715e>/*requireExactMatch*/</color><color=#f8f8f2>,</color>
            <color=#66d9ef>false</color> <color=#75715e>/*doFetch*/</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>,</color>
            <color=#66d9ef>null</color> <color=#75715e>/*trackingList*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If no possible parent is found, the compressor may have deleted</color>
<color=#75715e>     * this item before we got to processing it. (Although it seems this</color>
<color=#75715e>     * cannot currently happen since we never delete the root node.)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>parent</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>index</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>parentLevel</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>parentRef</color><color=#f8f8f2>;</color>

    <color=#75715e>/* List of siblings to log after releasing the parent latch. */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>List</color><color=#f92672><</color><color=#f8f8f2>CheckpointReference</color><color=#f92672>></color> <color=#f8f8f2>logSiblingsSeparately</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * If bottomLevelTarget is true, the parent IN contains bottom</color>
<color=#75715e>       * level BINs.  The masking is used to normalize the level for</color>
<color=#75715e>       * ordinary DBs and the mapping tree DB.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>bottomLevelTarget</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#f8f8f2>parentLevel</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>LEVEL_MASK</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>2</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * INs at the max flush level are always non-provisional and</color>
<color=#75715e>       * INs at the bottom level (when this is not also the max flush</color>
<color=#75715e>       * level) are always provisional.  In between INs are</color>
<color=#75715e>       * provisional BEFORE_CKPT_END (see Provisional).</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Provisional</color> <color=#f8f8f2>provisional</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetLevel</color> <color=#f92672>>=</color> <color=#f8f8f2>maxFlushLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>provisional</color> <color=#f92672>=</color> <color=#f8f8f2>Provisional</color><color=#f8f8f2>.</color><color=#a6e22e>NO</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bottomLevelTarget</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>provisional</color> <color=#f92672>=</color> <color=#f8f8f2>Provisional</color><color=#f8f8f2>.</color><color=#a6e22e>YES</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>provisional</color> <color=#f92672>=</color> <color=#f8f8f2>Provisional</color><color=#f8f8f2>.</color><color=#a6e22e>BEFORE_CKPT_END</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If we didn't reach the target level, a child wasn't resident</color>
<color=#75715e>       * and there is nothing to log at this level. To be on the safe</color>
<color=#75715e>       * side, we'll put the parent into the dirty set to be logged when</color>
<color=#75715e>       * that level is processed.</color>
<color=#75715e>       *</color>
<color=#75715e>       * Only do this if the parent we found is at a higher level than</color>
<color=#75715e>       * the child.  This ensures that the non-exact search does not</color>
<color=#75715e>       * find a sibling rather than a parent. [#11555]</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>exactParentFound</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parentLevel</color> <color=#f92672>></color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>addIN</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color> <color=#75715e>/*index*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*updateFlushLevels*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*updateMemoryBudget*/</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We found the parent. Add it unconditionally to the dirty map. We</color>
<color=#75715e>       * must make sure that every IN that was selected for the</color>
<color=#75715e>       * checkpointer's dirty IN set at the beginning of checkpoint is</color>
<color=#75715e>       * written into the log and can be properly accessed from</color>
<color=#75715e>       * ancestors. Eviction or a split may have written out a member of</color>
<color=#75715e>       * this dirty set before the checkpointer got to it. See [#10249].</color>
<color=#75715e>       */</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>parentLevel</color> <color=#f92672>==</color> <color=#f8f8f2>targetLevel</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>addIN</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color> <color=#75715e>/*index*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*updateFlushLevels*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*updateMemoryBudget*/</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Determine whether our search found the IN identified by either</color>
<color=#75715e>       * targetRef.nodeId or targetRef.lsn. If there is not a match, then</color>
<color=#75715e>       * the node was deleted, logged or split since creating the</color>
<color=#75715e>       * reference.</color>
<color=#75715e>       *</color>
<color=#75715e>       * For a non-DW DB, targetRef.lsn will be not null and we match on</color>
<color=#75715e>       * it. If the LSN has changed then of course the node was logged,</color>
<color=#75715e>       * and possibly split, and we will not log this target here.</color>
<color=#75715e>       *</color>
<color=#75715e>       * For a DW DB we also match on LSN if it is non-null. If the LSN</color>
<color=#75715e>       * is null then the reference was created for a never-logged IN and</color>
<color=#75715e>       * targetRef.nodeId >= 0. In that case we match on the nodeId. If</color>
<color=#75715e>       * the LSN or nodeId doesn't match, there must have been a split,</color>
<color=#75715e>       * and we will not log this target here. However, because splits</color>
<color=#75715e>       * are not logged for DW, this is not sufficient to cause both</color>
<color=#75715e>       * siblings that were part of split to be logged, when one node was</color>
<color=#75715e>       * added to the dirty map. We account for this when the parent is</color>
<color=#75715e>       * logged by calling logDirtyChildren. This approach relies on the</color>
<color=#75715e>       * fact that a split will dirty the parent.</color>
<color=#75715e>       *</color>
<color=#75715e>       * TODO:</color>
<color=#75715e>       * Why not always call logDirtyIN for a DW IN, whether or not the</color>
<color=#75715e>       * LSN or nodeId matches? logDirtyChildren is going to log it</color>
<color=#75715e>       * anyway if it is dirty.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>nodeId</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>();</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>target</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>target</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>targetRef</color><color=#f8f8f2>.</color><color=#a6e22e>nodeId</color> <color=#f92672>!=</color> <color=#f8f8f2>target</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Log the target, if dirty. */</color>
      <color=#f8f8f2>logDirtyIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>provisional</color><color=#f8f8f2>,</color> <color=#f8f8f2>fstats</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We will log a sub-tree when the target is at the bottom level</color>
<color=#75715e>       * and this is not a recursive call to flushIN during sub-tree</color>
<color=#75715e>       * logging. Return if we are only logging the target node here.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bottomLevelTarget</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>allowLogSubtree</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Log sub-tree siblings with the latch held when highPriority</color>
<color=#75715e>       * is configured and this is not a DW DB. For a DW DB, dirty LNs</color>
<color=#75715e>       * are logged for each BIN.  If we were to log a DW sub-tree with</color>
<color=#75715e>       * the parent latch held, the amount of logging may cause the latch</color>
<color=#75715e>       * to be held for too long a period.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>highPriority</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDurableDeferredWrite</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>logSiblingsSeparately</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>logSiblingsSeparately</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ArrayList</color><color=#f92672><></color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672>==</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>childId</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f8f8f2>:</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>childLsn</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>childRef</color> <color=#f92672>=</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>removeNode</color><color=#f8f8f2>(</color><color=#f8f8f2>targetLevel</color><color=#f8f8f2>,</color> <color=#f8f8f2>childLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>childId</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>childRef</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logSiblingsSeparately</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>logSiblingsSeparately</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>childRef</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>logDirtyIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>provisional</color><color=#f8f8f2>,</color> <color=#f8f8f2>fstats</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Get parentRef before releasing the latch. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parentLevel</color> <color=#f92672><=</color> <color=#f8f8f2>maxFlushLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>parentRef</color> <color=#f92672>=</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>.</color><color=#a6e22e>removeNode</color><color=#f8f8f2>(</color><color=#f8f8f2>parentLevel</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedLsn</color><color=#f8f8f2>(),</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>parentRef</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If highPriority is false, we don't hold the latch while logging</color>
<color=#75715e>     * the bottom level siblings.  We log them here with flushIN,</color>
<color=#75715e>     * performing a separate search for each one, after releasing the</color>
<color=#75715e>     * parent latch above.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logSiblingsSeparately</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>childRef</color> <color=#f8f8f2>:</color> <color=#f8f8f2>logSiblingsSeparately</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>flushIN</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>childRef</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxFlushLevel</color><color=#f8f8f2>,</color> <color=#f8f8f2>highPriority</color><color=#f8f8f2>,</color> <color=#f8f8f2>fstats</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*allowLogSubtree*/</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Log the sub-tree parent, which will be logged non-provisionally,</color>
<color=#75715e>     * in order to update cleaner utilization. This must be done with</color>
<color=#75715e>     * flushIN after releasing the parent latch above, since we must search</color>
<color=#75715e>     * and acquire the grandparent latch.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parentRef</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>flushIN</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>parentRef</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirtyMap</color><color=#f8f8f2>,</color> <color=#f8f8f2>maxFlushLevel</color><color=#f8f8f2>,</color> <color=#f8f8f2>highPriority</color><color=#f8f8f2>,</color> <color=#f8f8f2>fstats</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*allowLogSubtree*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Note that if this method is called, the parent must also be logged. This is true even if this</color>
<color=#75715e>   * method finds that the child is not dirty. In that case the child has already been flushed</color>
<color=#75715e>   * (e.g., by eviction) and the parent must be logged according to the rule for max flush level.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>logDirtyIN</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Provisional</color> <color=#f8f8f2>provisional</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>FlushStats</color> <color=#f8f8f2>fstats</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>child</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isBIN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isDelta</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>isDurableDeferredWrite</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Find dirty descendants to avoid logging nodes with</color>
<color=#75715e>           * never-logged children. See [#13936] and</color>
<color=#75715e>           * IN.logDirtyChildren for description of the case.</color>
<color=#75715e>           *</color>
<color=#75715e>           * Note that we must log both dirty and never-logged</color>
<color=#75715e>           * descendants to be sure to have a consistent view of</color>
<color=#75715e>           * the split. If we didn't, we could end up with the</color>
<color=#75715e>           * post-split version of a new sibling and the</color>
<color=#75715e>           * pre-split version of an split sibling in the log,</color>
<color=#75715e>           * which could result in a recovery where descendants</color>
<color=#75715e>           * are incorrectly duplicated, because they are in both</color>
<color=#75715e>           * the pre-split split sibling, and the post-split</color>
<color=#75715e>           * version of the new sibling.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>logDirtyChildren</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>newLsn</color> <color=#f92672>=</color>
            <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>log</color><color=#f8f8f2>(</color>
                <color=#66d9ef>true</color> <color=#75715e>/*allowDeltas*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>provisional</color><color=#f8f8f2>,</color>
                <color=#66d9ef>true</color> <color=#75715e>/*backgroundIO*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>);</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>newLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>isBIN</color> <color=#f92672>=</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>isDelta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>newLsn</color> <color=#f92672>==</color> <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>getLastDeltaLsn</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>child</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>OffHeapCache</color> <color=#f8f8f2>ohCache</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapCache</color><color=#f8f8f2>();</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>INLogEntry</color><color=#f92672><</color><color=#f8f8f2>BIN</color><color=#f92672>></color> <color=#f8f8f2>logEntry</color> <color=#f92672>=</color> <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>createBINLogEntryForCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logEntry</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>isBIN</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>isDelta</color> <color=#f92672>=</color> <color=#f8f8f2>logEntry</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>newLsn</color> <color=#f92672>=</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>logEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>logEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>provisional</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*backgroundIO*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>ohCache</color><color=#f8f8f2>.</color><color=#a6e22e>postBINLog</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>logEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>newLsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>updateEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>newLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>fstats</color><color=#f8f8f2>.</color><color=#a6e22e>nDeltaINFlushThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>fstats</color><color=#f8f8f2>.</color><color=#a6e22e>nDeltaINFlush</color><color=#f92672>++</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>fstats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullINFlushThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>fstats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullINFlush</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isBIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fstats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullBINFlush</color><color=#f92672>++</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>fstats</color><color=#f8f8f2>.</color><color=#a6e22e>nFullBINFlushThisRun</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * RootFlusher lets us write out the root IN within the root latch.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>RootFlusher</color> <color=#66d9ef>implements</color> <color=#f8f8f2>WithRootLatched</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>flushed</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>stillRoot</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>targetNodeId</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>RootFlusher</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>targetNodeId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>db</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>flushed</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>targetNodeId</color> <color=#f92672>=</color> <color=#f8f8f2>targetNodeId</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>stillRoot</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/** Flush the rootIN if dirty. */</color>
    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#f8f8f2>IN</color> <color=#a6e22e>doWork</color><color=#f8f8f2>(</color><color=#f8f8f2>ChildReference</color> <color=#f8f8f2>root</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>root</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>IN</color> <color=#f8f8f2>rootIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>fetchTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>targetNodeId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Find dirty descendants to avoid logging nodes with</color>
<color=#75715e>           * never-logged children. See [#13936]</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>isDurableDeferredWrite</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>logDirtyChildren</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/*</color>
<color=#75715e>           * stillRoot handles the situation where the root was split</color>
<color=#75715e>           * after it was placed in the checkpointer's dirty set.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>stillRoot</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>long</color> <color=#f8f8f2>newLsn</color> <color=#f92672>=</color> <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>log</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>root</color><color=#f8f8f2>.</color><color=#a6e22e>setLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>newLsn</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>flushed</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>rootIN</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>getFlushed</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>flushed</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>stillRoot</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>stillRoot</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * CheckpointReferences are used to identify nodes that must be flushed as</color>
<color=#75715e>   * part of the checkpoint. We don't keep an actual reference to the node</color>
<color=#75715e>   * because that prevents nodes from being GC'ed during checkpoint.</color>
<color=#75715e>   *</color>
<color=#75715e>   * Using a checkpointReference introduces a window between the point when</color>
<color=#75715e>   * the checkpoint dirty set is created and when the node is flushed. Some</color>
<color=#75715e>   * of the fields saved in the reference are immutable: db, nodeId.  The</color>
<color=#75715e>   * others are not and we have to handle potential change:</color>
<color=#75715e>   *</color>
<color=#75715e>   * isRoot: it's possible for isRoot to go from true->false, but not</color>
<color=#75715e>   *         false->true. True->false is handled by the flushIN method</color>
<color=#75715e>   *         by finding the root and checking if it is the target.</color>
<color=#75715e>   * treeKey: This can change only in the event of a split. If it does, there</color>
<color=#75715e>   *         is the chance that the checkpointer will find the wrong node to</color>
<color=#75715e>   *         flush, but that's okay because the split guarantees flushing to</color>
<color=#75715e>   *         the root, so the target will be properly logged within the</color>
<color=#75715e>   *         checkpoint period.</color>
<color=#75715e>   *</color>
<color=#75715e>   * The class and ctor are public for the Sizeof program.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>CheckpointReference</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nodeLevel</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isRoot</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>treeKey</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>CheckpointReference</color><color=#f8f8f2>(</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nodeLevel</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isRoot</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>treeKey</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>dbId</color> <color=#f92672>=</color> <color=#f8f8f2>dbId</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>nodeId</color> <color=#f92672>=</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>nodeLevel</color> <color=#f92672>=</color> <color=#f8f8f2>nodeLevel</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color> <color=#f92672>=</color> <color=#f8f8f2>isRoot</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>treeKey</color> <color=#f92672>=</color> <color=#f8f8f2>treeKey</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>Object</color> <color=#f8f8f2>o</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>o</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>CheckpointReference</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>other</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>CheckpointReference</color><color=#f8f8f2>)</color> <color=#f8f8f2>o</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>nodeId</color> <color=#f92672>==</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>nodeId</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>hashCode</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>toString</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"db="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" nodeId="</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeId</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** A struct to hold log flushing stats for checkpoint and database sync. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>FlushStats</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#f8f8f2>nFullINFlush</color><color=#f8f8f2>;</color>
    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#f8f8f2>nFullBINFlush</color><color=#f8f8f2>;</color>
    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#f8f8f2>nDeltaINFlush</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>nFullINFlushThisRun</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>nFullBINFlushThisRun</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>nDeltaINFlushThisRun</color><color=#f8f8f2>;</color>

    <color=#75715e>/* For future addition to stats:</color>
<color=#75715e>       private int nAlreadyEvictedThisRun;</color>
<color=#75715e>    */</color>

    <color=#75715e>/* Reset per-run counters. */</color>
    <color=#66d9ef>void</color> <color=#a6e22e>resetPerRunCounters</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nFullINFlushThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>nFullBINFlushThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>nDeltaINFlushThisRun</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#75715e>/* nAlreadyEvictedThisRun = 0; -- for future */</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>