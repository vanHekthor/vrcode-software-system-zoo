<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.rep.impl</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.bind.tuple.TupleBinding</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.bind.tuple.TupleInput</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.bind.tuple.TupleOutput</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentFailureException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.JEVersion</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.MemberNotFoundException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.impl.RepGroupDB.NodeBinding</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.net.InetSocketAddress</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.*</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * Represents a snapshot of the Replication Group as a whole. Note that membership associated with a</color>
<color=#75715e> * group is dynamic and its constituents can change at any time. It's useful to keep in mind that</color>
<color=#75715e> * due to the distributed nature of the Replication Group all the nodes in a replication group may</color>
<color=#75715e> * not have the same consistent picture of the replication group at a single point in time, but will</color>
<color=#75715e> * converge to become consistent eventually.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>RepGroupImpl</color> <color=#f8f8f2>{</color>

  <color=#75715e>/** The latest supported format version. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>MAX_FORMAT_VERSION</color> <color=#f92672>=</color> <color=#ae81ff>3</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Format version introduced in JE 6.0.1 that records a node's most recent JE version, and the</color>
<color=#75715e>   * minimum JE version required to join the group.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>FORMAT_VERSION_3</color> <color=#f92672>=</color> <color=#ae81ff>3</color><color=#f8f8f2>;</color>

  <color=#75715e>/** The latest format version that is compatible with JE 6.0.0 and earlier versions. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>FORMAT_VERSION_2</color> <color=#f92672>=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>

  <color=#75715e>/** The initial format version for newly created RepGroupImpl instances. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>INITIAL_FORMAT_VERSION</color> <color=#f92672>=</color> <color=#ae81ff>3</color><color=#f8f8f2>;</color>

  <color=#75715e>/** The oldest supported format version. */</color>
  <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>MIN_FORMAT_VERSION</color> <color=#f92672>=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>

  <color=#75715e>/** The first JE version that supports FORMAT_VERSION_3. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>FORMAT_VERSION_3_JE_VERSION</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>JEVersion</color><color=#f8f8f2>(</color><color=#e6db74>"6.0.1"</color><color=#f8f8f2>);</color>

  <color=#75715e>/** The first JE version that supports the oldest supported format version. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>MIN_FORMAT_VERSION_JE_VERSION</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>JEVersion</color><color=#f8f8f2>(</color><color=#e6db74>"5.0.0"</color><color=#f8f8f2>);</color>

  <color=#75715e>/** The initial change version. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>CHANGE_VERSION_START</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The special UUID associated with a group, when the group UUID is unknown</color>
<color=#75715e>   * because a node is still in the process of joining the group. This value</color>
<color=#75715e>   * cannot be created by UUID.randomUUID</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>UUID</color> <color=#f8f8f2>UNKNOWN_UUID</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>UUID</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The maximum number of nodes with transient ID that can join the group at the same time time.</color>
<color=#75715e>   * This number of transient id node IDs will be reserved at the top of the node ID range.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>MAX_NODES_WITH_TRANSIENT_ID</color> <color=#f92672>=</color> <color=#ae81ff>1024</color><color=#f8f8f2>;</color>

  <color=#75715e>/** The first node ID for persistent nodes. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>NODE_SEQUENCE_START</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#75715e>/** The maximum node ID for persistent nodes. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>NODE_SEQUENCE_MAX</color> <color=#f92672>=</color> <color=#f8f8f2>Integer</color><color=#f8f8f2>.</color><color=#a6e22e>MAX_VALUE</color> <color=#f92672>-</color> <color=#f8f8f2>MAX_NODES_WITH_TRANSIENT_ID</color><color=#f8f8f2>;</color>

  <color=#75715e>/** Returns true if the node is electable. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>ELECTABLE_PREDICATE</color> <color=#f92672>=</color>
      <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
        <color=#a6e22e>@Override</color>
        <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isElectable</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>};</color>

  <color=#75715e>/** Returns true if the node is a monitor. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>MONITOR_PREDICATE</color> <color=#f92672>=</color>
      <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
        <color=#a6e22e>@Override</color>
        <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isMonitor</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>};</color>

  <color=#75715e>/** Returns true if the node is secondary. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>SECONDARY_PREDICATE</color> <color=#f92672>=</color>
      <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
        <color=#a6e22e>@Override</color>
        <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isSecondary</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>};</color>

  <color=#75715e>/** Returns true if the node is external. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>EXTERNAL_PREDICATE</color> <color=#f92672>=</color>
      <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
        <color=#a6e22e>@Override</color>
        <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isExternal</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>};</color>

  <color=#75715e>/** Returns true if the node can return acks but is not an Arbiter. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>ACK_PREDICATE</color> <color=#f92672>=</color>
      <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
        <color=#a6e22e>@Override</color>
        <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isElectable</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isArbiter</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>};</color>

  <color=#75715e>/** Returns true if the node is an arbiter. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>ARBITER_PREDICATE</color> <color=#f92672>=</color>
      <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
        <color=#a6e22e>@Override</color>
        <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isArbiter</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>};</color>

  <color=#75715e>/* The name of the Replication Group. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>groupName</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The universally unique UUID associated with the replicated environment.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>UUID</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The version number associated with this group's format in the database.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#66d9ef>int</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Tracks the change version level. It's updated with every change to the</color>
<color=#75715e>   * member set in the membership database.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>changeVersion</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The most recently assigned node ID for persistent nodes.  Node IDs for</color>
<color=#75715e>   * persistent nodes are never reused.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>nodeIdSequence</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The following maps represent the set of nodes in the group indexed in</color>
<color=#75715e>   * two different ways: by user-defined node name and by internal id. Note</color>
<color=#75715e>   * that both maps contain nodes that are no longer members of the group.</color>
<color=#75715e>   *</color>
<color=#75715e>   * All access to nodesById and nodesByName should be synchronized on</color>
<color=#75715e>   * nodesById, to avoid ConcurrentModificationException and to provide</color>
<color=#75715e>   * consistent results for both maps.</color>
<color=#75715e>   */</color>

  <color=#75715e>/* All the nodes that form the replication group, indexed by Id. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f8f8f2>,</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>nodesById</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f8f8f2>,</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>

  <color=#75715e>/*</color>
<color=#75715e>   * All the nodes that form the replication group, indexed by node name.</color>
<color=#75715e>   * This map is used exclusively for efficient lookups by name. The map</color>
<color=#75715e>   * nodesById does all the heavy lifting.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>String</color><color=#f8f8f2>,</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>nodesByName</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><</color><color=#f8f8f2>String</color><color=#f8f8f2>,</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>

  <color=#75715e>/** The minimum JE version required for nodes to join the group. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>minJEVersion</color> <color=#f92672>=</color> <color=#f8f8f2>MIN_FORMAT_VERSION_JE_VERSION</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Constructor to create a new empty repGroup, typically as part of environment initialization.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param groupName the group name</color>
<color=#75715e>   * @param currentJEVersion if non-null, override the current JE version, for testing</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>RepGroupImpl</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>groupName</color><color=#f8f8f2>,</color> <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>currentJEVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>(</color><color=#f8f8f2>groupName</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>currentJEVersion</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Constructor to create a group and specify if the group's UUID should be unknown or generated</color>
<color=#75715e>   * randomly.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>RepGroupImpl</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>groupName</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>unknownUUID</color><color=#f8f8f2>,</color> <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>currentJEVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>groupName</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>unknownUUID</color> <color=#f92672>?</color> <color=#f8f8f2>UNKNOWN_UUID</color> <color=#f8f8f2>:</color> <color=#f8f8f2>UUID</color><color=#f8f8f2>.</color><color=#a6e22e>randomUUID</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>getCurrentFormatVersion</color><color=#f8f8f2>(</color><color=#f8f8f2>currentJEVersion</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Get the current format version, supporting a test override. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>getCurrentFormatVersion</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>currentJEVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentJEVersion</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#f8f8f2>MAX_FORMAT_VERSION</color> <color=#f8f8f2>:</color> <color=#f8f8f2>getMaxFormatVersion</color><color=#f8f8f2>(</color><color=#f8f8f2>currentJEVersion</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Constructor to create a group and specify the group's UUID and format version. */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>RepGroupImpl</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>groupName</color><color=#f8f8f2>,</color> <color=#f8f8f2>UUID</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>groupName</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>uuid</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>formatVersion</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>CHANGE_VERSION_START</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>NODE_SEQUENCE_START</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>((</color><color=#f8f8f2>formatVersion</color> <color=#f92672><</color> <color=#f8f8f2>FORMAT_VERSION_3</color><color=#f8f8f2>)</color>
            <color=#f92672>?</color> <color=#f8f8f2>MIN_FORMAT_VERSION_JE_VERSION</color>
            <color=#f8f8f2>:</color> <color=#f8f8f2>FORMAT_VERSION_3_JE_VERSION</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Constructor used to recreate an existing RepGroup, typically as part of a deserialization</color>
<color=#75715e>   * operation.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param groupName</color>
<color=#75715e>   * @param uuid</color>
<color=#75715e>   * @param formatVersion</color>
<color=#75715e>   * @param changeVersion</color>
<color=#75715e>   * @param minJEVersion</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>RepGroupImpl</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>String</color> <color=#f8f8f2>groupName</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>UUID</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>changeVersion</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>nodeIdSequence</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>minJEVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>groupName</color> <color=#f92672>=</color> <color=#f8f8f2>groupName</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>uuid</color> <color=#f92672>=</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>formatVersion</color> <color=#f92672>=</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>changeVersion</color> <color=#f92672>=</color> <color=#f8f8f2>changeVersion</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>setNodeIdSequence</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeIdSequence</color><color=#f8f8f2>);</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>minJEVersion</color> <color=#f92672>=</color> <color=#f8f8f2>minJEVersion</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>formatVersion</color> <color=#f92672><</color> <color=#f8f8f2>MIN_FORMAT_VERSION</color> <color=#f92672>||</color> <color=#f8f8f2>formatVersion</color> <color=#f92672>></color> <color=#f8f8f2>MAX_FORMAT_VERSION</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalStateException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Expected membership database format version between: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>MIN_FORMAT_VERSION</color>
              <color=#f92672>+</color> <color=#e6db74>" and "</color>
              <color=#f92672>+</color> <color=#f8f8f2>MAX_FORMAT_VERSION</color>
              <color=#f92672>+</color> <color=#e6db74>", encountered unsupported version: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>minJEVersion</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"The minJEVersion must not be null"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Returns true if the UUID has not as yet been established at this node.</color>
<color=#75715e>   * This is the case when a knew node first joins a group, and it has not</color>
<color=#75715e>   * as yet replicated the group database via the replication stream.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>hasUnknownUUID</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>UNKNOWN_UUID</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>uuid</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Predicate to help determine whether the UUID is the canonical unknown UUID. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isUnknownUUID</color><color=#f8f8f2>(</color><color=#f8f8f2>UUID</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>UNKNOWN_UUID</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>uuid</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Sets the UUID. The UUID can only be set if it's currently unknown. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setUUID</color><color=#f8f8f2>(</color><color=#f8f8f2>UUID</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>hasUnknownUUID</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"Expected placeholder UUID, not "</color> <color=#f92672>+</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>uuid</color> <color=#f92672>=</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Removes a member transiently from the rep group by marking it as removed and optionally</color>
<color=#75715e>   * deleting it from the by-name and by-ID maps. This action is usually a precursor to making the</color>
<color=#75715e>   * change persistent on disk.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param nodeName identifies the node being removed</color>
<color=#75715e>   * @param delete whether to delete the node from the maps</color>
<color=#75715e>   * @return the node that was removed</color>
<color=#75715e>   * @throws EnvironmentFailureException if the node is not part of the group or is a node with a</color>
<color=#75715e>   *     transient ID</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>RepNodeImpl</color> <color=#a6e22e>removeMember</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>nodeName</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>delete</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color> <color=#f92672>=</color> <color=#f8f8f2>getMember</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeName</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Node:"</color> <color=#f92672>+</color> <color=#f8f8f2>nodeName</color> <color=#f92672>+</color> <color=#e6db74>" is not a member of the group."</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>hasTransientId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Cannot remove node with transient id: "</color> <color=#f92672>+</color> <color=#f8f8f2>nodeName</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>delete</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeName</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>setRemoved</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>node</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Checks for whether a new or changed node definition is in conflict with other members of the</color>
<color=#75715e>   * group. In particular, checks that the specified node does not use the same socket address as</color>
<color=#75715e>   * another member.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This check must be done when adding a new member to the group, or changing the network</color>
<color=#75715e>   * address of an existing member, and must be done with the rep group entry in the database locked</color>
<color=#75715e>   * for write to prevent race conditions.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param node the new node that is being checked for conflicts</color>
<color=#75715e>   * @throws NodeConflictException if there is a conflict</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>checkForConflicts</color><color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color> <color=#f8f8f2>:</color> <color=#f8f8f2>getAllMembers</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getNameIdPair</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNameIdPair</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getSocketAddress</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getSocketAddress</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>NodeConflictException</color><color=#f8f8f2>(</color>
            <color=#e6db74>"New or moved node:"</color>
                <color=#f92672>+</color> <color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>", is configured with the socket address: "</color>
                <color=#f92672>+</color> <color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getSocketAddress</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>".  It conflicts with the socket already "</color>
                <color=#f92672>+</color> <color=#e6db74>"used by the member: "</color>
                <color=#f92672>+</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>hashCode</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>prime</color> <color=#f92672>=</color> <color=#ae81ff>31</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>prime</color> <color=#f92672>*</color> <color=#f8f8f2>result</color> <color=#f92672>+</color> <color=#f8f8f2>changeVersion</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>prime</color> <color=#f92672>*</color> <color=#f8f8f2>result</color> <color=#f92672>+</color> <color=#f8f8f2>((</color><color=#f8f8f2>groupName</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#ae81ff>0</color> <color=#f8f8f2>:</color> <color=#f8f8f2>groupName</color><color=#f8f8f2>.</color><color=#a6e22e>hashCode</color><color=#f8f8f2>());</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>prime</color> <color=#f92672>*</color> <color=#f8f8f2>result</color> <color=#f92672>+</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>hashCode</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#75715e>/* Don't bother with nodesByName */</color>
    <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>prime</color> <color=#f92672>*</color> <color=#f8f8f2>result</color> <color=#f92672>+</color> <color=#f8f8f2>((</color><color=#f8f8f2>uuid</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#ae81ff>0</color> <color=#f8f8f2>:</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>.</color><color=#a6e22e>hashCode</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>prime</color> <color=#f92672>*</color> <color=#f8f8f2>result</color> <color=#f92672>+</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>;</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>Object</color> <color=#f8f8f2>obj</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color> <color=#f92672>==</color> <color=#f8f8f2>obj</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>obj</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>obj</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>RepGroupImpl</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>RepGroupImpl</color> <color=#f8f8f2>other</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>RepGroupImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>obj</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>changeVersion</color> <color=#f92672>!=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>changeVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>groupName</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>groupName</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>groupName</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>groupName</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#75715e>/* Don't bother with nodesByName, since nodesById equality covers it */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>uuid</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>uuid</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>uuid</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>uuid</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>formatVersion</color> <color=#f92672>!=</color> <color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>formatVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>minJEVersion</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>minJEVersion</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Do this last, since it is expensive because of its need to avoid</color>
<color=#75715e>     * concurrency conflicts.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f8f8f2>,</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>otherNodesById</color><color=#f8f8f2>;</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>otherNodesById</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f8f8f2>,</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>(</color><color=#f8f8f2>other</color><color=#f8f8f2>.</color><color=#a6e22e>nodesById</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>otherNodesById</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Sets the nodes associated with the Rep group. Note that both nodesById and nodesByIndex are</color>
<color=#75715e>   * initialized.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setNodes</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f8f8f2>,</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>nodes</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/* Remove nodes with persistent id */</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Iterator</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>iter</color> <color=#f92672>=</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>().</color><color=#a6e22e>iterator</color><color=#f8f8f2>();</color> <color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>hasNext</color><color=#f8f8f2>();</color> <color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color> <color=#f92672>=</color> <color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f8f8f2>();</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>hasTransientId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Add specified nodes */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodes</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodes</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>prevById</color> <color=#f92672>=</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>
          <color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>prevByName</color> <color=#f92672>=</color> <color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>(),</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Also remove entries for any previous nodes if the</color>
<color=#75715e>           * mapping between names and IDs was changed.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>prevById</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>prevById</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>prevById</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>}</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>prevByName</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>prevByName</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>prevByName</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>()).</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>()))</color>
          <color=#f8f8f2>:</color> <color=#e6db74>"Node maps indexed by ID and name differ: "</color>
              <color=#f92672>+</color> <color=#e6db74>"IDs: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>nodesById</color>
              <color=#f92672>+</color> <color=#e6db74>", Names: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>nodesByName</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Add a node with transient id. The caller should already have assigned the node an ID and</color>
<color=#75715e>   * checked that the replication group supports secondary nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param node the node with transient id</color>
<color=#75715e>   * @throws IllegalStateException if the store does not currently support secondary nodes</color>
<color=#75715e>   * @throws NodeConflictException if the node conflicts with an existing persistent node</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>addTransientIdNode</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>hasTransientId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Attempt to call addTransientIdNode on a node without "</color> <color=#f92672>+</color> <color=#e6db74>"transient id: "</color> <color=#f92672>+</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNameIdPair</color><color=#f8f8f2>().</color><color=#a6e22e>hasNullId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Attempt to call addTransientIdNode on node without ID: "</color> <color=#f92672>+</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>prevById</color> <color=#f92672>=</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevById</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>prevById</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>hasTransientId</color><color=#f8f8f2>()</color>
          <color=#f8f8f2>:</color> <color=#e6db74>"Same node ID for nodes with transient and persistent ID: "</color> <color=#f92672>+</color> <color=#f8f8f2>node</color> <color=#f92672>+</color> <color=#e6db74>", "</color> <color=#f92672>+</color> <color=#f8f8f2>prevById</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>prevByName</color> <color=#f92672>=</color> <color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>());</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>prevByName</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>prevByName</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>hasTransientId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>NodeConflictException</color><color=#f8f8f2>(</color>
            <color=#e6db74>"New node with transient ID "</color>
                <color=#f92672>+</color> <color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>()</color>
                <color=#f92672>+</color> <color=#e6db74>" conflicts with an existing node with persistent ID"</color>
                <color=#f92672>+</color> <color=#e6db74>" with the same name: "</color>
                <color=#f92672>+</color> <color=#f8f8f2>prevByName</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>prevById2</color> <color=#f92672>=</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>prevById</color> <color=#f92672>==</color> <color=#f8f8f2>prevById2</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>prevByName2</color> <color=#f92672>=</color> <color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>(),</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>prevByName</color> <color=#f92672>==</color> <color=#f8f8f2>prevByName2</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>prevById</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>prevById</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>prevById</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>prevByName</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>prevByName</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>prevByName</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>()).</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>()))</color>
          <color=#f8f8f2>:</color> <color=#e6db74>"Node maps indexed by ID and name differ: "</color>
              <color=#f92672>+</color> <color=#e6db74>"IDs: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>nodesById</color>
              <color=#f92672>+</color> <color=#e6db74>", Names: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>nodesByName</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Remove a node with transient id, which should have an assigned ID</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param node the node with a transient ID</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>removeTransientNode</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>hasTransientId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Attempt to call removeTransientNode on a"</color> <color=#f92672>+</color> <color=#e6db74>" node without transient ID: "</color> <color=#f92672>+</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNameIdPair</color><color=#f8f8f2>().</color><color=#a6e22e>hasNullId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Attempt to call removeTransientNode on a node with no ID: "</color> <color=#f92672>+</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * returns the unique UUID associated with the replicated environment.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the UUID</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>UUID</color> <color=#a6e22e>getUUID</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>uuid</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the version of the format (the schema) in use by this group instance in the database.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the format version</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getFormatVersion</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the highest format version supported by the specified JE version.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param jeVersion the JE version</color>
<color=#75715e>   * @return the highest format version supported by that JE version</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>getMaxFormatVersion</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>jeVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>jeVersion</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>FORMAT_VERSION_3_JE_VERSION</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>FORMAT_VERSION_2</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>FORMAT_VERSION_3</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the version of the instance as represented by changes to the members constituting the</color>
<color=#75715e>   * group.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the object change version</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getChangeVersion</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>changeVersion</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Increments the object change version. It must be called with the group entry locked in the</color>
<color=#75715e>   * group database.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the incremented change version</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>incrementChangeVersion</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f92672>++</color><color=#f8f8f2>changeVersion</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the current highest node ID currently in use by the group.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the highest node ID in use</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getNodeIdSequence</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nodeIdSequence</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Set the node id sequence. This is only done in unusual circumstances, e.g. when a replication</color>
<color=#75715e>   * group is being reset in an existing replicated environment and we want to ensure that the</color>
<color=#75715e>   * internal node ids are not reused in the logs.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setNodeIdSequence</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>nodeIdSequence</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodeIdSequence</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>nodeIdSequence</color> <color=#f92672>></color> <color=#f8f8f2>NODE_SEQUENCE_MAX</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"Bad nodeIdSequence: "</color> <color=#f92672>+</color> <color=#f8f8f2>nodeIdSequence</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>nodeIdSequence</color> <color=#f92672>=</color> <color=#f8f8f2>nodeIdSequence</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Increments the node ID sequence and returns it.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the next node ID for use in a new node</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getNextNodeId</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodeIdSequence</color> <color=#f92672>>=</color> <color=#f8f8f2>NODE_SEQUENCE_MAX</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalStateException</color><color=#f8f8f2>(</color><color=#e6db74>"Reached maximum node ID"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f92672>++</color><color=#f8f8f2>nodeIdSequence</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns the node ID that is associated with the very first node in the replication group. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>getFirstNodeId</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>NODE_SEQUENCE_START</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns the minimum JE version that a node must be running in order to join the group. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>JEVersion</color> <color=#a6e22e>getMinJEVersion</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>minJEVersion</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Sets the minimum JE version that a node must be running in order to join the replication group.</color>
<color=#75715e>   * The group object should have had its nodes fetched using the {@link RepGroupDB#fetchGroup}</color>
<color=#75715e>   * method and should be stored to the group database after making this change. Throws a {@link</color>
<color=#75715e>   * MinJEVersionUnsupportedException} if the requested version is not supported. Updates the group</color>
<color=#75715e>   * format version as needed to match the JE version. Has no effect if the current minimum value is</color>
<color=#75715e>   * already as high or higher than the requested one.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param newMinJEVersion the new minimum JE version</color>
<color=#75715e>   * @throws MinJEVersionUnsupportedException if the requested version is not supported by the</color>
<color=#75715e>   *     group's electable nodes</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setMinJEVersion</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>newMinJEVersion</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>MinJEVersionUnsupportedException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newMinJEVersion</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"The newMinJEVersion argument must not be null"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newMinJEVersion</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>minJEVersion</color><color=#f8f8f2>)</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>newFormatVersion</color> <color=#f92672>=</color> <color=#f8f8f2>getMaxFormatVersion</color><color=#f8f8f2>(</color><color=#f8f8f2>newMinJEVersion</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Minimum JE version is not stored before format version 3 */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newFormatVersion</color> <color=#f92672><</color> <color=#f8f8f2>FORMAT_VERSION_3</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color> <color=#f8f8f2>:</color> <color=#f8f8f2>getElectableMembers</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>JEVersion</color> <color=#f8f8f2>nodeJEVersion</color> <color=#f92672>=</color> <color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getJEVersion</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>nodeJEVersion</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>nodeJEVersion</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>newMinJEVersion</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>MinJEVersionUnsupportedException</color><color=#f8f8f2>(</color><color=#f8f8f2>newMinJEVersion</color><color=#f8f8f2>,</color> <color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>(),</color> <color=#f8f8f2>nodeJEVersion</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>minJEVersion</color> <color=#f92672>=</color> <color=#f8f8f2>newMinJEVersion</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>formatVersion</color> <color=#f92672>=</color> <color=#f8f8f2>newFormatVersion</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Used to ensure that the ReplicationGroup value is consistent after it has been fetched via a</color>
<color=#75715e>   * readUncommitted access to the rep group database. It does so by ensuring that the summarized</color>
<color=#75715e>   * values match the nodes that were actually read.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>makeConsistent</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>computedNodeId</color> <color=#f92672>=</color> <color=#f8f8f2>NODE_SEQUENCE_START</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>computedChangeVersion</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>mi</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Get the highest node ID */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>computedNodeId</color> <color=#f92672><</color> <color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>computedNodeId</color> <color=#f92672>=</color> <color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#75715e>/* Get the highest change version. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>computedChangeVersion</color> <color=#f92672><</color> <color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getChangeVersion</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>computedChangeVersion</color> <color=#f92672>=</color> <color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getChangeVersion</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>setNodeIdSequence</color><color=#f8f8f2>(</color><color=#f8f8f2>computedNodeId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>changeVersion</color> <color=#f92672>=</color> <color=#f8f8f2>computedChangeVersion</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Serialization</color>
<color=#75715e>   */</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Serializes an object by converting its TupleBinding byte based representation into the hex</color>
<color=#75715e>   * characters denoting the bytes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param <T> the type of the object being serialized</color>
<color=#75715e>   * @param binding the tuble binding used to convert it into its byte form</color>
<color=#75715e>   * @param object the object being serialized</color>
<color=#75715e>   * @return the hex string containing the serialized hex form of the object</color>
<color=#75715e>   */</color>
  <color=#66d9ef>static</color> <color=#f92672><</color><color=#f8f8f2>T</color><color=#f92672>></color> <color=#f8f8f2>String</color> <color=#a6e22e>objectToHex</color><color=#f8f8f2>(</color><color=#f8f8f2>TupleBinding</color><color=#f92672><</color><color=#f8f8f2>T</color><color=#f92672>></color> <color=#f8f8f2>binding</color><color=#f8f8f2>,</color> <color=#f8f8f2>T</color> <color=#f8f8f2>object</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>TupleOutput</color> <color=#f8f8f2>tuple</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TupleOutput</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>100</color><color=#f92672>]</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>binding</color><color=#f8f8f2>.</color><color=#a6e22e>objectToEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>object</color><color=#f8f8f2>,</color> <color=#f8f8f2>tuple</color><color=#f8f8f2>);</color>
    <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>bytes</color> <color=#f92672>=</color> <color=#f8f8f2>tuple</color><color=#f8f8f2>.</color><color=#a6e22e>getBufferBytes</color><color=#f8f8f2>();</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#f8f8f2>tuple</color><color=#f8f8f2>.</color><color=#a6e22e>getBufferLength</color><color=#f8f8f2>();</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>lowNibble</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>bytes</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xf</color><color=#f8f8f2>);</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>highNibble</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#f8f8f2>bytes</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>>></color> <color=#ae81ff>4</color><color=#f8f8f2>)</color> <color=#f92672>&</color> <color=#ae81ff>0xf</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>buffer</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>Character</color><color=#f8f8f2>.</color><color=#a6e22e>forDigit</color><color=#f8f8f2>(</color><color=#f8f8f2>lowNibble</color><color=#f8f8f2>,</color> <color=#ae81ff>16</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>buffer</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>Character</color><color=#f8f8f2>.</color><color=#a6e22e>forDigit</color><color=#f8f8f2>(</color><color=#f8f8f2>highNibble</color><color=#f8f8f2>,</color> <color=#ae81ff>16</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>buffer</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns a serialized character based form of the group suitable for use in subclasses of</color>
<color=#75715e>   * SimpleProtocol. The serialized form is a multi-token string. The first token represents the</color>
<color=#75715e>   * RepGroup object itself with each subsequent node representing a node in the group. Tokens are</color>
<color=#75715e>   * separated by '|', the protocol separator character. The number of tokens is thus equal to the</color>
<color=#75715e>   * number of nodes in the group + 1. Each token is itself a hex character based representation of</color>
<color=#75715e>   * the binding used to serialize a RepGroup and store it into the database.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param groupFormatVersion the group format version</color>
<color=#75715e>   * @return the string encoded as above</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>serializeHex</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>groupFormatVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>RepGroupDB</color><color=#f8f8f2>.</color><color=#a6e22e>GroupBinding</color> <color=#f8f8f2>groupBinding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RepGroupDB</color><color=#f8f8f2>.</color><color=#a6e22e>GroupBinding</color><color=#f8f8f2>(</color><color=#f8f8f2>groupFormatVersion</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>buffer</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>objectToHex</color><color=#f8f8f2>(</color><color=#f8f8f2>groupBinding</color><color=#f8f8f2>,</color> <color=#66d9ef>this</color><color=#f8f8f2>));</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>mi</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Only include nodes that can be serialized with the specified</color>
<color=#75715e>         * format version</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>NodeBinding</color><color=#f8f8f2>.</color><color=#a6e22e>supportsObjectToEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>,</color> <color=#f8f8f2>groupFormatVersion</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>buffer</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>TextProtocol</color><color=#f8f8f2>.</color><color=#a6e22e>SEPARATOR</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>buffer</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>serializeHex</color><color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>,</color> <color=#f8f8f2>groupFormatVersion</color><color=#f8f8f2>));</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>buffer</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the serialized form of the node as a sequence of hex characters suitable for use by the</color>
<color=#75715e>   * text based protocols.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param node the node to be serialized.</color>
<color=#75715e>   * @param formatVersion the group format version</color>
<color=#75715e>   * @return the string containing the serialized form of the node</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>String</color> <color=#a6e22e>serializeHex</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>NodeBinding</color> <color=#f8f8f2>nodeBinding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>NodeBinding</color><color=#f8f8f2>(</color><color=#f8f8f2>formatVersion</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>objectToHex</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeBinding</color><color=#f8f8f2>,</color> <color=#f8f8f2>node</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Serialize the node into its byte representation.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param node the node to be serialized</color>
<color=#75715e>   * @param formatVersion the group format version</color>
<color=#75715e>   * @return the serialized byte array</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#a6e22e>serializeBytes</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>NodeBinding</color> <color=#f8f8f2>binding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>NodeBinding</color><color=#f8f8f2>(</color><color=#f8f8f2>formatVersion</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>TupleOutput</color> <color=#f8f8f2>tuple</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TupleOutput</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>NodeBinding</color><color=#f8f8f2>.</color><color=#a6e22e>APPROX_MAX_SIZE</color><color=#f92672>]</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>binding</color><color=#f8f8f2>.</color><color=#a6e22e>objectToEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>,</color> <color=#f8f8f2>tuple</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>tuple</color><color=#f8f8f2>.</color><color=#a6e22e>getBufferBytes</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Deserializes the object serialized by {@link #serializeHex}</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param hex the string containing the serialized form of the node</color>
<color=#75715e>   * @param formatVersion the group format version</color>
<color=#75715e>   * @return the de-serialized object</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>RepNodeImpl</color> <color=#a6e22e>hexDeserializeNode</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>hex</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>NodeBinding</color> <color=#f8f8f2>nodeBinding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>NodeBinding</color><color=#f8f8f2>(</color><color=#f8f8f2>formatVersion</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>hexToObject</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeBinding</color><color=#f8f8f2>,</color> <color=#f8f8f2>hex</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Deserialize the mode from its byte representation.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param bytes the byte representation of the node.</color>
<color=#75715e>   * @param formatVersion the group format version</color>
<color=#75715e>   * @return the deserialized object</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>RepNodeImpl</color> <color=#a6e22e>deserializeNode</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>bytes</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>formatVersion</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>NodeBinding</color> <color=#f8f8f2>binding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>NodeBinding</color><color=#f8f8f2>(</color><color=#f8f8f2>formatVersion</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>TupleInput</color> <color=#f8f8f2>tuple</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TupleInput</color><color=#f8f8f2>(</color><color=#f8f8f2>bytes</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>binding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToObject</color><color=#f8f8f2>(</color><color=#f8f8f2>tuple</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Carries out the two step de-serialization from hex string into a byte buffer and subsequently</color>
<color=#75715e>   * into its object representation.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the object representation</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f92672><</color><color=#f8f8f2>T</color><color=#f92672>></color> <color=#f8f8f2>T</color> <color=#a6e22e>hexToObject</color><color=#f8f8f2>(</color><color=#f8f8f2>TupleBinding</color><color=#f92672><</color><color=#f8f8f2>T</color><color=#f92672>></color> <color=#f8f8f2>binding</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>hex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>(</color><color=#f8f8f2>hex</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>2</color><color=#f8f8f2>)</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>hex</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>value</color> <color=#f92672>=</color> <color=#f8f8f2>Character</color><color=#f8f8f2>.</color><color=#a6e22e>digit</color><color=#f8f8f2>(</color><color=#f8f8f2>hex</color><color=#f8f8f2>.</color><color=#a6e22e>charAt</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color> <color=#ae81ff>16</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>value</color> <color=#f92672>|=</color> <color=#f8f8f2>Character</color><color=#f8f8f2>.</color><color=#a6e22e>digit</color><color=#f8f8f2>(</color><color=#f8f8f2>hex</color><color=#f8f8f2>.</color><color=#a6e22e>charAt</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>),</color> <color=#ae81ff>16</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>4</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>buffer</color><color=#f92672>[</color><color=#f8f8f2>i</color> <color=#f92672>>></color> <color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>value</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>TupleInput</color> <color=#f8f8f2>tuple</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TupleInput</color><color=#f8f8f2>(</color><color=#f8f8f2>buffer</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>binding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToObject</color><color=#f8f8f2>(</color><color=#f8f8f2>tuple</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * De-serializes an array of tokens into a Rep group object and its nodes. the token at <code></color>
<color=#75715e>   * start</code>represents the group object and each subsequent token represents a node in the</color>
<color=#75715e>   * group.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param tokens the array representing the group and its nodes</color>
<color=#75715e>   * @param start the position in the array at which to start the de-serialization.</color>
<color=#75715e>   * @return the de-serialized RepGroup</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>RepGroupImpl</color> <color=#a6e22e>deserializeHex</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color><color=#f92672>[]</color> <color=#f8f8f2>tokens</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>start</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>RepGroupDB</color><color=#f8f8f2>.</color><color=#a6e22e>GroupBinding</color> <color=#f8f8f2>groupBinding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RepGroupDB</color><color=#f8f8f2>.</color><color=#a6e22e>GroupBinding</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>RepGroupImpl</color> <color=#f8f8f2>group</color> <color=#f92672>=</color> <color=#f8f8f2>hexToObject</color><color=#f8f8f2>(</color><color=#f8f8f2>groupBinding</color><color=#f8f8f2>,</color> <color=#f8f8f2>tokens</color><color=#f92672>[</color><color=#f8f8f2>start</color><color=#f92672>++]</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f8f8f2>,</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>nodeMap</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f8f8f2>,</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>start</color> <color=#f92672><</color> <color=#f8f8f2>tokens</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#f8f8f2>hexDeserializeNode</color><color=#f8f8f2>(</color><color=#f8f8f2>tokens</color><color=#f92672>[</color><color=#f8f8f2>start</color><color=#f92672>++]</color><color=#f8f8f2>,</color> <color=#f8f8f2>group</color><color=#f8f8f2>.</color><color=#a6e22e>getFormatVersion</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>old</color> <color=#f92672>=</color> <color=#f8f8f2>nodeMap</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getNameIdPair</color><color=#f8f8f2>().</color><color=#a6e22e>getId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>n</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>old</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>group</color><color=#f8f8f2>.</color><color=#a6e22e>setNodes</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeMap</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>group</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Accessing nodes and groups of nodes</color>
<color=#75715e>   */</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the node IDs for all nodes that are currently members of the group and that act as</color>
<color=#75715e>   * proposers, acceptors, or distinguished learners. Returns IDs for all ELECTABLE and MONITOR</color>
<color=#75715e>   * nodes that are not removed, even if they are not acknowledged, but not for SECONDARY or</color>
<color=#75715e>   * EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#a6e22e>getAllElectionMemberIds</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#f8f8f2>ret</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>Integer</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>mi</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>isRemoved</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>hasTransientId</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns all nodes that are currently members of the group. Returns all ELECTABLE and MONITOR</color>
<color=#75715e>   * nodes that are acknowledged and not removed, and SECONDARY and EXTERNAL nodes. If the predicate</color>
<color=#75715e>   * is not null, only includes members that satisfy the predicate.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getAllMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>p</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>includeMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>p</color><color=#f8f8f2>,</color> <color=#f8f8f2>result</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds all nodes that are currently members of the group to the specified set. Adds all ELECTABLE</color>
<color=#75715e>   * and MONITOR nodes that are not removed, even if they are not acknowledged, and SECONDARY and</color>
<color=#75715e>   * EXTERNAL nodes. If the predicate is not null, only adds members that satisfy the predicate.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>includeAllMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>p</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><?</color> <color=#66d9ef>super</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>set</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>mi</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>isRemoved</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>((</color><color=#f8f8f2>p</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>p</color><color=#f8f8f2>.</color><color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>set</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Counts the number of nodes that are currently members of the group. Counts all ELECTABLE and</color>
<color=#75715e>   * MONITOR nodes that are not removed, even if they are not acknowledged, and SECONDARY and</color>
<color=#75715e>   * EXTERNAL nodes. If the predicate is not null, only counts members that satisfy the predicate.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>countAllMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>p</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>count</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>mi</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>isRemoved</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>((</color><color=#f8f8f2>p</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>p</color><color=#f8f8f2>.</color><color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>count</color><color=#f92672>++</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>count</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds nodes that are currently members of the group to the specified set. Adds ELECTABLE and</color>
<color=#75715e>   * MONITOR node that are not removed and are acknowledged, and SECONDARY and EXTERNAL nodes. If</color>
<color=#75715e>   * the predicate is not null, only adds members that satisfy the predicate.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>includeMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Predicate</color> <color=#f8f8f2>p</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><?</color> <color=#66d9ef>super</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>set</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>isRemoved</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>isQuorumAck</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>((</color><color=#f8f8f2>p</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>p</color><color=#f8f8f2>.</color><color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#f8f8f2>n</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>set</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>n</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Gets the node that is currently a member of the group that has the given socket address.</color>
<color=#75715e>   * Returns ELECTABLE and MONITOR nodes that are not removed, even if it is not acknowledged, and</color>
<color=#75715e>   * SECONDARY and EXTERNAL nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the desired node, or null if there is no such node, including if it was removed</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>RepNodeImpl</color> <color=#a6e22e>getMember</color><color=#f8f8f2>(</color><color=#f8f8f2>InetSocketAddress</color> <color=#f8f8f2>socket</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>socket</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getSocketAddress</color><color=#f8f8f2>())</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>isRemoved</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns nodes that are removed from the group. Returns ELECTABLE and MONITOR nodes that are</color>
<color=#75715e>   * removed and are acknowledged, but not SECONDARY or EXTERNAL nodes, which are not remembered</color>
<color=#75715e>   * when they are removed.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getRemovedNodes</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>ret</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>mi</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>isRemoved</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>isQuorumAck</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>ret</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>ret</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** A predicate for specifying which replication nodes to include. */</color>
  <color=#66d9ef>abstract</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>Predicate</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>abstract</color> <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns all electable nodes that are currently members of the group. Returns all ELECTABLE</color>
<color=#75715e>   * nodes that are not removed, even if they are not acknowledged, but not MONITOR, SECONDARY, or</color>
<color=#75715e>   * EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getAllElectableMembers</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getAllMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>ELECTABLE_PREDICATE</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns electable nodes that are currently members of the group. Returns ELECTABLE nodes that</color>
<color=#75715e>   * are not removed and are acknowledged, but not MONITOR, SECONDARY, or EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getElectableMembers</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>includeElectableMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds the electable nodes that are currently members of the group to the specified set. Adds</color>
<color=#75715e>   * ELECTABLE nodes that are not removed and are acknowledged, but not MONITOR, SECONDARY, or</color>
<color=#75715e>   * EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>includeElectableMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><?</color> <color=#66d9ef>super</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>set</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>includeAllMembers</color><color=#f8f8f2>(</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
          <color=#a6e22e>@Override</color>
          <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isElectable</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>isQuorumAck</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>},</color>
        <color=#f8f8f2>set</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the nodes that are currently members of the group that store replication data. Returns</color>
<color=#75715e>   * ELECTABLE nodes that are not removed and are acknowledged, and SECONDARY nodes, but not MONITOR</color>
<color=#75715e>   * or EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getDataMembers</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>includeDataMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds the nodes that are currently members of the group that store replication data to the</color>
<color=#75715e>   * specified set. Adds ELECTABLE nodes that are not removed and are acknowledged, and SECONDARY</color>
<color=#75715e>   * nodes, but not MONITOR or EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>includeDataMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><?</color> <color=#66d9ef>super</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>set</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>includeAllMembers</color><color=#f8f8f2>(</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
          <color=#a6e22e>@Override</color>
          <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isDataNode</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>isQuorumAck</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>},</color>
        <color=#f8f8f2>set</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the monitor nodes that are currently members of the group. Returns MONITOR nodes that</color>
<color=#75715e>   * are not removed and are acknowledged, but not ELECTABLE, SECONDARY, or EXTERNAL nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the set of monitor nodes</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getMonitorMembers</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>includeMonitorMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds the monitor nodes that are currently members of the group to the specified set. Adds</color>
<color=#75715e>   * MONITOR nodes that are not removed and are acknowledged, but not ELECTABLE, SECONDARY, or</color>
<color=#75715e>   * EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>includeMonitorMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><?</color> <color=#66d9ef>super</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>set</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>includeMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>MONITOR_PREDICATE</color><color=#f8f8f2>,</color> <color=#f8f8f2>set</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns all the nodes that are currently members of the group that act as distinguished</color>
<color=#75715e>   * learners to receive election results. Returns all ELECTABLE and MONITOR that are not removed,</color>
<color=#75715e>   * even if they are not acknowledged, but not SECONDARY or EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getAllLearnerMembers</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>includeAllMembers</color><color=#f8f8f2>(</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
          <color=#a6e22e>@Override</color>
          <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isElectable</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isMonitor</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>},</color>
        <color=#f8f8f2>result</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the secondary nodes that are currently members of the group.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Returns SECONDARY nodes, but not ELECTABLE, MONITOR, or EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getSecondaryMembers</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>includeSecondaryMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the external nodes that are currently members of the group.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Returns EXTERNAL nodes, but not ELECTABLE, MONITOR, or SECONDARY nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getExternalMembers</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>includeExternalMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds the secondary nodes that are currently members of the group to the specified set. Adds</color>
<color=#75715e>   * SECONDARY nodes, but not ELECTABLE, MONITOR, or EXTERNAL nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>includeSecondaryMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><?</color> <color=#66d9ef>super</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>set</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>includeAllMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>SECONDARY_PREDICATE</color><color=#f8f8f2>,</color> <color=#f8f8f2>set</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds the external nodes. Adds EXTERNAL nodes, but not ELECTABLE, MONITOR, or SECONDARY nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>includeExternalMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><?</color> <color=#66d9ef>super</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>set</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>includeAllMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>EXTERNAL_PREDICATE</color><color=#f8f8f2>,</color> <color=#f8f8f2>set</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns the arbiter nodes that are currently members of the group. Returns ARBITER nodes. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#a6e22e>getArbiterMembers</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>includeArbiterMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds the arbiter nodes that are currently members of the group to the specified set. Adds</color>
<color=#75715e>   * ARBITER nodes.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>includeArbiterMembers</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><?</color> <color=#66d9ef>super</color> <color=#f8f8f2>RepNodeImpl</color><color=#f92672>></color> <color=#f8f8f2>set</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>includeMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>ARBITER_PREDICATE</color><color=#f8f8f2>,</color> <color=#f8f8f2>set</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the socket addresses for all nodes that are currently members of the group. Returns</color>
<color=#75715e>   * addresses for all ELECTABLE and MONITOR nodes that are not removed, even if they are not</color>
<color=#75715e>   * acknowledged, and for all nodes with transient id. If the predicate is not null, only returns</color>
<color=#75715e>   * addresses for members that satisfy the predicate. ARBITER nodes are also ELECTABLE and will be</color>
<color=#75715e>   * part of the returned set.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>InetSocketAddress</color><color=#f92672>></color> <color=#a6e22e>getAllMemberSockets</color><color=#f8f8f2>(</color><color=#f8f8f2>Predicate</color> <color=#f8f8f2>p</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>InetSocketAddress</color><color=#f92672>></color> <color=#f8f8f2>sockets</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>InetSocketAddress</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>mi</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>((((</color><color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isElectable</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isMonitor</color><color=#f8f8f2>())</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>isRemoved</color><color=#f8f8f2>())</color>
                <color=#f92672>||</color> <color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>hasTransientId</color><color=#f8f8f2>())</color>
            <color=#f92672>&&</color> <color=#f8f8f2>((</color><color=#f8f8f2>p</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>p</color><color=#f8f8f2>.</color><color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>sockets</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>mi</color><color=#f8f8f2>.</color><color=#a6e22e>getSocketAddress</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>sockets</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return the socket addresses for all nodes that are currently members of the group and act as</color>
<color=#75715e>   * distinguished learners to receive election results. Returns addresses for all ELECTABLE and</color>
<color=#75715e>   * MONITOR nodes that are not removed, even if they are not acknowledged, but not for SECONDARY or</color>
<color=#75715e>   * EXTERNAL nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return set of learner socket addresses</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>InetSocketAddress</color><color=#f92672>></color> <color=#a6e22e>getAllLearnerSockets</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * TODO: Consider including secondary nodes in this list.</color>
<color=#75715e>     * That change would increase the chance that SECONDARY nodes have</color>
<color=#75715e>     * up-to-date information about the master, but would need to be</color>
<color=#75715e>     * paired with a change to only wait for delivery of notifications to</color>
<color=#75715e>     * ELECTABLE nodes, to avoid adding sensitivity to potentially longer</color>
<color=#75715e>     * network delays in communicating with secondary nodes.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getAllMemberSockets</color><color=#f8f8f2>(</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>Predicate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
          <color=#a6e22e>@Override</color>
          <color=#66d9ef>boolean</color> <color=#a6e22e>include</color><color=#f8f8f2>(</color><color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>n</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f92672>!</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isSecondary</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>n</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>().</color><color=#a6e22e>isExternal</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>});</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return the socket addresses for all nodes that are currently members of the group and act as</color>
<color=#75715e>   * helpers to supply election results. Returns addresses for all ELECTABLE and MONITOR nodes that</color>
<color=#75715e>   * are not removed, even if they are not acknowledged, and SECONDARY nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return set of helper socket addresses</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>InetSocketAddress</color><color=#f92672>></color> <color=#a6e22e>getAllHelperSockets</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getAllMemberSockets</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the socket addresses for all monitor nodes that are currently members of the group.</color>
<color=#75715e>   * Returns addresses for all MONITOR nodes that are not removed, even if they are not</color>
<color=#75715e>   * acknowledged, but not for ELECTABLE, SECONDARY, or EXTERNAL nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the set of Monitor socket addresses</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>InetSocketAddress</color><color=#f92672>></color> <color=#a6e22e>getAllMonitorSockets</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getAllMemberSockets</color><color=#f8f8f2>(</color><color=#f8f8f2>MONITOR_PREDICATE</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the socket addresses for all nodes that are currently members of the group and act as</color>
<color=#75715e>   * acceptors for elections. Returns addresses for all ELECTABLE nodes that are not removed, even</color>
<color=#75715e>   * if they are not acknowledged, but not for MONITOR, SECONDARY, or EXTERNAL nodes, which do not</color>
<color=#75715e>   * act as acceptors.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the set of acceptor socket addresses</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>InetSocketAddress</color><color=#f92672>></color> <color=#a6e22e>getAllAcceptorSockets</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getAllMemberSockets</color><color=#f8f8f2>(</color><color=#f8f8f2>ELECTABLE_PREDICATE</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the node with the specified ID that is currently a member of the group, throwing an</color>
<color=#75715e>   * exception if the node is found but is no longer a member. Returns ELECTABLE and MONITOR nodes</color>
<color=#75715e>   * that are not removed, even if they are not acknowledged, and SECONDARY and EXTERNAL nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param nodeId the node ID</color>
<color=#75715e>   * @return the member or null</color>
<color=#75715e>   * @throws EnvironmentFailureException if the node is no longer a member</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>RepNodeImpl</color> <color=#a6e22e>getMember</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color> <color=#f92672>=</color> <color=#f8f8f2>getNode</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeId</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>isRemoved</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#e6db74>"No longer a member:"</color> <color=#f92672>+</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>node</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the node with the specified name that is currently a member of the group, throwing an</color>
<color=#75715e>   * exception if the node is found but is no longer a member. Returns ELECTABLE and MONITOR nodes</color>
<color=#75715e>   * that are not removed, even if they are not acknowledged, and SECONDARY and EXTERNAL nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param name the node name</color>
<color=#75715e>   * @return the member or null</color>
<color=#75715e>   * @throws MemberNotFoundException if the node is no longer a member</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>RepNodeImpl</color> <color=#a6e22e>getMember</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>name</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MemberNotFoundException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color> <color=#f92672>=</color> <color=#f8f8f2>getNode</color><color=#f8f8f2>(</color><color=#f8f8f2>name</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>.</color><color=#a6e22e>isRemoved</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>MemberNotFoundException</color><color=#f8f8f2>(</color><color=#e6db74>"Node no longer a member:"</color> <color=#f92672>+</color> <color=#f8f8f2>name</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>node</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the node with the specified ID, regardless of its membership state. Returns all</color>
<color=#75715e>   * ELECTABLE and MONITOR nodes, even if they are removed or are not acknowledged, and SECONDARY</color>
<color=#75715e>   * and EXTERNAL nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the node or null</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>RepNodeImpl</color> <color=#a6e22e>getNode</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the node with the specified name, regardless of its membership state. Returns all</color>
<color=#75715e>   * ELECTABLE and MONITOR nodes, even if they are removed or are not acknowledged, and SECONDARY</color>
<color=#75715e>   * and EXTERNAL nodes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the node or null</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>RepNodeImpl</color> <color=#a6e22e>getNode</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>name</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>nodesByName</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>name</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the number of all electable nodes that are currently members of the group. Includes all</color>
<color=#75715e>   * ELECTABLE nodes that are not removed, even if they are not acknowledged, but not MONITOR,</color>
<color=#75715e>   * SECONDARY, or EXTERNAL nodes. Note that even unACKed nodes are considered part of the group for</color>
<color=#75715e>   * group size/durability considerations.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the size of the group for durability considerations</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getElectableGroupSize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>countAllMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>ELECTABLE_PREDICATE</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the number of all electable nodes that are currently members of the group. Includes all</color>
<color=#75715e>   * ELECTABLE nodes that are not removed, even if they are not acknowledged, but not MONITOR,</color>
<color=#75715e>   * ARBITER, SECONDARY, or EXTERNAL nodes. Note that even unACKed nodes are considered part of the</color>
<color=#75715e>   * group for group size/durability considerations.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the size of the group for durability considerations</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>getAckGroupSize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>countAllMembers</color><color=#f8f8f2>(</color><color=#f8f8f2>ACK_PREDICATE</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* Miscellaneous */</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the name of the group.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the name of the group.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>getName</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>groupName</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * An internal exception indicating that two nodes have conflicting</color>
<color=#75715e>   * configurations. For example, they both use the same hostname and port.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"serial"</color><color=#f8f8f2>)</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>NodeConflictException</color> <color=#66d9ef>extends</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>public</color> <color=#a6e22e>NodeConflictException</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>message</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>message</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Return information to the user, format nicely for ease of reading. */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>toString</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"Group info ["</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>groupName</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"] "</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>getUUID</color><color=#f8f8f2>())</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\n Format version: "</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>getFormatVersion</color><color=#f8f8f2>())</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\n Change version: "</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>getChangeVersion</color><color=#f8f8f2>())</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\n Max persist rep node ID: "</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>getNodeIdSequence</color><color=#f8f8f2>())</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\n Min JE version: "</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>minJEVersion</color><color=#f8f8f2>)</color>
        <color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\n"</color><color=#f8f8f2>);</color>

    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodesById</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>RepNodeImpl</color> <color=#f8f8f2>node</color> <color=#f8f8f2>:</color> <color=#f8f8f2>nodesById</color><color=#f8f8f2>.</color><color=#a6e22e>values</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" "</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>node</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>