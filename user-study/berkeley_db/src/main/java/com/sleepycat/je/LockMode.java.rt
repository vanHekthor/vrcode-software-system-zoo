<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * Record lock modes for read operations. Lock mode parameters may be specified for all operations</color>
<color=#75715e> * that retrieve data.</color>
<color=#75715e> *</color>
<color=#75715e> * <p><strong>Locking Rules</strong></color>
<color=#75715e> *</color>
<color=#75715e> * <p>Together with {@link CursorConfig}, {@link TransactionConfig} and {@link EnvironmentConfig}</color>
<color=#75715e> * settings, lock mode parameters determine how records are locked during read operations. Record</color>
<color=#75715e> * locking is used to enforce the isolation modes that are configured. Record locking is summarized</color>
<color=#75715e> * below for read and write operations. For more information on isolation levels and transactions,</color>
<color=#75715e> * see <a href="{@docRoot}/../TransactionGettingStarted/index.html" target="_top">Writing</color>
<color=#75715e> * Transactional Applications</a>.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>With one exception, a record lock is always acquired when a record is read or written, and a</color>
<color=#75715e> * cursor will always hold the lock as long as it is positioned on the record. The exception is when</color>
<color=#75715e> * {@link #READ_UNCOMMITTED} is specified, which allows a record to be read without any locking.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Both read (shared) and write (exclusive) locks are used. Read locks are normally acquired on</color>
<color=#75715e> * read ({@code get} method) operations and write locks on write ({@code put} method) operations.</color>
<color=#75715e> * The only exception is that a write lock will be acquired on a read operation if {@link #RMW} is</color>
<color=#75715e> * specified.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Because read locks are shared, multiple accessors may read the same record. Because write</color>
<color=#75715e> * locks are exclusive, if a record is written by one accessor it may not be read or written by</color>
<color=#75715e> * another accessor. An accessor is either a transaction or a thread (for non-transactional</color>
<color=#75715e> * operations).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Whether additional locking is performed and how locks are released depend on whether the</color>
<color=#75715e> * operation is transactional and other configuration settings.</color>
<color=#75715e> *</color>
<color=#75715e> * <p><strong>Transactional Locking</strong></color>
<color=#75715e> *</color>
<color=#75715e> * <p>Transactional operations include all write operations for a transactional database, and read</color>
<color=#75715e> * operations when a non-null {@link Transaction} parameter is passed. When a null transaction</color>
<color=#75715e> * parameter is passed for a write operation for a transactional database, an auto-commit</color>
<color=#75715e> * transaction is automatically used.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>With transactions, read and write locks are normally held until the end of the transaction</color>
<color=#75715e> * (commit or abort). Write locks are always held until the end of the transaction. However, if</color>
<color=#75715e> * {@link #READ_COMMITTED} is configured, then read locks for cursor operations are only held during</color>
<color=#75715e> * the operation and while the cursor is positioned on the record. The read lock is released when</color>
<color=#75715e> * the cursor is moved to a different record or closed. When {@link #READ_COMMITTED} is used for a</color>
<color=#75715e> * database (non-cursor) operation, the read lock is released before the method returns.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When neither {@link #READ_UNCOMMITTED} nor {@link #READ_COMMITTED} is specified, read and</color>
<color=#75715e> * write locking as described above provide Repeatable Read isolation, which is the default</color>
<color=#75715e> * transactional isolation level. If Serializable isolation is configured, additional "next key"</color>
<color=#75715e> * locking is performed to prevent "phantoms" -- records that are not visible at one point in a</color>
<color=#75715e> * transaction but that become visible at a later point after being inserted by another transaction.</color>
<color=#75715e> * Serializable isolation is configured via {@link TransactionConfig#setSerializableIsolation} or</color>
<color=#75715e> * {@link EnvironmentConfig#setTxnSerializableIsolation}.</color>
<color=#75715e> *</color>
<color=#75715e> * <p><strong>Non-Transactional Locking</strong></color>
<color=#75715e> *</color>
<color=#75715e> * <p>Non-transactional operations include all operations for a non-transactional database</color>
<color=#75715e> * (including a Deferred Write database), and read operations for a transactional database when a</color>
<color=#75715e> * null {@link Transaction} parameter is passed.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>For non-transactional operations, both read and write locks are only held while a cursor is</color>
<color=#75715e> * positioned on the record, and are released when the cursor is moved to a different record or</color>
<color=#75715e> * closed. For database (non-cursor) operations, the read or write lock is released before the</color>
<color=#75715e> * method returns.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>This behavior is similar to {@link #READ_COMMITTED}, except that both read and write locks are</color>
<color=#75715e> * released. Configuring {@link #READ_COMMITTED} for a non-transactional database cursor has no</color>
<color=#75715e> * effect.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Because the current thread is the accessor (locker) for non-transactional operations, a single</color>
<color=#75715e> * thread may have multiple cursors open without locking conflicts. Two non-transactional cursors in</color>
<color=#75715e> * the same thread may access the same record via write or read operations without conflicts, and</color>
<color=#75715e> * the changes make by one cursor will be visible to the other cursor.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>However, a non-transactional operation will conflict with a transactional operation for the</color>
<color=#75715e> * same record even when performed in the same thread. When using a transaction in a particular</color>
<color=#75715e> * thread for a particular database, to avoid conflicts you should use that transaction for all</color>
<color=#75715e> * access to that database in that thread. In other words, to avoid conflicts always pass the</color>
<color=#75715e> * transaction parameter, not null, for all operations. If you don't wish to hold the read lock for</color>
<color=#75715e> * the duration of the transaction, specify {@link #READ_COMMITTED}.</color>
<color=#75715e> *</color>
<color=#75715e> * <p><strong>Read Uncommitted (Dirty-Read)</strong></string></color>
<color=#75715e> *</color>
<color=#75715e> * <p>When {@link #READ_UNCOMMITTED} is configured, no locking is performed by a read operation.</color>
<color=#75715e> * {@code READ_UNCOMMITTED} does not apply to write operations.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>{@code READ_UNCOMMITTED} is sometimes called dirty-read because records are visible to the</color>
<color=#75715e> * caller in their current state in the Btree at the time of the read, even when that state is due</color>
<color=#75715e> * to operations performed using a transaction that has not yet committed. In addition, because no</color>
<color=#75715e> * lock is acquired by the dirty read operation, the record's state may change at any time, even</color>
<color=#75715e> * while a cursor used to do the dirty-read is still positioned on the record.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>To illustrate this, let's say a record is read with dirty-read ({@code READ_UNCOMMITTED}) by</color>
<color=#75715e> * calling {@link Cursor#getNext Cursor.getNext} with a cursor C, and changes to the record are also</color>
<color=#75715e> * being made in another thread using transaction T. When a locking (non-dirty-read) call to {@link</color>
<color=#75715e> * Cursor#getCurrent Cursor.getCurrent} is subsequently made to read the same record again with C at</color>
<color=#75715e> * the current position, a result may be returned that is different than the result returned by the</color>
<color=#75715e> * earlier call to {@code getNext}. For example:</color>
<color=#75715e> *</color>
<color=#75715e> * <ul></color>
<color=#75715e> *   <li>If the record is updated by T after the dirty-read {@code getNext} call, and T is</color>
<color=#75715e> *       committed, a subsequent call to {@code getCurrent} will return the data updated by T.</color>
<color=#75715e> *   <li>If the record is updated by T before the dirty-read {@code getNext} call, the {@code</color>
<color=#75715e> *       getNext} will returned the data updated by T. But if call, the {@code getNext} will return</color>
<color=#75715e> *       the data updated by T. But if T is then aborted, a subsequent call to {@code getCurrent}</color>
<color=#75715e> *       will return the version of the data before it was updated by T.</color>
<color=#75715e> *   <li>If the record was inserted by T before the dirty-read {@code getNext} call, the {@code</color>
<color=#75715e> *       getNext} call will return the inserted record. But if T is aborted, a subsequent call to</color>
<color=#75715e> *       {@code getCurrent} will return {@link OperationStatus#KEYEMPTY}.</color>
<color=#75715e> *   <li>If the record is deleted by T after the dirty-read {@code getNext} call, and T is</color>
<color=#75715e> *       committed, a subsequent call to {@code getCurrent} will return {@link</color>
<color=#75715e> *       OperationStatus#KEYEMPTY}.</color>
<color=#75715e> * </ul></color>
<color=#75715e> *</color>
<color=#75715e> * <p>Note that deleted records are handled specially in JE. Deleted records remain in the Btree</color>
<color=#75715e> * until after the deleting transaction is committed, and they are removed from the Btree</color>
<color=#75715e> * asynchronously (not immediately at commit time). When using {@code #READ_UNCOMMITTED}, any record</color>
<color=#75715e> * encountered in the Btree that was previously deleted, whether or not the deleting transaction has</color>
<color=#75715e> * been committed, will be ignored (skipped over) by the read operation. Of course, if the deleting</color>
<color=#75715e> * transaction is aborted, the record will no longer be deleted. If the application is scanning</color>
<color=#75715e> * records, for example, this means that such records may be skipped by the scan. If this behavior</color>
<color=#75715e> * is not desirable, {@link #READ_UNCOMMITTED_ALL} may be used instead. This mode ensures that</color>
<color=#75715e> * records deleted by a transaction that is later aborted will not be skipped by a read operation.</color>
<color=#75715e> * This is accomplished in two different ways depending on the type of database and whether the</color>
<color=#75715e> * record's data is requested by the operation.</color>
<color=#75715e> *</color>
<color=#75715e> * <ol></color>
<color=#75715e> *   <li>If the DB is configured for duplicates or the record's data is not requested, then a record</color>
<color=#75715e> *       that has been deleted by an open transaction is returned by the read operation.</color>
<color=#75715e> *   <li>If the DB is not configured for duplicates and the record's data is requested, then the</color>
<color=#75715e> *       read operation must wait for the deleting transaction to close (commit or abort). After the</color>
<color=#75715e> *       transaction is closed, the record will be returned if it is actually not deleted and</color>
<color=#75715e> *       otherwise will be skipped.</color>
<color=#75715e> * </ol></color>
<color=#75715e> *</color>
<color=#75715e> * <p>By "record data" we mean both the {@code data} parameter for a regular or primary DB, and the</color>
<color=#75715e> * {@code pKey} parameter for a secondary DB. By "record data requested" we mean that all or part of</color>
<color=#75715e> * the {@code DatabaseEntry} will be returned by the read operation. Unless explicitly <em>not</em></color>
<color=#75715e> * requested, the complete {@code DatabaseEntry} is returned. See <a</color>
<color=#75715e> * href="Cursor.html#partialEntry">Using Partial DatabaseEntry Parameters</a> for more information.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Because of this difference in behavior, although {@code #READ_UNCOMMITTED} is fully</color>
<color=#75715e> * non-blocking, {@code #READ_UNCOMMITTED_ALL} is not (under the conditions described). As a result,</color>
<color=#75715e> * when using {@code #READ_UNCOMMITTED_ALL} under these conditions, a {@link LockConflictException}</color>
<color=#75715e> * will be thrown when blocking results in a deadlock or lock timeout.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>To summarize, callers that use {@code READ_UNCOMMITTED} or {@code #READ_UNCOMMITTED_ALL}</color>
<color=#75715e> * should be prepared for the following behaviors.</color>
<color=#75715e> *</color>
<color=#75715e> * <ul></color>
<color=#75715e> *   <li>After a successful dirty-read operation, because no lock is acquired the record can be</color>
<color=#75715e> *       changed by another transaction, even when the cursor used to perform the dirty-read</color>
<color=#75715e> *       operation is still positioned on the record.</color>
<color=#75715e> *   <li>After a successful dirty-read operation using a cursor C, say that another transaction T</color>
<color=#75715e> *       deletes the record, and T is committed. In this case, {@link OperationStatus#KEYEMPTY} will</color>
<color=#75715e> *       be returned by the following methods if they are called while C is still positioned on the</color>
<color=#75715e> *       deleted record: {@link Cursor#getCurrent Cursor.getCurrent}, {@link Cursor#putCurrent</color>
<color=#75715e> *       Cursor.putCurrent} and {@link Cursor#delete Cursor.delete}.</color>
<color=#75715e> *   <li>When using {@code READ_UNCOMMITTED}, deleted records will be skipped even when the deleting</color>
<color=#75715e> *       transaction is still open. No blocking will occur and {@link LockConflictException} is</color>
<color=#75715e> *       never thrown when using this mode.</color>
<color=#75715e> *   <li>When using {@code #READ_UNCOMMITTED_ALL}, deleted records will not be skipped even when the</color>
<color=#75715e> *       deleting transaction is open. If the DB is a duplicates DB or the record's data is not</color>
<color=#75715e> *       requested, the deleted record will be returned. If the DB is not a duplicates DB and the</color>
<color=#75715e> *       record's data is requested, blocking will occur until the deleting transaction is closed.</color>
<color=#75715e> *       In the latter case, {@link LockConflictException} will be thrown when this blocking results</color>
<color=#75715e> *       in a deadlock or a lock timeout.</color>
<color=#75715e> * </ul></color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>enum</color> <color=#f8f8f2>LockMode</color> <color=#f8f8f2>{</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Uses the default lock mode and is equivalent to passing {@code null} for the lock mode</color>
<color=#75715e>   * parameter.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The default lock mode is {@link #READ_UNCOMMITTED} when this lock mode is configured via</color>
<color=#75715e>   * {@link CursorConfig#setReadUncommitted} or {@link TransactionConfig#setReadUncommitted}, or</color>
<color=#75715e>   * when using a {@link DiskOrderedCursor}. The Read Uncommitted mode overrides any other</color>
<color=#75715e>   * configuration settings.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Otherwise, the default lock mode is {@link #READ_COMMITTED} when this lock mode is</color>
<color=#75715e>   * configured via {@link CursorConfig#setReadCommitted} or {@link</color>
<color=#75715e>   * TransactionConfig#setReadCommitted}. The Read Committed mode overrides other configuration</color>
<color=#75715e>   * settings except for {@link #READ_UNCOMMITTED}.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Otherwise, the default lock mode is to acquire read locks and release them according to the</color>
<color=#75715e>   * {@link LockMode default locking rules} for transactional and non-transactional operations.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>DEFAULT</color><color=#f8f8f2>,</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Reads modified but not yet committed data.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The Read Uncommitted mode is used if this lock mode is explicitly passed for the lock mode</color>
<color=#75715e>   * parameter, or if null or {@link #DEFAULT} is passed and Read Uncommitted is the default -- see</color>
<color=#75715e>   * {@link #DEFAULT} for details.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Unlike {@link #READ_UNCOMMITTED_ALL}, deleted records will be skipped even when the deleting</color>
<color=#75715e>   * transaction is still open. No blocking will occur and {@link LockConflictException} is never</color>
<color=#75715e>   * thrown when using this mode.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>See the {@link LockMode locking rules} for information on how Read Uncommitted impacts</color>
<color=#75715e>   * transactional and non-transactional locking.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>READ_UNCOMMITTED</color><color=#f8f8f2>,</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Reads modified but not yet committed data, ensuring that records are not skipped due to</color>
<color=#75715e>   * transaction aborts.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The Read Uncommitted mode is used only when this lock mode is explicitly passed for the lock</color>
<color=#75715e>   * mode parameter.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Unlike {@link #READ_UNCOMMITTED}, deleted records will not be skipped even when the deleting</color>
<color=#75715e>   * transaction is open. If the DB is a duplicates DB or the record's data is not requested, the</color>
<color=#75715e>   * deleted record will be returned. If the DB is not a duplicates DB and the record's data is</color>
<color=#75715e>   * requested, blocking will occur until the deleting transaction is closed. In the latter case,</color>
<color=#75715e>   * {@link LockConflictException} will be thrown when this blocking results in a deadlock or a lock</color>
<color=#75715e>   * timeout.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>See the {@link LockMode locking rules} for information on how Read Uncommitted impacts</color>
<color=#75715e>   * transactional and non-transactional locking.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>READ_UNCOMMITTED_ALL</color><color=#f8f8f2>,</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Read committed isolation provides for cursor stability but not repeatable reads. Data items</color>
<color=#75715e>   * which have been previously read by this transaction may be deleted or modified by other</color>
<color=#75715e>   * transactions before the cursor is closed or the transaction completes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Note that this LockMode may only be passed to {@link Database} get methods, not to {@link</color>
<color=#75715e>   * Cursor} methods. To configure a cursor for Read Committed isolation, use {@link</color>
<color=#75715e>   * CursorConfig#setReadCommitted}.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>See the {@link LockMode locking rules} for information on how Read Committed impacts</color>
<color=#75715e>   * transactional and non-transactional locking.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @see <a href="EnvironmentStats.html#cacheUnexpectedSizes">Cache Statistics: Unexpected</color>
<color=#75715e>   *     Sizes</a></color>
<color=#75715e>   */</color>
  <color=#f8f8f2>READ_COMMITTED</color><color=#f8f8f2>,</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Acquire write locks instead of read locks when doing the retrieval.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Because it causes a write lock to be acquired, specifying this lock mode as a {@link Cursor}</color>
<color=#75715e>   * or {@link Database} {@code get} (read) method parameter will override the Read Committed or</color>
<color=#75715e>   * Read Uncommitted isolation mode that is configured using {@link CursorConfig} or {@link</color>
<color=#75715e>   * TransactionConfig}. The write lock will acquired and held until the end of the transaction. For</color>
<color=#75715e>   * non-transactional use, the write lock will be released when the cursor is moved to a new</color>
<color=#75715e>   * position or closed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Setting this flag can eliminate deadlock during a read-modify-write cycle by acquiring the</color>
<color=#75715e>   * write lock during the read part of the cycle so that another thread of control acquiring a read</color>
<color=#75715e>   * lock for the same item, in its own read-modify-write cycle, will not result in deadlock.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>RMW</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ReadOptions</color> <color=#f8f8f2>readOptions</color><color=#f8f8f2>;</color>

  <color=#f8f8f2>LockMode</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>readOptions</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ReadOptions</color><color=#f8f8f2>().</color><color=#a6e22e>setLockMode</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns a ReadOptions with this LockMode property, and default values for all other properties.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>WARNING: Do not modify the returned object, since it is a singleton.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @since 7.0</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>ReadOptions</color> <color=#a6e22e>toReadOptions</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>readOptions</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>String</color> <color=#a6e22e>toString</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#e6db74>"LockMode."</color> <color=#f92672>+</color> <color=#f8f8f2>name</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>