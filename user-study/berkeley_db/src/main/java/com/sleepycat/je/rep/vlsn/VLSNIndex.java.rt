<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.rep.vlsn</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.bind.tuple.LongBinding</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.FileProtector.ProtectedFileSet</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DatabaseImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DbTree</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DbType</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogEntryType</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogItem</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.recovery.RecoveryInfo</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.impl.RepParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.impl.node.NameIdPair</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.vlsn.VLSNRange.VLSNRangeBinding</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.txn.BasicLocker</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.txn.Locker</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.txn.Txn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.*</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.io.PrintStream</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.ArrayList</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.HashMap</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Map</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.CountDownLatch</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.TimeUnit</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.atomic.AtomicLong</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Level</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Logger</color><color=#f8f8f2>;</color>

<color=#f92672>import static</color> <color=#f8f8f2>com.sleepycat.je.utilint.VLSN.NULL_VLSN</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * A VLSN (Virtual LSN) is used to identify every log entry shared between members of the</color>
<color=#75715e> * replication group. Since a JE log is identified by LSNs, we must have a way to map VLSN->LSNs in</color>
<color=#75715e> * order to fetch a replicated log record from the local log, using the VLSN. The VLSNIndex</color>
<color=#75715e> * implements those mappings. The VLSNIndex has these responsibilities:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Generating new VLSNs. Only masters need to generate VLSNs, but any node may have the potential</color>
<color=#75715e> * to be a master. The VLSN sequence must ascend over time and across recoveries, so the VSLN id</color>
<color=#75715e> * must be preserved much like the database, node and txn ids. Maintaining the VLSN range. Although</color>
<color=#75715e> * each node needs to receive and store each log entry from the replication stream, over time the</color>
<color=#75715e> * part of the stream that is stored can be reduced, either by log cleaning, or by syncups which can</color>
<color=#75715e> * truncate the replication stream. A node always holds a contiguous portion of the replication</color>
<color=#75715e> * stream. The VLSN range identifies that portion by having the start and end VLSNs, as well as key</color>
<color=#75715e> * landmarks such as the lastSync-able log entry and the last commit log entry. VLSN range</color>
<color=#75715e> * information is used by elections and syncup. Gatekeeper for waiting for the most recently logged</color>
<color=#75715e> * entries. Feeders block upon the VLSNIndex when they are trying to fetch the most recently logged</color>
<color=#75715e> * entries. These recent log entries are held in a two level cache within the VLSNIndex. A call to</color>
<color=#75715e> * VLSNIndex.waitForLsn() goes through this sequence: 1) check the log item stored in the vlsn wait</color>
<color=#75715e> * latch, if the call did wait. 2) check the log item cache If both fail, the FeederReader will</color>
<color=#75715e> * fetch the required log entry from log buffers or disk Providing the LSN mapping for a log record</color>
<color=#75715e> * identified by its VLSN. The Feeders and the syncup protocol both need to retrieve log records by</color>
<color=#75715e> * VLSN. To do that, we need an LSN mapping.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Mappings are added to VLSNIndex when replicated log entries are written into the local log.</color>
<color=#75715e> * Although all mappings are registered, the VLSNIndex does not keep every one, in order to save on</color>
<color=#75715e> * disk and in-memory storage. Only a sparse set is kept. When searching for a log entry by VLSN,</color>
<color=#75715e> * the caller uses the closest available mapping and then scans the log looking for that entry.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The VLSNIndex relies on the assumption that VLSN tagged log entries are ordered and contiguous</color>
<color=#75715e> * in the log. That is, the LSN for VLSN 1 is < the LSN for VLSN 2 < LSN for VLSN 3, and there is</color>
<color=#75715e> * never a gap in the VLSNs. However, at node syncup, the replication stream may need to be</color>
<color=#75715e> * truncated when rolling back a non-committed log entry. We can't literally truncate the log files</color>
<color=#75715e> * because the JE logs contain intermingled transactional and non transactional information.</color>
<color=#75715e> * Instead, the truncation is done both logically by amending the VLSNIndex, and physically by</color>
<color=#75715e> * overmarking those entries in the JE logs. Because of that, a physical dump of the log may show</color>
<color=#75715e> * some VLSN tagged entries as duplicate and/or out of order because they're abandoned log entries</color>
<color=#75715e> * that are not logically part of the replication stream any more For example, the log can look like</color>
<color=#75715e> * this: LSN 100, VLSN 1 LSN 200, VLSN 2 <- overmarked LSN 300, VLSN 3 <- overmarked --- syncup,</color>
<color=#75715e> * rollback to VLSN 1, restart at VLSN 2 LSN 400, VLSN 2 LSN 500, VLSN 3</color>
<color=#75715e> *</color>
<color=#75715e> * <p>VLSN->LSN mappings are created under the log write latch, which ensures that all VLSN tagged</color>
<color=#75715e> * log entries are ordered in the logical replication stream in the log. However, the mapping is</color>
<color=#75715e> * added to the VLSNIndex outside the log write latch, so the VLSNIndex database may have a</color>
<color=#75715e> * momentary gap. For example,</color>
<color=#75715e> *</color>
<color=#75715e> * <p>t0- thread 1 logs entry at VLSN=1, LSN=100, within log write latch t1- thread 2 logs entry at</color>
<color=#75715e> * VLSN=2, LSN=150, within log write latch t2- thread 3 logs entry at VLSN=3, LSN=200, within log</color>
<color=#75715e> * write latch t3- thread 1 calls VLSNIndex.put(VLSN=1/LSN=100) t4- thread 3 calls</color>
<color=#75715e> * VLSNIndex.put(VLSN=3/LSN=200) t5- thread 2 calls VLSNIndex.put(VLSN=2/LSN=150)</color>
<color=#75715e> *</color>
<color=#75715e> * <p>At t4, the VLSNIndex contains 1/100, 3/200, but not 2/150. However, we know that the VLSNIndex</color>
<color=#75715e> * always represents a contiguous range of VLSNs, so the fact that 2/150 is not yet is handled, and</color>
<color=#75715e> * is just like the case where the VLSNIndex optimized away the mapping in order to keep the index</color>
<color=#75715e> * sparse.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>We do guarantee that the start and end VLSNs in the range have mappings, in order to always be</color>
<color=#75715e> * able to provide a LTE and GTE mapping for all valid VLSNs. Because of that, if a VLSN comes out</color>
<color=#75715e> * of order, it does not update the range. Care must be taken when truncating the VLSNIndex from the</color>
<color=#75715e> * head or the tail to ensure that the guaranteed existence of the start and end range mapping</color>
<color=#75715e> * remains valid.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Cache and persistent storage:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The VLSN->LSN mappings in the range are grouped into instances of</color>
<color=#75715e> * com.sleepycat.je.util.VLSNBucket. Each bucket knows the first and last VLSN within its</color>
<color=#75715e> * mini-range. We observe these invariants - buckets are ordered by VLSN in the database and the</color>
<color=#75715e> * bucket cache, - only the last bucket is the target of updates at any time, - a single bucket</color>
<color=#75715e> * corresponds to a single file, but a single file may have multiple buckets covering it.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>While it would be nice to also guarantee that there are no gaps between buckets, ie:</color>
<color=#75715e> * bucket(N-1).last == bucket(N).first - 1 bucket(N).last == bucket(N-1).first - 1 it is not</color>
<color=#75715e> * possible to do so because we the put() call is not serialized because we don't want to add</color>
<color=#75715e> * overhead to the log write latch. In order to permit out of order puts(), and to require that only</color>
<color=#75715e> * the last bucket is updated, we must permit gaps between buckets.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Mappings start out being cached in VLSNBuckets held in memory by the VLSNTracker. As the</color>
<color=#75715e> * tracker fills, the buckets are flushed to persistent storage in a internal, non-replicated</color>
<color=#75715e> * database. Both the database and the tracker cache hold key/value pairs where</color>
<color=#75715e> *</color>
<color=#75715e> * <p>key = bucket.first data = bucket</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Since the first valid VLSN is 1, key = -1 is reserved for storage of the VLSNRange.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Buckets are filled up as new VLSNs arrive (either because they've been generated by write</color>
<color=#75715e> * operations on the master, or because they're incoming operations on the replica). They're flushed</color>
<color=#75715e> * to disk periodically rather than with every new VLSN, because the update rate would have too much</color>
<color=#75715e> * of a performance impact. Since there is this level of caching happening, we must be careful to</color>
<color=#75715e> * write in-memory buckets to disk at well known points to support recoverability. The flushing must</color>
<color=#75715e> * be instigated by a third party activity, such as checkpointing, rather than by the action of</color>
<color=#75715e> * adding a new mapping. That's because mappings are registered by the logging system, and although</color>
<color=#75715e> * we are not holding the log write latch at that point, it seems inadvisable to recursively</color>
<color=#75715e> * generate another logging call on behalf of the flush. Currently the VLSNIndex is flushed to disk</color>
<color=#75715e> * at every checkpoint. It can also optionally happen more often, and (TODO) we may want to do so</color>
<color=#75715e> * because we've seen cases where checkpoints take a very long time. Perhaps we should flush when we</color>
<color=#75715e> * flip to a new log file?</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Once written to disk, the buckets are generally not updated. Updates can happen when the range</color>
<color=#75715e> * is truncated, such as for syncup rollback, but the system is quiescent at that time, and there</color>
<color=#75715e> * are no new mappings created. Log cleaning can read the vlsnIndex and delete buckets, but will not</color>
<color=#75715e> * modify mappings. The VLSNRange does naturally change often, and that data record does get</color>
<color=#75715e> * updated.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Recovery:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The VLSN database is restored at recovery time just as all other databases are. However, there</color>
<color=#75715e> * may be a portion of the VLSN range that was not flushed to disk. At recovery, we piggyback onto</color>
<color=#75715e> * the log scanning done and re-track the any mappings found within the recovery range. Those</color>
<color=#75715e> * mappings are merged into those stored on disk, so that the VLSNIndex correctly reflects the</color>
<color=#75715e> * entire replication stream at startup. For example, suppose a log has:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>LSN 100 firstActiveLSN 200 Checkpoint start 300 VLSN 78 400 VLSNIndex flushed here 500</color>
<color=#75715e> * Checkpoint end 600 VLSN 79</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The VLSNIndex is initially populated with the version of the index found at LSN 400. That</color>
<color=#75715e> * doesn't include VLSN 79. A tracking pass is done from checkpoint start -> end of log, which</color>
<color=#75715e> * sweeps up VLSN 78 and VLSN 79 into a temporary tracker. That tracker is merged in the VLSNIndex,</color>
<color=#75715e> * to update its mappings to VLSN 79.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Note that the checkpoint VLSNIndex must encompass all vlsn mappings that are prior to the</color>
<color=#75715e> * checkpoint start of that recovery period. This follows the general philosophy that checkpoint</color>
<color=#75715e> * flushes all metadata, and recovery reads from checkpoint start onewards to add on any neede extra</color>
<color=#75715e> * data. Retrieving mappings:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Callers who need to retrieve mappings obtain a VLSNScanner, which acts as a cursor over the</color>
<color=#75715e> * VLSNIndex. A VLSNScanner finds and saves the applicable VLSNBucket, and queries the bucket</color>
<color=#75715e> * directly as long as it can provide mappings. This reduces the level of contention between</color>
<color=#75715e> * multiple readers (feeders) and writers (application threads, or the replay thread)</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Synchronization hierarchy:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>To write a new mapping, you must have the mutex on the VLSIndex, and then the tracker, which</color>
<color=#75715e> * lets you obtain the correct bucket, and then you must have a mutex on the bucket. To read a</color>
<color=#75715e> * mapping, you must have the tracker mutex to obtain the right bucket. If you already have the</color>
<color=#75715e> * right bucket in hand, you only need the bucket mutex.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>In truth, buckets which are not the "currentBucket" are not modified again, so a future</color>
<color=#75715e> * optimization would allow for reading a mapping on a finished bucket without synchronization.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The VLSNRange is updated as an atomic assignment to a volatile field after taking the mutex on</color>
<color=#75715e> * the current bucket. It is read without a mutex, by looking at it as a volatile field.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The hierarchy is VLSNIndex -> VLSNTracker -> VLSNBucket VLSNIndex -> VLSNTracker -> VLSNRange</color>
<color=#75715e> * VLSNIndex -> VLSNIndex.mappingSynchronizer VLSNIndex.flushSynchronizer -> VLSNTracker</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Removing mappings vs reading mappings - sync on the range.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>We also need to consider that fact that callers of the VLSNIndex may be holding other mutex,</color>
<color=#75715e> * or IN latches, and that the VLSNIndex methods may do database operations to read or write to the</color>
<color=#75715e> * internal VLSN database. That can result in a nested database operation, and we need to be careful</color>
<color=#75715e> * to avoid deadlocks. To be safe, we disable critical eviction [#18475] VLSNBucket.writeDatabase().</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Writers ------- Allocating a new VLSN: bump() - sync on log write latch Note that since there</color>
<color=#75715e> * is no synchronization on the VLSNINdex itself, [allocating new VLSN, logging its entry] and</color>
<color=#75715e> * [flushing the vlsn index to disk] is not atomic. See awaitConsistency().</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Adding a mapping: put() - sync on VLSNIndex -sync on VLSNTracker to access the right bucket,</color>
<color=#75715e> * and possibly create a new bucket. Atomically modify the VLSNRange.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Flushing mappings to disk: writeToDatabase() - sync on VLSNIndex.flushSyncrhonizer -></color>
<color=#75715e> * VLSNTracker</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Replica side syncup truncates the VLSNIndex from the end: - no synchronization needed, the</color>
<color=#75715e> * system is quiescent, and we can assume that VLSNs are neither read nor written by other threads.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Log cleaning truncates the VLSNIndex from the beginning: We assume that the log cleaner is</color>
<color=#75715e> * prohibited from deleting files that are being used for current feeding. We can also assume that</color>
<color=#75715e> * the end of the log is not being deleted, and that we're not conflict with put(). We do have to</color>
<color=#75715e> * worry about conflicting with backwards scans when executing syncup as a feeder, and with flushing</color>
<color=#75715e> * mappings to disk. Shall we disable log file deletion at this point?</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Steps to take:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>First change the VLSNRange: - sync on VLSNIndex - atomically modify the VLSNRange to ensure</color>
<color=#75715e> * that no readers or writers touch the buckets that will be deleted. - sync on VLSNTracker to</color>
<color=#75715e> * delete any dead buckets. Do that before updating the on-disk database, so that we don't lose any</color>
<color=#75715e> * buckets to writeToDatabase(). - without synchronization, scan the database and</color>
<color=#75715e> * non-transactionally delete any on-disk buckets that are <= the log cleaned file.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Readers ------- Active forward feeder checks if a mapping exists, and waits if necessary -</color>
<color=#75715e> * read the current VLSNRange w/out a mutex. If not satisfactory - sync on VLSNIndex - sync on</color>
<color=#75715e> * VLSNIndex.mappingSynchronizer</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Active forward feeder reads a mapping: first - getBucket() - sync on VLSNTracker to access the</color>
<color=#75715e> * right bucket if bucket is in hand - sync on target bucket to read bucket</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>VLSNIndex</color> <color=#f8f8f2>{</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The length of time that a checkpoint will wait for the vlsn index to</color>
<color=#75715e>   * contain all vlsn->lsn mappings before the checkpoint start.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>AWAIT_CONSISTENCY_MS</color> <color=#f92672>=</color> <color=#ae81ff>60000</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>  * VLSN waiting: A Feeder may block waiting for the next available record</color>
<color=#75715e>  * in the replication stream.</color>

<color=#75715e>  * vlsnPutLatch -      Latch used to wait for the next VLSN put operation.</color>
<color=#75715e>  * putWaitVLSN -       The VLSN associated with the vlsnPutLatch, it's only</color>
<color=#75715e>  *                     meaningful in the presence of a latch.</color>
<color=#75715e>  */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>VLSNAwaitLatch</color> <color=#f8f8f2>vlsnPutLatch</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>putWaitVLSN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Consider replacing the mapping synchronizer with a lower overhead and</color>
<color=#75715e>   * multi-processor friendly CAS style nowait code sequence.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>mappingSynchronizer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Object</color><color=#f8f8f2>();</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>flushSynchronizer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Object</color><color=#f8f8f2>();</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * nextVLSNCounter is incremented under the log write latch, when used on</color>
<color=#75715e>   * the master. If this node transitions from replica to master, this</color>
<color=#75715e>   * counter must be initialized before write operations begin. It can also</color>
<color=#75715e>   * be used by both masters and replicas when checking vlsn consistency</color>
<color=#75715e>   * before checkpoints.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nextVLSNCounter</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * For storing the persistent version of the VLSNIndex. For keys > 0,</color>
<color=#75715e>   * the key is the VLSN sequence number, data = VLSNBucket. Key = -1 has</color>
<color=#75715e>   * a special data item, which is the VLSNRange.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>mappingDbImpl</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The tracker handles the real mechanics of maintaining the VLSN range</color>
<color=#75715e>   * and mappings.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>VLSNTracker</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * A wait-free cache of the most recent log items in the VLSN index. These</color>
<color=#75715e>   * items are important since they are the ones needed by the feeders that</color>
<color=#75715e>   * are responsible for supplying timely commit acknowledgments.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LogItemCache</color> <color=#f8f8f2>logItemCache</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Statistics associated with the VLSN index</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>StatGroup</color> <color=#f8f8f2>statistics</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nHeadBucketsDeleted</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nTailBucketsDeleted</color><color=#f8f8f2>;</color>

  <color=#75715e>/* For testing [#20726] flushToDatabase while getGTEBucket is executing */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color><color=#f92672><?></color> <color=#f8f8f2>searchGTEHook</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The mapping db's name is passed in as a parameter instead of the more intuitive approach of</color>
<color=#75715e>   * defining it within the class to facilitate unit testing of the VLSNIndex.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>VLSNIndex</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>String</color> <color=#f8f8f2>mappingDbName</color><color=#f8f8f2>,</color>
      <color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"unused"</color><color=#f8f8f2>)</color> <color=#f8f8f2>NameIdPair</color> <color=#f8f8f2>nameIdPair</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>vlsnStride</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>vlsnMaxMappings</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>vlsnMaxDistance</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RecoveryInfo</color> <color=#f8f8f2>recoveryInfo</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * initialize the logger early so it can be used by the following</color>
<color=#75715e>     * methods.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>logger</color> <color=#f92672>=</color> <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>(</color><color=#f8f8f2>getClass</color><color=#f8f8f2>());</color>

    <color=#f8f8f2>statistics</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>StatGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSNIndexStatDefinition</color><color=#f8f8f2>.</color><color=#a6e22e>GROUP_NAME</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSNIndexStatDefinition</color><color=#f8f8f2>.</color><color=#a6e22e>GROUP_DESC</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nHeadBucketsDeleted</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>statistics</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSNIndexStatDefinition</color><color=#f8f8f2>.</color><color=#a6e22e>N_HEAD_BUCKETS_DELETED</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nTailBucketsDeleted</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>statistics</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSNIndexStatDefinition</color><color=#f8f8f2>.</color><color=#a6e22e>N_TAIL_BUCKETS_DELETED</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>init</color><color=#f8f8f2>(</color><color=#f8f8f2>mappingDbName</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnStride</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnMaxMappings</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnMaxDistance</color><color=#f8f8f2>,</color> <color=#f8f8f2>recoveryInfo</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>logItemCache</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>LogItemCache</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>().</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>RepParams</color><color=#f8f8f2>.</color><color=#a6e22e>VLSN_LOG_CACHE_SIZE</color><color=#f8f8f2>),</color> <color=#f8f8f2>statistics</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Initialize before this node begins working as a master. This node may become a Master directly</color>
<color=#75715e>   * after recovery, or it may transition to the master state after running for some time as a</color>
<color=#75715e>   * Replica.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Reset the vlsnIndex so the VLSN sequence corresponds to what this node thinks is the next</color>
<color=#75715e>   * VLSN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>initAsMaster</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>last</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>().</color><color=#a6e22e>getLast</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>last</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If the master does the conversion, the started VLSN should start</color>
<color=#75715e>       * from 2 so that Replica would throw a LogRefreshRequiredException</color>
<color=#75715e>       * and do a NetworkRestore to copy the master logs.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>nextVLSNCounter</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>needRepConvert</color><color=#f8f8f2>()</color> <color=#f92672>?</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nextVLSNCounter</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#f8f8f2>last</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Initialize before this node begins working as a replica after being a master. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>initAsReplica</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#75715e>/*</color>
<color=#75715e>     * Clear the VLSN await mechanism, which is used for feeding and for</color>
<color=#75715e>     * checkpoint precondition checking. Used when this node transitions away</color>
<color=#75715e>     * from master status, to replica status.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnPutLatch</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>vlsnPutLatch</color><color=#f8f8f2>.</color><color=#a6e22e>terminate</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>vlsnPutLatch</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>putWaitVLSN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>nextVLSNCounter</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Return the VLSN to use for tagging the next replicated log entry. Must</color>
<color=#75715e>   * be called within the log write latch.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>VLSN</color> <color=#a6e22e>bump</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>nextVLSNCounter</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getLatestAllocatedVal</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nextVLSNCounter</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Register a new VLSN->LSN mapping.  This is called outside the log write</color>
<color=#75715e>   * latch, but within the LogManager log() call. It must not cause any</color>
<color=#75715e>   * logging of its own and should not cause I/O.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>LogItem</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color> <color=#f92672>=</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>header</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color> <color=#f8f8f2>entryType</color> <color=#f92672>=</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>header</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>logItemCache</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>);</color>

    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>track</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>entryType</color><color=#f8f8f2>);</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>mappingSynchronizer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Put() calls may come out of order, so free the wait latch if</color>
<color=#75715e>         * the incoming VLSN >= the waiting VLSN. For example, a feeder</color>
<color=#75715e>         * may be awaiting VLSN 100, but the call to put(101) comes in</color>
<color=#75715e>         * before the call to put(100).</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>vlsnPutLatch</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>putWaitVLSN</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>vlsnPutLatch</color><color=#f8f8f2>.</color><color=#a6e22e>setLogItem</color><color=#f8f8f2>(</color><color=#f8f8f2>logItem</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>vlsnPutLatch</color><color=#f8f8f2>.</color><color=#a6e22e>countDown</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>vlsnPutLatch</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>putWaitVLSN</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINEST</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>finest</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"vlsnIndex put "</color> <color=#f92672>+</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Wait for the vlsn, or a higher numbered vlsn, to make its appearance in the VLSN index.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws InterruptedException</color>
<color=#75715e>   * @throws WaitTimeOutException if the VLSN did not appear within waitTime or the latch was</color>
<color=#75715e>   *     explicitly terminated.</color>
<color=#75715e>   * @return the LogItem associated with the vlsn, or null if the entry is now present in the log,</color>
<color=#75715e>   *     but is not available in the LogItemCache.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>LogItem</color> <color=#a6e22e>waitForVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>waitTime</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>InterruptedException</color><color=#f8f8f2>,</color> <color=#f8f8f2>WaitTimeOutException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* First check the volatile range field, without synchronizing. */</color>
    <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>useRange</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useRange</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>logItemCache</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>VLSNAwaitLatch</color> <color=#f8f8f2>waitLatch</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>useRange</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useRange</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>logItemCache</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>mappingSynchronizer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* The target VLSN hasn't arrived yet, we'll wait. */</color>
        <color=#f8f8f2>setupWait</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>

        <color=#75715e>/* Copy the latch while synchronized. */</color>
        <color=#f8f8f2>waitLatch</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnPutLatch</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Do any waiting outside the synchronization section. If the</color>
<color=#75715e>     * waited-for VLSN has already arrived, the waitLatch will have been</color>
<color=#75715e>     * counted down, and we'll go through.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>waitLatch</color><color=#f8f8f2>.</color><color=#a6e22e>await</color><color=#f8f8f2>(</color><color=#f8f8f2>waitTime</color><color=#f8f8f2>,</color> <color=#f8f8f2>TimeUnit</color><color=#f8f8f2>.</color><color=#a6e22e>MILLISECONDS</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>waitLatch</color><color=#f8f8f2>.</color><color=#a6e22e>isTerminated</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Timed out waiting for an incoming VLSN, or was terminated. */</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>WaitTimeOutException</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>().</color><color=#a6e22e>getLast</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"Waited for vlsn:"</color>
              <color=#f92672>+</color> <color=#f8f8f2>vlsn</color>
              <color=#f92672>+</color> <color=#e6db74>" should be greater than last in range:"</color>
              <color=#f92672>+</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>().</color><color=#a6e22e>getLast</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>LogItem</color> <color=#f8f8f2>logItem</color> <color=#f92672>=</color> <color=#f8f8f2>waitLatch</color><color=#f8f8f2>.</color><color=#a6e22e>getLogItem</color><color=#f8f8f2>();</color>
    <color=#75715e>/* If we waited successfully, logItem can't be null. */</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>header</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color>
        <color=#f92672>?</color> <color=#f8f8f2>logItem</color>
        <color=#f8f8f2>:</color>
        <color=#75715e>/*</color>
<color=#75715e>         * An out-of-order vlsn put, that is, a later VLSN arrived at</color>
<color=#75715e>         * the index before this one. We could look for it in the log</color>
<color=#75715e>         * item cache, but due to the very nature of the out of order</color>
<color=#75715e>         * put it's unlikely to be there and we would rather not incur</color>
<color=#75715e>         * the overhead of a failed lookup.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** For unit test only. */</color>
  <color=#66d9ef>synchronized</color> <color=#f8f8f2>VLSN</color> <color=#a6e22e>getPutWaitVLSN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>putWaitVLSN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Setup the context for waiting for a not-yet-registered VLSN. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>setupWait</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnPutLatch</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>putWaitVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>vlsnPutLatch</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSNAwaitLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* There can only be on possible VLSN to wait on. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>putWaitVLSN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#e6db74>"unexpected get for VLSN: "</color>
                <color=#f92672>+</color> <color=#f8f8f2>vlsn</color>
                <color=#f92672>+</color> <color=#e6db74>" already waiting for VLSN: "</color>
                <color=#f92672>+</color> <color=#f8f8f2>putWaitVLSN</color>
                <color=#f92672>+</color> <color=#e6db74>" current range="</color>
                <color=#f92672>+</color> <color=#f8f8f2>getRange</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Prevents truncation of the head of the index range (the lower bound). Used at the beginning of</color>
<color=#75715e>   * syncup. After calling this method, the head of the range is prevented from changing and and the</color>
<color=#75715e>   * files in the range will not be deleted. Passing the returned value to {@link</color>
<color=#75715e>   * com.sleepycat.je.cleaner.FileProtector#removeFileProtection} will allow the head of the range</color>
<color=#75715e>   * to change and files to be deleted.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>It is important that a syncup does not synchronize on VLSNIndex, since this could block</color>
<color=#75715e>   * waiting for an expensive operation such as truncation. The synchronization for protecting the</color>
<color=#75715e>   * range head is therefore on VLSNTracker.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param lockerName the name of the protecting entity, i.e., the syncup, to be used in</color>
<color=#75715e>   *     LogSizeStats.</color>
<color=#75715e>   * @return the ProtectedFileSet protecting the files in theVLSNIndex range.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>ProtectedFileSet</color> <color=#a6e22e>protectRangeHead</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>lockerName</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>protectRangeHead</color><color=#f8f8f2>(</color><color=#f8f8f2>lockerName</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns the file at the lower bound of the current range. This method does not synchronize. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getProtectedRangeStartFile</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getProtectedRangeStartFile</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Try to advance the VLSNIndex ProtectedFileRange and truncate the head of the VLSNIndex range,</color>
<color=#75715e>   * so that bytesNeeded can be freed by deleting files in this range.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Remove all information from the VLSNIndex for VLSNs <= deleteEndpoint. Used by log cleaning.</color>
<color=#75715e>   * To properly coordinate with readers of the VLSNIndex, we need to update the range before</color>
<color=#75715e>   * updating the buckets.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>We assume that deleteEnd is always the last vlsn in a file, and because of that, truncations</color>
<color=#75715e>   * will never split a bucket.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>A truncation may leave a gap at the head of the vlsn index though. This could occur if the</color>
<color=#75715e>   * buckets have a gap, due to out of order VLSNs. For example, it's possible that the index has</color>
<color=#75715e>   * these buckets:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>bucket A: firstVLSN = 10, lastVLSN = 20 bucket B: firstVLSN = 22, lastVLSN = 30</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If we truncate the index at 20 (deleteEnd == 20), then the resulting start of the range is</color>
<color=#75715e>   * 21, but the first bucket value is 22. In this case, we need to insert a ghost bucket.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method ensures that any changes are fsynced to disk before file deletion occurs.</color>
<color=#75715e>   * [#20702]</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>boolean</color> <color=#a6e22e>tryTruncateFromHead</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>Long</color><color=#f92672>></color> <color=#f8f8f2>truncateInfo</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>tryTruncateFromHead</color><color=#f8f8f2>(</color><color=#f8f8f2>bytesNeeded</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItemCache</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>truncateInfo</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* No change to the range was needed/possible. */</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>truncateDatabaseFromHead</color><color=#f8f8f2>(</color><color=#f8f8f2>truncateInfo</color><color=#f8f8f2>.</color><color=#a6e22e>first</color><color=#f8f8f2>(),</color> <color=#f8f8f2>truncateInfo</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>());</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Forcibly truncate the VLSNIndex range head, in situations where the environment is quiescent</color>
<color=#75715e>   * and we know that truncation is safe.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param deleteEnd the last VLSN to be truncated.</color>
<color=#75715e>   * @param deleteFileNum the file having deleteEnd as its last VLSN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>truncateFromHead</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>deleteEnd</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>deleteFileNum</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>fine</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"head truncate with "</color> <color=#f92672>+</color> <color=#f8f8f2>deleteEnd</color> <color=#f92672>+</color> <color=#e6db74>" delete file#:"</color> <color=#f92672>+</color> <color=#f8f8f2>deleteFileNum</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Since the range is the gatekeeper, update the tracker cache before</color>
<color=#75715e>     * the database, so that the range is adjusted first.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>truncateFromHead</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteEnd</color><color=#f8f8f2>,</color> <color=#f8f8f2>deleteFileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>logItemCache</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* No change to the range was needed. */</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>truncateDatabaseFromHead</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteEnd</color><color=#f8f8f2>,</color> <color=#f8f8f2>deleteFileNum</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>truncateDatabaseFromHead</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>deleteEnd</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>deleteFileNum</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Be sure that the changes are fsynced before deleting any files.  The</color>
<color=#75715e>     * changed vlsn index must be persisted so that there are no references</color>
<color=#75715e>     * to the deleted, cleaned files. Instead of using COMMIT_SYNC, use</color>
<color=#75715e>     * COMMIT_NO_SYNC with an explicit environment flush and fsync, because</color>
<color=#75715e>     * the latter ends the txn and releases locks sooner, and reduces</color>
<color=#75715e>     * possible lock contention on the VLSNIndex. Both feeders and write</color>
<color=#75715e>     * operations need to lock the VLSNIndex, so keeping lock contention</color>
<color=#75715e>     * minimal is essential.</color>
<color=#75715e>     * [#20702]</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>TransactionConfig</color> <color=#f8f8f2>config</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TransactionConfig</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>setDurability</color><color=#f8f8f2>(</color><color=#f8f8f2>Durability</color><color=#f8f8f2>.</color><color=#a6e22e>COMMIT_NO_SYNC</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Txn</color> <color=#f8f8f2>txn</color> <color=#f92672>=</color> <color=#f8f8f2>Txn</color><color=#f8f8f2>.</color><color=#a6e22e>createLocalTxn</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>config</color><color=#f8f8f2>);</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>flushSynchronizer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>pruneDatabaseHead</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteEnd</color><color=#f8f8f2>,</color> <color=#f8f8f2>deleteFileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>txn</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>txn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>commit</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>flushLog</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*fsync required*/</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>abort</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Remove all information from the VLSNIndex for VLSNs >= deleteStart Used by replica side syncup,</color>
<color=#75715e>   * when the log is truncated. Assumes that the vlsnIndex is quiescent, and no writes are</color>
<color=#75715e>   * happening, although the cleaner may read the vlsnIndex.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>truncateFromTail</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>deleteStart</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>logItemCache</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>currentRange</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentRange</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>().</color><color=#a6e22e>getNext</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteStart</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * deleteStart directly follows what's in this range, no need to</color>
<color=#75715e>       * delete anything.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The VLSNIndex has two parts -- the in-memory cache, and the</color>
<color=#75715e>     * database. Update the tracker, which holds the cache first, and then</color>
<color=#75715e>     * update the database.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>truncateFromTail</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>TransactionConfig</color> <color=#f8f8f2>config</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TransactionConfig</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Be sure to commit synchronously so that changes to the vlsn index</color>
<color=#75715e>     * are persisted before the log is truncated. There are no feeders or</color>
<color=#75715e>     * repstream write operations at this time, so the use of COMMIT_SYNC</color>
<color=#75715e>     * does not introduce any lock contention. [#20702]</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>setDurability</color><color=#f8f8f2>(</color><color=#f8f8f2>Durability</color><color=#f8f8f2>.</color><color=#a6e22e>COMMIT_SYNC</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Txn</color> <color=#f8f8f2>txn</color> <color=#f92672>=</color> <color=#f8f8f2>Txn</color><color=#f8f8f2>.</color><color=#a6e22e>createLocalTxn</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>config</color><color=#f8f8f2>);</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * The tracker knows the boundary between VLSNs that are on disk</color>
<color=#75715e>       * and VLSNs that are within its cache, and maintains that info</color>
<color=#75715e>       * as mappings are added, and as the tracker/cache is flushed.</color>
<color=#75715e>       * But since we're potentially truncating mappings that were on</color>
<color=#75715e>       * disk, we need to update the tracker's notion of where the flush</color>
<color=#75715e>       * boundary is.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastOnDisk</color> <color=#f92672>=</color> <color=#f8f8f2>pruneDatabaseTail</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>txn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>setLastOnDiskVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>lastOnDisk</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Because mappings can come out of order, it's possible that</color>
<color=#75715e>       * buckets are not completely contiguous, and that truncating</color>
<color=#75715e>       * will result in the loss of the mapping for the end of the range.</color>
<color=#75715e>       * For example, suppose the buckets are like this:</color>
<color=#75715e>       *  On disk: vlsn 13 -> bucket for vlsns 13-16</color>
<color=#75715e>       *  In tracker: vlsn 18 -> bucket for vlsns 18 -23</color>
<color=#75715e>       * Truncating the vlsnIndex at 18 will make the last VLSN become</color>
<color=#75715e>       * 17, and removing the vlsn 18 bucket will result in no mapping</color>
<color=#75715e>       * for the new end range, vlsn 17. If so, the tracker should</color>
<color=#75715e>       * create a new mapping, of vlsn 17 -> lastlsn, to cap off the</color>
<color=#75715e>       * range and ensure that there are mappings for the start and end</color>
<color=#75715e>       * lsns.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>ensureRangeEndIsMapped</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteStart</color><color=#f8f8f2>.</color><color=#a6e22e>getPrev</color><color=#f8f8f2>(),</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>txn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>commit</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>abort</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * All range points (first, last, etc) ought to be seen as one consistent group. Because of that,</color>
<color=#75715e>   * VLSNIndex doesn't offer getLastVLSN, getFirstVLSN type methods, to discourage the possibility</color>
<color=#75715e>   * of retrieving range points across two different range sets.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>VLSNRange</color> <color=#a6e22e>getRange</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the statistics associated with the VLSNIndex</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the vlsn statistics.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>StatGroup</color> <color=#a6e22e>getStats</color><color=#f8f8f2>(</color><color=#f8f8f2>StatsConfig</color> <color=#f8f8f2>config</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>statistics</color><color=#f8f8f2>.</color><color=#a6e22e>cloneGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getClear</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return the nearest file number <= the log file that houses this VLSN. This method is meant to</color>
<color=#75715e>   * be efficient and will not incur I/O. If there is no available, it does an approximation. The</color>
<color=#75715e>   * requested VLSN must be within the VLSNIndex range.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getLTEFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>getLTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLTEFileNumber</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The caller must ensure that the requested VLSN is within the VLSNIndex range; we assume that</color>
<color=#75715e>   * there is a valid bucket.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getGTEFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>getGTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getGTEFileNumber</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The requested VLSN must be within the VLSNIndex range; we assume that there is a valid bucket.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getGTELsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>getGTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getGTELsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Get the vlsnBucket that owns this VLSN. If there is no such bucket, get the bucket that follows</color>
<color=#75715e>   * this VLSN. Must always return a bucket.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Because this is unsynchronized, there is actually a remote chance that this call could view</color>
<color=#75715e>   * the VLSNIndex while a truncateFromTail() is going on, and see the index while it is logically</color>
<color=#75715e>   * inconsistent, should there be non-contiguous buckets in the vlsnIndex.. In that case, the</color>
<color=#75715e>   * caller will get an EnvironmentFailureException. Because the window is exceedingly small,</color>
<color=#75715e>   * requiring log cleaning and a rollback to collide in a very particular way, and because it is</color>
<color=#75715e>   * unpalatable to create synchronization hierarchy complexity for this tiny window, and because</color>
<color=#75715e>   * the problem is transient, this method is not synchronized. [#23491]</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param currentBucketInUse is used only for debugging, to add to the error message if the</color>
<color=#75715e>   *     GTEBucketFromDatabase fails.</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>VLSNBucket</color> <color=#a6e22e>getGTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>currentBucketInUse</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getGTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>getGTEBucketFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>currentBucketInUse</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Get the vlsnBucket that owns this VLSN. If there is no such bucket, get the bucket that</color>
<color=#75715e>   * precedes this VLSN. Must always return a bucket.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>VLSNBucket</color> <color=#a6e22e>getLTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getLTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>getLTEBucketFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * @return true if the status and key value indicate that this cursor is pointing at a valid</color>
<color=#75715e>   *     bucket. Recall that the VLSNRange is stored in the same database at entry -1.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isValidBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>((</color><color=#f8f8f2>status</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color>
        <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToLong</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>VLSNRange</color><color=#f8f8f2>.</color><color=#a6e22e>RANGE_KEY</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Get the bucket that matches this VLSN. If this vlsn is Y, then we want</color>
<color=#75715e>   * bucket at key X where X <= Y. If this method is called, we guarantee</color>
<color=#75715e>   * that a non-null bucket will be returned.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>VLSNBucket</color> <color=#a6e22e>getLTEBucketFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#f8f8f2>BasicLocker</color><color=#f8f8f2>.</color><color=#a6e22e>createBasicLocker</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#f8f8f2>makeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>locker</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>positionBeforeOrEqual</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Shouldn't get here. */</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"Couldn't find bucket for LTE VLSN "</color> <color=#f92672>+</color> <color=#f8f8f2>vlsn</color> <color=#f92672>+</color> <color=#e6db74>" in database. tracker="</color> <color=#f92672>+</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>locker</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>operationEnd</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return the bucket that holds a mapping >= this VLSN. If this method is called, we guarantee</color>
<color=#75715e>   * that a non-null bucket will be returned.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>At this point, we are sure that the target vlsn is within the range of vlsns held in the</color>
<color=#75715e>   * database. However, note that there is no explicit synchronization between this database search,</color>
<color=#75715e>   * and the VLSNTracker.flushToDatabase, which might be writing additional buckets to this</color>
<color=#75715e>   * database. This may affect the cases when the cursor search does not return a equality match on</color>
<color=#75715e>   * a bucket. [#20726]</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>For example, suppose the database looks like this: key=vlsn 10, data = bucket: vlsn 10 -></color>
<color=#75715e>   * lsn 0x10/100 vlsn 15 -> lsn 0x10/150 key=vlsn 20, data = bucket: vlsn 20 -> lsn 0x11/100 vlsn</color>
<color=#75715e>   * 25 -> lsn 0x11/150 If we are looking for a bucket for vlsn 22, there will not be a match from</color>
<color=#75715e>   * the call to cursor.getSearchKeyRange(key=22). The code that accounts for that will need to</color>
<color=#75715e>   * consider that new buckets may be flushed to the database while the search for a new bucket is</color>
<color=#75715e>   * going on. For example,</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>key=vlsn 30, data = bucket: vlsn 30 -> lsn 0x12/100 vlsn 35 -> lsn 0x12/150</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>may be written to the database while we are searching for a bucket that owns vlsn 22.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>VLSNBucket</color> <color=#a6e22e>getGTEBucketFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>target</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>currentBucketInUse</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#f8f8f2>BasicLocker</color><color=#f8f8f2>.</color><color=#a6e22e>createBasicLocker</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#f8f8f2>makeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>locker</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Look at the bucket at key >= target.Will return null if no GTE</color>
<color=#75715e>       * bucket.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>examineGTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>,</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We're here because we did not find a bucket >= target. Let's</color>
<color=#75715e>       * examine the last bucket in this database. We know that it will</color>
<color=#75715e>       * either be:</color>
<color=#75715e>       *</color>
<color=#75715e>       * 1) a bucket that's < target, but owns the mapping</color>
<color=#75715e>       * 2) if the index was appended to by VLSNTracker.flushToDatabase</color>
<color=#75715e>       *    while the search is going on, the last bucket may be one</color>
<color=#75715e>       *    that is > or >= target.</color>
<color=#75715e>       * Using the example above, the last bucket could be case 1:</color>
<color=#75715e>       *</color>
<color=#75715e>       * a bucket that is < target 22:</color>
<color=#75715e>       *    key=vlsn 20, data = bucket: vlsn 20 -> lsn 0x11/100</color>
<color=#75715e>       *                                vlsn 25 -> lsn 0x11/150</color>
<color=#75715e>       *</color>
<color=#75715e>       * or case 2, a bucket that is >= target 22, because the index grew</color>
<color=#75715e>       *    key=vlsn 30, data = bucket: vlsn 30 -> lsn 0x12/100</color>
<color=#75715e>       *                                vlsn 35 -> lsn 0x12/150</color>
<color=#75715e>       */</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>(</color><color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>searchGTEHook</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>endBucket</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isValidBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>endBucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>endBucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>endBucket</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If this end bucket is not the owner of the target VLSN, we</color>
<color=#75715e>         * expect it to be a greaterThan bucket which was inserted</color>
<color=#75715e>         * because of a concurrent VLSNTracker.flushToDatabase call</color>
<color=#75715e>         * that did not exist when we did the previous</color>
<color=#75715e>         * cursor.getKeyRangeSearch (case 2), In that case, we can</color>
<color=#75715e>         * search again for the owning bucket.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>endBucket</color><color=#f8f8f2>.</color><color=#a6e22e>follows</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>examineGTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>,</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>);</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Shouldn't get here! There should have been a bucket in this</color>
<color=#75715e>       * database >= this target.</color>
<color=#75715e>       */</color>

      <color=#75715e>/* Dump the bucket database for debugging. */</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>count</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>Long</color> <color=#f8f8f2>keyValue</color> <color=#f92672>=</color> <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToLong</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"key => "</color> <color=#f92672>+</color> <color=#f8f8f2>keyValue</color> <color=#f92672>+</color> <color=#e6db74>"\n"</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>count</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>range</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNRange</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"range =>"</color> <color=#f92672>+</color> <color=#f8f8f2>range</color> <color=#f92672>+</color> <color=#e6db74>"\n"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"bucket => "</color> <color=#f92672>+</color> <color=#f8f8f2>bucket</color> <color=#f92672>+</color> <color=#e6db74>"\n"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>count</color><color=#f92672>++</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>severe</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"VLSNIndex Dump: "</color> <color=#f92672>+</color> <color=#f8f8f2>sb</color><color=#f8f8f2>);</color>

      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"Couldn't find bucket for GTE VLSN "</color>
              <color=#f92672>+</color> <color=#f8f8f2>target</color>
              <color=#f92672>+</color> <color=#e6db74>" in database. EndBucket="</color>
              <color=#f92672>+</color> <color=#f8f8f2>endBucket</color>
              <color=#f92672>+</color> <color=#e6db74>"currentBucket="</color>
              <color=#f92672>+</color> <color=#f8f8f2>currentBucketInUse</color>
              <color=#f92672>+</color> <color=#e6db74>" tracker = "</color>
              <color=#f92672>+</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>locker</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>operationEnd</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Find a bucket that is GTE the target, and sees if that bucket is the owner. If it is not the</color>
<color=#75715e>   * owner look at the previous bucket.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return null if no GTE bucket was found.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>VLSNBucket</color> <color=#a6e22e>examineGTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>target</color><color=#f8f8f2>,</color> <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* getSearchKeyRange will return a bucket >= target if one exists */</color>
    <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>longToEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>key</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getSearchKeyRange</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The bucket we found is > than our target. Look at the</color>
<color=#75715e>       * previous one.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getPrev</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isValidBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>prevBucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevBucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>prevBucket</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * There is no bucket that owns this target, return the greater</color>
<color=#75715e>       * one.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* No bucket at a key >= the target. */</color>
    <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Position this cursor at the largest value bucket which is <= the</color>
<color=#75715e>   * target VLSN.</color>
<color=#75715e>   * @return true if there is a bucket that fits this criteria,</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>positionBeforeOrEqual</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>longToEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>key</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#75715e>/* getSearchKeyRange will give us a bucket >= Y. */</color>
    <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getSearchKeyRange</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* The bucket we found is > than our VLSN. Get the previous one. */</color>
      <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getPrev</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>isValidBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Hey, nothing else in the database. */</color>
    <color=#f8f8f2>}</color>
    <color=#75715e>/*</color>
<color=#75715e>     * There was no bucket >= Y. Let's find the last bucket in this</color>
<color=#75715e>     * database then. It should be a bucket that's < Y.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>isValidBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Position this cursor at the smallest value bucket which is >= the</color>
<color=#75715e>   * target VLSN.</color>
<color=#75715e>   * @return true if there is a bucket that fits this criteria,</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>positionAfterOrEqual</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>longToEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>.</color><color=#a6e22e>getSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>key</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#75715e>/* getSearchKeyRange will give us a bucket >= Y. */</color>
    <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getSearchKeyRange</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * This bucket is > our VLSN. Check the bucket before.</color>
<color=#75715e>       *  - It might be a bucket that owns this VLSN</color>
<color=#75715e>       *  - the prevbucket might precede this VLSN.</color>
<color=#75715e>       *  - the record before might be the range.</color>
<color=#75715e>       * One way or another, there should always be a record before</color>
<color=#75715e>       * any bucket -- it's the range.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getPrev</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>status</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isValidBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Move back to the original bucket, all those preceding buckets</color>
<color=#75715e>       * were unsatifactory.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#75715e>/*</color>
<color=#75715e>     * There was no bucket >= Y. Let's find the last bucket in this</color>
<color=#75715e>     * database then. It should be a bucket that's < Y.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isValidBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Remove all VLSN->LSN mappings <= deleteEnd</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>pruneDatabaseHead</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>deleteEnd</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>deleteFileNum</color><color=#f8f8f2>,</color> <color=#f8f8f2>Txn</color> <color=#f8f8f2>txn</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#f8f8f2>makeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>txn</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>positionBeforeOrEqual</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>,</color> <color=#f8f8f2>deleteEnd</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Nothing to do. */</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Delete this bucket and everything before this bucket. */</color>

      <color=#75715e>/* Avoid fetching the bucket itself, since it's not needed */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>noData</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>noData</color><color=#f8f8f2>.</color><color=#a6e22e>setPartial</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>deleteCount</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

      <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>keyValue</color> <color=#f92672>=</color> <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToLong</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>keyValue</color> <color=#f92672>==</color> <color=#f8f8f2>VLSNRange</color><color=#f8f8f2>.</color><color=#a6e22e>RANGE_KEY</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>delete</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>deleteCount</color><color=#f92672>++</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>!=</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
              <color=#e6db74>"Couldn't delete, got status of "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>status</color>
                  <color=#f92672>+</color> <color=#e6db74>" for delete of bucket "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>keyValue</color>
                  <color=#f92672>+</color> <color=#e6db74>" deleteEnd="</color>
                  <color=#f92672>+</color> <color=#f8f8f2>deleteEnd</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getPrev</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>noData</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>nHeadBucketsDeleted</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteCount</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Check the first real bucket, and see if we need to insert</color>
<color=#75715e>       * a ghost bucket.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>VLSN</color> <color=#f8f8f2>newStart</color> <color=#f92672>=</color> <color=#f8f8f2>deleteEnd</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>longToEntry</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getSearchKeyRange</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>

      <color=#75715e>/* No real buckets, nothing to adjust. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>!=</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>firstBucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
      <color=#75715e>/* First bucket matches the range, nothing to adjust. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>newStart</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>newStart</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"newStart "</color> <color=#f92672>+</color> <color=#f8f8f2>newStart</color> <color=#f92672>+</color> <color=#e6db74>" should be < first bucket:"</color> <color=#f92672>+</color> <color=#f8f8f2>firstBucket</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Add a ghost bucket so that there is a bucket to match the</color>
<color=#75715e>       * first item in the range.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>nextFile</color> <color=#f92672>=</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>getFollowingFileNum</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteFileNum</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/* forward */</color><color=#f8f8f2>);</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>lastPossibleLsn</color> <color=#f92672>=</color> <color=#f8f8f2>firstBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>firstBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>placeholder</color> <color=#f92672>=</color>
          <color=#66d9ef>new</color> <color=#f8f8f2>GhostBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>newStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>makeLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>nextFile</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>),</color> <color=#f8f8f2>lastPossibleLsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>placeholder</color><color=#f8f8f2>.</color><color=#a6e22e>writeToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Remove all VLSN->LSN mappings >= deleteStart.  Recall that the</color>
<color=#75715e>   * mappingDb is keyed by the first VLSN in the bucket. The replication</color>
<color=#75715e>   * stream will be quiescent when this is called. The caller must be</color>
<color=#75715e>   * sure that there are buckets in the database that cover deleteStart.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param lastLsn is the location, if known, of the vlsn at deleteStart -1.</color>
<color=#75715e>   * If the location is not know, NULL_LSN is used. In that case the pruning</color>
<color=#75715e>   * may need to delete mappings < deleteSTart, in order to keep the bucket</color>
<color=#75715e>   * capped with a legitimate lastLSN. If lastLsn is not NULL_LSN, then the</color>
<color=#75715e>   * deletion can precisely delete only mappings >= deleteStart, because it</color>
<color=#75715e>   * can always create a new deleteStart-1 -> lastLsn mapping to cap off the</color>
<color=#75715e>   * end range.</color>
<color=#75715e>   * @return lastVLSN left on disk.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>VLSN</color> <color=#a6e22e>pruneDatabaseTail</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>deleteStart</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>Txn</color> <color=#f8f8f2>txn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * At this point, the tracker is accurate as to which vlsn is last</color>
<color=#75715e>     * on disk.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastOnDiskVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getLastOnDisk</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#f8f8f2>makeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>txn</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>positionAfterOrEqual</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>,</color> <color=#f8f8f2>deleteStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * No bucket that matches this criteria, everything on disk is</color>
<color=#75715e>         * < deleteStart, nothing to do.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>lastOnDiskVLSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Does this bucket straddle deleteStart? Then prune off part of</color>
<color=#75715e>       * the bucket.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteStart</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>removeFromTail</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteStart</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastLsn</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>lastOnDiskVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>fillDataEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>putCurrent</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>!=</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Couldn't update "</color> <color=#f92672>+</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>!=</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>lastOnDiskVLSN</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Delete everything after this bucket. */</color>

      <color=#75715e>/* Avoid fetching the bucket itself, since it's not needed */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>noData</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>noData</color><color=#f8f8f2>.</color><color=#a6e22e>setPartial</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>deleteCount</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

      <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>delete</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>!=</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Couldn't delete after vlsn "</color> <color=#f92672>+</color> <color=#f8f8f2>deleteStart</color> <color=#f92672>+</color> <color=#e6db74>" status="</color> <color=#f92672>+</color> <color=#f8f8f2>status</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>deleteCount</color><color=#f92672>++</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>noData</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>nTailBucketsDeleted</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>deleteCount</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We've deleted some part of what was on disk. See what we're left</color>
<color=#75715e>       * with, and find the last mapping in the last bucket so we can say</color>
<color=#75715e>       * precisely which is the last vlsn mapped on disk and update the</color>
<color=#75715e>       * tracker cache. This last mapping may not be exactly</color>
<color=#75715e>       * deleteStart-1, if there is a gap in the mappings.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isValidBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>status</color><color=#f8f8f2>,</color> <color=#f8f8f2>key</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* A valid bucket was returned */</color>
        <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>lastOnDiskVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * No mappings in the database -- either there is nothing in</color>
<color=#75715e>         * the database, or we only have the special range record at</color>
<color=#75715e>         * key=-1</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>lastOnDiskVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>NULL_VLSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>lastOnDiskVLSN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * At startup, we need to - get a handle onto the internal database which stores the VLSN index -</color>
<color=#75715e>   * read the latest on-disk version to initialize the tracker - find any VLSN->LSN mappings which</color>
<color=#75715e>   * were not saved in the on-disk version, and merge them in. These mappings weren't flushed</color>
<color=#75715e>   * because they occurred after the checkpoint end. They're found by the recovery procedure, and</color>
<color=#75715e>   * are added in now.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method will execute when the map is quiescent, and needs no synchronization.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>init</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>String</color> <color=#f8f8f2>mappingDbName</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>vlsnStride</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>vlsnMaxMappings</color><color=#f8f8f2>,</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>vlsnMaxDistance</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>RecoveryInfo</color> <color=#f8f8f2>recoveryInfo</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>openMappingDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>mappingDbName</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>tracker</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>VLSNTracker</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>mappingDbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnStride</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnMaxMappings</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnMaxDistance</color><color=#f8f8f2>,</color> <color=#f8f8f2>statistics</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Put any in-memory mappings discovered during the recovery process</color>
<color=#75715e>     * into the fileMapperDb. That way, we'll preserve mappings that</color>
<color=#75715e>     * precede this recovery's checkpoint.</color>
<color=#75715e>     *</color>
<color=#75715e>     * For example, suppose the log looks like this:</color>
<color=#75715e>     *</color>
<color=#75715e>     * VLSN1</color>
<color=#75715e>     * VLSN2</color>
<color=#75715e>     * checkpoint start for this recovery, for the instantiation of the</color>
<color=#75715e>     *          replicator</color>
<color=#75715e>     * checkpoint end for this recovery</color>
<color=#75715e>     * <- at this point in time, after the env comes up, we'll create</color>
<color=#75715e>     * the VLSN index. VLSN1 and VLSN2 were discovered during recovery and</color>
<color=#75715e>     * are recorded in memory. Normally a checkpoint flushes the VLSNIndex</color>
<color=#75715e>     * but the VLSNIndex isn't instantiated yet, because the VLSNIndex</color>
<color=#75715e>     * needs an initialized environment.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>merge</color><color=#f8f8f2>((</color><color=#f8f8f2>VLSNRecoveryTracker</color><color=#f8f8f2>)</color> <color=#f8f8f2>recoveryInfo</color><color=#f8f8f2>.</color><color=#a6e22e>vlsnProxy</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Initialize ProtectedFileRange after VLSN range is determined. */</color>
    <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>range</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>long</color> <color=#f8f8f2>firstFile</color> <color=#f92672>=</color> <color=#f8f8f2>getLTEFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>initProtectedFileRange</color><color=#f8f8f2>(</color><color=#f8f8f2>firstFile</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * When one or more reserved files are missing, truncate the index so</color>
<color=#75715e>     * it reflects the VLSN range for existing files.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>recoveryInfo</color><color=#f8f8f2>.</color><color=#a6e22e>lastMissingFileVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>truncateFromHead</color><color=#f8f8f2>(</color><color=#f8f8f2>recoveryInfo</color><color=#f8f8f2>.</color><color=#a6e22e>lastMissingFileVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>recoveryInfo</color><color=#f8f8f2>.</color><color=#a6e22e>lastMissingFileNumber</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Update this index, which was initialized with what's on disk, with</color>
<color=#75715e>   * mappings found during recovery. These mappings ought to either overlap</color>
<color=#75715e>   * what's on disk, or cover the range immediately after what's on disk.  If</color>
<color=#75715e>   * it doesn't, the recovery mechanism, which flushes the mapping db at</color>
<color=#75715e>   * checkpoint is faulty and we've lost mappings.</color>
<color=#75715e>   *</color>
<color=#75715e>   * In other words, if this tracker holds the VLSN range a -> c, then the</color>
<color=#75715e>   * recovery tracker will have the VLSN range b -> d, where</color>
<color=#75715e>   *</color>
<color=#75715e>   *   a <= b</color>
<color=#75715e>   *   c <= d</color>
<color=#75715e>   *   if c < b, then b == c+1</color>
<color=#75715e>   *</color>
<color=#75715e>   * This method must be called when the index and tracker are quiescent, and</color>
<color=#75715e>   * there are no calls to track().</color>
<color=#75715e>   *</color>
<color=#75715e>   * The recoveryTracker is the authoritative voice on what should be in the</color>
<color=#75715e>   * VLSN index.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>merge</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSNRecoveryTracker</color> <color=#f8f8f2>recoveryTracker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>recoveryTracker</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>Durability</color><color=#f8f8f2>.</color><color=#a6e22e>COMMIT_SYNC</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>recoveryTracker</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Even though the recovery tracker has no mappings, it may have</color>
<color=#75715e>       * seen a rollback start that indicates that the VLSNIndex should</color>
<color=#75715e>       * be truncated. Setup the recovery tracker so it looks like</color>
<color=#75715e>       * it has a single mapping -- the matchpoint VLSN and LSN and</color>
<color=#75715e>       * proceed. Take this approach, rather than truncating the index,</color>
<color=#75715e>       * because we may need that matchpoint mapping to cap off the</color>
<color=#75715e>       * VLSN range.</color>
<color=#75715e>       *</color>
<color=#75715e>       * For example, suppose an index has mappings for VLSN 1, 5, 10,</color>
<color=#75715e>       * and the rollback is going to matchpoint 7. A pure truncation</color>
<color=#75715e>       * would lop off VLSN 10, making VLSN 5 the last mapping. We</color>
<color=#75715e>       * would then need to add on VLSN 7.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastMatchpointVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>recoveryTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getLastMatchpointVLSN</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastMatchpointVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Use a MATCHPOINT log entry to indicate that this is a syncable</color>
<color=#75715e>       * entry. This purposefully leaves the recovery tracker's range's</color>
<color=#75715e>       * lastTxnEnd null, so it will not overwrite the on disk</color>
<color=#75715e>       * tracker. This assumes that we will never rollback past the last</color>
<color=#75715e>       * txn end.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>recoveryTracker</color><color=#f8f8f2>.</color><color=#a6e22e>track</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>lastMatchpointVLSN</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>recoveryTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getLastMatchpointLsn</color><color=#f8f8f2>(),</color>
          <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_MATCHPOINT</color><color=#f8f8f2>.</color><color=#a6e22e>getTypeNum</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The mappings held in the recoveryTracker must either overlap what's</color>
<color=#75715e>     * on disk or immediately follow the last mapping on disk. If there</color>
<color=#75715e>     * is a gap between what is on disk and the recovery tracker, something</color>
<color=#75715e>     * went awry with the checkpoint scheme, which flushes the VLSN index</color>
<color=#75715e>     * at each checkpoint. We're in danger of losing some mappings. Most</color>
<color=#75715e>     * importantly, the last txnEnd VLSN in the range might not be right.</color>
<color=#75715e>     *</color>
<color=#75715e>     * The one exception is when the Environment has been converted from</color>
<color=#75715e>     * non-replicated and there are no VLSN entries in the VLSNIndex. In</color>
<color=#75715e>     * that case, it's valid that the entries seen from the recovery</color>
<color=#75715e>     * tracker may have a gap in VLSNs. For example, in a newly converted</color>
<color=#75715e>     * environment, the VLSN index range has NULL_VLSN as its last entry,</color>
<color=#75715e>     * but the first replicated log entry will start with 2.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Note: EnvironmentImpl.needRepConvert() would more accurately convey</color>
<color=#75715e>     * the fact that this is the very first recovery following a</color>
<color=#75715e>     * conversion.  But needRepConvert() on a replica is never true, and we</color>
<color=#75715e>     * need to disable this check on the replica's first recovery too.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>persistentLast</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>().</color><color=#a6e22e>getLast</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>recoveryFirst</color> <color=#f92672>=</color> <color=#f8f8f2>recoveryTracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>().</color><color=#a6e22e>getFirst</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isRepConverted</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>persistentLast</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>())</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isRepConverted</color><color=#f8f8f2>())</color>
        <color=#f92672>&&</color> <color=#f8f8f2>recoveryFirst</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>persistentLast</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>())</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"recoveryTracker should overlap or follow on disk "</color>
              <color=#f92672>+</color> <color=#e6db74>"last VLSN of "</color>
              <color=#f92672>+</color> <color=#f8f8f2>persistentLast</color>
              <color=#f92672>+</color> <color=#e6db74>" recoveryFirst= "</color>
              <color=#f92672>+</color> <color=#f8f8f2>recoveryFirst</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>currentRange</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentRange</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>().</color><color=#a6e22e>getNext</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>recoveryFirst</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* No overlap, just append mappings found at recovery. */</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>recoveryTracker</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>Durability</color><color=#f8f8f2>.</color><color=#a6e22e>COMMIT_SYNC</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The mappings in the recovery tracker should overwrite those in the</color>
<color=#75715e>     * VLSN index.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>TransactionConfig</color> <color=#f8f8f2>config</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TransactionConfig</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>setDurability</color><color=#f8f8f2>(</color><color=#f8f8f2>Durability</color><color=#f8f8f2>.</color><color=#a6e22e>COMMIT_SYNC</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Txn</color> <color=#f8f8f2>txn</color> <color=#f92672>=</color> <color=#f8f8f2>Txn</color><color=#f8f8f2>.</color><color=#a6e22e>createLocalTxn</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>config</color><color=#f8f8f2>);</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastOnDiskVLSN</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lastOnDiskVLSN</color> <color=#f92672>=</color> <color=#f8f8f2>pruneDatabaseTail</color><color=#f8f8f2>(</color><color=#f8f8f2>recoveryFirst</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>txn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>merge</color><color=#f8f8f2>(</color><color=#f8f8f2>lastOnDiskVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>recoveryTracker</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>txn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>commit</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>abort</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>openMappingDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>mappingDbName</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#f8f8f2>Txn</color><color=#f8f8f2>.</color><color=#a6e22e>createLocalAutoTxn</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#f8f8f2>TransactionConfig</color><color=#f8f8f2>());</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>locker</color><color=#f8f8f2>,</color> <color=#f8f8f2>mappingDbName</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color> <color=#75715e>/* databaseHandle */</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isReadOnly</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* This should have been caught earlier. */</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#e6db74>"A replicated environment can't be opened read only."</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>DatabaseConfig</color> <color=#f8f8f2>dbConfig</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseConfig</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>dbConfig</color><color=#f8f8f2>.</color><color=#a6e22e>setReplicated</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>createInternalDb</color><color=#f8f8f2>(</color><color=#f8f8f2>locker</color><color=#f8f8f2>,</color> <color=#f8f8f2>mappingDbName</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbConfig</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>mappingDbImpl</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>operationEnd</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>close</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>close</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>abnormalClose</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>close</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>close</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>doFlush</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>doFlush</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>Durability</color><color=#f8f8f2>.</color><color=#a6e22e>COMMIT_SYNC</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnPutLatch</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * This should be harmless because the feeders using the latch</color>
<color=#75715e>         * should all have been interrupted and shutdown. So just log</color>
<color=#75715e>         * this fact.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>vlsnPutLatch</color><color=#f8f8f2>.</color><color=#a6e22e>terminate</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>fine</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"Outstanding VLSN put latch cleared at close"</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mappingDbImpl</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>().</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>mappingDbImpl</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>mappingDbImpl</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** For unit testing. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>DatabaseImpl</color> <color=#a6e22e>getDatabaseImpl</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>mappingDbImpl</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Mappings are flushed to disk at close, and at checkpoints. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>Durability</color> <color=#f8f8f2>useDurability</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>TransactionConfig</color> <color=#f8f8f2>config</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TransactionConfig</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>setDurability</color><color=#f8f8f2>(</color><color=#f8f8f2>useDurability</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Txn</color> <color=#f8f8f2>txn</color> <color=#f92672>=</color> <color=#f8f8f2>Txn</color><color=#f8f8f2>.</color><color=#a6e22e>createLocalTxn</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>config</color><color=#f8f8f2>);</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>txn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>commit</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>success</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>txn</color><color=#f8f8f2>.</color><color=#a6e22e>abort</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Mappings are flushed to disk at close, and at checkpoints. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>Txn</color> <color=#f8f8f2>txn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>flushSynchronizer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>flushToDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>mappingDbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>txn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For debugging and unit tests</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>Long</color><color=#f92672>></color> <color=#a6e22e>dumpDb</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>display</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>display</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#f8f8f2>tracker</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>Long</color><color=#f92672>></color> <color=#f8f8f2>mappings</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><</color><color=#f8f8f2>VLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>Long</color><color=#f92672>></color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#f8f8f2>BasicLocker</color><color=#f8f8f2>.</color><color=#a6e22e>createBasicLocker</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#f8f8f2>makeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>locker</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The first item in the database is the VLSNRange. All subsequent</color>
<color=#75715e>       * items are VLSNBuckets.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>count</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>Long</color> <color=#f8f8f2>keyValue</color> <color=#f92672>=</color> <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToLong</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>display</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"key => "</color> <color=#f92672>+</color> <color=#f8f8f2>keyValue</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>count</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>range</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNRange</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>display</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"range =>"</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
          <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>().</color><color=#a6e22e>getSequence</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672><=</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>().</color><color=#a6e22e>getSequence</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>VLSN</color> <color=#f8f8f2>v</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
            <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>v</color><color=#f8f8f2>);</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>mappings</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>v</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>display</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"bucket =>"</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>dump</color><color=#f8f8f2>(</color><color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>count</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>locker</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>operationEnd</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>mappings</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For DbStreamVerify utility. Verify the on-disk database, disregarding the cached tracker.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws DatabaseException</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"null"</color><color=#f8f8f2>)</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>verifyDb</color><color=#f8f8f2>(</color><color=#f8f8f2>Environment</color> <color=#f8f8f2>env</color><color=#f8f8f2>,</color> <color=#f8f8f2>PrintStream</color> <color=#f8f8f2>out</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>verbose</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>DatabaseConfig</color> <color=#f8f8f2>dbConfig</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseConfig</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>dbConfig</color><color=#f8f8f2>.</color><color=#a6e22e>setReadOnly</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Database</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>env</color><color=#f8f8f2>.</color><color=#a6e22e>openDatabase</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbType</color><color=#f8f8f2>.</color><color=#a6e22e>VLSN_MAP</color><color=#f8f8f2>.</color><color=#a6e22e>getInternalName</color><color=#f8f8f2>(),</color> <color=#f8f8f2>dbConfig</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"Verifying VLSN index"</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>openCursor</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>CursorConfig</color><color=#f8f8f2>.</color><color=#a6e22e>READ_COMMITTED</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The first item in the database is the VLSNRange. All subsequent</color>
<color=#75715e>       * items are VLSNBuckets.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>count</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>range</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>lastBucket</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>Long</color> <color=#f8f8f2>lastKey</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>VLSN</color> <color=#f8f8f2>firstVLSNSeen</color> <color=#f92672>=</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastVLSNSeen</color> <color=#f92672>=</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN</color><color=#f8f8f2>;</color>
      <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>Long</color> <color=#f8f8f2>keyValue</color> <color=#f92672>=</color> <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToLong</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>count</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>keyValue</color> <color=#f92672>!=</color> <color=#f8f8f2>VLSNRange</color><color=#f8f8f2>.</color><color=#a6e22e>RANGE_KEY</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"Wrong key value for range! "</color> <color=#f92672>+</color> <color=#f8f8f2>range</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>range</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNRange</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"range=>"</color> <color=#f92672>+</color> <color=#f8f8f2>range</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>print</color><color=#f8f8f2>(</color><color=#e6db74>"key=> "</color> <color=#f92672>+</color> <color=#f8f8f2>keyValue</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>" bucket=>"</color> <color=#f92672>+</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastBucket</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>())</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"Buckets out of order."</color><color=#f8f8f2>);</color>
              <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"Last = "</color> <color=#f92672>+</color> <color=#f8f8f2>lastKey</color> <color=#f92672>+</color> <color=#e6db74>"/"</color> <color=#f92672>+</color> <color=#f8f8f2>lastBucket</color><color=#f8f8f2>);</color>
              <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"Current = "</color> <color=#f92672>+</color> <color=#f8f8f2>keyValue</color> <color=#f92672>+</color> <color=#e6db74>"/"</color> <color=#f92672>+</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>lastBucket</color> <color=#f92672>=</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>lastKey</color> <color=#f92672>=</color> <color=#f8f8f2>keyValue</color><color=#f8f8f2>;</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>firstVLSNSeen</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>firstVLSNSeen</color><color=#f8f8f2>.</color><color=#a6e22e>isNull</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>firstVLSNSeen</color> <color=#f92672>=</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>lastVLSNSeen</color> <color=#f92672>=</color> <color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>count</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>count</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"VLSNIndex not on disk"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstVLSNSeen</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>())</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color>
            <color=#e6db74>"First VLSN in bucket = "</color>
                <color=#f92672>+</color> <color=#f8f8f2>firstVLSNSeen</color>
                <color=#f92672>+</color> <color=#e6db74>" and doesn't match range "</color>
                <color=#f92672>+</color> <color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lastVLSNSeen</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>())</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color>
            <color=#e6db74>"Last VLSN in bucket = "</color>
                <color=#f92672>+</color> <color=#f8f8f2>lastVLSNSeen</color>
                <color=#f92672>+</color> <color=#e6db74>" and doesn't match range "</color>
                <color=#f92672>+</color> <color=#f8f8f2>range</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/* For unit test support. Index needs to be quiescent */</color>
  <color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"null"</color><color=#f8f8f2>)</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>boolean</color> <color=#a6e22e>verify</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>verbose</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>verify</color><color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>dbRange</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>ArrayList</color><color=#f92672><</color><color=#f8f8f2>VLSN</color><color=#f92672>></color> <color=#f8f8f2>firstVLSN</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ArrayList</color><color=#f92672><</color><color=#f8f8f2>VLSN</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>ArrayList</color><color=#f92672><</color><color=#f8f8f2>VLSN</color><color=#f92672>></color> <color=#f8f8f2>lastVLSN</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ArrayList</color><color=#f92672><</color><color=#f8f8f2>VLSN</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color> <color=#f92672>=</color> <color=#f8f8f2>BasicLocker</color><color=#f8f8f2>.</color><color=#a6e22e>createBasicLocker</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Synchronize so we don't try to verify while the checkpointer</color>
<color=#75715e>     * thread is calling flushToDatabase on the vlsnIndex.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>flushSynchronizer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * Read the on-disk range and buckets.</color>
<color=#75715e>       * -The tracker and the database buckets should not intersect.</color>
<color=#75715e>       * -The on-disk range should be a subset of the tracker range.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#f8f8f2>makeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>locker</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DatabaseEntry</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Read the on-disk range and all the buckets.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>OperationStatus</color> <color=#f8f8f2>status</color> <color=#f92672>=</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>status</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>VLSNRangeBinding</color> <color=#f8f8f2>rangeBinding</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSNRangeBinding</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>dbRange</color> <color=#f92672>=</color> <color=#f8f8f2>rangeBinding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToObject</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>

          <color=#75715e>/* Collect info about the  buckets. */</color>
          <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>LockMode</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>OperationStatus</color><color=#f8f8f2>.</color><color=#a6e22e>SUCCESS</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>bucket</color> <color=#f92672>=</color> <color=#f8f8f2>VLSNBucket</color><color=#f8f8f2>.</color><color=#a6e22e>readFromDatabase</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>Long</color> <color=#f8f8f2>keyValue</color> <color=#f92672>=</color> <color=#f8f8f2>LongBinding</color><color=#f8f8f2>.</color><color=#a6e22e>entryToLong</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>);</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>().</color><color=#a6e22e>getSequence</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>keyValue</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>

            <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>());</color>
            <color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>bucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLast</color><color=#f8f8f2>());</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cursor</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>cursor</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>locker</color><color=#f8f8f2>.</color><color=#a6e22e>operationEnd</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Verify range.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>VLSNRange</color> <color=#f8f8f2>trackerRange</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>trackerRange</color><color=#f8f8f2>.</color><color=#a6e22e>verifySubset</color><color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>,</color> <color=#f8f8f2>dbRange</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>firstTracked</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getFirstTracked</color><color=#f8f8f2>();</color>

    <color=#75715e>/* The db range and the buckets need to be consistent. */</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>firstOnDisk</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>lastOnDisk</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* There are buckets in the database. */</color>
      <color=#f8f8f2>lastOnDisk</color> <color=#f92672>=</color> <color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>lastVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>firstOnDisk</color> <color=#f92672>=</color> <color=#f8f8f2>firstVLSN</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>VLSNTracker</color><color=#f8f8f2>.</color><color=#a6e22e>verifyBucketBoundaries</color><color=#f8f8f2>(</color><color=#f8f8f2>firstVLSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastVLSN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * A VLSNIndex invariant is that there is always a mapping for the</color>
<color=#75715e>       * first and last VLSN in the range.  However, if the log cleaner</color>
<color=#75715e>       * lops off the head of the index, leaving a bucket gap at the</color>
<color=#75715e>       * beginning of the index, we break this invariant. For example,</color>
<color=#75715e>       * suppose the index has</color>
<color=#75715e>       *</color>
<color=#75715e>       * bucketA - VLSNs 10</color>
<color=#75715e>       * no bucket, due to out of order mapping - VLSN 11, 12</color>
<color=#75715e>       * bucket B - VLSNs 13-15</color>
<color=#75715e>       *</color>
<color=#75715e>       * If the cleaner deletes VLSN 10->11, VLSN 12 will be the start</color>
<color=#75715e>       * of the range, and needs a bucket. We'll do this by adding a</color>
<color=#75715e>       * bucket placeholder.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbRange</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>().</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>firstOnDisk</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>dumpMsg</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>verbose</color><color=#f8f8f2>,</color> <color=#e6db74>"Range doesn't match buckets "</color> <color=#f92672>+</color> <color=#f8f8f2>dbRange</color> <color=#f92672>+</color> <color=#e6db74>" firstOnDisk = "</color> <color=#f92672>+</color> <color=#f8f8f2>firstOnDisk</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* The tracker should know what the last VLSN on disk is. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>lastOnDisk</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getLastOnDisk</color><color=#f8f8f2>()))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>dumpMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>,</color> <color=#e6db74>"lastOnDisk="</color> <color=#f92672>+</color> <color=#f8f8f2>lastOnDisk</color> <color=#f92672>+</color> <color=#e6db74>" tracker="</color> <color=#f92672>+</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getLastOnDisk</color><color=#f8f8f2>());</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>firstTracked</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>NULL_VLSN</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * The last bucket VLSN should precede the first tracker VLSN.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstTracked</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>lastOnDisk</color><color=#f8f8f2>.</color><color=#a6e22e>getNext</color><color=#f8f8f2>())</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dumpMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>,</color> <color=#e6db74>"lastOnDisk="</color> <color=#f92672>+</color> <color=#f8f8f2>lastOnDisk</color> <color=#f92672>+</color> <color=#e6db74>" firstTracked="</color> <color=#f92672>+</color> <color=#f8f8f2>firstTracked</color><color=#f8f8f2>);</color>
          <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>dumpMsg</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>verbose</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>msg</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>verbose</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#f8f8f2>msg</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * For unit test support only. Can only be called when replication stream</color>
<color=#75715e>   * is quiescent.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isFlushedToDisk</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>isFlushedToDisk</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Ensure that the in-memory vlsn index encompasses all logged entries before it is flushed to</color>
<color=#75715e>   * disk. A No-Op for non-replicated systems.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The problem is in the interaction of logging and VLSN tracking. Allocating an new VLSN and</color>
<color=#75715e>   * logging a replicated log entry is done within the log write latch, without any VLSNINdex</color>
<color=#75715e>   * synchronization. That must be done to keep the log write latch critical section as small as</color>
<color=#75715e>   * possible, and to avoid any lock hiearchy issues.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The VLSNIndex is updated after the log write latch critical section. The VLSNIndex is</color>
<color=#75715e>   * flushed to disk by checkpoint, and it is assumed that this persistent version of the index</color>
<color=#75715e>   * encompasses all VLSN entries prior to checkpoint start. Since the logging of a new VLSN, and</color>
<color=#75715e>   * the flushing of the index are not atomic, it's possible that the checkpointer may start the</color>
<color=#75715e>   * flush of the vlsnIndex before the last vlsn's mapping is recorded in the index. To obey the</color>
<color=#75715e>   * requirement that the checkpointed vlsn index encompass all mappings < checkpoint start, check</color>
<color=#75715e>   * that the vlsn index is up to date before the flush. [#19754]</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>awaitConsistency() works by using the same waitForVLSN() method used by the Feeders.</color>
<color=#75715e>   * WaitForVLSN asserts that all feeders are waiting on single vlsn, to assure that no feeders are</color>
<color=#75715e>   * left in limbo, awaiting a vlsn that has gone by. This contract is valid for the feeders,</color>
<color=#75715e>   * because they wait for vlsns sequentially, consuming each one by one. However, this ckpter</color>
<color=#75715e>   * awaitConsistency functionality uses the nextVLSNCounter, which can leapfrog ahead arbitrarily,</color>
<color=#75715e>   * in this case:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>vlsn range holds 1 -> N-1 Feeder is present, awaiting vlsn N thread A bumps vlsn to N and</color>
<color=#75715e>   * writes record under log write latch thread B bumps vlsn to N + 1 and writes record under log</color>
<color=#75715e>   * write latch ckpter awaits consistency, using N+1, while feeders are awaiting N thread A puts</color>
<color=#75715e>   * VLSN N outside log write latch thread B puts VLSN N+1 outside log write latch</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Because of this, the ckpter must distinguish between what it is really waiting on (VLSN N+1)</color>
<color=#75715e>   * and what is can next wait on to fulfil the feeder waiting contract (VLSN N)</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>awaitConsistency</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* VLSNIndex is not initialized and in use yet, no need to wait. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nextVLSNCounter</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsnAllocatedBeforeCkpt</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>VLSN</color> <color=#f8f8f2>endOfRangePlusOne</color><color=#f8f8f2>;</color>
    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If we retry, get a fresh VLSN value if and only if the</color>
<color=#75715e>       * previously determined vlsnAllocatedBeforeCkpt was decremented</color>
<color=#75715e>       * due to a logging failure.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnAllocatedBeforeCkpt</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>vlsnAllocatedBeforeCkpt</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>getLatestAllocatedVal</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>VLSN</color> <color=#f8f8f2>latestAllocated</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>getLatestAllocatedVal</color><color=#f8f8f2>());</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>latestAllocated</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsnAllocatedBeforeCkpt</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>info</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
              <color=#e6db74>"Reducing awaitConsistency VLSN from "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>vlsnAllocatedBeforeCkpt</color>
                  <color=#f92672>+</color> <color=#e6db74>" to "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>latestAllocated</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>vlsnAllocatedBeforeCkpt</color> <color=#f92672>=</color> <color=#f8f8f2>latestAllocated</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * [#20165] Since the await is based on the nextVLSNCounter, it's</color>
<color=#75715e>       * possible that a feeder is already waiting on earlier VLSN.</color>
<color=#75715e>       * Safeguard against that by only waiting for one more than</color>
<color=#75715e>       * the end of the range, to avoid conflict with feeders.</color>
<color=#75715e>       * See method comments.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>endOfRangePlusOne</color> <color=#f92672>=</color> <color=#f8f8f2>tracker</color><color=#f8f8f2>.</color><color=#a6e22e>getRange</color><color=#f8f8f2>().</color><color=#a6e22e>getLast</color><color=#f8f8f2>().</color><color=#a6e22e>getNext</color><color=#f8f8f2>();</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnAllocatedBeforeCkpt</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>endOfRangePlusOne</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * All vlsns allocated before the checkpoint are now in the</color>
<color=#75715e>         * range.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>isLoggable</color><color=#f8f8f2>(</color><color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>FINE</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>fine</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#e6db74>"awaitConsistency target="</color>
                <color=#f92672>+</color> <color=#f8f8f2>endOfRangePlusOne</color>
                <color=#f92672>+</color> <color=#e6db74>" allocatedBeforeCkpt="</color>
                <color=#f92672>+</color> <color=#f8f8f2>vlsnAllocatedBeforeCkpt</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>waitForVLSN</color><color=#f8f8f2>(</color><color=#f8f8f2>endOfRangePlusOne</color><color=#f8f8f2>,</color> <color=#f8f8f2>AWAIT_CONSISTENCY_MS</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>endOfRangePlusOne</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsnAllocatedBeforeCkpt</color><color=#f8f8f2>)</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* We reached the real target. */</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We got to the VLSN we waited for, but it's still earlier than</color>
<color=#75715e>         * vlsnAllocatedBeforeCkpt. Loop again.</color>
<color=#75715e>         */</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>WaitTimeOutException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>severe</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#e6db74>"Retrying for vlsn index consistency "</color>
                <color=#f92672>+</color> <color=#e6db74>" before checkpoint, awaiting vlsn "</color>
                <color=#f92672>+</color> <color=#f8f8f2>endOfRangePlusOne</color>
                <color=#f92672>+</color> <color=#e6db74>" with ckpt consistency target of "</color>
                <color=#f92672>+</color> <color=#f8f8f2>vlsnAllocatedBeforeCkpt</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>InterruptedException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>severe</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>logger</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
            <color=#e6db74>"Interrupted while awaiting vlsn index "</color>
                <color=#f92672>+</color> <color=#e6db74>"consistency before checkpoint, awaiting "</color>
                <color=#f92672>+</color> <color=#e6db74>"vlsn "</color>
                <color=#f92672>+</color> <color=#f8f8f2>endOfRangePlusOne</color>
                <color=#f92672>+</color> <color=#e6db74>" with ckpt consistency target of "</color>
                <color=#f92672>+</color> <color=#f8f8f2>vlsnAllocatedBeforeCkpt</color>
                <color=#f92672>+</color> <color=#e6db74>", will retry"</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If the environment was invalidated by other activity, get out of</color>
<color=#75715e>       * this loop because the vlsn we are waiting for may never</color>
<color=#75715e>       * come. Re-throw the invalidating exception to indicate that the</color>
<color=#75715e>       * checkpoint did not succeed. [#20919]</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>checkIfInvalid</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>void</color> <color=#a6e22e>setGTEHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color><color=#f92672><?></color> <color=#f8f8f2>hook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>searchGTEHook</color> <color=#f92672>=</color> <color=#f8f8f2>hook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** A cursor over the VLSNIndex. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>abstract</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>VLSNScanner</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>VLSNIndex</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This is purely for assertions. The VLSNScanner assumes that</color>
<color=#75715e>     * getStartingLsn() is called once before getLsn() is called.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>startingLsnInvocations</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>VLSNScanner</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSNIndex</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>vlsnIndex</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>startingLsnInvocations</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#66d9ef>abstract</color> <color=#66d9ef>long</color> <color=#a6e22e>getStartingLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * @param vlsn We're requesting a LSN mapping for this vlsn</color>
<color=#75715e>     * @return If there is a mapping for this VLSN, return it, else return NULL_LSN. We assume that</color>
<color=#75715e>     *     we checked that this VLSN is in the VLSNIndex's range.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>abstract</color> <color=#66d9ef>long</color> <color=#a6e22e>getPreciseLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Assumes that VLSNs are scanned backwards. May be used by syncup to optimally search for</color>
<color=#75715e>   * matchpoints.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>BackwardVLSNScanner</color> <color=#66d9ef>extends</color> <color=#f8f8f2>VLSNScanner</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>public</color> <color=#a6e22e>BackwardVLSNScanner</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSNIndex</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Use the >= mapping for the requested VLSN to find the starting lsn</color>
<color=#75715e>     * to use for a scan. This can only be used on a VLSN that is known to</color>
<color=#75715e>     * be in the range.</color>
<color=#75715e>     */</color>
    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getStartingLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>startingLsnInvocations</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>currentBucket</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getGTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getGTELsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/** @see VLSNScanner#getPreciseLsn */</color>
    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getPreciseLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>startingLsnInvocations</color> <color=#f92672>==</color> <color=#ae81ff>1</color>
          <color=#f8f8f2>:</color> <color=#e6db74>"startingLsns() called "</color> <color=#f92672>+</color> <color=#f8f8f2>startingLsnInvocations</color> <color=#f92672>+</color> <color=#e6db74>" times"</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Ideally, we have a bucket that has the mappings for this VLSN.</color>
<color=#75715e>       * If we don't, we attempt to get the next applicable bucket.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentBucket</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * This bucket doesn't own the VLSN. Is it because (a)</color>
<color=#75715e>           * there's a gap and two buckets don't abut, or (b) because</color>
<color=#75715e>           * we walked off the end of the current bucket, and we need</color>
<color=#75715e>           * a new one? Distinguish case (a) by seeing if the current</color>
<color=#75715e>           * bucket will be needed for an upcoming VLSN.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>precedes</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Case B: We've walked off the end of the current</color>
<color=#75715e>           * bucket.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>currentBucket</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We walked off the end of the currentBucket. Get a new bucket,</color>
<color=#75715e>       * finding the closest bucket that would hold this mapping.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentBucket</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>currentBucket</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getLTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * The next bucket doesn't own this vlsn, which means that</color>
<color=#75715e>         * we're in a gap between two buckets.  Note:</color>
<color=#75715e>         * vlsnIndex.LTEBucket guards against returning null.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#e6db74>"vlsn = "</color> <color=#f92672>+</color> <color=#f8f8f2>vlsn</color> <color=#f92672>+</color> <color=#e6db74>" currentBucket="</color> <color=#f92672>+</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>;</color>

      <color=#75715e>/* We're in the right bucket. */</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Disable critical eviction for all VLSNIndex cursors. [#18475] An improvement would be to enable</color>
<color=#75715e>   * eviction, and do all database operations that are in a loop asynchronously.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>Cursor</color> <color=#a6e22e>makeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>Locker</color> <color=#f8f8f2>locker</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>Cursor</color> <color=#f8f8f2>cursor</color> <color=#f92672>=</color> <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>makeCursor</color><color=#f8f8f2>(</color><color=#f8f8f2>mappingDbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>locker</color><color=#f8f8f2>,</color> <color=#f8f8f2>CursorConfig</color><color=#f8f8f2>.</color><color=#a6e22e>DEFAULT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>getCursorImpl</color><color=#f8f8f2>(</color><color=#f8f8f2>cursor</color><color=#f8f8f2>).</color><color=#a6e22e>setAllowEviction</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>cursor</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Scans VLSNs in a forward direction, used by feeders. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>ForwardVLSNScanner</color> <color=#66d9ef>extends</color> <color=#f8f8f2>VLSNScanner</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>public</color> <color=#a6e22e>ForwardVLSNScanner</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSNIndex</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Use the <= mapping to the requested VLSN to find the starting lsn to use for a scan. This can</color>
<color=#75715e>     * only be used on a VLSN that is known to be in the range.</color>
<color=#75715e>     */</color>
    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getStartingLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>startingLsnInvocations</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>currentBucket</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getLTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLTELsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/** @see VLSNScanner#getPreciseLsn */</color>
    <color=#a6e22e>@Override</color>
    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getPreciseLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/* approximate */</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * When doing an approximate search, the target vlsn may be a non-mapped vlsn within a bucket,</color>
<color=#75715e>     * or it may be between two different buckets. For example, suppose we have two buckets:</color>
<color=#75715e>     *</color>
<color=#75715e>     * <p>vlsn 1 -> lsn 10 vlsn 5 -> lsn 50 vlsn 7 -> lsn 70</color>
<color=#75715e>     *</color>
<color=#75715e>     * <p>vlsn 20 -> lsn 120 vlsn 25 -> lsn 125</color>
<color=#75715e>     *</color>
<color=#75715e>     * <p>If the vlsn we are looking for is 4, the LTE lsn for an approximate return value will be</color>
<color=#75715e>     * vlsn 1-> lsn 10, in the same bucket. If we are looking for vlsn 9, the LTE lsn for an</color>
<color=#75715e>     * approximate return value will be vlsn 7->lsn 70, which is the last mapping in an earlier</color>
<color=#75715e>     * bucket.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param vlsn We're requesting a LSN mapping for this vlsn</color>
<color=#75715e>     * @return If there is a mapping for this VLSN, return it. If it does not exist, return the</color>
<color=#75715e>     *     nearest non-null mapping, where nearest the <= LSN. We assume that we checked that this</color>
<color=#75715e>     *     VLSN is in the VLSNIndex's range.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getApproximateLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/* approximate */</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>approximate</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>startingLsnInvocations</color> <color=#f92672>==</color> <color=#ae81ff>1</color>
          <color=#f8f8f2>:</color> <color=#e6db74>"startingLsns() called "</color> <color=#f92672>+</color> <color=#f8f8f2>startingLsnInvocations</color> <color=#f92672>+</color> <color=#e6db74>" times"</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>debugBucket</color> <color=#f92672>=</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Ideally, we have a bucket that has the mappings for this VLSN.</color>
<color=#75715e>       * If we don't, we attempt to get the next applicable bucket.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentBucket</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * This bucket doesn't own the VLSN. Is it because (a)</color>
<color=#75715e>           * there's a gap and two buckets don't abut, or (b) because</color>
<color=#75715e>           * we walked off the end of the current bucket, and we need</color>
<color=#75715e>           * a new one? Distinguish case (a) by seeing if the current</color>
<color=#75715e>           * bucket will be needed for an upcoming VLSN.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>follows</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#75715e>/* Case A: No bucket available for this VLSN. */</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>approximate</color> <color=#f92672>?</color> <color=#f8f8f2>findPrevLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/* Case B: We've walked off the end of the bucket. */</color>
          <color=#f8f8f2>currentBucket</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * We walked off the end of the currentBucket. Get a new bucket,</color>
<color=#75715e>       * finding the closest bucket that would hold this mapping.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentBucket</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>currentBucket</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getGTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>debugBucket</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * The next bucket doesn't own this vlsn, which means that</color>
<color=#75715e>         * we're in a gap between two buckets. Note:</color>
<color=#75715e>         * vlsnIndex.getGTEBucket guards against returning null.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>approximate</color> <color=#f92672>?</color> <color=#f8f8f2>findPrevLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#e6db74>"vlsn = "</color> <color=#f92672>+</color> <color=#f8f8f2>vlsn</color> <color=#f92672>+</color> <color=#e6db74>" currentBucket="</color> <color=#f92672>+</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>approximate</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We're in the right bucket, and it owns this</color>
<color=#75715e>         * VLSN. Nevertheless, the bucket may or may not contain a</color>
<color=#75715e>         * mapping for this VLSN, so return the LTE version mapping.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLTELsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>vlsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Find the lsn mapping that precedes the target. This assumes that</color>
<color=#75715e>     * no bucket owns the target vlsn -- that it's a vlsn that falls</color>
<color=#75715e>     * between buckets.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>findPrevLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>VLSN</color> <color=#f8f8f2>target</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>VLSNBucket</color> <color=#f8f8f2>prevBucket</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnIndex</color><color=#f8f8f2>.</color><color=#a6e22e>getLTEBucket</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>);</color>
      <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>prevBucket</color><color=#f8f8f2>.</color><color=#a6e22e>owns</color><color=#f8f8f2>(</color><color=#f8f8f2>target</color><color=#f8f8f2>)</color>
          <color=#f8f8f2>:</color> <color=#e6db74>"target="</color> <color=#f92672>+</color> <color=#f8f8f2>target</color> <color=#f92672>+</color> <color=#e6db74>"prevBucket="</color> <color=#f92672>+</color> <color=#f8f8f2>prevBucket</color> <color=#f92672>+</color> <color=#e6db74>" currentBucket="</color> <color=#f92672>+</color> <color=#f8f8f2>currentBucket</color><color=#f8f8f2>;</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>prevBucket</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLsn</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Associates the logItem with the latch, so that it's readily available when the latch is</color>
<color=#75715e>   * released.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>VLSNAwaitLatch</color> <color=#66d9ef>extends</color> <color=#f8f8f2>CountDownLatch</color> <color=#f8f8f2>{</color>
    <color=#75715e>/* The LogItem whose addition to the VLSN released the latch. */</color>
    <color=#66d9ef>private</color> <color=#f8f8f2>LogItem</color> <color=#f8f8f2>logItem</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>terminated</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>public</color> <color=#a6e22e>VLSNAwaitLatch</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getTriggerLSN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>lsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#f8f8f2>VLSN</color> <color=#a6e22e>getTriggerVLSN</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>.</color><color=#a6e22e>header</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setLogItem</color><color=#f8f8f2>(</color><color=#f8f8f2>LogItem</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>logItem</color> <color=#f92672>=</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Returns the log item that caused the latch to be released. It's only meaningful after the</color>
<color=#75715e>     * latch has been released.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return log item or null if the latch timed out or it's wait was terminated</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#f8f8f2>LogItem</color> <color=#a6e22e>getLogItem</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>logItem</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Free up any waiters on this latch and shutdown. */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>terminate</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>terminated</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>countDown</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isTerminated</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>terminated</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * An exception primarily intended to implement non-local control flow</color>
<color=#75715e>   * upon a vlsn wait latch timeout.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@SuppressWarnings</color><color=#f8f8f2>(</color><color=#e6db74>"serial"</color><color=#f8f8f2>)</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>WaitTimeOutException</color> <color=#66d9ef>extends</color> <color=#f8f8f2>Exception</color> <color=#f8f8f2>{</color>

    <color=#a6e22e>@Override</color>
    <color=#75715e>/* Eliminate unnecessary overhead. */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#f8f8f2>Throwable</color> <color=#a6e22e>fillInStackTrace</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>