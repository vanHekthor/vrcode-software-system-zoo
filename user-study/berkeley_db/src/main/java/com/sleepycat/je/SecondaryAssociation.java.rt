<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.util.Collection</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * @hidden For internal use only.</color>
<color=#75715e> *     <p>Provides a way to create an association between primary and secondary databases that is</color>
<color=#75715e> *     not limited to a one-to-many association.</color>
<color=#75715e> *     <p>By implementing this interface, a secondary database may be associated with one or more</color>
<color=#75715e> *     primary databases. For example, imagine an application that wishes to partition data from a</color>
<color=#75715e> *     single logical "table" into multiple primary databases to take advantage of the performance</color>
<color=#75715e> *     benefits of {@link Environment#removeDatabase} for a single partition, while at the same</color>
<color=#75715e> *     having a single index database for the entire "table". For read operations via a secondary</color>
<color=#75715e> *     database, JE reads the primary key from the secondary database and then must read the primary</color>
<color=#75715e> *     record from the primary database. The mapping from a primary key to its primary database is</color>
<color=#75715e> *     performed by the user's implementation of the {@link #getPrimary} method.</color>
<color=#75715e> *     <p>In addition, a primary database may be divided into subsets of keys where each subset may</color>
<color=#75715e> *     be efficiently indexed by zero or more secondary databases. This effectively allows multiple</color>
<color=#75715e> *     logical "tables" per primary database. When a primary record is written, the secondaries for</color>
<color=#75715e> *     its logical "table" are returned by the user's implementation of {@link #getSecondaries}.</color>
<color=#75715e> *     During a primary record write, because {@link #getSecondaries} is called to determine the</color>
<color=#75715e> *     secondary databases, only the key creators/extractors for those secondaries are invoked. For</color>
<color=#75715e> *     example, if you have a single primary database with 10 logical "tables", each of which has 5</color>
<color=#75715e> *     distinct secondary databases, when a record is written only 5 key creators/extractors will be</color>
<color=#75715e> *     invoked, not 50.</color>
<color=#75715e> *     <p><b>Configuring a SecondaryAssociation</b></color>
<color=#75715e> *     <p>When primary and secondary databases are associated using a {@code SecondaryAssociation},</color>
<color=#75715e> *     the databases must all be configured with the same {@code SecondaryAssociation} instance. A</color>
<color=#75715e> *     common error is to forget to configure the {@code SecondaryAssociation} on the primary</color>
<color=#75715e> *     database.</color>
<color=#75715e> *     <p>A {@code SecondaryAssociation} is configured using {@link</color>
<color=#75715e> *     DatabaseConfig#setSecondaryAssociation} and {@link SecondaryConfig#setSecondaryAssociation}</color>
<color=#75715e> *     for a primary and secondary database, respectively. When calling {@link</color>
<color=#75715e> *     Environment#openSecondaryDatabase}, null must be passed for the primaryDatabase parameter</color>
<color=#75715e> *     when a {@code SecondaryAssociation} is configured.</color>
<color=#75715e> *     <p>Note that when a {@code SecondaryAssociation} is configured, {@code true} may not be</color>
<color=#75715e> *     passed to the {@link SecondaryConfig#setAllowPopulate} method. Population of new secondary</color>
<color=#75715e> *     databases in an existing {@code SecondaryAssociation} is done differently, as described</color>
<color=#75715e> *     below.</color>
<color=#75715e> *     <p><b>Adding and removing secondary associations</b></color>
<color=#75715e> *     <p>The state information defining the association between primary and secondary databases is</color>
<color=#75715e> *     maintained by the application, and made available to JE by implementing the {@code</color>
<color=#75715e> *     SecondaryAssociation} interface. The application may add/remove databases to/from the</color>
<color=#75715e> *     association without any explicit coordination with JE. However, certain rules need to be</color>
<color=#75715e> *     followed to maintain data integrity.</color>
<color=#75715e> *     <p>In the simplest case, there is a fixed (never changing) set of primary and secondary</color>
<color=#75715e> *     databases and they are added to the association at the time they are created, before writing</color>
<color=#75715e> *     or reading records. In this case, since reads and writes do not occur concurrently with</color>
<color=#75715e> *     changes to the association, no special rules are needed. For example:</color>
<color=#75715e> *     <ol></color>
<color=#75715e> *       <li>Open the databases.</color>
<color=#75715e> *       <li>Add databases to the association.</color>
<color=#75715e> *       <li>Begin writing and reading.</color>
<color=#75715e> *     </ol></color>
<color=#75715e> *     <p>In other cases, primary and secondary databases may be added to an already established</color>
<color=#75715e> *     association, along with concurrent reads and writes. The rules for doing so are described</color>
<color=#75715e> *     below.</color>
<color=#75715e> *     <p>Adding an empty (newly created) primary database is no more complex than in the simple</color>
<color=#75715e> *     case above, assuming that writes to the primary database do not proceed until after it has</color>
<color=#75715e> *     been added to the association.</color>
<color=#75715e> *     <ol></color>
<color=#75715e> *       <li>Open the new primary database.</color>
<color=#75715e> *       <li>Add the primary database to the association such that {@link #getSecondaries} returns</color>
<color=#75715e> *           the appropriate list when passed a key in the new primary database, and {@link</color>
<color=#75715e> *           #getPrimary} returns the new database when passed a key it contains.</color>
<color=#75715e> *       <li>Begin writing to the new primary database.</color>
<color=#75715e> *     </ol></color>
<color=#75715e> *     <p>Using the procedure above for adding a primary database, records will be indexed in</color>
<color=#75715e> *     secondary databases as they are added to the primary database, and will be immediately</color>
<color=#75715e> *     available to secondary index queries.</color>
<color=#75715e> *     <p>Alternatively, records can be added to the primary database without making them</color>
<color=#75715e> *     immediately available to secondary index queries by using the following procedure. Records</color>
<color=#75715e> *     will be indexed in secondary databases as they are added but will not be returned by</color>
<color=#75715e> *     secondary queries until after the last step.</color>
<color=#75715e> *     <ol></color>
<color=#75715e> *       <li>Open the new primary database.</color>
<color=#75715e> *       <li>Modify the association such that {@link #getSecondaries} returns the appropriate list</color>
<color=#75715e> *           when passed a key in the new primary database, but {@link #getPrimary} returns null</color>
<color=#75715e> *           when passed a key it contains.</color>
<color=#75715e> *       <li>Write records in the new primary database.</color>
<color=#75715e> *       <li>Modify the association such that {@link #getPrimary} returns the new database when</color>
<color=#75715e> *           passed a key it contains.</color>
<color=#75715e> *     </ol></color>
<color=#75715e> *     <p>The following procedure should be used for removing an existing (non-empty) primary</color>
<color=#75715e> *     database from an association.</color>
<color=#75715e> *     <ol></color>
<color=#75715e> *       <li>Remove the primary database from the association, such that {@link #getPrimary} returns</color>
<color=#75715e> *           null for all keys in the primary.</color>
<color=#75715e> *       <li>Disable read and write operations on the database and ensure that all in-progress</color>
<color=#75715e> *           operations have completed.</color>
<color=#75715e> *       <li>At this point the primary database may be closed and removed (e.g., with {@link</color>
<color=#75715e> *           Environment#removeDatabase}), if desired.</color>
<color=#75715e> *       <li>For each secondary database associated with the removed primary database, {@link</color>
<color=#75715e> *           SecondaryDatabase#deleteObsoletePrimaryKeys} should be called to process all secondary</color>
<color=#75715e> *           records.</color>
<color=#75715e> *       <li>At this point {@link #getPrimary} may throw an exception (rather than return null) when</color>
<color=#75715e> *           called for a primary key in the removed database, if desired.</color>
<color=#75715e> *     </ol></color>
<color=#75715e> *     <p>The following procedure should be used for adding a new (empty) secondary database to an</color>
<color=#75715e> *     association, and to populate the secondary incrementally from its associated primary</color>
<color=#75715e> *     database(s).</color>
<color=#75715e> *     <ol></color>
<color=#75715e> *       <li>Open the secondary database and call {@link</color>
<color=#75715e> *           SecondaryDatabase#startIncrementalPopulation}. The secondary may not be used (yet) for</color>
<color=#75715e> *           read operations.</color>
<color=#75715e> *       <li>Add the secondary database to the association, such that the collection returned by</color>
<color=#75715e> *           {@link #getSecondaries} includes the new database, for all primary keys that should be</color>
<color=#75715e> *           indexed.</color>
<color=#75715e> *       <li>For each primary database associated with the new secondary database, {@link</color>
<color=#75715e> *           Database#populateSecondaries} should be called to process all primary records.</color>
<color=#75715e> *       <li>Call {@link SecondaryDatabase#endIncrementalPopulation}. The secondary database may now</color>
<color=#75715e> *           be used for read operations.</color>
<color=#75715e> *     </ol></color>
<color=#75715e> *     <p>The following procedure should be used for removing an existing (non-empty) secondary</color>
<color=#75715e> *     database from an association.</color>
<color=#75715e> *     <ol></color>
<color=#75715e> *       <li>Remove the secondary database from the association, such that it is not included in the</color>
<color=#75715e> *           collection returned by {@link #getSecondaries}.</color>
<color=#75715e> *       <li>Disable read and write operations on the database and ensure that all in-progress</color>
<color=#75715e> *           operations have completed.</color>
<color=#75715e> *       <li>The secondary database may now be closed and removed, if desired.</color>
<color=#75715e> *     </ol></color>
<color=#75715e> *     <p><b>Other Implementation Requirements</b></color>
<color=#75715e> *     <p>The implementation must use data structures for storing and accessing association</color>
<color=#75715e> *     information that provide <em>happens-before</em> semantics. In other words, when the</color>
<color=#75715e> *     association is changed, other threads calling the methods in this interface must see the</color>
<color=#75715e> *     changes as soon as the change is complete.</color>
<color=#75715e> *     <p>The implementation should use non-blocking data structures to hold association information</color>
<color=#75715e> *     to avoid blocking on the methods in this interface, which may be frequently called from many</color>
<color=#75715e> *     threads.</color>
<color=#75715e> *     <p>The simplest way to meet the above two requirements is to use concurrent structures such</color>
<color=#75715e> *     as those provided in the java.util.concurrent package, e.g., ConcurrentHashMap.</color>
<color=#75715e> *     <p>For an example implementation, see:</color>
<color=#75715e> *     test/com/sleepycat/je/test/SecondaryAssociationTest.java</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>interface</color> <color=#a6e22e>SecondaryAssociation</color> <color=#f8f8f2>{</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Implementation note on concurrent access and latching.</color>
<color=#75715e>   *</color>
<color=#75715e>   * When adding/removing primary/secondary DBs to an existing association,</color>
<color=#75715e>   * concurrency issues arise.  This section explains how they are handled,</color>
<color=#75715e>   * assuming the rules described in the javadoc below are followed when a</color>
<color=#75715e>   * custom association is configured.</color>
<color=#75715e>   *</color>
<color=#75715e>   * There are two cases:</color>
<color=#75715e>   *</color>
<color=#75715e>   * 1) A custom association is NOT configured.  An internal association is</color>
<color=#75715e>   * created that manages the one-many association between a primary and its</color>
<color=#75715e>   * secondaries.</color>
<color=#75715e>   *</color>
<color=#75715e>   * 2) A custom association IS configured.  It is used internally.</color>
<color=#75715e>   *</color>
<color=#75715e>   * For case 1, no custom association, DB addition and removal take place in</color>
<color=#75715e>   * the Environment.openSecondaryDatabase and SecondaryDatabase.close</color>
<color=#75715e>   * methods, respectively.  These methods, and the changes to the internal</color>
<color=#75715e>   * association, are protected by acquiring the secondary latch</color>
<color=#75715e>   * (EnvironmentImpl.getSecondaryAssociationLock) exclusively.  All write</color>
<color=#75715e>   * operations that use the association -- puts and deletes -- acquire this</color>
<color=#75715e>   * latch shared.  Therefore, write operations and changes to the</color>
<color=#75715e>   * association do not take place concurrently.  Read operations via a</color>
<color=#75715e>   * secondary DB/cursor do not acquire this latch, so they can take place</color>
<color=#75715e>   * concurrently with changes to the association; however, read operations</color>
<color=#75715e>   * only call getPrimary and they expect it may return null at any time (the</color>
<color=#75715e>   * operation ignores the record in that case).  It is impossible to close</color>
<color=#75715e>   * a primary while it is being read via a secondary, because secondaries</color>
<color=#75715e>   * must be closed before their associated primary.  (And the application is</color>
<color=#75715e>   * responsible for finishing reads before closing any DB.)</color>
<color=#75715e>   *</color>
<color=#75715e>   * For case 2, a custom association, the secondary latch does not provide</color>
<color=#75715e>   * protection because modifications to the association take place in the</color>
<color=#75715e>   * application domain, not in the Environment.openSecondaryDatabase and</color>
<color=#75715e>   * SecondaryDatabase.close methods.  Instead, protection is provided by the</color>
<color=#75715e>   * rules described in the javadoc here. Namely:</color>
<color=#75715e>   *</color>
<color=#75715e>   *   Primary/secondary DBs are added to the association AFTER opening them</color>
<color=#75715e>   *   (of course).  The DBs will not be be accessed until they are added to</color>
<color=#75715e>   *   the association.</color>
<color=#75715e>   *</color>
<color=#75715e>   *   Primary/secondary DBs are removed from the association BEFORE closing</color>
<color=#75715e>   *   them.  The application is responsible for ensuring they are no longer</color>
<color=#75715e>   *   accessed before they are closed.</color>
<color=#75715e>   *</color>
<color=#75715e>   *   When a primary DB is added, its secondaries will be kept in sync as</color>
<color=#75715e>   *   soon as writing begins, since it must be added to the association</color>
<color=#75715e>   *   before writes are allowed.</color>
<color=#75715e>   *</color>
<color=#75715e>   *   When a secondary DB is added, the incremental population procedure</color>
<color=#75715e>   *   ensures that it is fully populated before being accessed.</color>
<color=#75715e>   */</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns true if there are no secondary databases in the association.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method is used by JE to optimize for the case where a primary has no secondary</color>
<color=#75715e>   * databases. This allows a {@code SecondaryAssociation} to be configured on a primary database</color>
<color=#75715e>   * even when it has no associated secondaries, with no added overhead, and to allow for the</color>
<color=#75715e>   * possibility that secondaries will be added later.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>For example, when a primary database has no secondaries, no internal latching is performed</color>
<color=#75715e>   * by JE during writes. JE determines that no secondaries are present by calling {@code isEmpty},</color>
<color=#75715e>   * prior to doing the write operation.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws RuntimeException if an unexpected problem occurs. The exception will be thrown to the</color>
<color=#75715e>   *     application, which should then take appropriate action.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>boolean</color> <color=#a6e22e>isEmpty</color><color=#f8f8f2>();</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the primary database for the given primary key. This method is called during read</color>
<color=#75715e>   * operations on secondary databases that are configured with this {@code SecondaryAssociation}.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method should return null when the primary database has been removed from the</color>
<color=#75715e>   * association, or when it should not be included in the results for secondary queries. In this</color>
<color=#75715e>   * case, the current operation will treat the secondary record as if it does not exist, i.e., it</color>
<color=#75715e>   * will be skipped over.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws RuntimeException if an unexpected problem occurs. The exception will be thrown to the</color>
<color=#75715e>   *     application, which should then take appropriate action.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>Database</color> <color=#a6e22e>getPrimary</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>primaryKey</color><color=#f8f8f2>);</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the secondary databases associated with the given primary key. This method is called</color>
<color=#75715e>   * during write operations on primary databases that are configured with this {@code</color>
<color=#75715e>   * SecondaryAssociation}.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws RuntimeException if an unexpected problem occurs. The exception will be thrown to the</color>
<color=#75715e>   *     application, which should then take appropriate action.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>Collection</color><color=#f92672><</color><color=#f8f8f2>SecondaryDatabase</color><color=#f92672>></color> <color=#a6e22e>getSecondaries</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseEntry</color> <color=#f8f8f2>primaryKey</color><color=#f8f8f2>);</color>
<color=#f8f8f2>}</color>