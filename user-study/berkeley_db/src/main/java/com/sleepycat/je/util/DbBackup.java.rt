<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.util</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.FileProtector</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.FileProtector.ProtectedActiveFileSet</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.cleaner.FileProtector.ProtectedFileRange</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.FileManager</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogEntryType</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.ReplicationContext</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.EmptyLogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.LogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.SingleItemEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.DbLsn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.TestHook</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.TestHookExecute</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.util.NavigableSet</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * DbBackup is a helper class for stopping and restarting JE background activity in an open</color>
<color=#75715e> * environment in order to simplify backup operations. It also lets the application create a backup</color>
<color=#75715e> * which can support restoring the environment to a specific point in time.</color>
<color=#75715e> *</color>
<color=#75715e> * <p><b>Backing up without DbBackup</b></color>
<color=#75715e> *</color>
<color=#75715e> * <p>Because JE has an append only log file architecture, it is always possible to do a hot backup</color>
<color=#75715e> * without the use of DbBackup by copying all log files (.jdb files) to your archival location. As</color>
<color=#75715e> * long as the log files are copied in alphabetical order, (numerical in effect) <i>and</i> all log</color>
<color=#75715e> * files are copied, the environment can be successfully backed up without any need to stop database</color>
<color=#75715e> * operations or background activity. This means that your backup operation must do a loop to check</color>
<color=#75715e> * for the creation of new log files before deciding that the backup is finished. For example:</color>
<color=#75715e> *</color>
<color=#75715e> * <pre></color>
<color=#75715e> * time    files in                    activity</color>
<color=#75715e> *         environment</color>
<color=#75715e> *</color>
<color=#75715e> *  t0     000000001.jdb     Backup starts copying file 1</color>
<color=#75715e> *         000000003.jdb</color>
<color=#75715e> *         000000004.jdb</color>
<color=#75715e> *</color>
<color=#75715e> *  t1     000000001.jdb     JE log cleaner migrates portion of file 3 to newly</color>
<color=#75715e> *         000000004.jdb     created file 5 and deletes file 3. Backup finishes</color>
<color=#75715e> *         000000005.jdb     file 1, starts copying file 4. Backup MUST include</color>
<color=#75715e> *                           file 5 for a consistent backup!</color>
<color=#75715e> *</color>
<color=#75715e> *  t2     000000001.jdb     Backup finishes copying file 4, starts and</color>
<color=#75715e> *         000000004.jdb     finishes file 5, has caught up. Backup ends.</color>
<color=#75715e> *         000000005.jdb</color>
<color=#75715e> * </pre></color>
<color=#75715e> *</color>
<color=#75715e> * <p>In the example above, the backup operation must be sure to copy file 5, which came into</color>
<color=#75715e> * existence after the backup had started. If the backup stopped operations at file 4, the backup</color>
<color=#75715e> * set would include only file 1 and 4, omitting file 3, which would be an inconsistent set.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Also note that log file 5 may not have filled up before it was copied to archival storage. On</color>
<color=#75715e> * the next backup, there might be a newer, larger version of file 5, and that newer version should</color>
<color=#75715e> * replace the older file 5 in archive storage.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Using the approach above, as opposed to using DbBackup, will copy all files including {@link</color>
<color=#75715e> * EnvironmentStats#getReservedLogSize reserved files} as well as {@link</color>
<color=#75715e> * EnvironmentStats#getActiveLogSize active files}. A large number of reserved files may be present</color>
<color=#75715e> * in an HA Environment, and they are essentially wasted space in a backup. Using DbBackup is</color>
<color=#75715e> * strongly recommended for this reason, as well as to reduce the complexity of file copying.</color>
<color=#75715e> *</color>
<color=#75715e> * <p><b>Backing up with DbBackup</b></color>
<color=#75715e> *</color>
<color=#75715e> * <p>DbBackup helps simplify application backup by defining the set of {@link</color>
<color=#75715e> * EnvironmentStats#getActiveLogSize active files} that must be copied for each backup operation. If</color>
<color=#75715e> * the environment directory has read/write protection, the application must pass DbBackup an open,</color>
<color=#75715e> * read/write environment handle.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When entering backup mode, JE determines the set of active files needed for a consistent</color>
<color=#75715e> * backup, and freezes all changes to those files. The application can copy that defined set of</color>
<color=#75715e> * files and finish operation without checking for the ongoing creation of new files. Also, there</color>
<color=#75715e> * will be no need to check for a newer version of the last file on the next backup.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>In the example above, if DbBackup was used at t0, the application would only have to copy</color>
<color=#75715e> * files 1, 3 and 4 to back up. On a subsequent backup, the application could start its copying at</color>
<color=#75715e> * file 5. There would be no need to check for a newer version of file 4.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When it is important to minimize the time that it takes to recover using a backup, a</color>
<color=#75715e> * checkpoint should be performed immediately before calling {@link #startBackup}. This will reduce</color>
<color=#75715e> * recovery time when opening the environment with the restored log files. A checkpoint is performed</color>
<color=#75715e> * explicitly by calling {@link Environment#checkpoint} using a config object for which {@link</color>
<color=#75715e> * CheckpointConfig#setForce setForce(true)} has been called.</color>
<color=#75715e> *</color>
<color=#75715e> * <p><b>Performing simple/full backups</b></color>
<color=#75715e> *</color>
<color=#75715e> * <p>The following examples shows how to perform a full backup. A checkpoint is performed to</color>
<color=#75715e> * minimize recovery time.</color>
<color=#75715e> *</color>
<color=#75715e> * <pre class="code"></color>
<color=#75715e> * void myBackup(Environment env, File destDir) {</color>
<color=#75715e> *     DbBackup backupHelper = new DbBackup(env);</color>
<color=#75715e> *</color>
<color=#75715e> *     // Optional: Do a checkpoint to reduce recovery time after a restore.</color>
<color=#75715e> *     env.checkpoint(new CheckpointConfig().setForce(true));</color>
<color=#75715e> *</color>
<color=#75715e> *     // Start backup, find out what needs to be copied.</color>
<color=#75715e> *     backupHelper.startBackup();</color>
<color=#75715e> *     try {</color>
<color=#75715e> *         // Copy the necessary files to archival storage.</color>
<color=#75715e> *         String[] filesToCopy = backupHelper.getLogFilesInBackupSet();</color>
<color=#75715e> *         myCopyFiles(env, backupHelper, filesToCopy, destDir);</color>
<color=#75715e> *     } finally {</color>
<color=#75715e> *         // Remember to exit backup mode, or the JE cleaner cannot delete</color>
<color=#75715e> *         // log files and disk usage will grow without bounds.</color>
<color=#75715e> *        backupHelper.endBackup();</color>
<color=#75715e> *     }</color>
<color=#75715e> * }</color>
<color=#75715e> *</color>
<color=#75715e> * void myCopyFiles(</color>
<color=#75715e> *     Environment env,</color>
<color=#75715e> *     DbBackup backupHelper,</color>
<color=#75715e> *     String[] filesToCopy,</color>
<color=#75715e> *     File destDir) {</color>
<color=#75715e> *</color>
<color=#75715e> *     for (String fileName : filesToCopy) {</color>
<color=#75715e> *         // Copy fileName to destDir.</color>
<color=#75715e> *         // See {@link LogVerificationReadableByteChannel} and</color>
<color=#75715e> *         // {@link LogVerificationInputStream}.</color>
<color=#75715e> *         ....</color>
<color=#75715e> *</color>
<color=#75715e> *         // Remove protection to allow file to be deleted in order to reclaim</color>
<color=#75715e> *         // disk space.</color>
<color=#75715e> *         backupHelper.removeFileProtection(fileName);</color>
<color=#75715e> *     }</color>
<color=#75715e> * }</color>
<color=#75715e> * </pre></color>
<color=#75715e> *</color>
<color=#75715e> * When copying files to the backup directory, it is critical that each file is verified before or</color>
<color=#75715e> * during the copy. If a file is copied that is corrupt (due to an earlier disk failure that went</color>
<color=#75715e> * unnoticed, for example), the backup will be invalid and provide a false sense of security.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The {@link LogVerificationInputStream example here} shows how to implement the {@code</color>
<color=#75715e> * myCopyFiles} method using {@link LogVerificationInputStream}. A {@link</color>
<color=#75715e> * LogVerificationReadableByteChannel} could also be used for higher performance copying. A filter</color>
<color=#75715e> * input stream is used to verify the file efficiently as it is being read. If you choose to use a</color>
<color=#75715e> * script for copying files, the {@link DbVerifyLog} command line tool can be used instead.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Assuming that the full backup copied files into an empty directory, to restore you can simply</color>
<color=#75715e> * copy these files back into another empty directory.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Always start with an empty directory as the destination for a full backup or a restore, to</color>
<color=#75715e> * ensure that no unused files are present. Unused files -- perhaps the residual of an earlier</color>
<color=#75715e> * environment or an earlier backup -- will take up space, and they will never be deleted by the JE</color>
<color=#75715e> * log cleaner. Also note that such files will not be used by JE for calculating utilization and</color>
<color=#75715e> * will not appear in the {@link DbSpace} output.</color>
<color=#75715e> *</color>
<color=#75715e> * <p><b>Performing incremental backups</b></color>
<color=#75715e> *</color>
<color=#75715e> * <p>Incremental backups are used to reduce the number of files copied during each backup. Compared</color>
<color=#75715e> * to a full backup, there are two additional pieces of information needed for an incremental</color>
<color=#75715e> * backup: the number of the last file in the previous backup, and a list of the active files in the</color>
<color=#75715e> * environment directory at the time of the current backup, i.e., the current snapshot. Their</color>
<color=#75715e> * purpose is explained below.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The number of the last file in the previous backup is used to avoid copying files that are</color>
<color=#75715e> * already present in the backup set. This file number must be obtained before beginning the backup,</color>
<color=#75715e> * either by checking the backup archive, or getting this value from a stored location. For example,</color>
<color=#75715e> * the last file number could be written to a special file in the backup set at the time of a</color>
<color=#75715e> * backup, and then read from the special file before starting the next backup.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The list of files in the current snapshot, which should be obtained by calling {@link</color>
<color=#75715e> * #getLogFilesInSnapshot} (after calling {@link #startBackup}), is used to avoid unused files after</color>
<color=#75715e> * a restore, and may also be used to reduce the size of the backup set. How to use this list is</color>
<color=#75715e> * described below.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Some applications need the ability to restore to the point in time of any of the incremental</color>
<color=#75715e> * backups that were made in the past, and other applications only need to restore to the point in</color>
<color=#75715e> * time of the most recent backup. Accordingly, the list of current files (that is made at the time</color>
<color=#75715e> * of the backup), should be used in one of two ways.</color>
<color=#75715e> *</color>
<color=#75715e> * <ol></color>
<color=#75715e> *   <li>If you only need to restore to the point in time of the most recent backup, then the list</color>
<color=#75715e> *       should be used to delete unused files from the backup set. After copying all files during</color>
<color=#75715e> *       the backup, any file that is <em>not</em> present in the list may then be deleted from the</color>
<color=#75715e> *       backup set. This both reduces the size of the backup set, and ensures that unused files</color>
<color=#75715e> *       will not be present in the backup set and therefore will not be restored.</color>
<color=#75715e> *   <li>If you need to keep all log files from each backup so you can restore to more than one</color>
<color=#75715e> *       point in time, then the list for each backup should be saved with the backup file set so it</color>
<color=#75715e> *       can be used during a restore. During the restore, only the files in the list should be</color>
<color=#75715e> *       copied, starting with an empty destination directory. This ensures that unused files will</color>
<color=#75715e> *       not be restored.</color>
<color=#75715e> * </ol></color>
<color=#75715e> *</color>
<color=#75715e> * <p>The following two examples shows how to perform an incremental backup. In the first example,</color>
<color=#75715e> * the list of current files is used to delete files from the backup set that are no longer needed.</color>
<color=#75715e> *</color>
<color=#75715e> * <pre class="code"></color>
<color=#75715e> * void myBackup(Environment env, File destDir) {</color>
<color=#75715e> *</color>
<color=#75715e> *     // Get the file number of the last file in the previous backup.</color>
<color=#75715e> *     long lastFileInPrevBackup =  ...</color>
<color=#75715e> *</color>
<color=#75715e> *     DbBackup backupHelper = new DbBackup(env, lastFileInPrevBackup);</color>
<color=#75715e> *</color>
<color=#75715e> *     // Optional: Do a checkpoint to reduce recovery time after a restore.</color>
<color=#75715e> *     env.checkpoint(new CheckpointConfig().setForce(true));</color>
<color=#75715e> *</color>
<color=#75715e> *     // Start backup, find out what needs to be copied.</color>
<color=#75715e> *     backupHelper.startBackup();</color>
<color=#75715e> *     try {</color>
<color=#75715e> *         // Copy the necessary files to archival storage.</color>
<color=#75715e> *         String[] filesToCopy = backupHelper.getLogFilesInBackupSet();</color>
<color=#75715e> *         myCopyFiles(env, backupHelper, filesToCopy, destDir);</color>
<color=#75715e> *</color>
<color=#75715e> *         // Delete files that are no longer needed.</color>
<color=#75715e> *         // WARNING: This should only be done after copying all new files.</color>
<color=#75715e> *         String[] filesInSnapshot = backupHelper.getLogFilesInSnapshot();</color>
<color=#75715e> *         myDeleteUnusedFiles(destDir, filesInSnapshot);</color>
<color=#75715e> *</color>
<color=#75715e> *         // Update knowledge of last file saved in the backup set.</color>
<color=#75715e> *         lastFileInPrevBackup = backupHelper.getLastFileInBackupSet();</color>
<color=#75715e> *         // Save lastFileInPrevBackup persistently here ...</color>
<color=#75715e> *     } finally {</color>
<color=#75715e> *         // Remember to exit backup mode, or the JE cleaner cannot delete</color>
<color=#75715e> *         // log files and disk usage will grow without bounds.</color>
<color=#75715e> *        backupHelper.endBackup();</color>
<color=#75715e> *     }</color>
<color=#75715e> * }</color>
<color=#75715e> *</color>
<color=#75715e> * void myDeleteUnusedFiles(File destDir, String[] filesInSnapshot) {</color>
<color=#75715e> *     // For each file in destDir that is NOT in filesInSnapshot, it should</color>
<color=#75715e> *     // be deleted from destDir to save disk space in the backup set, and to</color>
<color=#75715e> *     // ensure that unused files will not be restored.</color>
<color=#75715e> * }</color>
<color=#75715e> *</color>
<color=#75715e> * See myCopyFiles further above.</color>
<color=#75715e> * </pre></color>
<color=#75715e> *</color>
<color=#75715e> * <p>When performing backups as shown in the first example above, to restore you can simply copy</color>
<color=#75715e> * all files from the backup set into an empty directory.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>In the second example below, the list of current files is saved with the backup set so it can</color>
<color=#75715e> * be used during a restore. The backup set will effectively hold multiple backups that can be used</color>
<color=#75715e> * to restore to different points in time.</color>
<color=#75715e> *</color>
<color=#75715e> * <pre class="code"></color>
<color=#75715e> * void myBackup(Environment env, File destDir) {</color>
<color=#75715e> *</color>
<color=#75715e> *     // Get the file number of the last file in the previous backup.</color>
<color=#75715e> *     long lastFileInPrevBackup =  ...</color>
<color=#75715e> *</color>
<color=#75715e> *     DbBackup backupHelper = new DbBackup(env, lastFileInPrevBackup);</color>
<color=#75715e> *</color>
<color=#75715e> *     // Optional: Do a checkpoint to reduce recovery time after a restore.</color>
<color=#75715e> *     env.checkpoint(new CheckpointConfig().setForce(true));</color>
<color=#75715e> *</color>
<color=#75715e> *     // Start backup, find out what needs to be copied.</color>
<color=#75715e> *     backupHelper.startBackup();</color>
<color=#75715e> *     try {</color>
<color=#75715e> *         // Copy the necessary files to archival storage.</color>
<color=#75715e> *         String[] filesToCopy = backupHelper.getLogFilesInBackupSet();</color>
<color=#75715e> *         myCopyFiles(env, backupHelper, filesToCopy, destDir);</color>
<color=#75715e> *</color>
<color=#75715e> *         // Save current list of files with backup data set.</color>
<color=#75715e> *         String[] filesInSnapshot = backupHelper.getLogFilesInSnapshot();</color>
<color=#75715e> *         // Save filesInSnapshot persistently here ...</color>
<color=#75715e> *</color>
<color=#75715e> *         // Update knowledge of last file saved in the backup set.</color>
<color=#75715e> *         lastFileInPrevBackup = backupHelper.getLastFileInBackupSet();</color>
<color=#75715e> *         // Save lastFileInPrevBackup persistently here ...</color>
<color=#75715e> *     } finally {</color>
<color=#75715e> *         // Remember to exit backup mode, or the JE cleaner cannot delete</color>
<color=#75715e> *         // log files and disk usage will grow without bounds.</color>
<color=#75715e> *        backupHelper.endBackup();</color>
<color=#75715e> *     }</color>
<color=#75715e> * }</color>
<color=#75715e> *</color>
<color=#75715e> * See myCopyFiles further above.</color>
<color=#75715e> * </pre></color>
<color=#75715e> *</color>
<color=#75715e> * <p>When performing backups as shown in the second example above, to restore you must choose one</color>
<color=#75715e> * of the file lists that was saved. You may choose the list written by the most recent backup, or a</color>
<color=#75715e> * list written by an earlier backup. To restore, the files in the list should be copied into an</color>
<color=#75715e> * empty destination directory.</color>
<color=#75715e> *</color>
<color=#75715e> * <p><b><a href="restore">Restoring from a backup</a></b></color>
<color=#75715e> *</color>
<color=#75715e> * <p>As described in the sections above, the restore procedure is to copy the files from a backup</color>
<color=#75715e> * set into an empty directory. Depending on the type of backup that was performed (see above),</color>
<color=#75715e> * either all files from the backup set are copied, or only the files on a list that was created</color>
<color=#75715e> * during the backup.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>There is one additional consideration when performing a restore, under the following</color>
<color=#75715e> * condition:</color>
<color=#75715e> *</color>
<color=#75715e> * <ul></color>
<color=#75715e> *   <li>Incremental backups are used, AND</color>
<color=#75715e> *       <ul></color>
<color=#75715e> *         <li>the backup was created using DbBackup with JE 6.2 or earlier, OR</color>
<color=#75715e> *         <li>the backup was created in a read-only JE environment.</color>
<color=#75715e> *       </ul></color>
<color=#75715e> * </ul></color>
<color=#75715e> *</color>
<color=#75715e> * <p>If the above condition holds, after copying the files an additional step is needed. To enable</color>
<color=#75715e> * the creation of future incremental backups using the restored files, the {@link</color>
<color=#75715e> * com.sleepycat.je.EnvironmentConfig#ENV_RECOVERY_FORCE_NEW_FILE} parameter should be set to true</color>
<color=#75715e> * when opening the JE Environment for the first time after the restore. When this parameter is set</color>
<color=#75715e> * to true, the last .jdb file restored will not be modified when opening the Environment, and the</color>
<color=#75715e> * next .jdb file will be created and will become the end-of-log file.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>WARNING: When the above special condition is true and this property is <em>not</em> set to</color>
<color=#75715e> * true when opening the environment for the first time after a restore, then the backup set that</color>
<color=#75715e> * was restored may not be used as the basis for future incremental backups. If a future incremental</color>
<color=#75715e> * backup were performed based on this backup set, it would be incomplete and data would be lost if</color>
<color=#75715e> * that incremental backup were restored.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When JE 6.3 or later is used to create the backup, and the backup is created in a read-write</color>
<color=#75715e> * environment (the usual case), this extra step is unnecessary. In this case, {@link #startBackup}</color>
<color=#75715e> * will have added an "immutable file" marker to the last file in the backup and this will prevent</color>
<color=#75715e> * that file from being modified, just as if the {@code ENV_RECOVERY_FORCE_NEW_FILE} parameter were</color>
<color=#75715e> * set to true.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>DbBackup</color> <color=#f8f8f2>{</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>envIsReadOnly</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>firstFileInBackup</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastFileInBackup</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>backupStarted</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>networkRestore</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>ProtectedActiveFileSet</color> <color=#f8f8f2>protectedFileSet</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>NavigableSet</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f92672>></color> <color=#f8f8f2>snapshotFiles</color><color=#f8f8f2>;</color>
  <color=#75715e>/* Status presents whether this back up is invalid because of roll back. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>invalid</color><color=#f8f8f2>;</color>
  <color=#75715e>/* The rollback start file number. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>rollbackStartedFileNumber</color><color=#f8f8f2>;</color>
  <color=#75715e>/* For unit tests. */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>TestHook</color> <color=#f8f8f2>testHook</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Creates a DbBackup helper for a full backup.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This is equivalent to using {@link #DbBackup(Environment,long)} and passing {@code -1} for</color>
<color=#75715e>   * the {@code lastFileInPrevBackup} parameter.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param env with an open, valid environment handle. If the environment directory has read/write</color>
<color=#75715e>   *     permissions, the environment handle must be configured for read/write.</color>
<color=#75715e>   * @throws IllegalArgumentException if the environment directory has read/write permissions, but</color>
<color=#75715e>   *     the environment handle is not configured for read/write.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>DbBackup</color><color=#f8f8f2>(</color><color=#f8f8f2>Environment</color> <color=#f8f8f2>env</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>this</color><color=#f8f8f2>(</color><color=#f8f8f2>env</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Creates a DbBackup helper for an incremental backup.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param env with an open, valid environment handle. If the environment directory has read/write</color>
<color=#75715e>   *     permissions, the environment handle must be configured for read/write.</color>
<color=#75715e>   * @param lastFileInPrevBackup the last file in the previous backup set when performing an</color>
<color=#75715e>   *     incremental backup, or {@code -1} to perform a full backup. The first file in this backup</color>
<color=#75715e>   *     set will be the file following {@code lastFileInPrevBackup}.</color>
<color=#75715e>   * @throws EnvironmentFailureException if an unexpected, internal or environment-wide failure</color>
<color=#75715e>   *     occurs.</color>
<color=#75715e>   * @throws IllegalArgumentException if the environment directory has read/write permissions, but</color>
<color=#75715e>   *     the environment handle is not configured for read/write.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>DbBackup</color><color=#f8f8f2>(</color><color=#f8f8f2>Environment</color> <color=#f8f8f2>env</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastFileInPrevBackup</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>(</color><color=#f8f8f2>env</color><color=#f8f8f2>,</color> <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>getNonNullEnvImpl</color><color=#f8f8f2>(</color><color=#f8f8f2>env</color><color=#f8f8f2>),</color> <color=#f8f8f2>lastFileInPrevBackup</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** @hidden For internal use only. */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>DbBackup</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * This is the true body of the DbBackup constructor. The env param may be null when this class is</color>
<color=#75715e>   * used internally.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#a6e22e>DbBackup</color><color=#f8f8f2>(</color><color=#f8f8f2>Environment</color> <color=#f8f8f2>env</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastFileInPrevBackup</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Check that the Environment is open. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>env</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>DbInternal</color><color=#f8f8f2>.</color><color=#a6e22e>checkOpen</color><color=#f8f8f2>(</color><color=#f8f8f2>env</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the environment is writable, we need a r/w environment handle</color>
<color=#75715e>     * in order to flip the file.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>envIsReadOnly</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>checkEnvHomePermissions</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f92672>!</color><color=#f8f8f2>envIsReadOnly</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isReadOnly</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Environment handle may not be read-only when directory "</color> <color=#f92672>+</color> <color=#e6db74>"is read-write"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>firstFileInBackup</color> <color=#f92672>=</color> <color=#f8f8f2>lastFileInPrevBackup</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Start backup mode in order to determine the definitive backup set needed at this point in time.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method determines the last file in the backup set, which is the last log file in the</color>
<color=#75715e>   * environment at this point in time. Following this method call, all new data will be written to</color>
<color=#75715e>   * other, new log files. In other words, the last file in the backup set will not be modified</color>
<color=#75715e>   * after this method returns.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p><em>WARNING:</em> After calling this method, deletion of log files in the backup set by the</color>
<color=#75715e>   * JE log cleaner will be disabled until {@link #endBackup()} is called. To prevent unbounded</color>
<color=#75715e>   * growth of disk usage, be sure to call {@link #endBackup()} to re-enable log file deletion.</color>
<color=#75715e>   * Additionally, the Environment can't be closed until endBackup() is called.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws com.sleepycat.je.rep.LogOverwriteException if a replication operation is overwriting</color>
<color=#75715e>   *     log files. The backup can not proceed because files may be invalid. The backup may be</color>
<color=#75715e>   *     attempted at a later time.</color>
<color=#75715e>   * @throws EnvironmentFailureException if an unexpected, internal or environment-wide failure</color>
<color=#75715e>   *     occurs.</color>
<color=#75715e>   * @throws IllegalStateException if a backup is already in progress</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>startBackup</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>backupStarted</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalStateException</color><color=#f8f8f2>(</color><color=#e6db74>"startBackup was already called"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Throw a LogOverwriteException if the Environment is rolling back. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>addDbBackup</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>createLogOverwriteException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"A replication operation is overwriting log files. The "</color>
              <color=#f92672>+</color> <color=#e6db74>"backup can not proceed because files may be invalid. The "</color>
              <color=#f92672>+</color> <color=#e6db74>"backup may be attempted at a later time."</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>FileProtector</color> <color=#f8f8f2>fileProtector</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileProtector</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * For a network restore we use a different backup name/id and also</color>
<color=#75715e>     * protect the 2 newest (highest numbered) reserved files. This is a</color>
<color=#75715e>     * safeguard to ensure that the restored node can function as a master.</color>
<color=#75715e>     * In a future release this approach may be improved by additionally</color>
<color=#75715e>     * copying all reserved files to the restored node, but only after it</color>
<color=#75715e>     * has recovered using the active files [#25783].</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>backupId</color> <color=#f92672>=</color>
        <color=#f8f8f2>networkRestore</color>
            <color=#f92672>?</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeSequence</color><color=#f8f8f2>().</color><color=#a6e22e>getNextNetworkRestoreId</color><color=#f8f8f2>()</color>
            <color=#f8f8f2>:</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeSequence</color><color=#f8f8f2>().</color><color=#a6e22e>getNextBackupId</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>backupName</color> <color=#f92672>=</color>
        <color=#f8f8f2>(</color><color=#f8f8f2>networkRestore</color> <color=#f92672>?</color> <color=#f8f8f2>FileProtector</color><color=#f8f8f2>.</color><color=#a6e22e>NETWORK_RESTORE_NAME</color> <color=#f8f8f2>:</color> <color=#f8f8f2>FileProtector</color><color=#f8f8f2>.</color><color=#a6e22e>BACKUP_NAME</color><color=#f8f8f2>)</color>
            <color=#f92672>+</color> <color=#e6db74>"-"</color>
            <color=#f92672>+</color> <color=#f8f8f2>backupId</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nReservedFiles</color> <color=#f92672>=</color> <color=#f8f8f2>networkRestore</color> <color=#f92672>?</color> <color=#ae81ff>2</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Protect all files from deletion momentarily, while determining the</color>
<color=#75715e>     * last file and protecting the active files.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>ProtectedFileRange</color> <color=#f8f8f2>allFilesProtected</color> <color=#f92672>=</color>
        <color=#f8f8f2>fileProtector</color><color=#f8f8f2>.</color><color=#a6e22e>protectFileRange</color><color=#f8f8f2>(</color><color=#f8f8f2>backupName</color> <color=#f92672>+</color> <color=#e6db74>"-init"</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envIsReadOnly</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * All files are currently immutable, so the backup list is the</color>
<color=#75715e>         * current set of files. However, we can't add a marker to the</color>
<color=#75715e>         * last file in list, and therefore it will not be immutable</color>
<color=#75715e>         * after being restored to a read-write directory (unless the</color>
<color=#75715e>         * user sets ENV_RECOVERY_FORCE_NEW_FILE after restoring).</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>lastFileInBackup</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>getLastFileNum</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * Flip the log so that all files in the backup list are</color>
<color=#75715e>         * immutable. But first, write an "immutable file" marker in</color>
<color=#75715e>         * the last file in the backup, so it cannot be modified after</color>
<color=#75715e>         * it is restored. Recovery enforces this rule.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>LogEntry</color> <color=#f8f8f2>marker</color> <color=#f92672>=</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>SingleItemEntry</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_IMMUTABLE_FILE</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#f8f8f2>EmptyLogEntry</color><color=#f8f8f2>());</color>

        <color=#66d9ef>long</color> <color=#f8f8f2>markerLsn</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogManager</color><color=#f8f8f2>().</color><color=#a6e22e>log</color><color=#f8f8f2>(</color><color=#f8f8f2>marker</color><color=#f8f8f2>,</color> <color=#f8f8f2>ReplicationContext</color><color=#f8f8f2>.</color><color=#a6e22e>NO_REPLICATE</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>forceLogFileFlip</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>lastFileInBackup</color> <color=#f92672>=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getFileNumber</color><color=#f8f8f2>(</color><color=#f8f8f2>markerLsn</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Protect all active files from deletion. This includes files</color>
<color=#75715e>       * prior to firstFileInBackup, in order to get a snapshot of all</color>
<color=#75715e>       * active files. New files do not need protection, since the backup</color>
<color=#75715e>       * set does not include them. lastFileInBackup will be protected by</color>
<color=#75715e>       * protectActiveFiles because it is not the last file in the env.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>protectedFileSet</color> <color=#f92672>=</color>
          <color=#f8f8f2>fileProtector</color><color=#f8f8f2>.</color><color=#a6e22e>protectActiveFiles</color><color=#f8f8f2>(</color><color=#f8f8f2>backupName</color><color=#f8f8f2>,</color> <color=#f8f8f2>nReservedFiles</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*protectNewFiles*/</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>fileProtector</color><color=#f8f8f2>.</color><color=#a6e22e>removeFileProtection</color><color=#f8f8f2>(</color><color=#f8f8f2>allFilesProtected</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* At this point, endBackup must be called to undo file protection. */</color>
    <color=#f8f8f2>backupStarted</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Files after lastFileInBackup do not need protection. */</color>
    <color=#f8f8f2>protectedFileSet</color><color=#f8f8f2>.</color><color=#a6e22e>truncateTail</color><color=#f8f8f2>(</color><color=#f8f8f2>lastFileInBackup</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Snapshot the complete backup file set. */</color>
    <color=#f8f8f2>snapshotFiles</color> <color=#f92672>=</color> <color=#f8f8f2>protectedFileSet</color><color=#f8f8f2>.</color><color=#a6e22e>getProtectedFiles</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Now that we have the snapshot, files before firstFileInBackup do not</color>
<color=#75715e>     * need protection.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>protectedFileSet</color><color=#f8f8f2>.</color><color=#a6e22e>truncateHead</color><color=#f8f8f2>(</color><color=#f8f8f2>firstFileInBackup</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * End backup mode, thereby re-enabling normal deletion of log files by the JE log cleaner.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @throws com.sleepycat.je.rep.LogOverwriteException if a replication operation has overwritten</color>
<color=#75715e>   *     log files. Any copied files should be considered invalid and discarded. The backup may be</color>
<color=#75715e>   *     attempted at a later time.</color>
<color=#75715e>   * @throws com.sleepycat.je.EnvironmentFailureException if an unexpected, internal or</color>
<color=#75715e>   *     environment-wide failure occurs.</color>
<color=#75715e>   * @throws IllegalStateException if a backup has not been started.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>endBackup</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>checkBackupStarted</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>backupStarted</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>testHook</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileProtector</color><color=#f8f8f2>().</color><color=#a6e22e>removeFileProtection</color><color=#f8f8f2>(</color><color=#f8f8f2>protectedFileSet</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>removeDbBackup</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>

    <color=#75715e>/* If this back up is invalid, throw a LogOverwriteException. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>invalid</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>invalid</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>createLogOverwriteException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"A replication operation has overwritten log files from "</color>
              <color=#f92672>+</color> <color=#e6db74>"file "</color>
              <color=#f92672>+</color> <color=#f8f8f2>rollbackStartedFileNumber</color>
              <color=#f92672>+</color> <color=#e6db74>". Any copied files "</color>
              <color=#f92672>+</color> <color=#e6db74>"should be considered invalid and discarded. The backup "</color>
              <color=#f92672>+</color> <color=#e6db74>"may be attempted at a later time."</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Can only be called in backup mode, after startBackup() has been called.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the file number of the last file in the current backup set. Save this value to reduce</color>
<color=#75715e>   *     the number of files that must be copied at the next backup session.</color>
<color=#75715e>   * @throws IllegalStateException if a backup has not been started.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>long</color> <color=#a6e22e>getLastFileInBackupSet</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>checkBackupStarted</color><color=#f8f8f2>();</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>lastFileInBackup</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Get the minimum list of files that must be copied for this backup. When performing an</color>
<color=#75715e>   * incremental backup, this consists of the set of active files that are greater than the last</color>
<color=#75715e>   * file copied in the previous backup session. When performing a full backup, this consists of the</color>
<color=#75715e>   * set of all active files. Can only be called in backup mode, after startBackup() has been</color>
<color=#75715e>   * called.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The file numbers returned are in the range from the constructor parameter {@code</color>
<color=#75715e>   * lastFileInPrevBackup + 1} to the last log file at the time that {@link #startBackup} was</color>
<color=#75715e>   * called.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the names of all files to be copied, sorted in alphabetical order. The return values</color>
<color=#75715e>   *     are generally simple file names, not full paths. However, if multiple data directories are</color>
<color=#75715e>   *     being used (i.e. the {@link <a href="../EnvironmentConfig.html#LOG_N_DATA_DIRECTORIES"></color>
<color=#75715e>   *     je.log.nDataDirectories</a>} parameter is non-0), then the file names are prepended with</color>
<color=#75715e>   *     the associated "dataNNN/" prefix, where "dataNNN/" is the data directory name within the</color>
<color=#75715e>   *     environment home directory and "/" is the relevant file separator for the platform.</color>
<color=#75715e>   * @throws EnvironmentFailureException if an unexpected, internal or environment-wide failure</color>
<color=#75715e>   *     occurs.</color>
<color=#75715e>   * @throws IllegalStateException if a backup has not been started.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#f8f8f2>String</color><color=#f92672>[]</color> <color=#a6e22e>getLogFilesInBackupSet</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>checkBackupStarted</color><color=#f8f8f2>();</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getFileNames</color><color=#f8f8f2>(</color><color=#f8f8f2>snapshotFiles</color><color=#f8f8f2>.</color><color=#a6e22e>tailSet</color><color=#f8f8f2>(</color><color=#f8f8f2>firstFileInBackup</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Get the minimum list of files that must be copied for this backup. This consists of the set of</color>
<color=#75715e>   * active files that are greater than the last file copied in the previous backup session. Can</color>
<color=#75715e>   * only be called in backup mode, after startBackup() has been called.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param lastFileInPrevBackup file number of last file copied in the last backup session,</color>
<color=#75715e>   *     obtained from getLastFileInBackupSet().</color>
<color=#75715e>   * @return the names of all the files to be copied that come after lastFileInPrevBackup.</color>
<color=#75715e>   * @throws EnvironmentFailureException if an unexpected, internal or environment-wide failure</color>
<color=#75715e>   *     occurs.</color>
<color=#75715e>   * @throws IllegalStateException if a backup has not been started.</color>
<color=#75715e>   * @deprecated replaced by {@link #getLogFilesInBackupSet()}; pass lastFileInPrevBackup to the</color>
<color=#75715e>   *     {@link #DbBackup(Environment,long)} constructor.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Deprecated</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#f8f8f2>String</color><color=#f92672>[]</color> <color=#a6e22e>getLogFilesInBackupSet</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lastFileInPrevBackup</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>checkBackupStarted</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>getFileNames</color><color=#f8f8f2>(</color><color=#f8f8f2>snapshotFiles</color><color=#f8f8f2>.</color><color=#a6e22e>tailSet</color><color=#f8f8f2>(</color><color=#f8f8f2>lastFileInPrevBackup</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Get the list of all active files that are needed for the environment at the point of time when</color>
<color=#75715e>   * backup mode started, i.e., the current snapshot. Can only be called in backup mode, after</color>
<color=#75715e>   * startBackup() has been called.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>When performing an incremental backup, this method is called to determine the files that</color>
<color=#75715e>   * would needed for a restore. As described in the examples at the top of this class, this list</color>
<color=#75715e>   * can be used to avoid unused files after a restore, and may also be used to reduce the size of</color>
<color=#75715e>   * the backup set.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>When performing a full backup this method is normally not needed, since in that case it</color>
<color=#75715e>   * returns the same set of files that is returned by {@link #getLogFilesInBackupSet()}.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the names of all files in the snapshot, sorted in alphabetical order. The return values</color>
<color=#75715e>   *     are generally simple file names, not full paths. However, if multiple data directories are</color>
<color=#75715e>   *     being used (i.e. the {@link <a href="../EnvironmentConfig.html#LOG_N_DATA_DIRECTORIES"></color>
<color=#75715e>   *     je.log.nDataDirectories</a>} parameter is non-0), then the file names are prepended with</color>
<color=#75715e>   *     the associated "dataNNN/" prefix, where "dataNNN/" is the data directory name within the</color>
<color=#75715e>   *     environment home directory and "/" is the relevant file separator for the platform.</color>
<color=#75715e>   * @throws EnvironmentFailureException if an unexpected, internal or environment-wide failure</color>
<color=#75715e>   *     occurs.</color>
<color=#75715e>   * @throws IllegalStateException if a backup has not been started.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#f8f8f2>String</color><color=#f92672>[]</color> <color=#a6e22e>getLogFilesInSnapshot</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>checkBackupStarted</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>getFileNames</color><color=#f8f8f2>(</color><color=#f8f8f2>snapshotFiles</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>String</color><color=#f92672>[]</color> <color=#a6e22e>getFileNames</color><color=#f8f8f2>(</color><color=#f8f8f2>NavigableSet</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f92672>></color> <color=#f8f8f2>fileSet</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>FileManager</color> <color=#f8f8f2>fileManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>String</color><color=#f92672>[]</color> <color=#f8f8f2>names</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>String</color><color=#f92672>[</color><color=#f8f8f2>fileSet</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>Long</color> <color=#f8f8f2>file</color> <color=#f8f8f2>:</color> <color=#f8f8f2>fileSet</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>names</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>getPartialFileName</color><color=#f8f8f2>(</color><color=#f8f8f2>file</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>names</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Removes protection for a file in the backup set. This method should be called after copying a</color>
<color=#75715e>   * file, so that it may be deleted to avoid exceeding disk usage limits.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param fileName a file name that has already been copied, in the format returned by {@link</color>
<color=#75715e>   *     #getLogFilesInBackupSet} .</color>
<color=#75715e>   * @since 7.5</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>removeFileProtection</color><color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>fileName</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>checkBackupStarted</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>protectedFileSet</color><color=#f8f8f2>.</color><color=#a6e22e>removeFile</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getFileManager</color><color=#f8f8f2>().</color><color=#a6e22e>getNumFromName</color><color=#f8f8f2>(</color><color=#f8f8f2>fileName</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>checkBackupStarted</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>backupStarted</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalStateException</color><color=#f8f8f2>(</color><color=#e6db74>"startBackup was not called"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For internal use only.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @hidden Returns true if a backup has been started and is in progress.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>boolean</color> <color=#a6e22e>backupIsOpen</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>backupStarted</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For internal use only.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @hidden Invalidate this backup if replication overwrites the log.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>invalidate</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>fileNumber</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>invalid</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>rollbackStartedFileNumber</color> <color=#f92672>=</color> <color=#f8f8f2>fileNumber</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For internal use only.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @hidden Marks this backup as a network restore. Causes the protected file set name/id to be set</color>
<color=#75715e>   *     specially, and two reserved files to be included. See {@link #startBackup()}.</color>
<color=#75715e>   *     <p>Another approach (for future consideration) is to factor out the part of DbBackup that</color>
<color=#75715e>   *     is needed by network restore into utility methods, so that special code for network restore</color>
<color=#75715e>   *     can be removed from DbBackup. The shared portion should be just the startBackup code.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setNetworkRestore</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>networkRestore</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * For internal use only.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @hidden A test entry point used to simulate the environment is now rolling back, and this</color>
<color=#75715e>   *     TestHook would invalidate the in progress DbBackups.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setTestHook</color><color=#f8f8f2>(</color><color=#f8f8f2>TestHook</color> <color=#f8f8f2>testHook</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>testHook</color> <color=#f92672>=</color> <color=#f8f8f2>testHook</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>