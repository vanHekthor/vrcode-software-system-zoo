<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.evictor</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.CacheMode</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentFailureException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentMutableConfig</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.StatsConfig</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.evictor.Evictor.EvictionSource</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.LogEntryType</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.Provisional</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.BINDeltaLogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.entry.INLogEntry</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.BIN</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.IN</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.LN</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.*</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.nio.ByteBuffer</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Arrays</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Map</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.atomic.AtomicBoolean</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.atomic.AtomicInteger</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.atomic.AtomicLong</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Level</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Logger</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.zip.Checksum</color><color=#f8f8f2>;</color>

<color=#f92672>import static</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentFailureException.unexpectedState</color><color=#f8f8f2>;</color>
<color=#f92672>import static</color> <color=#f8f8f2>com.sleepycat.je.evictor.OffHeapStatDefinition.*</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * Off-heap cache and evictor.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Overview -------- When an LN or BIN is evicted from the main cache it is moved off-heap. The</color>
<color=#75715e> * off-heap evictor (this class) will apply the same LRU algorithm and CacheMode logic that is used</color>
<color=#75715e> * by the main evictor. When an off-heap cache is used, the main evictor will not place dirty INs on</color>
<color=#75715e> * a priority 2 LRU list, and will not perform LN stripping or BIN delta mutation; instead, these</color>
<color=#75715e> * actions become the responsibility of the off-heap evictor.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>UINs are not stored off-heap because the complexity this would add is not worth the benefits.</color>
<color=#75715e> * An extremely large data set can be represented by the UINs that fit in a 10GB main cache, so the</color>
<color=#75715e> * lack of off-heap UINs is not considered a deficiency.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Movement of LNs and BINs between the two caches is performed as follows. Note that LNs and</color>
<color=#75715e> * BINs are not moved off-heap if they are deleted nor if they belong to an internal database. And</color>
<color=#75715e> * of course, embedded and duplicate DB LNs are not stored separately off-heap.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When an LN or a BIN is evicted from main, it is stored off-heap.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>If the off-heap memory block cannot be allocated, the object is not stored and no exception is</color>
<color=#75715e> * thrown. This prevents allocation failures from causing CRUD operation failures. Stats about</color>
<color=#75715e> * allocation failures are maintained and a SEVERE message is logged when the failure is because no</color>
<color=#75715e> * more system memory is available. See the OffHeapAllocator interface for details.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>For an off-heap LN with a parent BIN in main cache, the LN's memory ID is maintained in the</color>
<color=#75715e> * BIN. The BIN is assigned an off-heap LRU index so the off-heap evictor can perform off-heap LN</color>
<color=#75715e> * stripping. In this case, the BIN is in both a main and off-heap LRU list. For now at least</color>
<color=#75715e> * (TODO), because deferred write DBs are not supported, a priority-1 off-heap LRU list is used,</color>
<color=#75715e> * since the LNs will never be logged.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>An off-heap BIN is assigned an off-heap LRU index, which is stored in its parent UIN slot in</color>
<color=#75715e> * main cache. The slot also has an "off-heap dirty" flag that allows the checkpointer to discover</color>
<color=#75715e> * dirty off-heap BINs, and "priority 2" flag that indicates whether the BIN is in the priority 1 or</color>
<color=#75715e> * 2 LRU lists.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When a BIN moves off-heap and the BIN currently has off-heap LNs, the references (memory IDs)</color>
<color=#75715e> * of the off-heap LNs are stored with the serialized BIN. When the off-heap evictor processes the</color>
<color=#75715e> * BIN, it will free the off-heap LNs and modify or replace the off-heap BIN so that it no longer</color>
<color=#75715e> * references them. This is the equivalent of the LN stripping performed by the main cache evictor.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>An off-heap BIN will be mutated to a BIN-delta using the same rules used by the main evictor.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The use of separate priority 1 and priority 1 LRU lists also copies the approach used in the</color>
<color=#75715e> * main evictor (when no off-heap cache is configured).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Eviction of nodes on the priority 2 lists occurs only after emptying the priority 1 lists.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- A BIN is moved from a priority 1 list to a priority 2 list when it is dirty, its LNs have</color>
<color=#75715e> * been stripped and BIN-delta mutation has been attempted.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Therefore, only dirty BINs with no resident LNs, and which have been mutated to BIN-deltas</color>
<color=#75715e> * (if possible), appear in the priority 2 lists.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>However, in the off-heap cache, all off-heap BINs appear in an LRU list, unlike the main cache</color>
<color=#75715e> * where some INs do not appear because they have resident children and therefore are not evictable.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Nodes in both caches at once ---------------------------- There are advantages and</color>
<color=#75715e> * disadvantages to allowing duplication of a node (LN or BIN) in the off-heap and main cache. The</color>
<color=#75715e> * advantage is when a node is loaded from off-heap into main, and we know (because</color>
<color=#75715e> * CacheMode.EVICT_LN, EVICT_BIN or UNCHANGED is used) that when the operation is complete the node</color>
<color=#75715e> * will be evicted from main and stored off-heap again. In this case it is more efficient to leave</color>
<color=#75715e> * it off-heap and tolerate the duplication for the duration of the operation. However, the</color>
<color=#75715e> * drawbacks of doing this are:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>1. We cannot assume in code that a node is in only one cache at a time. When it appears in</color>
<color=#75715e> * both caches, we must always use the object in the main cache, since the off-heap object may be</color>
<color=#75715e> * stale.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>2. If for some reason the node is NOT evicted from the main cache, we must remove it from</color>
<color=#75715e> * off-heap. This can happen when the node is accessed with a different CacheMode (by the original</color>
<color=#75715e> * thread or a different thread) prior to completing the operation. Removal from the off-heap cache</color>
<color=#75715e> * should be done ASAP, so the duplication does not cause unnecessary eviction.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>3. If the node in the main cache is modified, this invalidates the node in the off-heap cache</color>
<color=#75715e> * and we must be sure not to use the off-heap version and to remove it ASAP. This is very complex</color>
<color=#75715e> * for BINs in particular, because they can be modified in so many different ways. For LNs, on the</color>
<color=#75715e> * other hand, the types of modifications are fairly limited.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Because of the complexity issue in item 3, we do not allow duplication of BINs. We do allow</color>
<color=#75715e> * duplication of LNs, and this is handled as follows:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- freeRedundantLN is called when an LN is accessed via IN.fetchLN or getLN. If a CacheMode is</color>
<color=#75715e> * used that will not evict the LN, the LN is removed from off-heap.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- freeLN is called (via BIN.freeOffHeapLN) during any operation that will modify an LN.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>If for some reason these mechanisms fail to prevent unwanted duplication, eviction will</color>
<color=#75715e> * eventually remove the redundant nodes.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>LRU data structures and concurrency control ------------------------------------------- LRU</color>
<color=#75715e> * entries form linked lists. Like in the main cache, there are two sets of LRU lists for priority 1</color>
<color=#75715e> * and 2 BINs, and multiple lists in each set to reduce thread contention on the linked lists.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>LRU information is allocated using arrays to minimize per-entry object overhead. There is a</color>
<color=#75715e> * single pool of allocated entries that are used for all LRULists. The entries are uniquely</color>
<color=#75715e> * identified by an int ID.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The arrays are allocated in Chunks and a Chunk is never de-allocated. This is for two reasons:</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Chunks can be referenced without any locking (concurrency control is discussed below).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Using Chunks avoids having to pre-allocate all LRU entries, while still minimizing Object</color>
<color=#75715e> * overhead (see CHUNK_SIZE).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The 'chunks' array contains all allocated Chunks. In each Chunk there is an array for each</color>
<color=#75715e> * field in an LRU entry.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>LRU entries are assigned sequential int IDs starting from zero. The chunk for a given entry ID</color>
<color=#75715e> * is: chunks[entry / CHUNK_SIZE] and the array index within the chunk is: entry % CHUNK_SIZE</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The chunks array can be read (indexed to obtain a Chunk object) without any locking because a</color>
<color=#75715e> * copy-on-write technique is used. When a new Chunk must be allocated, the addRemoveEntryMutex</color>
<color=#75715e> * protects the assignment of the chunks array. This mutex also protects the free entry list (the</color>
<color=#75715e> * firstFreeListEntry field and the next/prev indexes of the entries on the free list). This mutex</color>
<color=#75715e> * is global per Environment, but is not frequently locked -- only when an LRU entry is added or</color>
<color=#75715e> * removed.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The fields of an LRU entry -- the array slots -- are protected as follows.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- The linked list fields -- prev and next slots -- are protected by the LRUList mutex, for</color>
<color=#75715e> * entries in an LRUList. For entries on the free list, these are protected by the</color>
<color=#75715e> * addRemoveEntryMutex.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>- Other fields -- owners and memIds slots, for example -- are protected by the IN latch. The</color>
<color=#75715e> * IN "owns" these fields for its associated LRU entry (in the case of a BIN) or entries (in the</color>
<color=#75715e> * case of an IN).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Of course the IN latch also protects the fields in the IN related to the LRU entry: the BIN's</color>
<color=#75715e> * lruIdx field, and the arrays of child LN memId (for a BIN) and child IN lruIdx (for a UIN).</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When multiple locks are taken, the order is: IN latch, LRUList mutex -or- IN latch,</color>
<color=#75715e> * addRemoveEntryMutex</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The LRUList mutex and addRemoveEntryMutex are never both locked.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>AN LRU entry is in a special state when it is removed from the LRU list and is being processed</color>
<color=#75715e> * by the evictor. In this case the IN is latched, but there is a window after it is removed and</color>
<color=#75715e> * before it is latched where anything can happen. Before processing, several checks are made to</color>
<color=#75715e> * ensure that the entry still belongs to the IN, the IN has not been evicted, and the entry has not</color>
<color=#75715e> * been put back on the LRUList. This last check requires synchronizing on the LRUList, so</color>
<color=#75715e> * unfortunately we must synchronize twice on the LRU list: once to remove the entry, and again</color>
<color=#75715e> * after latching the IN to ensure that it has not been put back on the LRUList by another thread.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>TODO: - Test allocation failures using an allocator that simulates random failures. Currently,</color>
<color=#75715e> * allocation failures never happen in the real world, because Linux kills the process before memory</color>
<color=#75715e> * is exhausted. But when we allow alternate allocators, failures may occur if a memory pool is</color>
<color=#75715e> * filled.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>OffHeapCache</color> <color=#66d9ef>implements</color> <color=#f8f8f2>EnvConfigObserver</color> <color=#f8f8f2>{</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>VLSN_SIZE</color> <color=#f92672>=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f92672>=</color> <color=#ae81ff>4</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>MAX_UNUSED_BIN_BYTES</color> <color=#f92672>=</color> <color=#ae81ff>100</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>BIN_FLAG_DELTA</color> <color=#f92672>=</color> <color=#ae81ff>0x1</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>BIN_FLAG_CAN_MUTATE</color> <color=#f92672>=</color> <color=#ae81ff>0x2</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>BIN_FLAG_PROHIBIT_NEXT_DELTA</color> <color=#f92672>=</color> <color=#ae81ff>0x4</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>BIN_FLAG_LOGGED_FULL_VERSION</color> <color=#f92672>=</color> <color=#ae81ff>0x8</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>DEBUG_DOUBLE_FREE</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>DEBUG_FREE_BLOCKS_PER_MAP</color> <color=#f92672>=</color> <color=#ae81ff>250000</color><color=#f8f8f2>;</color> <color=#75715e>// about 0.5 G</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>DEBUG_TRACE</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>DEBUG_TRACE_STACK</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>DEBUG_TRACE_AND_LOG</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Number of LRU entries to allocate at a time, i.e., per chunk.</color>
<color=#75715e>   * The goals are:</color>
<color=#75715e>   *</color>
<color=#75715e>   * 1. Create arrays large enough to make the object overhead insignificant.</color>
<color=#75715e>   * The byte[], the smallest array, is 100KB and its object overhead (16</color>
<color=#75715e>   * bytes max) is tiny in comparison.</color>
<color=#75715e>   *</color>
<color=#75715e>   * 2. Create arrays less than than 1MB in size to prevent GC issues.</color>
<color=#75715e>   * "Humongous" objects, which are expensive to GC viewpoint are 1MB or</color>
<color=#75715e>   * larger. The long[], the largest array, is 800KB with a 100K chunk size.</color>
<color=#75715e>   *</color>
<color=#75715e>   * 3. Create chunks small enough that we don't use a big percentage of a</color>
<color=#75715e>   * smallish heap to allocate one chunk. The chunk size is a little over</color>
<color=#75715e>   * 2MB, or easily small enough to meet this requirement.</color>
<color=#75715e>   *</color>
<color=#75715e>   * 4. Create chunks large enough so that we don't frequently grow the chunk</color>
<color=#75715e>   * list, which requires holding the free list mutex. 100K entries per chunk</color>
<color=#75715e>   * is easily enough.</color>
<color=#75715e>   *</color>
<color=#75715e>   * 5. Create chunks small enough so that we don't hold the free list mutex</color>
<color=#75715e>   * for too long while adding all the entries in a new chunk to the free</color>
<color=#75715e>   * list. 100K may be too large in this respect, and it could be reduced if</color>
<color=#75715e>   * this is a noticeable issue. Even better, rather than add a new chunk's</color>
<color=#75715e>   * entries to the free list, treat those entries as a "free stack" and pop</color>
<color=#75715e>   * them off separately.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>CHUNK_SIZE</color> <color=#f92672>=</color> <color=#ae81ff>100</color> <color=#f92672>*</color> <color=#ae81ff>1024</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>CHUNK_MEMORY_SIZE</color> <color=#f92672>=</color>
      <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>OBJECT_OVERHEAD</color>
          <color=#f92672>+</color> <color=#ae81ff>16</color>
          <color=#f92672>+</color> <color=#75715e>// For four array references -- accuracy is unimportant.</color>
          <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>longArraySize</color><color=#f8f8f2>(</color><color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>)</color>
          <color=#f92672>+</color> <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>objectArraySize</color><color=#f8f8f2>(</color><color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>)</color>
          <color=#f92672>+</color> <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>intArraySize</color><color=#f8f8f2>(</color><color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>)</color> <color=#f92672>*</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Amount that tests should add to a minimal main cache configuration,</color>
<color=#75715e>   * when an off-heap cache is used.</color>
<color=#75715e>   *</color>
<color=#75715e>   * TODO: For now this is not budgeted.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>MIN_MAIN_CACHE_OVERHEAD</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#75715e>// CHUNK_MEMORY_SIZE;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>Chunk</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the IN is a UIN, the memId is the block containing the BIN.</color>
<color=#75715e>     *</color>
<color=#75715e>     * If the IN is a BIN, the memId is currently unused. It may be used in</color>
<color=#75715e>     * the future for the off-heap full BIN for a BIN-delta in main.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>memIds</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The IN that owns this entry.</color>
<color=#75715e>     *   . Is null if the entry is not used, i.e., on the free list.</color>
<color=#75715e>     *   . Is a UIN if the entry is for an off-heap BIN.</color>
<color=#75715e>     *   . Is a BIN if the entry is for a BIN in the main cache.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color><color=#f92672>[]</color> <color=#f8f8f2>owners</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * IDs of the prev/next entries in the LRU linked list. For entries on</color>
<color=#75715e>     * the free list, only the next entry is used (it is singly-linked).</color>
<color=#75715e>     *</color>
<color=#75715e>     * The prev and next entry ID are -1 to mean the end of the list.</color>
<color=#75715e>     *    . If prev == -1, then entry ID == LRUList.back.</color>
<color=#75715e>     *    . If next == -1, then entry ID == LRUList.front.</color>
<color=#75715e>     *</color>
<color=#75715e>     * If next == -2, the entry is not in an LRUList nor is it on the free</color>
<color=#75715e>     * list. When next == -2 and the owner is non-null, this means the</color>
<color=#75715e>     * entry has been removed from the LRU list to be processed by the</color>
<color=#75715e>     * evictor; the evictor may decide to add it back to an LRU list or</color>
<color=#75715e>     * place is on the free list.</color>
<color=#75715e>     *</color>
<color=#75715e>     * When an entry is on the free list, next is the next ID on the free</color>
<color=#75715e>     * list, and the owner is null.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>prev</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>next</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>Chunk</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>memIds</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>long</color><color=#f92672>[</color><color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>owners</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>IN</color><color=#f92672>[</color><color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>prev</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[</color><color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>next</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[</color><color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>class</color> <color=#a6e22e>LRUList</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The front field is the entry ID of the cold end, and back is the ID</color>
<color=#75715e>     * of the hot end. Both fields are -1 if the list is empty. If there is</color>
<color=#75715e>     * only one entry, both fields have the same value.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>front</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>back</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>void</color> <color=#a6e22e>addBack</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>owner</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Must set owner before adding to LRU list, since an entry that is</color>
<color=#75715e>       * on the LRU list with a null owner would be considered as a free</color>
<color=#75715e>       * entry (by other threads).</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>owner</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>memIds</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>memId</color><color=#f8f8f2>;</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>addBackInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>void</color> <color=#a6e22e>addFront</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>addFrontInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>void</color> <color=#a6e22e>moveBack</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>back</color> <color=#f92672>==</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>removeInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>addBackInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>void</color> <color=#a6e22e>moveFront</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>front</color> <color=#f92672>==</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>removeInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>addFrontInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#a6e22e>removeFront</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>front</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>removeInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>void</color> <color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>removeInternal</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>addBackInternal</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>2</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>back</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>back</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>front</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>prev</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>back</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>front</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>front</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>nextChunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>back</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nextIdx</color> <color=#f92672>=</color> <color=#f8f8f2>back</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>nextChunk</color><color=#f8f8f2>.</color><color=#a6e22e>prev</color><color=#f92672>[</color><color=#f8f8f2>nextIdx</color><color=#f92672>]</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>nextChunk</color><color=#f8f8f2>.</color><color=#a6e22e>prev</color><color=#f92672>[</color><color=#f8f8f2>nextIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>back</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>prev</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>back</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>addFrontInternal</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>2</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>front</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>back</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>front</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>prev</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>front</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>back</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>back</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>prevChunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>front</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>prevIdx</color> <color=#f92672>=</color> <color=#f8f8f2>front</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>prevChunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>prevIdx</color><color=#f92672>]</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>prevChunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>prevIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>prev</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>front</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>front</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>removeInternal</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>assert</color> <color=#f8f8f2>front</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>back</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>prev</color> <color=#f92672>=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>prev</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>next</color> <color=#f92672>=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prev</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>prev</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>back</color> <color=#f92672>==</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>back</color> <color=#f92672>=</color> <color=#f8f8f2>next</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>back</color> <color=#f92672>!=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>prevChunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>prev</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>prevIdx</color> <color=#f92672>=</color> <color=#f8f8f2>prev</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>prevChunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>prevIdx</color><color=#f92672>]</color> <color=#f92672>==</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>prevChunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>prevIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>next</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>next</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>next</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>front</color> <color=#f92672>==</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>front</color> <color=#f92672>=</color> <color=#f8f8f2>prev</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>front</color> <color=#f92672>!=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>nextChunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>next</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nextIdx</color> <color=#f92672>=</color> <color=#f8f8f2>next</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

        <color=#66d9ef>assert</color> <color=#f8f8f2>nextChunk</color><color=#f8f8f2>.</color><color=#a6e22e>prev</color><color=#f92672>[</color><color=#f8f8f2>nextIdx</color><color=#f92672>]</color> <color=#f92672>==</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>nextChunk</color><color=#f8f8f2>.</color><color=#a6e22e>prev</color><color=#f92672>[</color><color=#f8f8f2>nextIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>prev</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>2</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>size</color> <color=#f92672>-=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>>=</color> <color=#f92672>-</color><color=#ae81ff>2</color><color=#f8f8f2>;</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>!=</color> <color=#f92672>-</color><color=#ae81ff>2</color> <color=#f92672>&&</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#a6e22e>getSize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Logger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>OffHeapAllocator</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>runEvictorThreads</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>maxPoolThreads</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicInteger</color> <color=#f8f8f2>activePoolThreads</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicInteger</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicBoolean</color> <color=#f8f8f2>shutdownRequested</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicBoolean</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ThreadPoolExecutor</color> <color=#f8f8f2>evictionPool</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>terminateMillis</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>maxMemory</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#f8f8f2>memoryLimit</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>evictBytes</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>Exception</color><color=#f92672>></color> <color=#f8f8f2>freedBlocks</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>Exception</color><color=#f92672>></color> <color=#f8f8f2>prevFreedBlocks</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#f8f8f2>Chunk</color><color=#f92672>[]</color> <color=#f8f8f2>chunks</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>firstFreeListEntry</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>addRemoveEntryMutex</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Object</color><color=#f8f8f2>();</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>numLRULists</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color><color=#f92672>[]</color> <color=#f8f8f2>pri1LRUSet</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color><color=#f92672>[]</color> <color=#f8f8f2>pri2LRUSet</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>nextPri1LRUList</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>nextPri2LRUList</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nAllocFailure</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nAllocOverflow</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nThreadUnavailable</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nCriticalNodesTargeted</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nNodesTargeted</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nNodesEvicted</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nDirtyNodesEvicted</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nNodesStripped</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nNodesMutated</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nNodesSkipped</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nLNsEvicted</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nLNsLoaded</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nLNsStored</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nBINsLoaded</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLong</color> <color=#f8f8f2>nBINsStored</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLong</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicInteger</color> <color=#f8f8f2>cachedLNs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicInteger</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicInteger</color> <color=#f8f8f2>cachedBINs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicInteger</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicInteger</color> <color=#f8f8f2>cachedBINDeltas</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicInteger</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicInteger</color> <color=#f8f8f2>totalBlocks</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicInteger</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicInteger</color> <color=#f8f8f2>lruSize</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicInteger</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>

  <color=#66d9ef>public</color> <color=#a6e22e>OffHeapCache</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>logger</color> <color=#f92672>=</color> <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>(</color><color=#f8f8f2>getClass</color><color=#f8f8f2>());</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>configManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>maxMemory</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>MAX_OFF_HEAP_MEMORY</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>maxMemory</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>allocator</color> <color=#f92672>=</color> <color=#f8f8f2>DummyAllocator</color><color=#f8f8f2>.</color><color=#a6e22e>INSTANCE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>OffHeapAllocatorFactory</color> <color=#f8f8f2>factory</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>OffHeapAllocatorFactory</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>allocator</color> <color=#f92672>=</color> <color=#f8f8f2>factory</color><color=#f8f8f2>.</color><color=#a6e22e>getDefaultAllocator</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Throwable</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// TODO: allow continuing without an off-heap cache?</color>
        <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalStateException</color><color=#f8f8f2>(</color><color=#e6db74>"Unable to create default allocator for off-heap cache"</color><color=#f8f8f2>,</color> <color=#f8f8f2>e</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>evictBytes</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>OFFHEAP_EVICT_BYTES</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>numLRULists</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>OFFHEAP_N_LRU_LISTS</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>setMaxBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>maxMemory</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>memoryLimit</color> <color=#f92672>=</color> <color=#f8f8f2>maxMemory</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>pri1LRUSet</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LRUList</color><color=#f92672>[</color><color=#f8f8f2>numLRULists</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>pri2LRUSet</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LRUList</color><color=#f92672>[</color><color=#f8f8f2>numLRULists</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>numLRULists</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>pri1LRUSet</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LRUList</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>pri2LRUSet</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LRUList</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_DOUBLE_FREE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>freedBlocks</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ConcurrentHashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>
      <color=#f8f8f2>prevFreedBlocks</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ConcurrentHashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>freedBlocks</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>prevFreedBlocks</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>terminateMillis</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getDuration</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>EVICTOR_TERMINATE_TIMEOUT</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>corePoolSize</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>OFFHEAP_CORE_THREADS</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>maxPoolThreads</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>OFFHEAP_MAX_THREADS</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>keepAliveTime</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getDuration</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>OFFHEAP_KEEP_ALIVE</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isShared</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSharedCache</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>evictionPool</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>ThreadPoolExecutor</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>corePoolSize</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>maxPoolThreads</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>keepAliveTime</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>TimeUnit</color><color=#f8f8f2>.</color><color=#a6e22e>MILLISECONDS</color><color=#f8f8f2>,</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>ArrayBlockingQueue</color><color=#f92672><</color><color=#f8f8f2>Runnable</color><color=#f92672>></color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>),</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>StoppableThreadFactory</color><color=#f8f8f2>(</color><color=#f8f8f2>isShared</color> <color=#f92672>?</color> <color=#66d9ef>null</color> <color=#f8f8f2>:</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"JEOffHeapEvictor"</color><color=#f8f8f2>,</color> <color=#f8f8f2>logger</color><color=#f8f8f2>),</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>RejectedExecutionHandler</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
              <color=#a6e22e>@Override</color>
              <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>rejectedExecution</color><color=#f8f8f2>(</color><color=#f8f8f2>Runnable</color> <color=#f8f8f2>r</color><color=#f8f8f2>,</color> <color=#f8f8f2>ThreadPoolExecutor</color> <color=#f8f8f2>executor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>nThreadUnavailable</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
              <color=#f8f8f2>}</color>
            <color=#f8f8f2>});</color>

    <color=#f8f8f2>runEvictorThreads</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getBoolean</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>ENV_RUN_OFFHEAP_EVICTOR</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>addConfigObserver</color><color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>envConfigUpdate</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentMutableConfig</color> <color=#f8f8f2>ignore</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>terminateMillis</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getDuration</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>EVICTOR_TERMINATE_TIMEOUT</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>corePoolSize</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>OFFHEAP_CORE_THREADS</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>maxPoolThreads</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>OFFHEAP_MAX_THREADS</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>keepAliveTime</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getDuration</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>OFFHEAP_KEEP_ALIVE</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>evictionPool</color><color=#f8f8f2>.</color><color=#a6e22e>setCorePoolSize</color><color=#f8f8f2>(</color><color=#f8f8f2>corePoolSize</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>evictionPool</color><color=#f8f8f2>.</color><color=#a6e22e>setMaximumPoolSize</color><color=#f8f8f2>(</color><color=#f8f8f2>maxPoolThreads</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>evictionPool</color><color=#f8f8f2>.</color><color=#a6e22e>setKeepAliveTime</color><color=#f8f8f2>(</color><color=#f8f8f2>keepAliveTime</color><color=#f8f8f2>,</color> <color=#f8f8f2>TimeUnit</color><color=#f8f8f2>.</color><color=#a6e22e>MILLISECONDS</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>runEvictorThreads</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getBoolean</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>ENV_RUN_OFFHEAP_EVICTOR</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newMaxMemory</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>MAX_OFF_HEAP_MEMORY</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>newMaxMemory</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>(</color><color=#f8f8f2>maxMemory</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#75715e>// TODO detect this error earlier?</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
          <color=#e6db74>"Cannot change off-heap cache size between zero and non-zero"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>maxMemory</color> <color=#f92672>=</color> <color=#f8f8f2>newMaxMemory</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>setMaxBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>newMaxMemory</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>memoryLimit</color> <color=#f92672>=</color> <color=#f8f8f2>newMaxMemory</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>requestShutdown</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>shutdownRequested</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>evictionPool</color><color=#f8f8f2>.</color><color=#a6e22e>shutdown</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>shutdown</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>shutdownRequested</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>evictionPool</color><color=#f8f8f2>.</color><color=#a6e22e>shutdown</color><color=#f8f8f2>();</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>shutdownFinished</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>shutdownFinished</color> <color=#f92672>=</color> <color=#f8f8f2>evictionPool</color><color=#f8f8f2>.</color><color=#a6e22e>awaitTermination</color><color=#f8f8f2>(</color><color=#f8f8f2>terminateMillis</color><color=#f8f8f2>,</color> <color=#f8f8f2>TimeUnit</color><color=#f8f8f2>.</color><color=#a6e22e>MILLISECONDS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>InterruptedException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* We've been interrupted, just give up and end. */</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>shutdownFinished</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>evictionPool</color><color=#f8f8f2>.</color><color=#a6e22e>shutdownNow</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>clearCache</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>);</color>

      <color=#75715e>//            envImpl.getMemoryBudget().updateAdminMemoryUsage(</color>
      <color=#75715e>//                0 - (chunks.length * CHUNK_MEMORY_SIZE));</color>

      <color=#f8f8f2>chunks</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isEnabled</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>allocator</color> <color=#f92672>!=</color> <color=#f8f8f2>DummyAllocator</color><color=#f8f8f2>.</color><color=#a6e22e>INSTANCE</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>clearCache</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>matchEnv</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Use local var because when matchEnv is non-null, other threads (for</color>
<color=#75715e>     * other envs in the shared pool) are running and may replace the</color>
<color=#75715e>     * array. However, all entries for matchEnv will remain in the local</color>
<color=#75715e>     * array.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color><color=#f92672>[]</color> <color=#f8f8f2>myChunks</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>myChunks</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f8f8f2>:</color> <color=#f8f8f2>myChunks</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672><</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>owner</color> <color=#f92672>=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>owner</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>matchEnv</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>owner</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>matchEnv</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>owner</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>();</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>removeINFromMain</color><color=#f8f8f2>(</color><color=#f8f8f2>owner</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>owner</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>StatGroup</color> <color=#a6e22e>loadStats</color><color=#f8f8f2>(</color><color=#f8f8f2>StatsConfig</color> <color=#f8f8f2>config</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>StatGroup</color> <color=#f8f8f2>stats</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StatGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>GROUP_NAME</color><color=#f8f8f2>,</color> <color=#f8f8f2>GROUP_DESC</color><color=#f8f8f2>);</color>

    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>ALLOC_FAILURE</color><color=#f8f8f2>,</color> <color=#f8f8f2>nAllocFailure</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>ALLOC_OVERFLOW</color><color=#f8f8f2>,</color> <color=#f8f8f2>nAllocOverflow</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>THREAD_UNAVAILABLE</color><color=#f8f8f2>,</color> <color=#f8f8f2>nThreadUnavailable</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CRITICAL_NODES_TARGETED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nCriticalNodesTargeted</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>NODES_TARGETED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nNodesTargeted</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>NODES_EVICTED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nNodesEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>DIRTY_NODES_EVICTED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nDirtyNodesEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>NODES_STRIPPED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nNodesStripped</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>NODES_MUTATED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nNodesMutated</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>NODES_SKIPPED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>LNS_EVICTED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nLNsEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>LNS_LOADED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nLNsLoaded</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>LNS_STORED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nLNsStored</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>BINS_LOADED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nBINsLoaded</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>BINS_STORED</color><color=#f8f8f2>,</color> <color=#f8f8f2>nBINsStored</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>IntStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CACHED_LNS</color><color=#f8f8f2>,</color> <color=#f8f8f2>cachedLNs</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>IntStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CACHED_BINS</color><color=#f8f8f2>,</color> <color=#f8f8f2>cachedBINs</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>IntStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>CACHED_BIN_DELTAS</color><color=#f8f8f2>,</color> <color=#f8f8f2>cachedBINDeltas</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>TOTAL_BYTES</color><color=#f8f8f2>,</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>getUsedBytes</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>IntStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>TOTAL_BLOCKS</color><color=#f8f8f2>,</color> <color=#f8f8f2>totalBlocks</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>
    <color=#66d9ef>new</color> <color=#f8f8f2>IntStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>LRU_SIZE</color><color=#f8f8f2>,</color> <color=#f8f8f2>lruSize</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>());</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getClear</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nAllocFailure</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nAllocOverflow</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nThreadUnavailable</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nCriticalNodesTargeted</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nNodesTargeted</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nNodesEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nDirtyNodesEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nNodesStripped</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nNodesMutated</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nLNsEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nLNsLoaded</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nLNsStored</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nBINsLoaded</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nBINsStored</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>stats</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getMaxMemory</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>maxMemory</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getUsedMemory</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>getUsedBytes</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Forces allocation of the first chunk of entries. Used by tests that need to more precisely</color>
<color=#75715e>   * control cache behavior.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>preallocateLRUEntries</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>chunks</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>freeEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>allocateEntry</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>OffHeapAllocator</color> <color=#a6e22e>getAllocator</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>debug</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>msg</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>DEBUG_TRACE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_TRACE_STACK</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>msg</color> <color=#f92672>+=</color> <color=#e6db74>" "</color> <color=#f92672>+</color> <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>getStackTrace</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_TRACE_AND_LOG</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>traceAndLog</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>INFO</color><color=#f8f8f2>,</color> <color=#f8f8f2>msg</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>logger</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>INFO</color><color=#f8f8f2>,</color> <color=#f8f8f2>msg</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>addBack</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>owner</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>owner</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>allocateEntry</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lruIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>numLRULists</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color> <color=#f8f8f2>lru</color> <color=#f92672>=</color> <color=#f8f8f2>pri2</color> <color=#f92672>?</color> <color=#f8f8f2>pri2LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pri1LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>lru</color><color=#f8f8f2>.</color><color=#a6e22e>addBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>owner</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>moveBack</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lruIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>numLRULists</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color> <color=#f8f8f2>lru</color> <color=#f92672>=</color> <color=#f8f8f2>pri2</color> <color=#f92672>?</color> <color=#f8f8f2>pri2LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pri1LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>lru</color><color=#f8f8f2>.</color><color=#a6e22e>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>moveFront</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lruIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>numLRULists</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color> <color=#f8f8f2>lru</color> <color=#f92672>=</color> <color=#f8f8f2>pri2</color> <color=#f92672>?</color> <color=#f8f8f2>pri2LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pri1LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>lru</color><color=#f8f8f2>.</color><color=#a6e22e>moveFront</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lruIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>numLRULists</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color> <color=#f8f8f2>lru</color> <color=#f92672>=</color> <color=#f8f8f2>pri2</color> <color=#f92672>?</color> <color=#f8f8f2>pri2LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pri1LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>lru</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>freeEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Takes an entry from the free list. If the free list is empty, allocates a new chunk and adds</color>
<color=#75715e>   * its entries to the free list.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>allocateEntry</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>addRemoveEntryMutex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>firstFreeListEntry</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>firstFreeListEntry</color><color=#f8f8f2>;</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>firstFreeListEntry</color> <color=#f92672>=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>2</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>lruSize</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>newChunk</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Chunk</color><color=#f8f8f2>();</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>next</color> <color=#f92672>=</color> <color=#f8f8f2>newChunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>nOldChunks</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>chunks</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#f8f8f2>chunks</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

      <color=#75715e>/* Entry 0 in the new chunk will be returned. */</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>nextFree</color> <color=#f92672>=</color> <color=#f8f8f2>nOldChunks</color> <color=#f92672>*</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>nextFree</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>next</color><color=#f92672>[</color><color=#ae81ff>0</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>2</color><color=#f8f8f2>;</color>

      <color=#75715e>/* Entry 1 is the tail of the free list. */</color>
      <color=#f8f8f2>next</color><color=#f92672>[</color><color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Entry 2 and above are added to the free list.</color>
<color=#75715e>       *</color>
<color=#75715e>       * This loop needs to be as fast as possible, which is why we're</color>
<color=#75715e>       * using local vars for next and nextFree.</color>
<color=#75715e>       *</color>
<color=#75715e>       * In the loop, nextFree starts out as entry 1 (tail of free</color>
<color=#75715e>       * list) and ends up as the last free entry (head of free list).</color>
<color=#75715e>       */</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>next</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>nextFree</color><color=#f92672>++</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* The last entry is the head of the free list. */</color>
      <color=#f8f8f2>firstFreeListEntry</color> <color=#f92672>=</color> <color=#f8f8f2>nextFree</color><color=#f8f8f2>;</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color><color=#f92672>[]</color> <color=#f8f8f2>newChunks</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Chunk</color><color=#f92672>[</color><color=#f8f8f2>nOldChunks</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nOldChunks</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>arraycopy</color><color=#f8f8f2>(</color><color=#f8f8f2>chunks</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>newChunks</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>nOldChunks</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>newChunks</color><color=#f92672>[</color><color=#f8f8f2>nOldChunks</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>newChunk</color><color=#f8f8f2>;</color>

      <color=#75715e>/* Assign to volatile chunks field as the very last step. */</color>
      <color=#f8f8f2>chunks</color> <color=#f92672>=</color> <color=#f8f8f2>newChunks</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>lruSize</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

      <color=#75715e>//            envImpl.getMemoryBudget().updateAdminMemoryUsage(</color>
      <color=#75715e>//                CHUNK_MEMORY_SIZE);</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Removes the entry from its LRU and adds it to the free list. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>freeEntry</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#f8f8f2>addRemoveEntryMutex</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color> <color=#75715e>// Already on free list</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>firstFreeListEntry</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>firstFreeListEntry</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>lruSize</color><color=#f8f8f2>.</color><color=#a6e22e>decrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getMemId</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>memIds</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>IN</color> <color=#a6e22e>getOwner</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>setOwner</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>owner</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>owner</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>owner</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>setOwnerAndMemId</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>owner</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>owner</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>owner</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>memIds</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>memId</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called before eviction of an LN from main cache to provide an opportunity to store the LN</color>
<color=#75715e>   * off-heap.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>storeEvictedLN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>isDirty</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>();</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If already stored off-heap, make the entry hot when</color>
<color=#75715e>       * CacheMode.UNCHANGED does not apply (getFetchedCold is false).</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getFetchedCold</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>(),</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_TRACE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>debug</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color>
            <color=#e6db74>"Evicted LN already store LSN="</color> <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)));</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Do not store off-heap:</color>
<color=#75715e>     *  - When CacheMode.UNCHANGED applies (getFetchedCold is true). This</color>
<color=#75715e>     *    is when the node was originally fetched from disk into main.</color>
<color=#75715e>     *  - Deleted LNs are no longer needed.</color>
<color=#75715e>     *  - For embedded LNs and dup DBs, there is no separate LN.</color>
<color=#75715e>     *  - Off-heap caching for internal DBs is not currently supported.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getFetchedCold</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color>
        <color=#f92672>||</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#75715e>// TODO remove</color>
        <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbType</color><color=#f8f8f2>().</color><color=#a6e22e>isInternal</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>serializeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#f8f8f2>ln</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Add to LRU at hot end, or make hot if already in LRU. */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>addBack</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLruId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_TRACE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>debug</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#e6db74>"Stored evicted LN LSN="</color> <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)));</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Called when an LN has been fetched from disk and should be stored off-heap. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>storePreloadedLN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>();</color>

    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>isDirty</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isEmbeddedLN</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getSortedDuplicates</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>();</color> <color=#75715e>// TODO remove</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbType</color><color=#f8f8f2>().</color><color=#a6e22e>isInternal</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>serializeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#f8f8f2>ln</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* Preloading into a temporary BIN, not in the Btree. */</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Add to LRU at hot end, or make hot if already in LRU. */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>addBack</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLruId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>ensureOffHeapLNsInLRU</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>hasOffHeapLNs</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>addBack</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLruId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>LN</color> <color=#a6e22e>loadLN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>materializeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#f8f8f2>memId</color><color=#f8f8f2>);</color>

    <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>UNCHANGED</color><color=#f8f8f2>:</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>MAKE_COLD</color><color=#f8f8f2>:</color>
        <color=#75715e>/* Will be evicted from main. Leave off-heap. */</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>EVICT_LN</color><color=#f8f8f2>:</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>EVICT_BIN</color><color=#f8f8f2>:</color>
        <color=#75715e>/* Will be evicted from main. Leave off-heap and make hot. */</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>(),</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>DEFAULT</color><color=#f8f8f2>:</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>KEEP_HOT</color><color=#f8f8f2>:</color>
        <color=#75715e>/* Will remain in main. Remove from off-heap. */</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>freeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>default</color><color=#f8f8f2>:</color>
        <color=#66d9ef>assert</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_TRACE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>debug</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#e6db74>"Loaded LN LSN="</color> <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)));</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>ln</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>freeRedundantLN</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>CacheMode</color> <color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>cacheMode</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>UNCHANGED</color><color=#f8f8f2>:</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>MAKE_COLD</color><color=#f8f8f2>:</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getFetchedCold</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#75715e>/* Will be evicted from main. Leave off-heap. */</color>
          <color=#66d9ef>return</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#75715e>/* Will remain in main. Remove from off-heap. */</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>EVICT_BIN</color><color=#f8f8f2>:</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>EVICT_LN</color><color=#f8f8f2>:</color>
        <color=#75715e>/* Will be evicted from main. Leave off-heap. */</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>DEFAULT</color><color=#f8f8f2>:</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>KEEP_HOT</color><color=#f8f8f2>:</color>
        <color=#75715e>/* Will remain in main. Remove from off-heap. */</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#66d9ef>default</color><color=#f8f8f2>:</color>
        <color=#66d9ef>assert</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>freeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>loadVLSN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>getCacheVLSN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>8</color><color=#f92672>]</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>freeLN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Since the LN was off-heap, set fetched-cold to false. Otherwise</color>
<color=#75715e>     * the fetched-cold flag will prevent the LN from being stored</color>
<color=#75715e>     * off-heap when it is evicted later.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>LN</color><color=#f8f8f2>)</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>setFetchedCold</color><color=#f8f8f2>(</color><color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>freeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>freeLN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>cachedLNs</color><color=#f8f8f2>.</color><color=#a6e22e>decrementAndGet</color><color=#f8f8f2>();</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>freeMemory</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>serializeLN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>useOffHeapChecksums</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>=</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>?</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>vlsnSize</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCacheVLSN</color><color=#f8f8f2>()</color> <color=#f92672>?</color> <color=#f8f8f2>VLSN_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lnDataOffset</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnSize</color> <color=#f92672>+</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We make 3 calls to allocator.copy (one explicit and two via putLong</color>
<color=#75715e>     * and putInt) rather than just one because:</color>
<color=#75715e>     *  - This avoids an extra copy and buffer allocation for the LN data.</color>
<color=#75715e>     *  - The LN data is potentially large.</color>
<color=#75715e>     *  - The checksum is normally off in production, so there is at most</color>
<color=#75715e>     *    one extra allocator.copy for the VLSN.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>data</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>allocateMemory</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnDataOffset</color> <color=#f92672>+</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnSize</color> <color=#f92672>></color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>useChecksums</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>8</color><color=#f92672>]</color> <color=#f8f8f2>:</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnSize</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>putLong</color><color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getVLSNSequence</color><color=#f8f8f2>(),</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useChecksums</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Checksum</color> <color=#f8f8f2>checksum</color> <color=#f92672>=</color> <color=#f8f8f2>Adler32</color><color=#f8f8f2>.</color><color=#a6e22e>makeChecksum</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>checksum</color><color=#f8f8f2>.</color><color=#a6e22e>update</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumValue</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>checksum</color><color=#f8f8f2>.</color><color=#a6e22e>getValue</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>putInt</color><color=#f8f8f2>(</color><color=#f8f8f2>checksumValue</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnDataOffset</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>nLNsStored</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>cachedLNs</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>memId</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>LN</color> <color=#a6e22e>materializeLN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>useOffHeapChecksums</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>=</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>?</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>vlsnSize</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getCacheVLSN</color><color=#f8f8f2>()</color> <color=#f92672>?</color> <color=#f8f8f2>VLSN_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lnDataOffset</color> <color=#f92672>=</color> <color=#f8f8f2>vlsnSize</color> <color=#f92672>+</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f92672>-</color> <color=#f8f8f2>lnDataOffset</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnDataOffset</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnSize</color> <color=#f92672>></color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>useChecksums</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>8</color><color=#f92672>]</color> <color=#f8f8f2>:</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useChecksums</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>storedChecksum</color> <color=#f92672>=</color> <color=#f8f8f2>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>vlsnSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>storedChecksum</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>Checksum</color> <color=#f8f8f2>checksum</color> <color=#f92672>=</color> <color=#f8f8f2>Adler32</color><color=#f8f8f2>.</color><color=#a6e22e>makeChecksum</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>checksum</color><color=#f8f8f2>.</color><color=#a6e22e>update</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumValue</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>checksum</color><color=#f8f8f2>.</color><color=#a6e22e>getValue</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>storedChecksum</color> <color=#f92672>!=</color> <color=#f8f8f2>checksumValue</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
              <color=#e6db74>"Off-heap cache checksum error. Expected "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>storedChecksum</color>
                  <color=#f92672>+</color> <color=#e6db74>" but got "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>checksumValue</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>nLNsLoaded</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>LN</color><color=#f8f8f2>.</color><color=#a6e22e>makeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>clearDirty</color><color=#f8f8f2>();</color> <color=#75715e>// New LNs are initially dirty.</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>vlsnSize</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>setVLSNSequence</color><color=#f8f8f2>(</color><color=#f8f8f2>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>ln</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called before eviction of a BIN from main cache to provide an opportunity to store the BIN</color>
<color=#75715e>   * off-heap.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>removeINFromMain is called after this method by the main evictor. It is removeINFromMain</color>
<color=#75715e>   * that removes the main BIN's off-heap LRU entry, if it has one. The bin and parent latches are</color>
<color=#75715e>   * held across the calls to storeEvictedBIN and removeINFromMain.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>removeINFromMain will also free any off-heap LN IDs in the main BIN, and therefore this</color>
<color=#75715e>   * method must clear those IDs in the main BIN. When the BIN is stored off-heap by this method,</color>
<color=#75715e>   * the LN IDs will be stored along with the off-heap BIN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>storeEvictedBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Do not store off-heap:</color>
<color=#75715e>     *  - When CacheMode.UNCHANGED applies, the BIN was not loaded from</color>
<color=#75715e>     *    off-heap, and the BIN is not dirty.</color>
<color=#75715e>     *  - Off-heap caching for internal DBs is not currently supported.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getFetchedCold</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getFetchedColdOffHeap</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>())</color>
        <color=#f92672>||</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#75715e>// TODO remove</color>
        <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbType</color><color=#f8f8f2>().</color><color=#a6e22e>isInternal</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Serialize the BIN and add it to the off-heap LRU. */</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>serializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>());</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Reuse LRU entry if one exists for the BIN, in order not to change</color>
<color=#75715e>     * the effective LRU position of its off-heap LNs. When off-heap LNs</color>
<color=#75715e>     * are present, we want to preserve the off-heap LRU position to allow</color>
<color=#75715e>     * the LNs to be stripped sooner.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>setOwnerAndMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>clearOffHeapLNIds</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLruId</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>addBack</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*pri2*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*pri2*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>());</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_TRACE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>debug</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color>
          <color=#e6db74>"Stored BIN LSN="</color>
              <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color>
              <color=#f92672>+</color> <color=#e6db74>" Node="</color>
              <color=#f92672>+</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color>
              <color=#f92672>+</color> <color=#e6db74>" dirty="</color>
              <color=#f92672>+</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Called when a BIN has been fetched from disk and should be stored off-heap. */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>storePreloadedBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>();</color>

    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>();</color> <color=#75715e>// TODO remove</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbType</color><color=#f8f8f2>().</color><color=#a6e22e>isInternal</color><color=#f8f8f2>();</color>

    <color=#75715e>/* Pass non-null 'bin' so that off-heap LNs are not freed. */</color>
    <color=#f8f8f2>freeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>serializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>());</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>addBack</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*pri2*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*pri2*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>());</color>

    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called before eviction of a level 2 IN from main cache. Any off-heap BIN children are first</color>
<color=#75715e>   * logged, if dirty, and then discarded.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if all BINs could be discarded, or false if a dirty BIN could not be logged due to</color>
<color=#75715e>   *     a read-only env or disk limit violation.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>boolean</color> <color=#a6e22e>flushAndDiscardBINChildren</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNormalizedLevel</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>hasOffHeapBINIds</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>allDiscarded</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>flushAndDiscardBIN</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>entry</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINPri2</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
              <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>),</color>
              <color=#f8f8f2>getMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>),</color>
              <color=#f8f8f2>in</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>i</color><color=#f8f8f2>,</color>
              <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>,</color>
              <color=#66d9ef>true</color> <color=#75715e>/*freeLNs*/</color><color=#f8f8f2>)</color>
          <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>allDiscarded</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>allDiscarded</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called: - after eviction of an IN from main cache, and in that case storeEvictedBIN was called</color>
<color=#75715e>   * and the eviction was completed. - when an IN is removed from the main cache for another reason,</color>
<color=#75715e>   * such as a reverse split or Database removal. - for all INs in an Environment being removed from</color>
<color=#75715e>   * the shared cache.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>removeINFromMain</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>level</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNormalizedLevel</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>level</color> <color=#f92672>></color> <color=#ae81ff>2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>level</color> <color=#f92672>==</color> <color=#ae81ff>2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>hasOffHeapBINIds</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>long</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>freeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>level</color> <color=#f92672>==</color> <color=#ae81ff>1</color> <color=#f92672>&&</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>hasOffHeapLNs</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>hasOffHeapLNs</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>freeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLruId</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>loadBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>entry</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>materializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>getMemBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>getMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>)));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Loads a BIN for the given entry, if its last logged LSN is the given LSN. Can be used to store</color>
<color=#75715e>   * an entry for a BIN (the off-heap BIN ID) without holding its parent IN latch, and later find</color>
<color=#75715e>   * out whether that entry still refers to the same BIN. If the BIN was split, the LSN will have</color>
<color=#75715e>   * changed and null is returned. If the BIN is no longer off-heap, or was moved off-heap and back</color>
<color=#75715e>   * on, null is also returned.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If the BIN is redundantly resident in the main and off-heap caches, the main cache "live"</color>
<color=#75715e>   * version is returned. Otherwise the BIN is deserialized from the off-heap version and is not</color>
<color=#75715e>   * "live". When non-null is returned, the returned BIN is latched.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>loadBINIfLsnMatches</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>IN</color><color=#f8f8f2>,</color> <color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>findBINIfLsnMatches</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>first</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>();</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>getMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>materializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>getMemBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>());</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>evictBINIfLsnMatch</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>IN</color><color=#f8f8f2>,</color> <color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>findBINIfLsnMatches</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>result</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>first</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>freeBIN</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** If non-null is returned, the returned IN will be EX latched. */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>IN</color><color=#f8f8f2>,</color> <color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#a6e22e>findBINIfLsnMatches</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color> <color=#f92672>=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The validation process here is very similar to in evictOne. See the</color>
<color=#75715e>     * comments in that method.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color> <color=#f92672>!=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color>
        <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>envImpl</color>
        <color=#f92672>||</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>i</color><color=#f8f8f2>;</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>Pair</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#a6e22e>getBINBytes</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color> <color=#f92672>==</color> <color=#f8f8f2>getOwner</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>getMemBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>getMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Called when a BIN's bytes were obtained holding a shared latch, and then the latch was released</color>
<color=#75715e>   * and acquired again. We need to determine whether the BIN was changed and moved off-heap again,</color>
<color=#75715e>   * while unlatched.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Currently we just get the bytes again and compare.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Possible optimization: Maintain a generation count in the serialized BIN, whose value comes</color>
<color=#75715e>   * from a global counter that is incremented whenever a BIN is serialized. But would the range of</color>
<color=#75715e>   * such a counter be large enough to guarantee that wrapping won't be a problem? Certainly the</color>
<color=#75715e>   * odds are low, but how can we guarantee it won't happen? Another approach is to maintain the</color>
<color=#75715e>   * counter in the BIN in main cache, so it is a per BIN value.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>haveBINBytesChanged</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>bytes</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f92672>!</color><color=#f8f8f2>Arrays</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>bytes</color><color=#f8f8f2>,</color> <color=#f8f8f2>getBINBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>postBINLoad</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>entry</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color> <color=#f92672>==</color> <color=#f8f8f2>getOwner</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>));</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>freed</color> <color=#f92672>=</color> <color=#f8f8f2>freeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>freed</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>ensureOffHeapLNsInLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_TRACE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>debug</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color>
          <color=#e6db74>"Loaded BIN LSN="</color>
              <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color>
              <color=#f92672>+</color> <color=#e6db74>" Node="</color>
              <color=#f92672>+</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>()</color>
              <color=#f92672>+</color> <color=#e6db74>" dirty="</color>
              <color=#f92672>+</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>freeBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color> <color=#f92672>==</color> <color=#f8f8f2>getOwner</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINPri2</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>getMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>clearOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Only free the LNs referenced by the off-heap BIN if the BIN is not</color>
<color=#75715e>     * resident in main (bin == null). When the off-heap BIN is stale, its</color>
<color=#75715e>     * LN Ids are also stale.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>freeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#75715e>/*freeLNs*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>freeBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>freeLNs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>flags</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>freeLNs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>ParsedBIN</color> <color=#f8f8f2>pb</color> <color=#f92672>=</color>
          <color=#f8f8f2>parseBINBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>getMemBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>),</color> <color=#66d9ef>false</color> <color=#75715e>/*partialBuf*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*parseLNIds*/</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lnMemIds</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lnMemId</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lnMemIds</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnMemId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>freeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>lnMemId</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>flags</color> <color=#f92672>=</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>flags</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>useOffHeapChecksums</color><color=#f8f8f2>();</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>=</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>?</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>flags</color> <color=#f92672>=</color> <color=#f8f8f2>getByte</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>1</color><color=#f92672>]</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>cachedBINs</color><color=#f8f8f2>.</color><color=#a6e22e>decrementAndGet</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>flags</color> <color=#f92672>&</color> <color=#f8f8f2>BIN_FLAG_DELTA</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>cachedBINDeltas</color><color=#f8f8f2>.</color><color=#a6e22e>decrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>size</color> <color=#f92672>+</color> <color=#f8f8f2>freeMemory</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>long</color> <color=#a6e22e>serializeBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>asDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>hasCachedChildren</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>asDelta</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>useOffHeapChecksums</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>=</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>?</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>canMutate</color> <color=#f92672>=</color> <color=#f92672>!</color><color=#f8f8f2>asDelta</color> <color=#f92672>&&</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>canMutateToBINDelta</color><color=#f8f8f2>();</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>flags</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>asDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>flags</color> <color=#f92672>|=</color> <color=#f8f8f2>BIN_FLAG_DELTA</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>canMutate</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>flags</color> <color=#f92672>|=</color> <color=#f8f8f2>BIN_FLAG_CAN_MUTATE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getProhibitNextDelta</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>flags</color> <color=#f92672>|=</color> <color=#f8f8f2>BIN_FLAG_PROHIBIT_NEXT_DELTA</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>short</color> <color=#f8f8f2>lnIdSize</color> <color=#f92672>=</color> <color=#f8f8f2>getPackedLnMemIdSize</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If there are any LNs, then we should not be mutating from a full BIN</color>
<color=#75715e>     * to a BIN delta -- this isn't handled and should not happen.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>asDelta</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>lnIdSize</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>memSize</color> <color=#f92672>=</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>+</color> <color=#ae81ff>1</color> <color=#f92672>+</color> <color=#ae81ff>8</color> <color=#f92672>+</color> <color=#ae81ff>8</color> <color=#f92672>+</color> <color=#ae81ff>4</color> <color=#f92672>+</color> <color=#ae81ff>2</color> <color=#f92672>+</color> <color=#f8f8f2>lnIdSize</color> <color=#f92672>+</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLogSize</color><color=#f8f8f2>(</color><color=#f8f8f2>asDelta</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>allocateMemory</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>memSize</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>memSize</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>bufOffset</color> <color=#f92672>=</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>bufOffset</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>flags</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>putLong</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLastFullLsn</color><color=#f8f8f2>(),</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>putLong</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLastDeltaLsn</color><color=#f8f8f2>(),</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>putInt</color><color=#f8f8f2>(</color><color=#f8f8f2>getMinExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>),</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>4</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>putShort</color><color=#f8f8f2>(</color><color=#f8f8f2>lnIdSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnIdSize</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>packLnMemIds</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#f8f8f2>lnIdSize</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>byteBuf</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>wrap</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>-</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>serialize</color><color=#f8f8f2>(</color><color=#f8f8f2>byteBuf</color><color=#f8f8f2>,</color> <color=#f8f8f2>asDelta</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*clearDirtyBits*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useChecksums</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Checksum</color> <color=#f8f8f2>checksum</color> <color=#f92672>=</color> <color=#f8f8f2>Adler32</color><color=#f8f8f2>.</color><color=#a6e22e>makeChecksum</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>checksum</color><color=#f8f8f2>.</color><color=#a6e22e>update</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>-</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>);</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumValue</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>checksum</color><color=#f8f8f2>.</color><color=#a6e22e>getValue</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>putInt</color><color=#f8f8f2>(</color><color=#f8f8f2>checksumValue</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>nBINsStored</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>cachedBINs</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>asDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>cachedBINDeltas</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>memId</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>materializeBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>ParsedBIN</color> <color=#f8f8f2>pb</color> <color=#f92672>=</color> <color=#f8f8f2>parseBINBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*partialBuf*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*parseLNIds*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>materializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>flags</color> <color=#f92672>&</color> <color=#f8f8f2>BIN_FLAG_DELTA</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>nBINsLoaded</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>BIN</color> <color=#a6e22e>materializeBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>ParsedBIN</color> <color=#f8f8f2>pb</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>asDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BIN</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>materialize</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>binBytes</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_VERSION</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>asDelta</color> <color=#75715e>/*deltasOnly*/</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>flags</color> <color=#f92672>&</color> <color=#f8f8f2>BIN_FLAG_LOGGED_FULL_VERSION</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color> <color=#75715e>/*clearDirtyBits*/</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setLastFullLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lastFullLsn</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setLastDeltaLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lastDeltaLsn</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setProhibitNextDelta</color><color=#f8f8f2>((</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>flags</color> <color=#f92672>&</color> <color=#f8f8f2>BIN_FLAG_PROHIBIT_NEXT_DELTA</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lnMemIds</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lnMemIds</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lnMemId</color> <color=#f92672>=</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lnMemIds</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnMemId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnMemId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>INLogEntry</color><color=#f92672><</color><color=#f8f8f2>BIN</color><color=#f92672>></color> <color=#a6e22e>createBINLogEntryForCheckpoint</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color> <color=#f92672>==</color> <color=#f8f8f2>getOwner</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>getMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>createBINLogEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*preserveBINInCache*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>postBINLog</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>INLogEntry</color><color=#f92672><</color><color=#f8f8f2>BIN</color><color=#f92672>></color> <color=#f8f8f2>logEntry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newLsn</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>useOffHeapChecksums</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>=</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>?</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isDelta</color> <color=#f92672>=</color> <color=#f8f8f2>logEntry</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>entry</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>logEntry</color><color=#f8f8f2>.</color><color=#a6e22e>isPreSerialized</color><color=#f8f8f2>()</color> <color=#f92672>?</color> <color=#66d9ef>null</color> <color=#f8f8f2>:</color> <color=#f8f8f2>logEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getMainItem</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Update checksum, flags and last full/delta LSNs.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>getMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>checksumSize</color> <color=#f92672>+</color> <color=#ae81ff>1</color> <color=#f92672>+</color> <color=#ae81ff>8</color> <color=#f92672>+</color> <color=#ae81ff>8</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>bufOffset</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#75715e>/* The checksum is now invalid. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useChecksums</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>putInt</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Update flags. */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>flags</color> <color=#f92672>=</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>bufOffset</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>flags</color> <color=#f92672>|=</color> <color=#f8f8f2>BIN_FLAG_LOGGED_FULL_VERSION</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>flags</color> <color=#f92672>&=</color> <color=#f92672>~</color><color=#f8f8f2>BIN_FLAG_PROHIBIT_NEXT_DELTA</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>bufOffset</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>flags</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Update lastFullLsn. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>putLong</color><color=#f8f8f2>(</color><color=#f8f8f2>newLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>

    <color=#75715e>/* Update lastDeltaLsn. */</color>
    <color=#f8f8f2>putLong</color><color=#f8f8f2>(</color><color=#f8f8f2>isDelta</color> <color=#f92672>?</color> <color=#f8f8f2>newLsn</color> <color=#f8f8f2>:</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bufOffset</color> <color=#f92672>==</color> <color=#f8f8f2>buf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Move from pri2 LRU list to back of pri1 LRU list. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINPri2</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>pri2LRUSet</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>numLRULists</color><color=#f92672>]</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*pri2*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*pri2*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*dirty*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>INLogEntry</color><color=#f92672><</color><color=#f8f8f2>BIN</color><color=#f92672>></color> <color=#a6e22e>createBINLogEntry</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>preserveBINInCache</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color> <color=#f92672>=</color> <color=#f8f8f2>getMemBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>ParsedBIN</color> <color=#f8f8f2>pb</color> <color=#f92672>=</color> <color=#f8f8f2>parseBINBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*partialBuf*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*parseLNIds*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isDelta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>flags</color> <color=#f92672>&</color> <color=#f8f8f2>BIN_FLAG_DELTA</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>canMutateToDelta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>flags</color> <color=#f92672>&</color> <color=#f8f8f2>BIN_FLAG_CAN_MUTATE</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the BIN is a delta, we must log a delta. In that case we cannot</color>
<color=#75715e>     * compress expired slots, and we can log the pre-serialized BIN.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>isDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BINDeltaLogEntry</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>binBytes</color><color=#f8f8f2>,</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lastFullLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lastDeltaLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_BIN_DELTA</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * For a full BIN, normally we log a delta iff it can be mutated to a</color>
<color=#75715e>     * delta. However, if any slots are expired, we attempt to compress</color>
<color=#75715e>     * them and then determine whether to log a delta.</color>
<color=#75715e>     *</color>
<color=#75715e>     * This mimics the logic in IN.logInternal, for BINs in main cache.</color>
<color=#75715e>     *</color>
<color=#75715e>     * TODO: Use materialized BIN in the log entry when any slot has an</color>
<color=#75715e>     * expiration time, even if none are currently expired. Such BINs must</color>
<color=#75715e>     * be materialized during logging for expiration tracking anyway by</color>
<color=#75715e>     * INLogEntry.getBINWithExpiration. Then the getBINWithExpiration and</color>
<color=#75715e>     * BIN.mayHaveExpirationValues methods will no longer be needed.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>hasExpiredSlot</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isExpired</color><color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>minExpiration</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*hours*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If we do not need to log a full BIN as a delta, or to compress its</color>
<color=#75715e>     * expired slots, then we can log the pre-serialized BIN.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>hasExpiredSlot</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>canMutateToDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>INLogEntry</color><color=#f92672><></color><color=#f8f8f2>(</color>
          <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>binBytes</color><color=#f8f8f2>,</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lastFullLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lastDeltaLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_BIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We must materialize the full BIN in order to log it as a delta or to</color>
<color=#75715e>     * compress its expired slots.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>materializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*asDelta*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Latch the BIN to avoid assertions during BIN.writeToLog. A side</color>
<color=#75715e>     * effect is setting the Database, which is also needed.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>());</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>logDelta</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>hasExpiredSlot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>origNSlots</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Compress non-dirty slots before determining delta status. */</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>compress</color><color=#f8f8f2>(</color><color=#66d9ef>false</color> <color=#75715e>/*compressDirtySlots*/</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>logDelta</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>shouldLogDelta</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Also compress dirty slots, if we will not log a delta. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>logDelta</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>compress</color><color=#f8f8f2>(</color><color=#66d9ef>true</color> <color=#75715e>/*compressDirtySlots*/</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* If we compressed an expired slot, re-serialize the BIN. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>preserveBINInCache</color> <color=#f92672>&&</color> <color=#f8f8f2>origNSlots</color> <color=#f92672>!=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newMemId</color> <color=#f92672>=</color> <color=#f8f8f2>serializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>());</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newMemId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * TODO: Is invalid if compressed slot had off-heap LN.</color>
<color=#75715e>           * Should discard off-heap BIN and install 'bin' in main.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>INLogEntry</color><color=#f92672><></color><color=#f8f8f2>(</color>
              <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>binBytes</color><color=#f8f8f2>,</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lastFullLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lastDeltaLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>LogEntryType</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_BIN</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>freeMemory</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>setOwnerAndMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>newMemId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* hasExpiredSlot is false, therefore canMutateToDelta is true. */</color>
      <color=#f8f8f2>logDelta</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>logDelta</color> <color=#f92672>?</color> <color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>BINDeltaLogEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>))</color> <color=#f8f8f2>:</color> <color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>INLogEntry</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>BINInfo</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isBINDelta</color><color=#f8f8f2>;</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>fullBINLsn</color><color=#f8f8f2>;</color>

    <color=#66d9ef>private</color> <color=#a6e22e>BINInfo</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>ParsedBIN</color> <color=#f8f8f2>pb</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>isBINDelta</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>flags</color> <color=#f92672>&</color> <color=#f8f8f2>BIN_FLAG_DELTA</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>fullBINLsn</color> <color=#f92672>=</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lastFullLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#f8f8f2>BINInfo</color> <color=#a6e22e>getBINInfo</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>entry</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>useOffHeapChecksums</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>=</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>?</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>getMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>checksumSize</color> <color=#f92672>+</color> <color=#ae81ff>1</color> <color=#f92672>+</color> <color=#ae81ff>8</color> <color=#f92672>+</color> <color=#ae81ff>8</color> <color=#f92672>+</color> <color=#ae81ff>4</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>ParsedBIN</color> <color=#f8f8f2>pb</color> <color=#f92672>=</color> <color=#f8f8f2>parseBINBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*partialBuf*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*parseLNIds*/</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BINInfo</color><color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>long</color> <color=#a6e22e>getINSize</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>hasOffHeapLNs</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>long</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>totalSize</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNormalizedLevel</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>hasOffHeapBINIds</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>getMemId</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>totalSize</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Redundant BIN, do not count off-heap LNs here. */</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>ParsedBIN</color> <color=#f8f8f2>pb</color> <color=#f92672>=</color>
          <color=#f8f8f2>parseBINBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>getMemBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>),</color> <color=#66d9ef>false</color> <color=#75715e>/*partialBuf*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*parseLNIds*/</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lnMemIds</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lnMemId</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pb</color><color=#f8f8f2>.</color><color=#a6e22e>lnMemIds</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnMemId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>totalSize</color><color=#f8f8f2>(</color><color=#f8f8f2>lnMemId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>class</color> <color=#a6e22e>ParsedBIN</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>flags</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>lnMemIds</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastFullLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastDeltaLsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>minExpiration</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>binBytes</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>ParsedBIN</color><color=#f8f8f2>(</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>flags</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>lnMemIds</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastFullLsn</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastDeltaLsn</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>minExpiration</color><color=#f8f8f2>,</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>binBytes</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>flags</color> <color=#f92672>=</color> <color=#f8f8f2>flags</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lnMemIds</color> <color=#f92672>=</color> <color=#f8f8f2>lnMemIds</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lastFullLsn</color> <color=#f92672>=</color> <color=#f8f8f2>lastFullLsn</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>lastDeltaLsn</color> <color=#f92672>=</color> <color=#f8f8f2>lastDeltaLsn</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>minExpiration</color> <color=#f92672>=</color> <color=#f8f8f2>minExpiration</color><color=#f8f8f2>;</color>
      <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>binBytes</color> <color=#f92672>=</color> <color=#f8f8f2>binBytes</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>ParsedBIN</color> <color=#a6e22e>parseBINBytes</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>partialBuf</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>parseLNIds</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>partialBuf</color> <color=#f92672>&&</color> <color=#f8f8f2>parseLNIds</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>useOffHeapChecksums</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>=</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>?</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useChecksums</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>partialBuf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>storedChecksum</color> <color=#f92672>=</color> <color=#f8f8f2>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>storedChecksum</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>final</color> <color=#f8f8f2>Checksum</color> <color=#f8f8f2>checksum</color> <color=#f92672>=</color> <color=#f8f8f2>Adler32</color><color=#f8f8f2>.</color><color=#a6e22e>makeChecksum</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>checksum</color><color=#f8f8f2>.</color><color=#a6e22e>update</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>-</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>);</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumValue</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>checksum</color><color=#f8f8f2>.</color><color=#a6e22e>getValue</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>storedChecksum</color> <color=#f92672>!=</color> <color=#f8f8f2>checksumValue</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>unexpectedState</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
              <color=#e6db74>"Off-heap cache checksum error. Expected "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>storedChecksum</color>
                  <color=#f92672>+</color> <color=#e6db74>" but got "</color>
                  <color=#f92672>+</color> <color=#f8f8f2>checksumValue</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>bufOffset</color> <color=#f92672>=</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>flags</color> <color=#f92672>=</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>bufOffset</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastFullLsn</color> <color=#f92672>=</color> <color=#f8f8f2>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lastDeltaLsn</color> <color=#f92672>=</color> <color=#f8f8f2>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>minExpiration</color> <color=#f92672>=</color> <color=#f8f8f2>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>4</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>partialBuf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>ParsedBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>flags</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastFullLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastDeltaLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>minExpiration</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>short</color> <color=#f8f8f2>lnIdsSize</color> <color=#f92672>=</color> <color=#f8f8f2>getShort</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>

    <color=#75715e>/* lnIdsSize was negated if LNs were stripped by eviction. */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>lnMemIds</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnIdsSize</color> <color=#f92672>></color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>parseLNIds</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lnMemIds</color> <color=#f92672>=</color> <color=#f8f8f2>unpackLnMemIds</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnIdsSize</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lnMemIds</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>abs</color><color=#f8f8f2>(</color><color=#f8f8f2>lnIdsSize</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>byteBuf</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>wrap</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>-</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>ParsedBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>flags</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnMemIds</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastFullLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>lastDeltaLsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>minExpiration</color><color=#f8f8f2>,</color> <color=#f8f8f2>byteBuf</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Returns the minimum expiration time in hours, or zero of no slots have an expiration time. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>getMinExpiration</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>minExpire</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>expire</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getExpiration</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>expire</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>minExpire</color> <color=#f92672>></color> <color=#f8f8f2>expire</color> <color=#f92672>||</color> <color=#f8f8f2>minExpire</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>minExpire</color> <color=#f92672>=</color> <color=#f8f8f2>expire</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>minExpire</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpirationInHours</color><color=#f8f8f2>()</color> <color=#f92672>?</color> <color=#f8f8f2>minExpire</color> <color=#f8f8f2>:</color> <color=#f8f8f2>(</color><color=#f8f8f2>minExpire</color> <color=#f92672>*</color> <color=#ae81ff>24</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds LN memIds to the buffer using an RLE approach to save space:</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>- The memIds are packed in slot index order. All slots are represented. - A positive byte</color>
<color=#75715e>   * indicates the number of 8-byte memIds that follow. - A negative byte indicates the number of</color>
<color=#75715e>   * slots that have no memId. - When a run exceeds 127 slots, another run is added. So there is no</color>
<color=#75715e>   * effective limit on number of slots, although we know the maximum will fit in a short integer.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>packLnMemIds</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>off</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>nOff</color> <color=#f92672>=</color> <color=#f8f8f2>off</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#66d9ef>byte</color> <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>memId</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>n</color> <color=#f92672>==</color> <color=#ae81ff>127</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>nOff</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>nOff</color> <color=#f92672>=</color> <color=#f8f8f2>off</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>putLong</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>off</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>n</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>></color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>n</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>127</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>nOff</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>nOff</color> <color=#f92672>=</color> <color=#f8f8f2>off</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>n</color> <color=#f92672>-=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>nOff</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>short</color> <color=#a6e22e>getPackedLnMemIdSize</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>hasOffHeapLNs</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>off</color> <color=#f92672>=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#66d9ef>byte</color> <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>n</color> <color=#f92672>==</color> <color=#ae81ff>127</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>n</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>></color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>n</color> <color=#f92672>==</color> <color=#f92672>-</color><color=#ae81ff>127</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>n</color> <color=#f92672>-=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>off</color> <color=#f92672>></color> <color=#f8f8f2>Short</color><color=#f8f8f2>.</color><color=#a6e22e>MAX_VALUE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#f8f8f2>unexpectedState</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>short</color><color=#f8f8f2>)</color> <color=#f8f8f2>off</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#a6e22e>unpackLnMemIds</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>startOff</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>len</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>len</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>endOff</color> <color=#f92672>=</color> <color=#f8f8f2>startOff</color> <color=#f92672>+</color> <color=#f8f8f2>len</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>off</color> <color=#f92672>=</color> <color=#f8f8f2>startOff</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>off</color> <color=#f92672><</color> <color=#f8f8f2>endOff</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>off</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#f8f8f2>n</color> <color=#f92672>*</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>n</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>i</color> <color=#f92672>-=</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>ids</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>long</color><color=#f92672>[</color><color=#f8f8f2>i</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>off</color> <color=#f92672>=</color> <color=#f8f8f2>startOff</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>off</color> <color=#f92672><</color> <color=#f8f8f2>endOff</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>int</color> <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>off</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>ids</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#f8f8f2>off</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>off</color> <color=#f92672>+=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>n</color> <color=#f92672>-=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>assert</color> <color=#f8f8f2>n</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>i</color> <color=#f92672>-=</color> <color=#f8f8f2>n</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>ids</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>allocateMemory</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>size</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Only enable the off-heap cache after recovery. This ensures</color>
<color=#75715e>     * that off-heap memory is available to recovery as file system</color>
<color=#75715e>     * cache, which is important when performing multiple passes over</color>
<color=#75715e>     * the recovery interval.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isValid</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>allocate</color><color=#f8f8f2>(</color><color=#f8f8f2>size</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>totalBlocks</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_DOUBLE_FREE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>Long</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#f8f8f2>memId</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>freedBlocks</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>prevFreedBlocks</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>OutOfMemoryError</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>envLogMsg</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>SEVERE</color><color=#f8f8f2>,</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"OutOfMemoryError trying to allocate in the off-heap cache. "</color>
              <color=#f92672>+</color> <color=#e6db74>"Continuing, but more problems are likely. Allocator error: "</color>
              <color=#f92672>+</color> <color=#f8f8f2>e</color><color=#f8f8f2>.</color><color=#a6e22e>getMessage</color><color=#f8f8f2>());</color>

      <color=#f8f8f2>nAllocFailure</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>memoryLimit</color> <color=#f92672>=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>getUsedBytes</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>evictBytes</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>OffHeapAllocator</color><color=#f8f8f2>.</color><color=#a6e22e>OffHeapOverflowException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>nAllocOverflow</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>memoryLimit</color> <color=#f92672>=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>getUsedBytes</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>needEviction</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>wakeUpEvictionThreads</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>memId</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>freeMemory</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_DOUBLE_FREE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Long</color> <color=#f8f8f2>key</color> <color=#f92672>=</color> <color=#f8f8f2>memId</color><color=#f8f8f2>;</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>added</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>Exception</color><color=#f92672>></color> <color=#f8f8f2>curr</color> <color=#f92672>=</color> <color=#f8f8f2>freedBlocks</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>Exception</color><color=#f92672>></color> <color=#f8f8f2>prev</color> <color=#f92672>=</color> <color=#f8f8f2>prevFreedBlocks</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>freedBlocks</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#f8f8f2>DEBUG_FREE_BLOCKS_PER_MAP</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>freedBlocks</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#f8f8f2>DEBUG_FREE_BLOCKS_PER_MAP</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>prevFreedBlocks</color> <color=#f92672>=</color> <color=#f8f8f2>freedBlocks</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>freedBlocks</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ConcurrentHashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>

            <color=#f8f8f2>e</color> <color=#f92672>=</color> <color=#f8f8f2>freedBlocks</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#f8f8f2>Exception</color><color=#f8f8f2>(</color><color=#e6db74>"Freed: "</color> <color=#f92672>+</color> <color=#f8f8f2>memId</color><color=#f8f8f2>));</color>

            <color=#f8f8f2>added</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>curr</color> <color=#f92672>=</color> <color=#f8f8f2>freedBlocks</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>prev</color> <color=#f92672>=</color> <color=#f8f8f2>prevFreedBlocks</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>added</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>e</color> <color=#f92672>=</color> <color=#f8f8f2>curr</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#f8f8f2>Exception</color><color=#f8f8f2>(</color><color=#e6db74>"Freed: "</color> <color=#f92672>+</color> <color=#f8f8f2>memId</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>e</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>Exception</color><color=#f8f8f2>(</color><color=#e6db74>"Double-freed: "</color> <color=#f92672>+</color> <color=#f8f8f2>memId</color> <color=#f92672>+</color> <color=#e6db74>"\n"</color> <color=#f92672>+</color> <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>getStackTrace</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>))</color>
            <color=#f8f8f2>.</color><color=#a6e22e>printStackTrace</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>curr</color> <color=#f92672>!=</color> <color=#f8f8f2>prev</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>e</color> <color=#f92672>=</color> <color=#f8f8f2>prev</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>key</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>e</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>new</color> <color=#f8f8f2>Exception</color><color=#f8f8f2>(</color><color=#e6db74>"Double-freed: "</color> <color=#f92672>+</color> <color=#f8f8f2>memId</color> <color=#f92672>+</color> <color=#e6db74>"\n"</color> <color=#f92672>+</color> <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>getStackTrace</color><color=#f8f8f2>(</color><color=#f8f8f2>e</color><color=#f8f8f2>))</color>
              <color=#f8f8f2>.</color><color=#a6e22e>printStackTrace</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>totalBlocks</color><color=#f8f8f2>.</color><color=#a6e22e>decrementAndGet</color><color=#f8f8f2>();</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>free</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#a6e22e>getMemBytes</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>bytes</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>)</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>bytes</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>bytes</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bytes</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>byte</color> <color=#a6e22e>getByte</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>tempBuf</color><color=#f92672>[</color><color=#ae81ff>0</color><color=#f92672>]</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>putShort</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>short</color> <color=#f8f8f2>val</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>putShort</color><color=#f8f8f2>(</color><color=#f8f8f2>val</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#ae81ff>2</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>short</color> <color=#a6e22e>getShort</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>2</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getShort</color><color=#f8f8f2>(</color><color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>putInt</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>val</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>putInt</color><color=#f8f8f2>(</color><color=#f8f8f2>val</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#ae81ff>4</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>4</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>putLong</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>val</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>putLong</color><color=#f8f8f2>(</color><color=#f8f8f2>val</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#ae81ff>8</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>getLong</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>8</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>tempBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>putShort</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>short</color> <color=#f8f8f2>val</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>8</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>val</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>short</color> <color=#a6e22e>getShort</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>short</color><color=#f8f8f2>)</color> <color=#f8f8f2>((</color><color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color><color=#f92672>]</color> <color=#f92672><<</color> <color=#ae81ff>8</color><color=#f8f8f2>)</color> <color=#f92672>|</color> <color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>putInt</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>val</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>24</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>16</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>2</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>8</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>3</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>val</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>((</color><color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color><color=#f92672>]</color> <color=#f92672><<</color> <color=#ae81ff>24</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>((</color><color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>16</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>((</color><color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>2</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>8</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>(</color><color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>3</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>putLong</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>val</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>56</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>48</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>2</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>40</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>3</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>32</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>4</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>24</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>5</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>16</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>6</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>>></color> <color=#ae81ff>8</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>7</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f8f8f2>)</color> <color=#f8f8f2>val</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>long</color> <color=#a6e22e>getLong</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>buf</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color><color=#f92672>]</color> <color=#f92672><<</color> <color=#ae81ff>56</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>(((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>48</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>(((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>2</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>40</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>(((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>3</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>32</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>(((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>4</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>24</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>(((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>5</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>16</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>(((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>6</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>8</color><color=#f8f8f2>)</color>
        <color=#f92672>|</color> <color=#f8f8f2>((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>buf</color><color=#f92672>[</color><color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#ae81ff>7</color><color=#f92672>]</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>));</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>doCriticalEviction</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>needEviction</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>wakeUpEvictionThreads</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>needCriticalEviction</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>evictBatch</color><color=#f8f8f2>(</color><color=#f8f8f2>EvictionSource</color><color=#f8f8f2>.</color><color=#a6e22e>CRITICAL</color><color=#f8f8f2>,</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>doDaemonEviction</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>needEviction</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>wakeUpEvictionThreads</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>needCriticalEviction</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>evictBatch</color><color=#f8f8f2>(</color><color=#f8f8f2>EvictionSource</color><color=#f8f8f2>.</color><color=#a6e22e>DAEMON</color><color=#f8f8f2>,</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>doManualEvict</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isEnabled</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>evictBatch</color><color=#f8f8f2>(</color><color=#f8f8f2>EvictionSource</color><color=#f8f8f2>.</color><color=#a6e22e>MANUAL</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*backgroundIO*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>wakeUpEvictionThreads</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>runEvictorThreads</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>isEnabled</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This check is meant to avoid the lock taken by</color>
<color=#75715e>     * ArrayBlockingQueue.offer() when this is futile. The lock reduces</color>
<color=#75715e>     * concurrency because this method is called so frequently.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>activePoolThreads</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#f8f8f2>maxPoolThreads</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>evictionPool</color><color=#f8f8f2>.</color><color=#a6e22e>execute</color><color=#f8f8f2>(</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>Runnable</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
          <color=#a6e22e>@Override</color>
          <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>run</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>activePoolThreads</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
            <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>evictBatch</color><color=#f8f8f2>(</color><color=#f8f8f2>EvictionSource</color><color=#f8f8f2>.</color><color=#a6e22e>EVICTORTHREAD</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*backgroundIO*/</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>activePoolThreads</color><color=#f8f8f2>.</color><color=#a6e22e>decrementAndGet</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>});</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>needEviction</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isEnabled</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * When off-heap cache size is set to zero after being non-zero, we</color>
<color=#75715e>     * perform eviction only until the cache becomes empty.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>maxMemory</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>getUsedBytes</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>getUsedBytes</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#f8f8f2>evictBytes</color> <color=#f92672>>=</color> <color=#f8f8f2>memoryLimit</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>needCriticalEviction</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>isEnabled</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * When off-heap cache size is set to zero after being non-zero, we</color>
<color=#75715e>     * perform only non-critical eviction.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>maxMemory</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>getUsedBytes</color><color=#f8f8f2>()</color> <color=#f92672>>=</color> <color=#f8f8f2>memoryLimit</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>getLRUSize</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color><color=#f92672>[]</color> <color=#f8f8f2>listSet</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color> <color=#f8f8f2>l</color> <color=#f8f8f2>:</color> <color=#f8f8f2>listSet</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>size</color> <color=#f92672>+=</color> <color=#f8f8f2>l</color><color=#f8f8f2>.</color><color=#a6e22e>getSize</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>size</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>evictBatch</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>EvictionSource</color> <color=#f8f8f2>source</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>maxBytesToEvict</color> <color=#f92672>=</color> <color=#f8f8f2>evictBytes</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>getUsedBytes</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>memoryLimit</color><color=#f8f8f2>);</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>bytesEvicted</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>maxLruEntries</color> <color=#f92672>=</color> <color=#f8f8f2>getLRUSize</color><color=#f8f8f2>(</color><color=#f8f8f2>pri1LRUSet</color><color=#f8f8f2>);</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>nLruEntries</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>bytesEvicted</color> <color=#f92672><</color> <color=#f8f8f2>maxBytesToEvict</color> <color=#f92672>&&</color> <color=#f8f8f2>needEviction</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>shutdownRequested</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nLruEntries</color> <color=#f92672>>=</color> <color=#f8f8f2>maxLruEntries</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pri2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>pri2</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>maxLruEntries</color> <color=#f92672>=</color> <color=#f8f8f2>getLRUSize</color><color=#f8f8f2>(</color><color=#f8f8f2>pri2LRUSet</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>nLruEntries</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color> <color=#f8f8f2>lru</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pri2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lruIdx</color> <color=#f92672>=</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>abs</color><color=#f8f8f2>(</color><color=#f8f8f2>nextPri2LRUList</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f92672>%</color> <color=#f8f8f2>numLRULists</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>lru</color> <color=#f92672>=</color> <color=#f8f8f2>pri2LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lruIdx</color> <color=#f92672>=</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>abs</color><color=#f8f8f2>(</color><color=#f8f8f2>nextPri1LRUList</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f92672>%</color> <color=#f8f8f2>numLRULists</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>lru</color> <color=#f92672>=</color> <color=#f8f8f2>pri1LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>lru</color><color=#f8f8f2>.</color><color=#a6e22e>removeFront</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>nLruEntries</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>bytesEvicted</color> <color=#f92672>+=</color> <color=#f8f8f2>evictOne</color><color=#f8f8f2>(</color><color=#f8f8f2>source</color><color=#f8f8f2>,</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>lru</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>evictOne</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>EvictionSource</color> <color=#f8f8f2>source</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color> <color=#f8f8f2>lru</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>nNodesTargeted</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>source</color> <color=#f92672>==</color> <color=#f8f8f2>EvictionSource</color><color=#f8f8f2>.</color><color=#a6e22e>CRITICAL</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nCriticalNodesTargeted</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Note that almost anything could have happened in other threads</color>
<color=#75715e>     * after removing the entry from the LRU and prior to latching the</color>
<color=#75715e>     * owner IN. We account for these possibilities below.</color>
<color=#75715e>     *</color>
<color=#75715e>     * When we decide to "skip" an entry, it is not added back to the LRU</color>
<color=#75715e>     * and it is not freed. The assumption is that another thread is</color>
<color=#75715e>     * processing the entry and will add it to the LRU or free it.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color> <color=#f92672>=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the IN is null, skip the entry. The IN may have been evicted.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If the owner has changed or the IN was evicted, skip it.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color> <color=#f92672>!=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>owners</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
        <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If owner is a BIN, it is in the main cache but may have</color>
<color=#75715e>       * off-heap LNs.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>;</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If entry is no longer associated with this BIN, skip it.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
          <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If the entry was added back to the LRU, skip it. This check</color>
<color=#75715e>         * requires synchronizing on the LRUList after latching the IN.</color>
<color=#75715e>         * We know we're checking the correct LRUList because an entry</color>
<color=#75715e>         * with a BIN owner can never be in the priority 2 LRU set.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lru</color><color=#f8f8f2>.</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
          <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>stripLNsFromMainBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The owner has a child BIN that is off-heap.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>entry</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#f8f8f2>i</color><color=#f8f8f2>;</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If entry is no longer associated with this IN, skip it.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
        <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If the entry was moved between a pri1 and pri2 LRU list, skip</color>
<color=#75715e>       * it. This means that the LRUList from which we removed the entry</color>
<color=#75715e>       * is not the list it belongs to.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pri2</color> <color=#f92672>!=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINPri2</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
        <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If the entry was added back to the LRU, skip it. This check</color>
<color=#75715e>       * requires synchronizing on the LRUList after latching the IN, and</color>
<color=#75715e>       * it requires that we're using the correct LRU list (the check</color>
<color=#75715e>       * above).</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lru</color><color=#f8f8f2>.</color><color=#a6e22e>contains</color><color=#f8f8f2>(</color><color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
        <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * The BIN should never be resident in main.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>residentBIN</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BIN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>residentBIN</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"BIN is resident in both caches, id="</color> <color=#f92672>+</color> <color=#f8f8f2>residentBIN</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>useOffHeapChecksums</color><color=#f8f8f2>();</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>=</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>?</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>memIds</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>flags</color> <color=#f92672>=</color> <color=#f8f8f2>getByte</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>1</color><color=#f92672>]</color><color=#f8f8f2>);</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dirty</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * First try stripping LNs.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>nLNBytesEvicted</color> <color=#f92672>=</color>
          <color=#f8f8f2>stripLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nLNBytesEvicted</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>nLNBytesEvicted</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Next try mutating a full BIN to a BIN-delta.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>flags</color> <color=#f92672>&</color> <color=#f8f8f2>BIN_FLAG_CAN_MUTATE</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>=</color>
            <color=#f8f8f2>mutateToBINDelta</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>(),</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nBytesEvicted</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>nBytesEvicted</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If it is in the pri1 list and is dirty with no resident LNs,</color>
<color=#75715e>       * move it to the pri2 list. We currently have no stat for this.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>pri2</color> <color=#f92672>&&</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*pri2*/</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*pri2*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*dirty*/</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Log the BIN if it is dirty and finally just get rid of it.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>flushAndDiscardBIN</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*freeLNs*/</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Strip off-heap LNs referenced by a main cache BIN. If there are any off-heap expired LNs, strip</color>
<color=#75715e>   * only them. Otherwise, strip all LNs.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>stripLNsFromMainBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#75715e>/*</color>
<color=#75715e>     * Strip expired LNs first.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>nEvicted</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>boolean</color> <color=#f8f8f2>anyNonExpired</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpired</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>+=</color> <color=#f8f8f2>freeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>nEvicted</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>anyNonExpired</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If any were expired, return. If any non-expired LNs remain, put back</color>
<color=#75715e>     * the entry on the LRU list, leaving the non-expired LNs resident.</color>
<color=#75715e>     * Also compress the BIN to free the expired slots in the main cache.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nEvicted</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>anyNonExpired</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLruId</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>freeEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>().</color><color=#a6e22e>lazyCompress</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>nLNsEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>addAndGet</color><color=#f8f8f2>(</color><color=#f8f8f2>nEvicted</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nNodesStripped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>nBytesEvicted</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * No expired LNs are present. Strip the non-expired LNs.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lnBytes</color> <color=#f92672>=</color> <color=#f8f8f2>freeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnBytes</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>+=</color> <color=#f8f8f2>lnBytes</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>nEvicted</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nEvicted</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nLNsEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>addAndGet</color><color=#f8f8f2>(</color><color=#f8f8f2>nEvicted</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nNodesStripped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * No LNs are off-heap now, so remove the entry.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>setOffHeapLruId</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>freeEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>nBytesEvicted</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>stripLNs</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>entry</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINPri2</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dirty</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>memIds</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>stripLNs</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>stripLNs</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>useOffHeapChecksums</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>=</color> <color=#f8f8f2>useChecksums</color> <color=#f92672>?</color> <color=#f8f8f2>CHECKSUM_SIZE</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Contents of headBuf:</color>
<color=#75715e>     *  flags, fullLsn, deltaLsn, minExpiration, lnIdsSize.</color>
<color=#75715e>     * Note that headBuf does not contain the checksum.</color>
<color=#75715e>     * Contents of memId following headBuf fields: LN mem Ids, BIN.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>headBuf</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>1</color> <color=#f92672>+</color> <color=#ae81ff>8</color> <color=#f92672>+</color> <color=#ae81ff>8</color> <color=#f92672>+</color> <color=#ae81ff>4</color> <color=#f92672>+</color> <color=#ae81ff>2</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>headBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>headBuf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>memHeadLen</color> <color=#f92672>=</color> <color=#f8f8f2>checksumSize</color> <color=#f92672>+</color> <color=#f8f8f2>headBuf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color> <color=#f8f8f2>flags</color> <color=#f92672>=</color> <color=#f8f8f2>headBuf</color><color=#f92672>[</color><color=#ae81ff>0</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>bufOffset</color> <color=#f92672>=</color> <color=#ae81ff>1</color> <color=#f92672>+</color> <color=#ae81ff>8</color> <color=#f92672>+</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>minExpiration</color> <color=#f92672>=</color> <color=#f8f8f2>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>headBuf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>4</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>short</color> <color=#f8f8f2>lnIdsSize</color> <color=#f92672>=</color> <color=#f8f8f2>getShort</color><color=#f8f8f2>(</color><color=#f8f8f2>headBuf</color><color=#f8f8f2>,</color> <color=#f8f8f2>bufOffset</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>bufOffset</color> <color=#f92672>+=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bufOffset</color> <color=#f92672>==</color> <color=#f8f8f2>headBuf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>;</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>nEvicted</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If this is a full BIN and any slot is expired, then materialize the</color>
<color=#75715e>     * BIN, evict expired off-heap LNs, compress expired slots, and</color>
<color=#75715e>     * re-serialize the BIN.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>flags</color> <color=#f92672>&</color> <color=#f8f8f2>BIN_FLAG_DELTA</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color> <color=#f92672>&&</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isExpired</color><color=#f8f8f2>(</color><color=#f8f8f2>minExpiration</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*hours*/</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>materializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>getMemBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>));</color>

      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>());</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLNId</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isExpired</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
          <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>+=</color> <color=#f8f8f2>freeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>nEvicted</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/*</color>
<color=#75715e>         * TODO: Compression is expensive because we must re-serialize</color>
<color=#75715e>         * the BIN. It may be more efficient to only proceed to</color>
<color=#75715e>         * compression if no LNs were freed above, although we would</color>
<color=#75715e>         * first need to clear the LN memIds.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>origNSlots</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>compress</color><color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>shouldLogDelta</color><color=#f8f8f2>()</color> <color=#75715e>/*compressDirtySlots*/</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * If we compressed any expired slots, re-serialize the BIN.</color>
<color=#75715e>         * Also re-serialize in the rare case than an LN was freed but</color>
<color=#75715e>         * no slot was compressed due to record locks; if we did not do</color>
<color=#75715e>         * this, the invalid/freed LN memId would not be cleared.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>origNSlots</color> <color=#f92672>!=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>nEvicted</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newMemId</color> <color=#f92672>=</color> <color=#f8f8f2>serializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isBINDelta</color><color=#f8f8f2>());</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newMemId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>/*</color>
<color=#75715e>             * When allocations are failing, freeing the BIN is the</color>
<color=#75715e>             * simplest and most productive thing to do.</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>+=</color>
                <color=#f8f8f2>flushAndDiscardBIN</color><color=#f8f8f2>(</color>
                    <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*freeLNs*/</color><color=#f8f8f2>);</color>

            <color=#66d9ef>return</color> <color=#f8f8f2>nBytesEvicted</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>+=</color> <color=#f8f8f2>freeMemory</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>-=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>totalSize</color><color=#f8f8f2>(</color><color=#f8f8f2>newMemId</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>memIds</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>newMemId</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#75715e>/* Return if we freed any memory by LN eviction or compression. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nBytesEvicted</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nLNsEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>addAndGet</color><color=#f8f8f2>(</color><color=#f8f8f2>nEvicted</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>nNodesStripped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>nBytesEvicted</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnIdsSize</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>lnBuf</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>lnIdsSize</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>memHeadLen</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnBuf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color><color=#f92672>[]</color> <color=#f8f8f2>lnMemIds</color> <color=#f92672>=</color> <color=#f8f8f2>unpackLnMemIds</color><color=#f8f8f2>(</color><color=#f8f8f2>lnBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>lnIdsSize</color><color=#f8f8f2>);</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lnMemId</color> <color=#f8f8f2>:</color> <color=#f8f8f2>lnMemIds</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnMemId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>+=</color> <color=#f8f8f2>freeLN</color><color=#f8f8f2>(</color><color=#f8f8f2>lnMemId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nEvicted</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>nEvicted</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lnIdsSize</color> <color=#f92672><=</color> <color=#f8f8f2>MAX_UNUSED_BIN_BYTES</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * When there are only a small number of LN memIds, we can tolerate</color>
<color=#75715e>       * the wasted space in the BIN so we just negate the size.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>tempBuf</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#ae81ff>8</color><color=#f92672>]</color><color=#f8f8f2>;</color>

      <color=#f8f8f2>putShort</color><color=#f8f8f2>((</color><color=#66d9ef>short</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#f92672>-</color><color=#f8f8f2>lnIdsSize</color><color=#f8f8f2>),</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>memHeadLen</color> <color=#f92672>-</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>);</color>

      <color=#75715e>/* However, the checksum is now invalid. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>useChecksums</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>putInt</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>tempBuf</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * When there are many LN memIds, we reclaim the space they use by</color>
<color=#75715e>       * copying the BIN to a smaller block and freeing the old block.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>newSize</color> <color=#f92672>=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>)</color> <color=#f92672>-</color> <color=#f8f8f2>lnIdsSize</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newMemId</color> <color=#f92672>=</color> <color=#f8f8f2>allocateMemory</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>newSize</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newMemId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * When allocations are failing, freeing the BIN is the</color>
<color=#75715e>         * simplest and most productive thing to do.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>+=</color>
            <color=#f8f8f2>flushAndDiscardBIN</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*freeLNs*/</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>nBytesEvicted</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>-=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>totalSize</color><color=#f8f8f2>(</color><color=#f8f8f2>newMemId</color><color=#f8f8f2>);</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Copy all parts of the old BIN to the new, except for the</color>
<color=#75715e>       * checksum, lnIdsSize and the LN memIds. We don't need to set</color>
<color=#75715e>       * the checksum or lnIdsSize to zero in the new block because it</color>
<color=#75715e>       * was zero-filled when it was allocated. Instead we omit these</color>
<color=#75715e>       * fields when copying.</color>
<color=#75715e>       *</color>
<color=#75715e>       * The first copy includes all headBuf fields except for the</color>
<color=#75715e>       * lnIdsSize at the end of the buffer. The second copy includes</color>
<color=#75715e>       * the serialized BIN alone.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>headBuf</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>newMemId</color><color=#f8f8f2>,</color> <color=#f8f8f2>checksumSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>headBuf</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>-</color> <color=#ae81ff>2</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>copy</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>memHeadLen</color> <color=#f92672>+</color> <color=#f8f8f2>lnIdsSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>newMemId</color><color=#f8f8f2>,</color> <color=#f8f8f2>memHeadLen</color><color=#f8f8f2>,</color> <color=#f8f8f2>newSize</color> <color=#f92672>-</color> <color=#f8f8f2>memHeadLen</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>+=</color> <color=#f8f8f2>freeMemory</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>memIds</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>newMemId</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>nLNsEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>addAndGet</color><color=#f8f8f2>(</color><color=#f8f8f2>nEvicted</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nNodesStripped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nBytesEvicted</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>mutateToBINDelta</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>entry</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color> <color=#f92672>=</color> <color=#f8f8f2>chunks</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>/</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>CHUNK_SIZE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>mutateToBINDelta</color><color=#f8f8f2>(</color>
        <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>(),</color>
        <color=#f8f8f2>entry</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINPri2</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>),</color>
        <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color>
        <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>mutateToBINDelta</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>Chunk</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>chunkIdx</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color> <color=#f92672>=</color> <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>memIds</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>materializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>getMemBytes</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>));</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getLastFullLsn</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newMemId</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latchNoUpdateLRU</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>);</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>newMemId</color> <color=#f92672>=</color> <color=#f8f8f2>serializeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*asDelta*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newMemId</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>=</color> <color=#f8f8f2>freeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*freeLNs*/</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nBytesEvicted</color> <color=#f92672>-=</color> <color=#f8f8f2>allocator</color><color=#f8f8f2>.</color><color=#a6e22e>totalSize</color><color=#f8f8f2>(</color><color=#f8f8f2>newMemId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>chunk</color><color=#f8f8f2>.</color><color=#a6e22e>memIds</color><color=#f92672>[</color><color=#f8f8f2>chunkIdx</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>newMemId</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>nNodesMutated</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>moveBack</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nBytesEvicted</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Logs the BIN child if it is dirty, and then discards it.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return bytes freed, or zero if a dirty BIN could not be logged due to a read-only env or disk</color>
<color=#75715e>   *     limit violation.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>long</color> <color=#a6e22e>flushAndDiscardBIN</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>freeLNs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getEnv</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_TRACE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>debug</color><color=#f8f8f2>(</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color>
          <color=#e6db74>"Discard BIN LSN="</color>
              <color=#f92672>+</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>getNoFormatString</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>))</color>
              <color=#f92672>+</color> <color=#e6db74>" pri2="</color>
              <color=#f92672>+</color> <color=#f8f8f2>pri2</color>
              <color=#f92672>+</color> <color=#e6db74>" dirty="</color>
              <color=#f92672>+</color> <color=#f8f8f2>dirty</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dirty</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * Cannot evict dirty nodes in a read-only environment, or when a</color>
<color=#75715e>       * disk limit has been exceeded. We can assume that the cache will</color>
<color=#75715e>       * not overflow with dirty nodes because writes are prohibited.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isReadOnly</color><color=#f8f8f2>()</color> <color=#f92672>||</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDiskLimitViolation</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>nNodesSkipped</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
        <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>INLogEntry</color><color=#f92672><</color><color=#f8f8f2>BIN</color><color=#f92672>></color> <color=#f8f8f2>logEntry</color> <color=#f92672>=</color>
          <color=#f8f8f2>createBINLogEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*preserveBINInCache*/</color><color=#f8f8f2>);</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Provisional</color> <color=#f8f8f2>provisional</color> <color=#f92672>=</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>coordinateWithCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>(),</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>BIN_LEVEL</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>);</color>

      <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>logEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>logEntry</color><color=#f8f8f2>,</color> <color=#f8f8f2>provisional</color><color=#f8f8f2>,</color> <color=#f8f8f2>backgroundIO</color><color=#f8f8f2>,</color> <color=#f8f8f2>parent</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>updateEntry</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>VLSN</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_VLSN_SEQUENCE</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color> <color=#75715e>/*lastLoggedSize*/</color><color=#f8f8f2>);</color>

      <color=#f8f8f2>nDirtyNodesEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>logEntry</color><color=#f8f8f2>.</color><color=#a6e22e>isPreSerialized</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>logEntry</color><color=#f8f8f2>.</color><color=#a6e22e>getMainItem</color><color=#f8f8f2>().</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>nNodesEvicted</color><color=#f8f8f2>.</color><color=#a6e22e>incrementAndGet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>parent</color><color=#f8f8f2>.</color><color=#a6e22e>clearOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>freeBIN</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>memId</color><color=#f8f8f2>,</color> <color=#f8f8f2>freeLNs</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>long</color> <color=#a6e22e>testEvictMainBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BIN</color> <color=#f8f8f2>bin</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapLruId</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>entry</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color> <color=#f8f8f2>lru</color> <color=#f92672>=</color> <color=#f8f8f2>pri1LRUSet</color><color=#f92672>[</color><color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>numLRULists</color><color=#f92672>]</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>lru</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>evictOne</color><color=#f8f8f2>(</color><color=#f8f8f2>EvictionSource</color><color=#f8f8f2>.</color><color=#a6e22e>MANUAL</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*backgroundIO*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>lru</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*pri2*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>long</color> <color=#a6e22e>testEvictOffHeapBIN</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>entry</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getOffHeapBINId</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>entry</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pri2</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINPri2</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>lruIdx</color> <color=#f92672>=</color> <color=#f8f8f2>entry</color> <color=#f92672>%</color> <color=#f8f8f2>numLRULists</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>LRUList</color> <color=#f8f8f2>lru</color> <color=#f92672>=</color> <color=#f8f8f2>pri2</color> <color=#f92672>?</color> <color=#f8f8f2>pri2LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pri1LRUSet</color><color=#f92672>[</color><color=#f8f8f2>lruIdx</color><color=#f92672>]</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>lru</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>evictOne</color><color=#f8f8f2>(</color><color=#f8f8f2>EvictionSource</color><color=#f8f8f2>.</color><color=#a6e22e>MANUAL</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*backgroundIO*/</color><color=#f8f8f2>,</color> <color=#f8f8f2>entry</color><color=#f8f8f2>,</color> <color=#f8f8f2>lru</color><color=#f8f8f2>,</color> <color=#f8f8f2>pri2</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>