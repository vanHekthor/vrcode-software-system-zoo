<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.log</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.DatabaseException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.EnvironmentFailureException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.StatsConfig</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.config.EnvironmentParams</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.DbConfigManager</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.EnvironmentImpl</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.latch.Latch</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.latch.LatchFactory</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.*</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.io.IOException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.nio.ByteBuffer</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.LinkedList</color><color=#f8f8f2>;</color>

<color=#f92672>import static</color> <color=#f8f8f2>com.sleepycat.je.log.LogStatDefinition.*</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * LogBufferPool manages a circular pool of LogBuffers. The currentWriteBuffer is the buffer that is</color>
<color=#75715e> * currently used to add data. When the buffer is full, the next (adjacent) buffer is made available</color>
<color=#75715e> * for writing. The buffer pool has a dirty list of buffers. A buffer becomes a member of the dirty</color>
<color=#75715e> * list when the currentWriteBuffer is moved to another buffer. Buffers are removed from the dirty</color>
<color=#75715e> * list when they are written. The dirtyStart/dirtyEnd variables indicate the list of dirty buffers.</color>
<color=#75715e> * A value of -1 for either variables indicates that there are no dirty buffers. These variable are</color>
<color=#75715e> * synchronized via the LogBufferPool.bufferPoolLatch. The LogManager.logWriteLatch (aka LWL) is</color>
<color=#75715e> * used to serialize access to the currentWriteBuffer, so that entries are added in write/LSN order.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>A buffer used for writing is accessed by the getWriteBuffer method. This method must be called</color>
<color=#75715e> * while holding the LWL. The buffer returned is not latched.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>A LogBuffer has a pin count (LogBuffer.writePinCount) associated with it. The pin count is</color>
<color=#75715e> * incremented when space is allocated in the buffer. The allocation of space is serialized under</color>
<color=#75715e> * the LWL. Threads will add data to the buffer by latching the buffer, but without holding the LWL.</color>
<color=#75715e> * After the data is added, the pin count is decremented. A buffer cannot be used for reading unless</color>
<color=#75715e> * the pin count is zero. It should be noted that the increment of the pin count is done with the</color>
<color=#75715e> * buffer latched. The decrement does not latch the buffer.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>Read access to a log buffer is allowed only if the buffer is latched and the pin count is</color>
<color=#75715e> * zero. A thread that attempt to access a log buffer for reading will latch and check the pin</color>
<color=#75715e> * count. If the pin count is not zero, the latch is released and the process is retried. The thread</color>
<color=#75715e> * attempting to access the log buffer for reading may be delayed. The worst case is when the reader</color>
<color=#75715e> * has to wait until the buffer is filled (the pin count would be zero).</color>
<color=#75715e> *</color>
<color=#75715e> * @see LogBuffer</color>
<color=#75715e> */</color>
<color=#66d9ef>class</color> <color=#a6e22e>LogBufferPool</color> <color=#f8f8f2>{</color>
  <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>DEBUG_NAME</color> <color=#f92672>=</color> <color=#f8f8f2>LogBufferPool</color><color=#f8f8f2>.</color><color=#a6e22e>class</color><color=#f8f8f2>.</color><color=#a6e22e>getName</color><color=#f8f8f2>();</color>

  <color=#66d9ef>private</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>nLogBuffers</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>logBufferSize</color><color=#f8f8f2>;</color> <color=#75715e>// size of each log buffer</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>LinkedList</color><color=#f92672><</color><color=#f8f8f2>LogBuffer</color><color=#f92672>></color> <color=#f8f8f2>bufferPool</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * The dirty start/end are the indexes of the first/last dirty buffers.</color>
<color=#75715e>   * These dirty buffers do not include the current write buffer.</color>
<color=#75715e>   * These fields are changed under buffer pool latch.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>dirtyStart</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>dirtyEnd</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Buffer that holds the current log end.  All writes go</color>
<color=#75715e>   * to this buffer.The members are protected by</color>
<color=#75715e>   * the LogManager.logWriteLatch.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#f8f8f2>LogBuffer</color> <color=#f8f8f2>currentWriteBuffer</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>currentWriteBufferIndex</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>FileManager</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>;</color>

  <color=#75715e>/* Stats */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>StatGroup</color> <color=#f8f8f2>stats</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLongStat</color> <color=#f8f8f2>nNotResident</color><color=#f8f8f2>;</color> <color=#75715e>// instantiated from an LSN</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>AtomicLongStat</color> <color=#f8f8f2>nCacheMiss</color><color=#f8f8f2>;</color> <color=#75715e>// retrieved from disk</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>IntStat</color> <color=#f8f8f2>logBuffers</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nBufferBytes</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Number of times that current write pointer could not be incremented</color>
<color=#75715e>   * because there was no non-dirty buffer.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>LongStat</color> <color=#f8f8f2>nNoFreeBuffer</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>runInMemory</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * bufferPoolLatch synchronizes access and changes to the buffer pool.</color>
<color=#75715e>   * Related latches are the log write latch in LogManager and the read</color>
<color=#75715e>   * latches in each log buffer. The log write latch is always taken before</color>
<color=#75715e>   * the bufferPoolLatch. The bufferPoolLatch is always taken before any</color>
<color=#75715e>   * logBuffer read latch. When faulting in an object from the log, the order</color>
<color=#75715e>   * of latching is:</color>
<color=#75715e>   *          bufferPoolLatch.acquire()</color>
<color=#75715e>   *          LogBuffer read latch acquire();</color>
<color=#75715e>   *          bufferPoolLatch.release();</color>
<color=#75715e>   *          LogBuffer read latch release()</color>
<color=#75715e>   * bufferPoolLatch is also used to protect assignment to the</color>
<color=#75715e>   * currentWriteBuffer field.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Latch</color> <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * A minimum LSN property for the pool that can be checked without</color>
<color=#75715e>   * latching, to reduce contention by readers. An LSN less than minBufferLsn</color>
<color=#75715e>   * is guaranteed not to be in the pool. An LSN greater or equal to</color>
<color=#75715e>   * minBufferLsn may or may not be in the pool, and latching is necessary to</color>
<color=#75715e>   * determine this.  Initializing minBufferLsn to zero ensures that we will</color>
<color=#75715e>   * latch and check the pool until it is initialized with a valid LSN.</color>
<color=#75715e>   * [#19642]</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#66d9ef>long</color> <color=#f8f8f2>minBufferLsn</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

  <color=#f8f8f2>LogBufferPool</color><color=#f8f8f2>(</color><color=#f8f8f2>FileManager</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>,</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>fileManager</color> <color=#f92672>=</color> <color=#f8f8f2>fileManager</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>bufferPoolLatch</color> <color=#f92672>=</color>
        <color=#f8f8f2>LatchFactory</color><color=#f8f8f2>.</color><color=#a6e22e>createExclusiveLatch</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>DEBUG_NAME</color> <color=#f92672>+</color> <color=#e6db74>"_FullLatch"</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*collectStats*/</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Configure the pool. */</color>
    <color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>configManager</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getConfigManager</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>runInMemory</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isMemOnly</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>reset</color><color=#f8f8f2>(</color><color=#f8f8f2>configManager</color><color=#f8f8f2>);</color>

    <color=#75715e>/* Current buffer is the active buffer that writes go into. */</color>
    <color=#f8f8f2>currentWriteBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>bufferPool</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>currentWriteBufferIndex</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>stats</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StatGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>LogStatDefinition</color><color=#f8f8f2>.</color><color=#a6e22e>LBF_GROUP_NAME</color><color=#f8f8f2>,</color> <color=#f8f8f2>LogStatDefinition</color><color=#f8f8f2>.</color><color=#a6e22e>LBF_GROUP_DESC</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nNotResident</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>LBFP_NOT_RESIDENT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nCacheMiss</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AtomicLongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>LBFP_MISS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>logBuffers</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>IntStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>LBFP_LOG_BUFFERS</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nBufferBytes</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>LBFP_BUFFER_BYTES</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nNoFreeBuffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LongStat</color><color=#f8f8f2>(</color><color=#f8f8f2>stats</color><color=#f8f8f2>,</color> <color=#f8f8f2>LBFP_NO_FREE_BUFFER</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#a6e22e>getLogBufferSize</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>logBufferSize</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Initialize the pool at construction time and when the cache is resized. This method is called</color>
<color=#75715e>   * after the memory budget has been calculated.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The LWL must be held when the buffer pool is not being constructed.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>reset</color><color=#f8f8f2>(</color><color=#f8f8f2>DbConfigManager</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * When running in memory, we can't clear the existing pool and</color>
<color=#75715e>     * changing the buffer size is not very useful, so just return.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>runInMemory</color> <color=#f92672>&&</color> <color=#f8f8f2>bufferPool</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Write the currentWriteBuffer to the file and reset</color>
<color=#75715e>     * currentWriteBuffer.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentWriteBuffer</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bumpAndWriteDirty</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Based on the log budget, figure the number and size of</color>
<color=#75715e>     * log buffers to use.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>numBuffers</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getInt</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>NUM_LOG_BUFFERS</color><color=#f8f8f2>);</color>
    <color=#66d9ef>long</color> <color=#f8f8f2>logBufferBudget</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getMemoryBudget</color><color=#f8f8f2>().</color><color=#a6e22e>getLogBufferBudget</color><color=#f8f8f2>();</color>

    <color=#66d9ef>long</color> <color=#f8f8f2>logFileSize</color> <color=#f92672>=</color> <color=#f8f8f2>configManager</color><color=#f8f8f2>.</color><color=#a6e22e>getLong</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentParams</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_FILE_MAX</color><color=#f8f8f2>);</color>
    <color=#75715e>/* Buffers must be int sized. */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>newBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>logBufferBudget</color> <color=#f92672>/</color> <color=#f8f8f2>numBuffers</color><color=#f8f8f2>;</color>
    <color=#75715e>/* Limit log buffer size to size of a log file. */</color>
    <color=#f8f8f2>newBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>min</color><color=#f8f8f2>(</color><color=#f8f8f2>newBufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>logFileSize</color><color=#f8f8f2>);</color>
    <color=#75715e>/* list of buffers that are available for log writing */</color>
    <color=#f8f8f2>LinkedList</color><color=#f92672><</color><color=#f8f8f2>LogBuffer</color><color=#f92672>></color> <color=#f8f8f2>newPool</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LinkedList</color><color=#f92672><</color><color=#f8f8f2>LogBuffer</color><color=#f92672>></color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If we're running in memory only, don't pre-allocate all the buffers.</color>
<color=#75715e>     * This case only occurs when called from the constructor.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>runInMemory</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>numBuffers</color> <color=#f92672>=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>numBuffers</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>newPool</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>LogBuffer</color><color=#f8f8f2>(</color><color=#f8f8f2>newBufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The following applies when this method is called to reset the pool</color>
<color=#75715e>     * when an existing pool is in use:</color>
<color=#75715e>     * - The old pool will no longer be referenced.</color>
<color=#75715e>     * - Buffers being read in the old pool will be no longer referenced</color>
<color=#75715e>     * after the read operation is complete.</color>
<color=#75715e>     * - The currentWriteBuffer field is not changed here; it will be no</color>
<color=#75715e>     * longer referenced after it is written to the file and a new</color>
<color=#75715e>     * currentWriteBuffer is assigned.</color>
<color=#75715e>     * - The logBufferSize can be changed now because it is only used for</color>
<color=#75715e>     * allocating new buffers; it is not used as the size of the</color>
<color=#75715e>     * currentWriteBuffer.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>bufferPool</color> <color=#f92672>=</color> <color=#f8f8f2>newPool</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>nLogBuffers</color> <color=#f92672>=</color> <color=#f8f8f2>numBuffers</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>logBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>newBufferSize</color><color=#f8f8f2>;</color>
    <color=#75715e>/* Current buffer is the active buffer that writes go into. */</color>
    <color=#f8f8f2>currentWriteBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>bufferPool</color><color=#f8f8f2>.</color><color=#a6e22e>getFirst</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>currentWriteBufferIndex</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Get a log buffer for writing an entry of sizeNeeded bytes.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If sizeNeeded will fit in currentWriteBuffer, currentWriteBuffer is returned without</color>
<color=#75715e>   * requiring any flushing. The caller can allocate the entry in the buffer returned.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If sizeNeeded won't fit in currentWriteBuffer, but is LTE the LogBuffer capacity, we bump</color>
<color=#75715e>   * the buffer to get an empty currentWriteBuffer. If there are no free write buffers, then all</color>
<color=#75715e>   * dirty buffers must be flushed. The caller can allocate the entry in the buffer returned.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If sizeNeeded is greater than the LogBuffer capacity, flush all dirty buffers and return an</color>
<color=#75715e>   * empty (but too small) currentWriteBuffer. The caller must then write the entry to the file</color>
<color=#75715e>   * directly.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The LWL must be held.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param sizeNeeded size of the entry to be written.</color>
<color=#75715e>   * @param flippedFile if true, always flush all dirty buffers and get an empty currentWriteBuffer,</color>
<color=#75715e>   *     and fsync/finish the log file.</color>
<color=#75715e>   * @return currentWriteBuffer, which may or may not have enough room for sizeNeeded.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>LogBuffer</color> <color=#a6e22e>getWriteBuffer</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>flippedFile</color><color=#f8f8f2>)</color>
      <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color><color=#f8f8f2>,</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We need a new log buffer either because this log buffer is full, or</color>
<color=#75715e>     * the LSN has marched along to the next file.  Each log buffer only</color>
<color=#75715e>     * holds entries that belong to a single file.  If we've flipped over</color>
<color=#75715e>     * into the next file, we'll need to get a new log buffer even if the</color>
<color=#75715e>     * current one has room.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>flippedFile</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Write the dirty buffers to the file and get an empty</color>
<color=#75715e>       * currentWriteBuffer.</color>
<color=#75715e>       *</color>
<color=#75715e>       * TODO: Why pass true for flushWriteQueue before doing an fsync?</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>bumpAndWriteDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*flushWriteQueue*/</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Now that the buffers have been written, fsync. */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>runInMemory</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>syncLogEndAndFinishFile</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>currentWriteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>hasRoom</color><color=#f8f8f2>(</color><color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Try to bump the current write buffer since there</color>
<color=#75715e>       * was not enough space in the current write buffer.</color>
<color=#75715e>       */</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bumpCurrent</color><color=#f8f8f2>(</color><color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>currentWriteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>hasRoom</color><color=#f8f8f2>(</color><color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We could not bump because there was no free</color>
<color=#75715e>         * buffer, or the item is larger than the buffer size.</color>
<color=#75715e>         * Write the dirties to free a buffer up, or to flush</color>
<color=#75715e>         * in preparation for writing a temporary buffer.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>bumpAndWriteDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*flushWriteQueue*/</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>currentWriteBuffer</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Bump current write buffer and write the dirty buffers.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The LWL must be held to ensure that, if there are no free buffers, we can write the dirty</color>
<color=#75715e>   * buffers and have a free one, which is required to bump the current write buffer.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param sizeNeeded used only if running in memory. Size of the log buffer buffer that is needed.</color>
<color=#75715e>   * @param flushWriteQueue true if data is written to log, otherwise data may be placed on the</color>
<color=#75715e>   *     write queue.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>bumpAndWriteDirty</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>flushWriteQueue</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Write the currentWriteBuffer to the file and reset</color>
<color=#75715e>     * currentWriteBuffer.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>bumpCurrent</color><color=#f8f8f2>(</color><color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       *  Could not bump the current write buffer; no clean buffers.</color>
<color=#75715e>       *  Write the current dirty buffers so we can bump.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>writeDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>flushWriteQueue</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bumpCurrent</color><color=#f8f8f2>(</color><color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Since we have the log write latch we should be</color>
<color=#75715e>         * able to bump the current buffer.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>writeDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>flushWriteQueue</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* should not ever get here */</color>
        <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedState</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#e6db74>"No free log buffers."</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>

    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Since we have the log write latch we should be</color>
<color=#75715e>       * able to bump the current buffer.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>writeDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>flushWriteQueue</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Returns the next buffer slot number from the input buffer slot number. The slots are are a</color>
<color=#75715e>   * circular buffer.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The bufferPoolLatch must be held.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the next slot number after the given slotNumber.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>getNextSlot</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>slotNumber</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>isExclusiveOwner</color><color=#f8f8f2>();</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>slotNumber</color> <color=#f92672><</color> <color=#f8f8f2>(</color><color=#f8f8f2>bufferPool</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>))</color> <color=#f92672>?</color> <color=#f92672>++</color><color=#f8f8f2>slotNumber</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Writes the dirty log buffers.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>No latches need be held.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Note that if no buffers are dirty, nothing will be written, even when data is buffered in</color>
<color=#75715e>   * the write queue and flushWriteQueue is true. If we were to allow a condition where 1) the write</color>
<color=#75715e>   * queue is non-empty, 2) there are no dirty log buffers, and 3) the current write buffer is</color>
<color=#75715e>   * empty, then a flushNoSync at that time won't flush the write queue. This should never happen</color>
<color=#75715e>   * because: a) flushNoSync leaves the write queue empty, b) LogManager.serialLogWork leaves the</color>
<color=#75715e>   * current write buffer non-empty, and c) writeDirty(false) doesn't change the state of the</color>
<color=#75715e>   * current write buffer. TODO: Confirm this with a more detailed analysis.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param flushWriteQueue true then data is written to file otherwise the data may be placed on</color>
<color=#75715e>   *     the FileManager WriteQueue.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>writeDirty</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>flushWriteQueue</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dirtyStart</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
      <color=#66d9ef>boolean</color> <color=#f8f8f2>process</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>LogBuffer</color> <color=#f8f8f2>lb</color> <color=#f92672>=</color> <color=#f8f8f2>bufferPool</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>dirtyStart</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>lb</color><color=#f8f8f2>.</color><color=#a6e22e>waitForZeroAndLatch</color><color=#f8f8f2>();</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>writeBufferToFile</color><color=#f8f8f2>(</color><color=#f8f8f2>lb</color><color=#f8f8f2>,</color> <color=#f8f8f2>flushWriteQueue</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>lb</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dirtyStart</color> <color=#f92672>==</color> <color=#f8f8f2>dirtyEnd</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>process</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dirtyStart</color> <color=#f92672>=</color> <color=#f8f8f2>getNextSlot</color><color=#f8f8f2>(</color><color=#f8f8f2>dirtyStart</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>process</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>dirtyStart</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>dirtyEnd</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>releaseIfOwner</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Writes a log buffer.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The LWL or buffer latch must be held.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param latchedBuffer buffer to write</color>
<color=#75715e>   * @param flushWriteQueue true then data is written to file otherwise the data may be placed on</color>
<color=#75715e>   *     the FileManager WriteQueue.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>writeBufferToFile</color><color=#f8f8f2>(</color><color=#f8f8f2>LogBuffer</color> <color=#f8f8f2>latchedBuffer</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>flushWriteQueue</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>runInMemory</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Check for an invalid env while buffer is latched and before writing.</color>
<color=#75715e>     * This is necessary to prevent writing a buffer corruption that was</color>
<color=#75715e>     * detected during a read from the buffer. The read will invalidate the</color>
<color=#75715e>     * env while holding the buffer latch.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>checkIfInvalid</color><color=#f8f8f2>();</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>currentByteBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>latchedBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>getDataBuffer</color><color=#f8f8f2>();</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>savePosition</color> <color=#f92672>=</color> <color=#f8f8f2>currentByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>();</color>
      <color=#66d9ef>int</color> <color=#f8f8f2>saveLimit</color> <color=#f92672>=</color> <color=#f8f8f2>currentByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>limit</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>currentByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>

      <color=#75715e>/*</color>
<color=#75715e>       * If we're configured for writing (not memory-only situation),</color>
<color=#75715e>       * write this buffer to disk and find a new buffer to use.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>fileManager</color><color=#f8f8f2>.</color><color=#a6e22e>writeLogBuffer</color><color=#f8f8f2>(</color><color=#f8f8f2>latchedBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>flushWriteQueue</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Throwable</color> <color=#f8f8f2>t</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>currentByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>(</color><color=#f8f8f2>savePosition</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>currentByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>limit</color><color=#f8f8f2>(</color><color=#f8f8f2>saveLimit</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Exceptions thrown during logging are expected to be</color>
<color=#75715e>         * fatal. Ensure that the environment is invalidated</color>
<color=#75715e>         * when a non-fatal exception is unexpectedly thrown.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>t</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

          <color=#75715e>/*</color>
<color=#75715e>           * If we've already invalidated the environment,</color>
<color=#75715e>           * re-throw so as not to excessively wrap the</color>
<color=#75715e>           * exception.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>isValid</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>)</color> <color=#f8f8f2>t</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>
          <color=#75715e>/* Otherwise, invalidate the environment. */</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedException</color><color=#f8f8f2>(</color>
              <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>)</color> <color=#f8f8f2>t</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>t</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>Error</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>invalidate</color><color=#f8f8f2>((</color><color=#f8f8f2>Error</color><color=#f8f8f2>)</color> <color=#f8f8f2>t</color><color=#f8f8f2>);</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>(</color><color=#f8f8f2>Error</color><color=#f8f8f2>)</color> <color=#f8f8f2>t</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>t</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>Exception</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedException</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color><color=#f8f8f2>)</color> <color=#f8f8f2>t</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>throw</color> <color=#f8f8f2>EnvironmentFailureException</color><color=#f8f8f2>.</color><color=#a6e22e>unexpectedException</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>t</color><color=#f8f8f2>.</color><color=#a6e22e>getMessage</color><color=#f8f8f2>(),</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>latchedBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Move the current write buffer to the next. Will not bump the current write buffer if the buffer</color>
<color=#75715e>   * is empty.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The LWL must be held.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param sizeNeeded used only if running in memory. Size of the log buffer that is needed.</color>
<color=#75715e>   * @return false when the buffer needs flushing, but there are no free buffers. Returns true when</color>
<color=#75715e>   *     when running in memory, when the buffer is empty, or when the buffer is non-empty and is</color>
<color=#75715e>   *     bumped.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>boolean</color> <color=#a6e22e>bumpCurrent</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* We're done with the buffer, flip to make it readable. */</color>
    <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>currentWriteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>latchForWrite</color><color=#f8f8f2>();</color>

    <color=#f8f8f2>LogBuffer</color> <color=#f8f8f2>latchedBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>currentWriteBuffer</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>

      <color=#75715e>/*</color>
<color=#75715e>       * Is there anything in this write buffer?</color>
<color=#75715e>       */</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentWriteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>getFirstLsn</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>runInMemory</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>bufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#f8f8f2>logBufferSize</color> <color=#f92672>></color> <color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#f8f8f2>logBufferSize</color> <color=#f8f8f2>:</color> <color=#f8f8f2>sizeNeeded</color><color=#f8f8f2>);</color>
        <color=#75715e>/* We're supposed to run in-memory, allocate another buffer. */</color>
        <color=#f8f8f2>currentWriteBuffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>LogBuffer</color><color=#f8f8f2>(</color><color=#f8f8f2>bufferSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>bufferPool</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>currentWriteBuffer</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>currentWriteBufferIndex</color> <color=#f92672>=</color> <color=#f8f8f2>bufferPool</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dirtyStart</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>dirtyStart</color> <color=#f92672>=</color> <color=#f8f8f2>currentWriteBufferIndex</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Check to see if there is an undirty buffer to use. */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>getNextSlot</color><color=#f8f8f2>(</color><color=#f8f8f2>currentWriteBufferIndex</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#f8f8f2>dirtyStart</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>nNoFreeBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
          <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>dirtyEnd</color> <color=#f92672>=</color> <color=#f8f8f2>currentWriteBufferIndex</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>currentWriteBufferIndex</color> <color=#f92672>=</color> <color=#f8f8f2>getNextSlot</color><color=#f8f8f2>(</color><color=#f8f8f2>currentWriteBufferIndex</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>LogBuffer</color> <color=#f8f8f2>nextToUse</color> <color=#f92672>=</color> <color=#f8f8f2>bufferPool</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>currentWriteBufferIndex</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>LogBuffer</color> <color=#f8f8f2>newInitialBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>bufferPool</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>getNextSlot</color><color=#f8f8f2>(</color><color=#f8f8f2>currentWriteBufferIndex</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>nextToUse</color><color=#f8f8f2>.</color><color=#a6e22e>reinit</color><color=#f8f8f2>();</color>

      <color=#75715e>/* Assign currentWriteBuffer with the latch held. */</color>
      <color=#f8f8f2>currentWriteBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>nextToUse</color><color=#f8f8f2>;</color>

      <color=#75715e>/* Paranoia: do this after transition to new buffer. */</color>
      <color=#f8f8f2>updateMinBufferLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>newInitialBuffer</color><color=#f8f8f2>);</color>
      <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>latchedBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>release</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>releaseIfOwner</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Set minBufferLsn to start of new initial buffer. The update occurs only after cycling once</color>
<color=#75715e>   * through the buffers in the pool. This is a simple implementation, and waiting until we've</color>
<color=#75715e>   * filled the buffer pool to initialize it is sufficient for reducing read contention in</color>
<color=#75715e>   * getReadBufferByLsn. [#19642]</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>The LWL must be held.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>updateMinBufferLsn</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>LogBuffer</color> <color=#f8f8f2>newInitialBuffer</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>newMinLsn</color> <color=#f92672>=</color> <color=#f8f8f2>newInitialBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>getFirstLsn</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>newMinLsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>minBufferLsn</color> <color=#f92672>=</color> <color=#f8f8f2>newMinLsn</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Find a buffer that contains the given LSN location.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>No latches need be held.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the buffer that contains the given LSN location, latched and ready to read, or return</color>
<color=#75715e>   *     null.</color>
<color=#75715e>   */</color>
  <color=#f8f8f2>LogBuffer</color> <color=#a6e22e>getReadBufferByLsn</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#f8f8f2>nNotResident</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>

    <color=#75715e>/* Avoid latching if the LSN is known not to be in the pool. */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>compareTo</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>minBufferLsn</color><color=#f8f8f2>)</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>nCacheMiss</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Latch and check the buffer pool. */</color>
    <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>acquireExclusive</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * TODO: Check currentWriteBuffer last, because we will have to</color>
<color=#75715e>       * wait for its pin count to go to zero, which may require waiting</color>
<color=#75715e>       * until it is full.</color>
<color=#75715e>       */</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>LogBuffer</color> <color=#f8f8f2>l</color> <color=#f8f8f2>:</color> <color=#f8f8f2>bufferPool</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>l</color><color=#f8f8f2>.</color><color=#a6e22e>containsLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>l</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>nCacheMiss</color><color=#f8f8f2>.</color><color=#a6e22e>increment</color><color=#f8f8f2>();</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>releaseIfOwner</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#f8f8f2>StatGroup</color> <color=#a6e22e>loadStats</color><color=#f8f8f2>(</color><color=#f8f8f2>StatsConfig</color> <color=#f8f8f2>config</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>DatabaseException</color> <color=#f8f8f2>{</color>

    <color=#75715e>/* Also return buffer pool memory usage */</color>
    <color=#f8f8f2>logBuffers</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>(</color><color=#f8f8f2>nLogBuffers</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>nBufferBytes</color><color=#f8f8f2>.</color><color=#a6e22e>set</color><color=#f8f8f2>((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>nLogBuffers</color> <color=#f92672>*</color> <color=#f8f8f2>logBufferSize</color><color=#f8f8f2>);</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>stats</color><color=#f8f8f2>.</color><color=#a6e22e>cloneGroup</color><color=#f8f8f2>(</color><color=#f8f8f2>config</color><color=#f8f8f2>.</color><color=#a6e22e>getClear</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Return the current nCacheMiss statistic in a lightweight fashion, without perturbing other</color>
<color=#75715e>   * statistics or requiring synchronization.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>getNCacheMiss</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>nCacheMiss</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** For unit testing. */</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>StatGroup</color> <color=#a6e22e>getBufferPoolLatchStats</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>bufferPoolLatch</color><color=#f8f8f2>.</color><color=#a6e22e>getStats</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>