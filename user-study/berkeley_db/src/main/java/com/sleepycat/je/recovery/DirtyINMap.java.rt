<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.recovery</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.CacheMode</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.dbi.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.log.Provisional</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.recovery.Checkpointer.CheckpointReference</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.IN</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.tree.MapLN</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.DbLsn</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.LoggerUtils</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.Pair</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.utilint.TestHookExecute</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.util.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.logging.Level</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * Manages the by-level map of checkpoint references that are to be flushed by a checkpoint or</color>
<color=#75715e> * Database.sync, the MapLNs to be flushed, the highest level by database to be flushed, and the</color>
<color=#75715e> * state of the checkpoint.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>An single instance of this class is used for checkpoints and has the same lifetime as the</color>
<color=#75715e> * checkpointer and environment. An instance per Database.sync is created as needed. Only one</color>
<color=#75715e> * checkpoint can occur at a time, but multiple syncs may occur concurrently with each other and</color>
<color=#75715e> * with the checkpoint.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>The methods in this class are synchronized to protect internal state from concurrent access by</color>
<color=#75715e> * the checkpointer and eviction, and to coordinate state changes between the two. Eviction must</color>
<color=#75715e> * participate in the checkpoint so that INs cascade up properly; see</color>
<color=#75715e> * coordinateEvictionWithCheckpoint.</color>
<color=#75715e> *</color>
<color=#75715e> * <p>When INs are latched along with synchronization on a DirtyINMap, the order must be: 1) IN</color>
<color=#75715e> * latches and 2) synchronize on DirtyINMap. For example, the evictor latches the parent and child</color>
<color=#75715e> * IN before calling the synchronized method coordinateEvictionWithCheckpoint, and</color>
<color=#75715e> * selectDirtyINsForCheckpoint latches the IN before calling the synchronized method</color>
<color=#75715e> * selectForCheckpoint.</color>
<color=#75715e> */</color>
<color=#66d9ef>class</color> <color=#a6e22e>DirtyINMap</color> <color=#f8f8f2>{</color>

  <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>DIRTY_SET_DEBUG_TRACE</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>SortedMap</color><color=#f92672><</color>
          <color=#f8f8f2>Integer</color><color=#f8f8f2>,</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color><color=#f8f8f2>,</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>>>></color>
      <color=#f8f8f2>levelMap</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#f8f8f2>numEntries</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f92672>></color> <color=#f8f8f2>mapLNsToFlush</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>DatabaseImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>;</color>

  <color=#66d9ef>enum</color> <color=#f8f8f2>CkptState</color> <color=#f8f8f2>{</color>
    <color=#75715e>/** No checkpoint in progress, or is used for Database.sync. */</color>
    <color=#f8f8f2>NONE</color><color=#f8f8f2>,</color>
    <color=#75715e>/** Checkpoint started but dirty map is not yet complete. */</color>
    <color=#f8f8f2>DIRTY_MAP_INCOMPLETE</color><color=#f8f8f2>,</color>
    <color=#75715e>/** Checkpoint in progress and dirty map is complete. */</color>
    <color=#f8f8f2>DIRTY_MAP_COMPLETE</color><color=#f8f8f2>,</color>
  <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#f8f8f2>CkptState</color> <color=#f8f8f2>ckptState</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>ckptFlushAll</color><color=#f8f8f2>;</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>ckptFlushExtraLevel</color><color=#f8f8f2>;</color>

  <color=#f8f8f2>DirtyINMap</color><color=#f8f8f2>(</color><color=#f8f8f2>EnvironmentImpl</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>envImpl</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>levelMap</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TreeMap</color><color=#f92672><></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>numEntries</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>mapLNsToFlush</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>highestFlushLevels</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>IdentityHashMap</color><color=#f92672><</color><color=#f8f8f2>DatabaseImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Integer</color><color=#f92672>></color><color=#f8f8f2>();</color>
    <color=#f8f8f2>ckptState</color> <color=#f92672>=</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>NONE</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Coordinates an eviction with an in-progress checkpoint and returns whether or not provisional</color>
<color=#75715e>   * logging is needed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return the provisional status to use for logging the target.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>synchronized</color> <color=#f8f8f2>Provisional</color> <color=#a6e22e>coordinateEvictionWithCheckpoint</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetLevel</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>parent</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the checkpoint is in-progress and has not finished dirty map</color>
<color=#75715e>     * construction, we must add the parent to the dirty map.  That way the</color>
<color=#75715e>     * dirtiness and logging will cascade up in the same way as if the</color>
<color=#75715e>     * target were not evicted, and instead were encountered during dirty</color>
<color=#75715e>     * map construction.  We don't want the evictor's actions to introduce</color>
<color=#75715e>     * an IN in the log that has not cascaded up properly.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Note that we add the parent even if it is not dirty here.  It will</color>
<color=#75715e>     * become dirty after the target child is logged, but that hasn't</color>
<color=#75715e>     * happened yet.</color>
<color=#75715e>     *</color>
<color=#75715e>     * We do not add the parent if it is null, which is the case when the</color>
<color=#75715e>     * root is being evicted.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ckptState</color> <color=#f92672>==</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_MAP_INCOMPLETE</color> <color=#f92672>&&</color> <color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#75715e>/* Add latched parent IN to dirty map. */</color>
      <color=#f8f8f2>selectForCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color> <color=#75715e>/*index*/</color><color=#f8f8f2>);</color>

      <color=#75715e>/* Save dirty/temp DBs for later. */</color>
      <color=#f8f8f2>saveMapLNsToFlush</color><color=#f8f8f2>(</color><color=#f8f8f2>parent</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * The evictor has to log provisionally in three cases:</color>
<color=#75715e>     *</color>
<color=#75715e>     * 1 - The eviction target is part of a deferred write database.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>Provisional</color><color=#f8f8f2>.</color><color=#a6e22e>YES</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * 2 - The checkpoint is in-progress and has not finished dirty map</color>
<color=#75715e>     *     construction, and the target is not the root. The parent IN has</color>
<color=#75715e>     *     been added to the dirty map, so we know the child IN is at a</color>
<color=#75715e>     *     level below the max flush level.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ckptState</color> <color=#f92672>==</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_MAP_INCOMPLETE</color> <color=#f92672>&&</color> <color=#f8f8f2>parent</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>Provisional</color><color=#f8f8f2>.</color><color=#a6e22e>YES</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * 3 - The checkpoint is in-progress and has finished dirty map</color>
<color=#75715e>     *     construction, and is at a level above the eviction target.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ckptState</color> <color=#f92672>==</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_MAP_COMPLETE</color> <color=#f92672>&&</color> <color=#f8f8f2>targetLevel</color> <color=#f92672><</color> <color=#f8f8f2>getHighestFlushLevel</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f8f8f2>Provisional</color><color=#f8f8f2>.</color><color=#a6e22e>YES</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Otherwise, log non-provisionally. */</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>Provisional</color><color=#f8f8f2>.</color><color=#a6e22e>NO</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Coordinates a split with an in-progress checkpoint.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>TODO: Is it necessary to perform MapLN flushing for nodes logged by a split (and not just</color>
<color=#75715e>   * the new sibling)?</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param newSibling the sibling IN created by the split.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>coordinateSplitWithCheckpoint</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>newSibling</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>newSibling</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchExclusiveOwner</color><color=#f8f8f2>();</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If the checkpoint is in-progress and has not finished dirty map</color>
<color=#75715e>     * construction, we must add the BIN children of the new sibling to the</color>
<color=#75715e>     * dirty map. The new sibling will be added to the INList but it may or</color>
<color=#75715e>     * may not be seen by the in-progress INList iteration, and we must</color>
<color=#75715e>     * ensure that its dirty BIN children are logged by the checkpoint.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Note that we cannot synchronize on 'this' before calling</color>
<color=#75715e>     * selectDirtyBINChildrenForCheckpoint, since it latches BIN children.</color>
<color=#75715e>     * IN latching must come before synchronization on 'this'. Eventually</color>
<color=#75715e>     * after latching the IN, selectForCheckpoint is called , which  is</color>
<color=#75715e>     * synchronized and checks for ckptState == DIRTY_MAP_INCOMPLETE.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>selectDirtyBINChildrenForCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>newSibling</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Must be called before starting a checkpoint, and must not be called for Database.sync. Updates</color>
<color=#75715e>   * memory budget and sets checkpoint state.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>beginCheckpoint</color><color=#f8f8f2>(</color><color=#66d9ef>boolean</color> <color=#f8f8f2>flushAll</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>flushExtraLevel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>mapLNsToFlush</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>();</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>numEntries</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>ckptState</color> <color=#f92672>==</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>NONE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>ckptState</color> <color=#f92672>=</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_MAP_INCOMPLETE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>ckptFlushAll</color> <color=#f92672>=</color> <color=#f8f8f2>flushAll</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>ckptFlushExtraLevel</color> <color=#f92672>=</color> <color=#f8f8f2>flushExtraLevel</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Must be called after a checkpoint or Database.sync is complete. Updates memory budget and</color>
<color=#75715e>   * clears checkpoint state.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>reset</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>removeCostFromMemoryBudget</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>mapLNsToFlush</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>numEntries</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>ckptState</color> <color=#f92672>=</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>NONE</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Scan the INList for all dirty INs, excluding temp DB INs. Save them in a tree-level ordered map</color>
<color=#75715e>   * for level ordered flushing.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Take this opportunity to recalculate the memory budget tree usage.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method itself is not synchronized to allow concurrent eviction. Synchronization is</color>
<color=#75715e>   * performed on a per-IN basis to protect the data structures here, and eviction can occur in</color>
<color=#75715e>   * between INs.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>selectDirtyINsForCheckpoint</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>ckptState</color> <color=#f92672>==</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_MAP_INCOMPLETE</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Opportunistically recalculate the INList memory budget while</color>
<color=#75715e>     * traversing the entire INList.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>INList</color> <color=#f8f8f2>inMemINs</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>inMemINs</color><color=#f8f8f2>.</color><color=#a6e22e>memRecalcBegin</color><color=#f8f8f2>();</color>

    <color=#66d9ef>boolean</color> <color=#f8f8f2>completed</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>in</color> <color=#f8f8f2>:</color> <color=#f8f8f2>inMemINs</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>latchShared</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>continue</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>}</color>

          <color=#f8f8f2>inMemINs</color><color=#f8f8f2>.</color><color=#a6e22e>memRecalcIterate</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>);</color>

          <color=#75715e>/* Add dirty UIN to dirty map. */</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>selectForCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color> <color=#75715e>/*index*/</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/* Add dirty level 2 children to dirty map. */</color>
          <color=#f8f8f2>selectDirtyBINChildrenForCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>);</color>

          <color=#75715e>/* Save dirty/temp DBs for later. */</color>
          <color=#f8f8f2>saveMapLNsToFlush</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Call test hook after releasing latch. */</color>
        <color=#f8f8f2>TestHookExecute</color><color=#f8f8f2>.</color><color=#a6e22e>doHookIfSet</color><color=#f8f8f2>(</color><color=#f8f8f2>Checkpointer</color><color=#f8f8f2>.</color><color=#a6e22e>examineINForCheckpointHook</color><color=#f8f8f2>,</color> <color=#f8f8f2>in</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
      <color=#f8f8f2>completed</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>inMemINs</color><color=#f8f8f2>.</color><color=#a6e22e>memRecalcEnd</color><color=#f8f8f2>(</color><color=#f8f8f2>completed</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Finish filling out the highestFlushLevels map. For each entry in</color>
<color=#75715e>     * highestFlushLevels that has a null level Integer value (set by</color>
<color=#75715e>     * selectForCheckpoint), we call DbTree.getHighestLevel and replace the</color>
<color=#75715e>     * null level. We must call DbTree.getHighestLevel, which latches the</color>
<color=#75715e>     * root, only when not synchronized, to avoid breaking the</color>
<color=#75715e>     * synchronization rules described in the class comment.  This must be</color>
<color=#75715e>     * done in several steps to follow the sychronization rules, yet</color>
<color=#75715e>     * protect the highestFlushLevels using synchronization.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>DatabaseImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#f8f8f2>maxFlushDbs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashMap</color><color=#f92672><></color><color=#f8f8f2>();</color>

    <color=#75715e>/* Copy entries with a null level. */</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f8f8f2>:</color> <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>keySet</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>maxFlushDbs</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Call getHighestLevel without synchronization. */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>Map</color><color=#f8f8f2>.</color><color=#a6e22e>Entry</color><color=#f92672><</color><color=#f8f8f2>DatabaseImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#f8f8f2>entry</color> <color=#f8f8f2>:</color> <color=#f8f8f2>maxFlushDbs</color><color=#f8f8f2>.</color><color=#a6e22e>entrySet</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>entry</color><color=#f8f8f2>.</color><color=#a6e22e>setValue</color><color=#f8f8f2>(</color><color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getHighestLevel</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>()));</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Fill in levels in highestFlushLevels. */</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>Map</color><color=#f8f8f2>.</color><color=#a6e22e>Entry</color><color=#f92672><</color><color=#f8f8f2>DatabaseImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Integer</color><color=#f92672>></color> <color=#f8f8f2>entry</color> <color=#f8f8f2>:</color> <color=#f8f8f2>maxFlushDbs</color><color=#f8f8f2>.</color><color=#a6e22e>entrySet</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

        <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>entry</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(),</color> <color=#f8f8f2>entry</color><color=#f8f8f2>.</color><color=#a6e22e>getValue</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/* Complete this phase of the checkpoint. */</color>
    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>addCostToMemoryBudget</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>ckptState</color> <color=#f92672>=</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_MAP_COMPLETE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DIRTY_SET_DEBUG_TRACE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>traceDirtySet</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Add the IN to the dirty map if dirty map construction is in progress and the IN is not in a</color>
<color=#75715e>   * temp DB. If added, the highest flush level map is also updated.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>selectForCheckpoint</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Must check state while synchronized. The state may not be</color>
<color=#75715e>     * DIRTY_MAP_INCOMPLETE when called from eviction or a split.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ckptState</color> <color=#f92672>!=</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_MAP_INCOMPLETE</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isTemporary</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>addIN</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*updateFlushLevels*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*updateMemoryBudget*/</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Adds the the dirty child BINs of the 'in' if dirty map construction is in progress and the IN</color>
<color=#75715e>   * is not in a temp DB.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Main cache resident BINs are added when their parent is encountered in the INList iteration,</color>
<color=#75715e>   * rather than when the BIN is encountered in the iteration. This is because a BIN can transition</color>
<color=#75715e>   * between main and off-heap caches during the construction of the dirty map. When a BIN is loaded</color>
<color=#75715e>   * from off-heap and added to the main cache, it is added to the INList at that time, and such a</color>
<color=#75715e>   * BIN may not be encountered in the iteration. (ConcurrentHashMap iteration only guarantees that</color>
<color=#75715e>   * nodes will be encountered if they are present when the iterator is created). So if we relied on</color>
<color=#75715e>   * encountering BINs in the iteration, some might be missed.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>Note that this method is not synchronized because it latches the BIN children. IN latching</color>
<color=#75715e>   * must come before synchronizing on 'this'. The selectForCheckpoint method, which is called after</color>
<color=#75715e>   * latching the BIN, is synchronized.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>selectDirtyBINChildrenForCheckpoint</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNormalizedLevel</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>bin</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#75715e>/* When called via split a child may already be latched. */</color>
        <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>latchBinHere</color> <color=#f92672>=</color> <color=#f92672>!</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>isLatchOwner</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>latchBinHere</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>latchShared</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>selectForCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>bin</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>latchBinHere</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bin</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isOffHeapBINDirty</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>selectForCheckpoint</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f8f8f2>i</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>updateFlushLevels</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>Integer</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isBIN</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isRoot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * IN was added to the dirty map.  Update the highest level seen</color>
<color=#75715e>     * for the database.  Use one level higher when ckptFlushExtraLevel</color>
<color=#75715e>     * is set.  When ckptFlushAll is set, use the maximum level for the</color>
<color=#75715e>     * database.  Durable deferred-write databases must be synced, so</color>
<color=#75715e>     * also use the maximum level.</color>
<color=#75715e>     *</color>
<color=#75715e>     * Always flush at least one level above the bottom-most BIN level so</color>
<color=#75715e>     * that the BIN level is logged provisionally and the expense of</color>
<color=#75715e>     * processing BINs during recovery is avoided.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ckptFlushAll</color> <color=#f92672>||</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDurableDeferredWrite</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>containsKey</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Null is used as an indicator that getHighestLevel should be</color>
<color=#75715e>         * called in selectDirtyINsForCheckpoint, when not</color>
<color=#75715e>         * synchronized.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>ckptFlushExtraLevel</color> <color=#f92672>||</color> <color=#f8f8f2>isBIN</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>isRoot</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* Next level up in the same tree. */</color>
        <color=#f8f8f2>level</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Integer</color> <color=#f8f8f2>highestLevelSeen</color> <color=#f92672>=</color> <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>highestLevelSeen</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>level</color> <color=#f92672>></color> <color=#f8f8f2>highestLevelSeen</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>level</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Scan the INList for all dirty INs for a given database. Arrange them in level sorted map for</color>
<color=#75715e>   * level ordered flushing.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method is not synchronized to allow concurrent eviction. Coordination between eviction</color>
<color=#75715e>   * and Database.sync is not required.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>selectDirtyINsForDbSync</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>ckptState</color> <color=#f92672>==</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>NONE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color> <color=#f92672>=</color> <color=#f8f8f2>dbImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>();</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>in</color> <color=#f8f8f2>:</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getInMemoryINs</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabaseId</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>latch</color><color=#f8f8f2>(</color><color=#f8f8f2>CacheMode</color><color=#f8f8f2>.</color><color=#a6e22e>UNCHANGED</color><color=#f8f8f2>);</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getInListResident</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDirty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>addIN</color><color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color> <color=#75715e>/*index*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*updateFlushLevels*/</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color> <color=#75715e>/*updateMemoryBudget*/</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>releaseLatch</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Create a single entry map that forces all levels of this DB to</color>
<color=#75715e>     * be flushed.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>().</color><color=#a6e22e>getHighestLevel</color><color=#f8f8f2>(</color><color=#f8f8f2>dbImpl</color><color=#f8f8f2>));</color>

    <color=#75715e>/* Add the dirty map to the memory budget.  */</color>
    <color=#f8f8f2>addCostToMemoryBudget</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>synchronized</color> <color=#66d9ef>int</color> <color=#a6e22e>getHighestFlushLevel</color><color=#f8f8f2>(</color><color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>ckptState</color> <color=#f92672>!=</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_MAP_INCOMPLETE</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This method is only called while flushing dirty nodes for a</color>
<color=#75715e>     * checkpoint or Database.sync, not for an eviction, so an entry for</color>
<color=#75715e>     * this database should normally exist.  However, if the DB root (and</color>
<color=#75715e>     * DatabaseImpl) have been evicted since the highestFlushLevels was</color>
<color=#75715e>     * constructed, the new DatabaseImpl instance will not be present in</color>
<color=#75715e>     * the map.  In this case, we do not need to checkpoint the IN and</color>
<color=#75715e>     * eviction should be non-provisional.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>Integer</color> <color=#f8f8f2>val</color> <color=#f92672>=</color> <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>val</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#f8f8f2>val</color> <color=#f8f8f2>:</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>MIN_LEVEL</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>synchronized</color> <color=#66d9ef>int</color> <color=#a6e22e>getNumLevels</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>addCostToMemoryBudget</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>MemoryBudget</color> <color=#f8f8f2>mb</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getMemoryBudget</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>cost</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>numEntries</color><color=#f8f8f2>)</color> <color=#f92672>*</color> <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINT_REFERENCE_SIZE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>mb</color><color=#f8f8f2>.</color><color=#a6e22e>updateAdminMemoryUsage</color><color=#f8f8f2>(</color><color=#f8f8f2>cost</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>removeCostFromMemoryBudget</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>MemoryBudget</color> <color=#f8f8f2>mb</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getMemoryBudget</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>cost</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#66d9ef>long</color><color=#f8f8f2>)</color> <color=#f8f8f2>numEntries</color><color=#f8f8f2>)</color> <color=#f92672>*</color> <color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINT_REFERENCE_SIZE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>mb</color><color=#f8f8f2>.</color><color=#a6e22e>updateAdminMemoryUsage</color><color=#f8f8f2>(</color><color=#ae81ff>0</color> <color=#f92672>-</color> <color=#f8f8f2>cost</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Add a node unconditionally to the dirty map.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param in is the IN to add, or the parent of an off-heap IN to add when index >= 0.</color>
<color=#75715e>   * @param index is the index of the off-heap child to add, or -1 to add the 'in' itself.</color>
<color=#75715e>   * @param updateMemoryBudget if true then update the memory budget as the map is changed; if false</color>
<color=#75715e>   *     then addCostToMemoryBudget must be called later.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>addIN</color><color=#f8f8f2>(</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>index</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>updateFlushLevels</color><color=#f8f8f2>,</color>
      <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>updateMemoryBudget</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Integer</color> <color=#f8f8f2>level</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isRoot</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>idKey</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>isBin</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>index</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>level</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getLsn</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>nodeId</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>isRoot</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>idKey</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getKey</color><color=#f8f8f2>(</color><color=#f8f8f2>index</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>isBin</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>level</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getLevel</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>lsn</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getLastLoggedLsn</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>nodeId</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNodeId</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>isRoot</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isRoot</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>idKey</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getIdentifierKey</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>isBin</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color> <color=#f8f8f2>lsnMap</color><color=#f8f8f2>;</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color> <color=#f8f8f2>nodeMap</color><color=#f8f8f2>;</color>

    <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color><color=#f8f8f2>,</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>>></color> <color=#f8f8f2>pairOfMaps</color> <color=#f92672>=</color>
        <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pairOfMaps</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>lsnMap</color> <color=#f92672>=</color> <color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>first</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>nodeMap</color> <color=#f92672>=</color> <color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * We use TreeMap rather than HashMap because HashMap.iterator() is</color>
<color=#75715e>       * a slow way of getting the first element (see removeNextNode).</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>lsnMap</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TreeMap</color><color=#f92672><></color><color=#f8f8f2>();</color>
      <color=#f8f8f2>nodeMap</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>TreeMap</color><color=#f92672><></color><color=#f8f8f2>();</color>
      <color=#f8f8f2>pairOfMaps</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Pair</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>lsnMap</color><color=#f8f8f2>,</color> <color=#f8f8f2>nodeMap</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>();</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>ref</color> <color=#f92672>=</color>
        <color=#66d9ef>new</color> <color=#f8f8f2>CheckpointReference</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>(),</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>,</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#f8f8f2>isRoot</color><color=#f8f8f2>,</color> <color=#f8f8f2>idKey</color><color=#f8f8f2>,</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>

    <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>added</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>added</color> <color=#f92672>=</color> <color=#f8f8f2>lsnMap</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#f8f8f2>ref</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>nodeId</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDeferredWriteMode</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>added</color> <color=#f92672>=</color> <color=#f8f8f2>nodeMap</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeId</color><color=#f8f8f2>,</color> <color=#f8f8f2>ref</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>added</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>numEntries</color><color=#f92672>++</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>updateFlushLevels</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>updateFlushLevels</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>isBin</color><color=#f8f8f2>,</color> <color=#f8f8f2>isRoot</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>updateMemoryBudget</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>MemoryBudget</color> <color=#f8f8f2>mb</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getMemoryBudget</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>mb</color><color=#f8f8f2>.</color><color=#a6e22e>updateAdminMemoryUsage</color><color=#f8f8f2>(</color><color=#f8f8f2>MemoryBudget</color><color=#f8f8f2>.</color><color=#a6e22e>CHECKPOINT_REFERENCE_SIZE</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Get the lowest level currently stored in the map. */</color>
  <color=#66d9ef>synchronized</color> <color=#f8f8f2>Integer</color> <color=#a6e22e>getLowestLevelSet</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>firstKey</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Removes the set corresponding to the given level. */</color>
  <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>removeLevel</color><color=#f8f8f2>(</color><color=#f8f8f2>Integer</color> <color=#f8f8f2>level</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>synchronized</color> <color=#f8f8f2>CheckpointReference</color> <color=#a6e22e>removeNode</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>level</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>lsn</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>long</color> <color=#f8f8f2>nodeId</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color><color=#f8f8f2>,</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>>></color> <color=#f8f8f2>pairOfMaps</color> <color=#f92672>=</color>
        <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pairOfMaps</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color> <color=#f8f8f2>lsnMap</color> <color=#f92672>=</color> <color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>first</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color> <color=#f8f8f2>nodeMap</color> <color=#f92672>=</color> <color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>lsn</color> <color=#f92672>!=</color> <color=#f8f8f2>DbLsn</color><color=#f8f8f2>.</color><color=#a6e22e>NULL_LSN</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>ref</color> <color=#f92672>=</color> <color=#f8f8f2>lsnMap</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>lsn</color><color=#f8f8f2>);</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ref</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>ref</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>nodeId</color> <color=#f92672>>=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>ref</color> <color=#f92672>=</color> <color=#f8f8f2>nodeMap</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeId</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>ref</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>synchronized</color> <color=#f8f8f2>CheckpointReference</color> <color=#a6e22e>removeNextNode</color><color=#f8f8f2>(</color><color=#f8f8f2>Integer</color> <color=#f8f8f2>level</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color><color=#f8f8f2>,</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>>></color> <color=#f8f8f2>pairOfMaps</color> <color=#f92672>=</color>
        <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>);</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pairOfMaps</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color> <color=#f8f8f2>map</color><color=#f8f8f2>;</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>first</color><color=#f8f8f2>().</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>map</color> <color=#f92672>=</color> <color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>first</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>().</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>map</color> <color=#f92672>=</color> <color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>Iterator</color><color=#f92672><</color><color=#f8f8f2>Map</color><color=#f8f8f2>.</color><color=#a6e22e>Entry</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>>></color> <color=#f8f8f2>iter</color> <color=#f92672>=</color> <color=#f8f8f2>map</color><color=#f8f8f2>.</color><color=#a6e22e>entrySet</color><color=#f8f8f2>().</color><color=#a6e22e>iterator</color><color=#f8f8f2>();</color>

    <color=#66d9ef>assert</color> <color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>hasNext</color><color=#f8f8f2>();</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>CheckpointReference</color> <color=#f8f8f2>ref</color> <color=#f92672>=</color> <color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>next</color><color=#f8f8f2>().</color><color=#a6e22e>getValue</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>iter</color><color=#f8f8f2>.</color><color=#a6e22e>remove</color><color=#f8f8f2>();</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>ref</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * If the given IN is a BIN for the ID mapping database, saves all dirty/temp MapLNs contained in</color>
<color=#75715e>   * it.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>synchronized</color> <color=#66d9ef>void</color> <color=#a6e22e>saveMapLNsToFlush</color><color=#f8f8f2>(</color><color=#f8f8f2>IN</color> <color=#f8f8f2>in</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>isBIN</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>getId</color><color=#f8f8f2>().</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>DbTree</color><color=#f8f8f2>.</color><color=#a6e22e>ID_DB_ID</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getNEntries</color><color=#f8f8f2>();</color> <color=#f8f8f2>i</color> <color=#f92672>+=</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>MapLN</color> <color=#f8f8f2>ln</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>MapLN</color><color=#f8f8f2>)</color> <color=#f8f8f2>in</color><color=#f8f8f2>.</color><color=#a6e22e>getTarget</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ln</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>isCheckpointNeeded</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>mapLNsToFlush</color><color=#f8f8f2>.</color><color=#a6e22e>add</color><color=#f8f8f2>(</color><color=#f8f8f2>ln</color><color=#f8f8f2>.</color><color=#a6e22e>getDatabase</color><color=#f8f8f2>().</color><color=#a6e22e>getId</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Flushes all saved dirty/temp MapLNs and clears the saved set.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>If dirty, a MapLN must be flushed at each checkpoint to record updated utilization info in</color>
<color=#75715e>   * the checkpoint interval. If it is a temporary DB, the MapLN must be flushed because all temp</color>
<color=#75715e>   * DBs must be encountered by recovery so they can be removed if they were not closed (and</color>
<color=#75715e>   * removed) by the user. This method is not synchronized because it takes the Btree root latch,</color>
<color=#75715e>   * and we must never latch something in the Btree after synchronizing on DirtyINMap; see class</color>
<color=#75715e>   * comments. Special synchronization is performed for accessing internal state; see below.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param checkpointStart start LSN of the checkpoint in progress. To reduce unnecessary logging,</color>
<color=#75715e>   *     the MapLN is only flushed if it has not been written since that LSN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>flushMapLNs</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>checkpointStart</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#75715e>/*</color>
<color=#75715e>     * This method is called only while flushing dirty nodes for a</color>
<color=#75715e>     * checkpoint or Database.sync, not for an eviction, and mapLNsToFlush</color>
<color=#75715e>     * is not changed during the flushing phase.  So we don't strictly need</color>
<color=#75715e>     * to synchronize while accessing mapLNsToFlush.  However, for</color>
<color=#75715e>     * consistency and extra safety we always synchronize while accessing</color>
<color=#75715e>     * internal state.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>final</color> <color=#f8f8f2>Set</color><color=#f92672><</color><color=#f8f8f2>DatabaseId</color><color=#f92672>></color> <color=#f8f8f2>mapLNsCopy</color><color=#f8f8f2>;</color>

    <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>assert</color> <color=#f8f8f2>ckptState</color> <color=#f92672>!=</color> <color=#f8f8f2>CkptState</color><color=#f8f8f2>.</color><color=#a6e22e>DIRTY_MAP_INCOMPLETE</color><color=#f8f8f2>;</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mapLNsToFlush</color><color=#f8f8f2>.</color><color=#a6e22e>isEmpty</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>mapLNsCopy</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>mapLNsCopy</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>HashSet</color><color=#f92672><></color><color=#f8f8f2>(</color><color=#f8f8f2>mapLNsToFlush</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>mapLNsToFlush</color><color=#f8f8f2>.</color><color=#a6e22e>clear</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mapLNsCopy</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>

      <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>DatabaseId</color> <color=#f8f8f2>dbId</color> <color=#f8f8f2>:</color> <color=#f8f8f2>mapLNsCopy</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>checkDiskLimitViolation</color><color=#f8f8f2>();</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f92672>=</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>dbId</color><color=#f8f8f2>);</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>db</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isDeleted</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>isCheckpointNeeded</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

            <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>modifyDbRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>,</color> <color=#f8f8f2>checkpointStart</color> <color=#75715e>/*ifBeforeLsn*/</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color> <color=#75715e>/*mustExist*/</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>releaseDb</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Flushes the DB mapping tree root at the end of the checkpoint, if either mapping DB is dirty</color>
<color=#75715e>   * and the root was not flushed previously during the checkpoint.</color>
<color=#75715e>   *</color>
<color=#75715e>   * <p>This method is not synchronized because it does not access internal state. Also, it takes</color>
<color=#75715e>   * the DbTree root latch and although this latch should never be held by eviction, for consistency</color>
<color=#75715e>   * we should not latch something related to the Btree after synchronizing on DirtyINMap; see class</color>
<color=#75715e>   * comments.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param checkpointStart start LSN of the checkpoint in progress. To reduce unnecessary logging,</color>
<color=#75715e>   *     the Root is only flushed if it has not been written since that LSN.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>void</color> <color=#a6e22e>flushRoot</color><color=#f8f8f2>(</color><color=#66d9ef>long</color> <color=#f8f8f2>checkpointStart</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>DbTree</color> <color=#f8f8f2>dbTree</color> <color=#f92672>=</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getDbTree</color><color=#f8f8f2>();</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>DbTree</color><color=#f8f8f2>.</color><color=#a6e22e>ID_DB_ID</color><color=#f8f8f2>).</color><color=#a6e22e>isCheckpointNeeded</color><color=#f8f8f2>()</color>
        <color=#f92672>||</color> <color=#f8f8f2>dbTree</color><color=#f8f8f2>.</color><color=#a6e22e>getDb</color><color=#f8f8f2>(</color><color=#f8f8f2>DbTree</color><color=#f8f8f2>.</color><color=#a6e22e>NAME_DB_ID</color><color=#f8f8f2>).</color><color=#a6e22e>isCheckpointNeeded</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>logMapTreeRoot</color><color=#f8f8f2>(</color><color=#f8f8f2>checkpointStart</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>synchronized</color> <color=#66d9ef>int</color> <color=#a6e22e>getNumEntries</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>numEntries</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>traceDirtySet</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>assert</color> <color=#f8f8f2>DIRTY_SET_DEBUG_TRACE</color><color=#f8f8f2>;</color>

    <color=#66d9ef>final</color> <color=#f8f8f2>StringBuilder</color> <color=#f8f8f2>sb</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>StringBuilder</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"Ckpt dirty set"</color><color=#f8f8f2>);</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Integer</color> <color=#f8f8f2>level</color> <color=#f8f8f2>:</color> <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>keySet</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Pair</color><color=#f92672><</color><color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color><color=#f8f8f2>,</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>>></color> <color=#f8f8f2>pairOfMaps</color> <color=#f92672>=</color>
          <color=#f8f8f2>levelMap</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>);</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color> <color=#f8f8f2>lsnMap</color> <color=#f92672>=</color> <color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>first</color><color=#f8f8f2>();</color>

      <color=#66d9ef>final</color> <color=#f8f8f2>Map</color><color=#f92672><</color><color=#f8f8f2>Long</color><color=#f8f8f2>,</color> <color=#f8f8f2>CheckpointReference</color><color=#f92672>></color> <color=#f8f8f2>nodeMap</color> <color=#f92672>=</color> <color=#f8f8f2>pairOfMaps</color><color=#f8f8f2>.</color><color=#a6e22e>second</color><color=#f8f8f2>();</color>

      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\nlevel = 0x"</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>Integer</color><color=#f8f8f2>.</color><color=#a6e22e>toHexString</color><color=#f8f8f2>(</color><color=#f8f8f2>level</color><color=#f8f8f2>));</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" lsnMap = "</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>lsnMap</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>());</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>" nodeMap = "</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>nodeMap</color><color=#f8f8f2>.</color><color=#a6e22e>size</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>"\ndbId:highestFlushLevel"</color><color=#f8f8f2>);</color>

    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>DatabaseImpl</color> <color=#f8f8f2>db</color> <color=#f8f8f2>:</color> <color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>keySet</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>' '</color><color=#f8f8f2>).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>.</color><color=#a6e22e>getId</color><color=#f8f8f2>()).</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#e6db74>':'</color><color=#f8f8f2>);</color>
      <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>append</color><color=#f8f8f2>(</color><color=#f8f8f2>highestFlushLevels</color><color=#f8f8f2>.</color><color=#a6e22e>get</color><color=#f8f8f2>(</color><color=#f8f8f2>db</color><color=#f8f8f2>)</color> <color=#f92672>&</color> <color=#f8f8f2>IN</color><color=#f8f8f2>.</color><color=#a6e22e>LEVEL_MASK</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#f8f8f2>LoggerUtils</color><color=#f8f8f2>.</color><color=#a6e22e>logMsg</color><color=#f8f8f2>(</color><color=#f8f8f2>envImpl</color><color=#f8f8f2>.</color><color=#a6e22e>getLogger</color><color=#f8f8f2>(),</color> <color=#f8f8f2>envImpl</color><color=#f8f8f2>,</color> <color=#f8f8f2>Level</color><color=#f8f8f2>.</color><color=#a6e22e>INFO</color><color=#f8f8f2>,</color> <color=#f8f8f2>sb</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>