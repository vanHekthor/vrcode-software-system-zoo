<color=#75715e>/*-</color>
<color=#75715e> * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * This file was distributed by Oracle as part of a version of Oracle Berkeley</color>
<color=#75715e> * DB Java Edition made available at:</color>
<color=#75715e> *</color>
<color=#75715e> * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html</color>
<color=#75715e> *</color>
<color=#75715e> * Please see the LICENSE file included in the top-level directory of the</color>
<color=#75715e> * appropriate version of Oracle Berkeley DB Java Edition for a copy of the</color>
<color=#75715e> * license and additional information.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.sleepycat.je.rep.utilint.net</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.net.InstanceLogger</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>com.sleepycat.je.rep.net.SSLAuthenticator</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>javax.net.ssl.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.io.IOException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.net.SocketException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.nio.BufferOverflowException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.nio.BufferUnderflowException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.nio.ByteBuffer</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.nio.channels.SocketChannel</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.concurrent.locks.ReentrantLock</color><color=#f8f8f2>;</color>

<color=#f92672>import static</color> <color=#f8f8f2>java.util.logging.Level.FINE</color><color=#f8f8f2>;</color>
<color=#f92672>import static</color> <color=#f8f8f2>java.util.logging.Level.INFO</color><color=#f8f8f2>;</color>
<color=#f92672>import static</color> <color=#f8f8f2>javax.net.ssl.SSLEngineResult.HandshakeStatus</color><color=#f8f8f2>;</color>
<color=#f92672>import static</color> <color=#f8f8f2>javax.net.ssl.SSLEngineResult.Status</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * SSLDataChannel provides SSL-based communications on top of a SocketChannel. We attempt to</color>
<color=#75715e> * maintain a degree of compatibility with SocketChannel in terms of request completion semantics.</color>
<color=#75715e> * In particular, If in blocking mode: read() will return at least one byte if the buffer has room</color>
<color=#75715e> * write() will write the entire buffer If in non-blocking mode: read() and write are not guaranteed</color>
<color=#75715e> * to consume or produce anything.</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>SSLDataChannel</color> <color=#66d9ef>extends</color> <color=#f8f8f2>AbstractDataChannel</color> <color=#f8f8f2>{</color>
  <color=#75715e>/** The SSLEngine that will manage the secure operations. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>SSLEngine</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>;</color>

  <color=#75715e>/** raw bytes received from the SocketChannel - not yet unwrapped. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>;</color>

  <color=#75715e>/** raw bytes to be sent to the wire - already wrapped */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>netXmitBuffer</color><color=#f8f8f2>;</color>

  <color=#75715e>/** Bytes unwrapped and ready for application consumption. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>;</color>

  <color=#75715e>/** A dummy buffer used during handshake operations. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>emptyXmitBuffer</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Lock object for protection of appRecvBuffer, netRecvBuffer and SSLEngine unwrap() operations</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ReentrantLock</color> <color=#f8f8f2>readLock</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ReentrantLock</color><color=#f8f8f2>();</color>

  <color=#75715e>/** Lock object for protection of netXmitBuffer and SSLEngine wrap() operations */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>ReentrantLock</color> <color=#f8f8f2>writeLock</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ReentrantLock</color><color=#f8f8f2>();</color>

  <color=#75715e>/* Set to true if we have closed the underlying socketChannel */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>channelClosed</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Remember whether we did a closeInbound already.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>sslInboundClosed</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * The String identifying the target host that we are connecting to, if this channel was created</color>
<color=#75715e>   * in client context.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>targetHost</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Possibly null authenticator object used for checking whether the peer for the negotiated</color>
<color=#75715e>   * session should be trusted.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>SSLAuthenticator</color> <color=#f8f8f2>authenticator</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Possibly null host verifier object used for checking whether the peer for the negotiated</color>
<color=#75715e>   * session is correct based on the connection target.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>HostnameVerifier</color> <color=#f8f8f2>hostVerifier</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Set to true when a handshake completes and a non-null authenticator acknowledges the session as</color>
<color=#75715e>   * trusted.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>volatile</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>peerTrusted</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

  <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#f8f8f2>InstanceLogger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>;</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Construct an SSLDataChannel given a SocketChannel and an SSLEngine</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param socketChannel a SocketChannel over which SSL communcation will occur. This should</color>
<color=#75715e>   *     generally be connected, but that is not absolutely required until the first read/write</color>
<color=#75715e>   *     operation.</color>
<color=#75715e>   * @param sslEngine an SSLEngine instance that will control the SSL interaction with the peer.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>public</color> <color=#a6e22e>SSLDataChannel</color><color=#f8f8f2>(</color>
      <color=#f8f8f2>SocketChannel</color> <color=#f8f8f2>socketChannel</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>SSLEngine</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>String</color> <color=#f8f8f2>targetHost</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>HostnameVerifier</color> <color=#f8f8f2>hostVerifier</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>SSLAuthenticator</color> <color=#f8f8f2>authenticator</color><color=#f8f8f2>,</color>
      <color=#f8f8f2>InstanceLogger</color> <color=#f8f8f2>logger</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>super</color><color=#f8f8f2>(</color><color=#f8f8f2>socketChannel</color><color=#f8f8f2>);</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>sslEngine</color> <color=#f92672>=</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>targetHost</color> <color=#f92672>=</color> <color=#f8f8f2>targetHost</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>authenticator</color> <color=#f92672>=</color> <color=#f8f8f2>authenticator</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>hostVerifier</color> <color=#f92672>=</color> <color=#f8f8f2>hostVerifier</color><color=#f8f8f2>;</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>logger</color> <color=#f92672>=</color> <color=#f8f8f2>logger</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>SSLSession</color> <color=#f8f8f2>sslSession</color> <color=#f92672>=</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>getSession</color><color=#f8f8f2>();</color>

    <color=#75715e>/* Determine the required buffer sizes */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>netBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>sslSession</color><color=#f8f8f2>.</color><color=#a6e22e>getPacketBufferSize</color><color=#f8f8f2>();</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>appBufferSize</color> <color=#f92672>=</color> <color=#f8f8f2>sslSession</color><color=#f8f8f2>.</color><color=#a6e22e>getApplicationBufferSize</color><color=#f8f8f2>();</color>

    <color=#75715e>/* allocate the buffers */</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>emptyXmitBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>allocate</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>netXmitBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>allocate</color><color=#f8f8f2>(</color><color=#ae81ff>3</color> <color=#f92672>*</color> <color=#f8f8f2>netBufferSize</color><color=#f8f8f2>);</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>appRecvBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>allocate</color><color=#f8f8f2>(</color><color=#ae81ff>2</color> <color=#f92672>*</color> <color=#f8f8f2>appBufferSize</color><color=#f8f8f2>);</color>
    <color=#66d9ef>this</color><color=#f8f8f2>.</color><color=#a6e22e>netRecvBuffer</color> <color=#f92672>=</color> <color=#f8f8f2>ByteBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>allocate</color><color=#f8f8f2>(</color><color=#ae81ff>2</color> <color=#f92672>*</color> <color=#f8f8f2>netBufferSize</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Is the channel encrypted?</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if the channel is encrypted</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isSecure</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Is the channel capable of determining peer trust? In this case, we are capable only if the</color>
<color=#75715e>   * application has configured an SSL authenticator</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if this data channel is capable of determining trust</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isTrustCapable</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>authenticator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Is the channel peer trusted? A channel is trusted if the peer should be treated as</color>
<color=#75715e>   * authenticated. The meaning of this is context dependent. The channel will only be trusted if</color>
<color=#75715e>   * the configured peer authenticator says it should be trusted, so the creator of this</color>
<color=#75715e>   * SSLDataChannel knows what "trusted" means.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if the SSL peer should be trusted</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isTrusted</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>peerTrusted</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Read data into the toFill data buffer.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param toFill the data buffer into which data will be read. This buffer is expected to be ready</color>
<color=#75715e>   *     for a put. It need not be empty.</color>
<color=#75715e>   * @return the count of bytes read into toFill.</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>read</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>toFill</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>read</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>ByteBuffer</color><color=#f92672>[]</color> <color=#f8f8f2>{</color><color=#f8f8f2>toFill</color><color=#f8f8f2>},</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>read</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color><color=#f92672>[]</color> <color=#f8f8f2>toFill</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>read</color><color=#f8f8f2>(</color><color=#f8f8f2>toFill</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>toFill</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>read</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color><color=#f92672>[]</color> <color=#f8f8f2>toFill</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>length</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>offset</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>length</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>offset</color> <color=#f92672>></color> <color=#f8f8f2>toFill</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>-</color> <color=#f8f8f2>length</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IndexOutOfBoundsException</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Short-circuit if there's no work to be done at this time.  This</color>
<color=#75715e>     * avoids an unnecessary read() operation from blocking.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>toFillRemaining</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>offset</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#f8f8f2>length</color><color=#f8f8f2>;</color> <color=#f92672>++</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>toFillRemaining</color> <color=#f92672>+=</color> <color=#f8f8f2>toFill</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>toFillRemaining</color> <color=#f92672><=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * In non-blocking mode, a preceding write operation might not have</color>
<color=#75715e>     * completed.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>socketChannel</color><color=#f8f8f2>.</color><color=#a6e22e>isBlocking</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>flush_internal</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If we have data that is already unwrapped and ready to transfer, do</color>
<color=#75715e>     * it now</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>readLock</color><color=#f8f8f2>.</color><color=#a6e22e>lock</color><color=#f8f8f2>();</color>
    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>count</color> <color=#f92672>=</color> <color=#f8f8f2>transfer</color><color=#f8f8f2>(</color><color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>toFill</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#f8f8f2>length</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>compact</color><color=#f8f8f2>();</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>count</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>readLock</color><color=#f8f8f2>.</color><color=#a6e22e>unlock</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>readCount</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>readCount</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>isInboundDone</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>processAnyHandshakes</color><color=#f8f8f2>();</color>

      <color=#75715e>/* See if we have unwrapped data available */</color>
      <color=#f8f8f2>readLock</color><color=#f8f8f2>.</color><color=#a6e22e>lock</color><color=#f8f8f2>();</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>readCount</color> <color=#f92672>=</color> <color=#f8f8f2>transfer</color><color=#f8f8f2>(</color><color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>toFill</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#f8f8f2>length</color><color=#f8f8f2>);</color>
          <color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>compact</color><color=#f8f8f2>();</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>readLock</color><color=#f8f8f2>.</color><color=#a6e22e>unlock</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>getHandshakeStatus</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>HandshakeStatus</color><color=#f8f8f2>.</color><color=#a6e22e>NOT_HANDSHAKING</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

        <color=#66d9ef>boolean</color> <color=#f8f8f2>progress</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>readLock</color><color=#f8f8f2>.</color><color=#a6e22e>lock</color><color=#f8f8f2>();</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>/* There is some data in the network buffer that may be</color>
<color=#75715e>             * able to be unwrapped.  If so, we'll try to unwrap it.</color>
<color=#75715e>             * If that fails, then we may need more network data.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>initialPos</color> <color=#f92672>=</color> <color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>
            <color=#66d9ef>final</color> <color=#f8f8f2>SSLEngineResult</color> <color=#f8f8f2>engineResult</color> <color=#f92672>=</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>unwrap</color><color=#f8f8f2>(</color><color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>compact</color><color=#f8f8f2>();</color>

            <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>updatedPos</color> <color=#f92672>=</color> <color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>();</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>updatedPos</color> <color=#f92672>!=</color> <color=#f8f8f2>initialPos</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#75715e>/* We did something */</color>
              <color=#f8f8f2>progress</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>

            <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>engineResult</color><color=#f8f8f2>.</color><color=#a6e22e>getStatus</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
              <color=#66d9ef>case</color> <color=#f8f8f2>BUFFER_UNDERFLOW</color><color=#f8f8f2>:</color>
                <color=#75715e>/* Not enough data to do anything useful. */</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>

              <color=#66d9ef>case</color> <color=#f8f8f2>BUFFER_OVERFLOW</color><color=#f8f8f2>:</color>
                <color=#75715e>/* Shouldn't happen, but apparently there's not</color>
<color=#75715e>                 * enough space in the application receive buffer */</color>
                <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferOverflowException</color><color=#f8f8f2>();</color>

              <color=#66d9ef>case</color> <color=#f8f8f2>CLOSED</color><color=#f8f8f2>:</color>
                <color=#75715e>/* We apparently got a CLOSE_NOTIFY */</color>
                <color=#f8f8f2>socketChannel</color><color=#f8f8f2>.</color><color=#a6e22e>socket</color><color=#f8f8f2>().</color><color=#a6e22e>shutdownInput</color><color=#f8f8f2>();</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>

              <color=#66d9ef>case</color> <color=#f8f8f2>OK</color><color=#f8f8f2>:</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>

          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>progress</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>count</color> <color=#f92672>=</color> <color=#f8f8f2>socketChannel</color><color=#f8f8f2>.</color><color=#a6e22e>read</color><color=#f8f8f2>(</color><color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>);</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>count</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>readCount</color> <color=#f92672>=</color> <color=#f8f8f2>count</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>count</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#75715e>/* Presumably we are in non-blocking mode */</color>
              <color=#66d9ef>break</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>readLock</color><color=#f8f8f2>.</color><color=#a6e22e>unlock</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>readCount</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#75715e>/*</color>
<color=#75715e>       * This will throw an SSLException if we haven't yet received a</color>
<color=#75715e>       * close_notify.</color>
<color=#75715e>       */</color>
      <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>closeInbound</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>sslInboundClosed</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>isInboundDone</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>readCount</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>int</color> <color=#a6e22e>write</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>toSend</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>write</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>ByteBuffer</color><color=#f92672>[]</color> <color=#f8f8f2>{</color><color=#f8f8f2>toSend</color><color=#f8f8f2>},</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>write</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color><color=#f92672>[]</color> <color=#f8f8f2>toSend</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>write</color><color=#f8f8f2>(</color><color=#f8f8f2>toSend</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>toSend</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>long</color> <color=#a6e22e>write</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color><color=#f92672>[]</color> <color=#f8f8f2>toSend</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>length</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>offset</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>length</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>offset</color> <color=#f92672>></color> <color=#f8f8f2>toSend</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>-</color> <color=#f8f8f2>length</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IndexOutOfBoundsException</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>toSendRemaining</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>offset</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#f8f8f2>length</color><color=#f8f8f2>;</color> <color=#f92672>++</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>toSendRemaining</color> <color=#f92672>+=</color> <color=#f8f8f2>toSend</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>toSendRemaining</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>toSendTotal</color> <color=#f92672>=</color> <color=#f8f8f2>toSendRemaining</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Probably not needed, but just in case there's a backlog, start with</color>
<color=#75715e>     * a flush to clear out the network transmit buffer.</color>
<color=#75715e>     */</color>
    <color=#f8f8f2>flush_internal</color><color=#f8f8f2>();</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#66d9ef>true</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>writeLock</color><color=#f8f8f2>.</color><color=#a6e22e>lock</color><color=#f8f8f2>();</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>SSLEngineResult</color> <color=#f8f8f2>engineResult</color> <color=#f92672>=</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>wrap</color><color=#f8f8f2>(</color><color=#f8f8f2>toSend</color><color=#f8f8f2>,</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#f8f8f2>length</color><color=#f8f8f2>,</color> <color=#f8f8f2>netXmitBuffer</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>toSendRemaining</color> <color=#f92672>-=</color> <color=#f8f8f2>engineResult</color><color=#f8f8f2>.</color><color=#a6e22e>bytesConsumed</color><color=#f8f8f2>();</color>

        <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>engineResult</color><color=#f8f8f2>.</color><color=#a6e22e>getStatus</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>case</color> <color=#f8f8f2>BUFFER_OVERFLOW</color><color=#f8f8f2>:</color>
            <color=#75715e>/*</color>
<color=#75715e>             * Although we are flushing as part of the loop, we can</color>
<color=#75715e>             * still receive this because flush_internal isn't</color>
<color=#75715e>             * guaranteed to flush everything.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>

          <color=#66d9ef>case</color> <color=#f8f8f2>BUFFER_UNDERFLOW</color><color=#f8f8f2>:</color>
            <color=#75715e>/* Should not be possible here */</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferUnderflowException</color><color=#f8f8f2>();</color>

          <color=#66d9ef>case</color> <color=#f8f8f2>CLOSED</color><color=#f8f8f2>:</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>SSLException</color><color=#f8f8f2>(</color><color=#e6db74>"Attempt to write to a closed SSL Channel"</color><color=#f8f8f2>);</color>

          <color=#66d9ef>case</color> <color=#f8f8f2>OK</color><color=#f8f8f2>:</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>writeLock</color><color=#f8f8f2>.</color><color=#a6e22e>unlock</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>

      <color=#f8f8f2>processAnyHandshakes</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>flush_internal</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>toSendRemaining</color> <color=#f92672>==</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>socketChannel</color><color=#f8f8f2>.</color><color=#a6e22e>isBlocking</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>return</color> <color=#f8f8f2>toSendTotal</color> <color=#f92672>-</color> <color=#f8f8f2>toSendRemaining</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Attempt to flush any pending writes to the underlying socket buffer. The caller should ensure</color>
<color=#75715e>   * that it is the only thread accessing the DataChannel in order that the return value be</color>
<color=#75715e>   * meaningful.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return flush status</color>
<color=#75715e>   */</color>
  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#f8f8f2>FlushStatus</color> <color=#a6e22e>flush</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#f8f8f2>flush_internal</color><color=#f8f8f2>();</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>writeLock</color><color=#f8f8f2>.</color><color=#a6e22e>tryLock</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>HandshakeStatus</color> <color=#f8f8f2>hstatus</color> <color=#f92672>=</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>getHandshakeStatus</color><color=#f8f8f2>();</color>
        <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>hstatus</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>case</color> <color=#f8f8f2>NEED_TASK</color><color=#f8f8f2>:</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>FlushStatus</color><color=#f8f8f2>.</color><color=#a6e22e>NEED_TASK</color><color=#f8f8f2>;</color>
          <color=#66d9ef>case</color> <color=#f8f8f2>NEED_UNWRAP</color><color=#f8f8f2>:</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>FlushStatus</color><color=#f8f8f2>.</color><color=#a6e22e>NEED_READ</color><color=#f8f8f2>;</color>
          <color=#66d9ef>case</color> <color=#f8f8f2>NEED_WRAP</color><color=#f8f8f2>:</color>
            <color=#75715e>/*</color>
<color=#75715e>             * We should not be here if we are the only thread doing</color>
<color=#75715e>             * handshake, so there must be another thread, they will</color>
<color=#75715e>             * flush after they wrap, our job is done here.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>FlushStatus</color><color=#f8f8f2>.</color><color=#a6e22e>DONE</color><color=#f8f8f2>;</color>
          <color=#66d9ef>case</color> <color=#f8f8f2>FINISHED</color><color=#f8f8f2>:</color>
          <color=#66d9ef>case</color> <color=#f8f8f2>NOT_HANDSHAKING</color><color=#f8f8f2>:</color>
            <color=#66d9ef>break</color><color=#f8f8f2>;</color>
          <color=#66d9ef>default</color><color=#f8f8f2>:</color>
            <color=#66d9ef>assert</color> <color=#66d9ef>false</color> <color=#f8f8f2>:</color> <color=#e6db74>"Unexpected handshake status."</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * It is possible that there was nothing to flush last time</color>
<color=#75715e>           * we flushed but someone wrote something before we</color>
<color=#75715e>           * acquired the lock, so we flush again here</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>n</color> <color=#f92672>=</color> <color=#f8f8f2>flush_internal</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>pos</color> <color=#f92672>=</color> <color=#f8f8f2>netXmitBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pos</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>FlushStatus</color><color=#f8f8f2>.</color><color=#a6e22e>DONE</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>n</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>FlushStatus</color><color=#f8f8f2>.</color><color=#a6e22e>AGAIN</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>/* Here n == 0 and pos != 0, i.e., socket write busy. */</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>FlushStatus</color><color=#f8f8f2>.</color><color=#a6e22e>WRITE_BUSY</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>writeLock</color><color=#f8f8f2>.</color><color=#a6e22e>unlock</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * If we weren't able to acquire the write lock, we can't be sure that</color>
<color=#75715e>     * everything has been flushed, and there's a good chance that someone</color>
<color=#75715e>     * else is writing (which the caller should have protected against in</color>
<color=#75715e>     * order to get a reliable answer). Just ask the caller to flush again.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>FlushStatus</color><color=#f8f8f2>.</color><color=#a6e22e>AGAIN</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** If any data is queued up to be sent in the network transmit buffer, try to push it out. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>flush_internal</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>count</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Don't insist on getting a lock.  If someone else has it, they will</color>
<color=#75715e>     * probably flush it for us.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>writeLock</color><color=#f8f8f2>.</color><color=#a6e22e>tryLock</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>netXmitBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>return</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>netXmitBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * try/finally to keep things clean, in case the socket channel</color>
<color=#75715e>         * gets closed</color>
<color=#75715e>         */</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>count</color> <color=#f92672>=</color> <color=#f8f8f2>socketChannel</color><color=#f8f8f2>.</color><color=#a6e22e>write</color><color=#f8f8f2>(</color><color=#f8f8f2>netXmitBuffer</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>netXmitBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>compact</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>writeLock</color><color=#f8f8f2>.</color><color=#a6e22e>unlock</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>count</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>void</color> <color=#a6e22e>close</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>flush_internal</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>isOutboundDone</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>closeOutbound</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>processAnyHandshakes</color><color=#f8f8f2>();</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>isInboundDone</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>sslInboundClosed</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * We only expect one handshake operation (the close) to</color>
<color=#75715e>           * happen at this point</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>processOneHandshake</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>synchronized</color> <color=#f8f8f2>(</color><color=#66d9ef>this</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>channelClosed</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>channelClosed</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
          <color=#f8f8f2>socketChannel</color><color=#f8f8f2>.</color><color=#a6e22e>close</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#a6e22e>@Override</color>
  <color=#66d9ef>public</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isOpen</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>socketChannel</color><color=#f8f8f2>.</color><color=#a6e22e>isOpen</color><color=#f8f8f2>();</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/**</color>
<color=#75715e>   * Transfer as much data as possible from the src buffer to the dst buffers.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @param src the source ByteBuffer - it is expected to be ready for a get.</color>
<color=#75715e>   * @param dsts the destination array of ByteBuffers, each of which is expected to be ready for a</color>
<color=#75715e>   *     put.</color>
<color=#75715e>   * @param offset the offset within the buffer array of the first buffer into which bytes are to be</color>
<color=#75715e>   *     transferred.</color>
<color=#75715e>   * @param length the maximum number of buffers to be accessed</color>
<color=#75715e>   * @return The number of bytes transfered from src to dst</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>int</color> <color=#a6e22e>transfer</color><color=#f8f8f2>(</color><color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>ByteBuffer</color><color=#f92672>[]</color> <color=#f8f8f2>dsts</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>offset</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>length</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>transferred</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>offset</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>offset</color> <color=#f92672>+</color> <color=#f8f8f2>length</color><color=#f8f8f2>;</color> <color=#f92672>++</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>dst</color> <color=#f92672>=</color> <color=#f8f8f2>dsts</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>;</color>
      <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>space</color> <color=#f92672>=</color> <color=#f8f8f2>dst</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>();</color>

      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#f8f8f2>space</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/* not enough room for it all */</color>
        <color=#66d9ef>final</color> <color=#f8f8f2>ByteBuffer</color> <color=#f8f8f2>slice</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>slice</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>slice</color><color=#f8f8f2>.</color><color=#a6e22e>limit</color><color=#f8f8f2>(</color><color=#f8f8f2>space</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>dst</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>slice</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#f8f8f2>space</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>transferred</color> <color=#f92672>+=</color> <color=#f8f8f2>space</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>transferred</color> <color=#f92672>+=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>remaining</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>dst</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>);</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>
    <color=#66d9ef>return</color> <color=#f8f8f2>transferred</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/** Repeatedly perform handshake operations while there is still more work to do. */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>processAnyHandshakes</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>processOneHandshake</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#75715e>/* do nothing */</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>

  <color=#75715e>/*</color>
<color=#75715e>   * Attempt a handshake step.</color>
<color=#75715e>   *</color>
<color=#75715e>   * @return true if it is appropriate to call this again immediately.</color>
<color=#75715e>   */</color>
  <color=#66d9ef>private</color> <color=#66d9ef>boolean</color> <color=#a6e22e>processOneHandshake</color><color=#f8f8f2>()</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IOException</color> <color=#f8f8f2>{</color>

    <color=#66d9ef>int</color> <color=#f8f8f2>readCount</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#66d9ef>int</color> <color=#f8f8f2>flushCount</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>SSLEngineResult</color> <color=#f8f8f2>engineResult</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

    <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>getHandshakeStatus</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>case</color> <color=#f8f8f2>FINISHED</color><color=#f8f8f2>:</color>
        <color=#75715e>/*</color>
<color=#75715e>         * Just finished handshaking. We shouldn't actually see this here</color>
<color=#75715e>         * as it is only supposed to be produced by a wrap or unwrap.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

      <color=#66d9ef>case</color> <color=#f8f8f2>NEED_TASK</color><color=#f8f8f2>:</color>
        <color=#75715e>/*</color>
<color=#75715e>         * Need results from delegated tasks before handshaking can</color>
<color=#75715e>         * continue, so do them now.  We assume that the tasks are done</color>
<color=#75715e>         * inline, and so we can return true here.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>runDelegatedTasks</color><color=#f8f8f2>();</color>
        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

      <color=#66d9ef>case</color> <color=#f8f8f2>NEED_UNWRAP</color><color=#f8f8f2>:</color>
        <color=#f8f8f2>{</color>
          <color=#66d9ef>boolean</color> <color=#f8f8f2>unwrapped</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

          <color=#75715e>/* Attempt to flush anything that is pending */</color>
          <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>flush_internal</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>SocketException</color> <color=#f8f8f2>se</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>}</color>

          <color=#75715e>/*</color>
<color=#75715e>           * Attempt to process anything that is pending in the</color>
<color=#75715e>           * netRecvBuffer.</color>
<color=#75715e>           */</color>
          <color=#f8f8f2>readLock</color><color=#f8f8f2>.</color><color=#a6e22e>lock</color><color=#f8f8f2>();</color>
          <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>position</color><color=#f8f8f2>()</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>
              <color=#f8f8f2>engineResult</color> <color=#f92672>=</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>unwrap</color><color=#f8f8f2>(</color><color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>);</color>
              <color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>compact</color><color=#f8f8f2>();</color>
              <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>engineResult</color><color=#f8f8f2>.</color><color=#a6e22e>getStatus</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>Status</color><color=#f8f8f2>.</color><color=#a6e22e>OK</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>unwrapped</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
              <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>unwrapped</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>isInboundDone</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
              <color=#75715e>/*</color>
<color=#75715e>               * Either we had nothing in the netRecvBuffer or there</color>
<color=#75715e>               * was not enough data to unwrap, so let's try getting</color>
<color=#75715e>               * some more.</color>
<color=#75715e>               *</color>
<color=#75715e>               * If a re-negotiation is happening and the</color>
<color=#75715e>               * appRecvBuffer was full, we could have received a</color>
<color=#75715e>               * BUFFER_OVERFLOW engineResult, in which case a read()</color>
<color=#75715e>               * is not really helpful here, but it's harmless and is</color>
<color=#75715e>               * a rare occurrence, so we won't worry about it.</color>
<color=#75715e>               */</color>
              <color=#f8f8f2>readCount</color> <color=#f92672>=</color> <color=#f8f8f2>socketChannel</color><color=#f8f8f2>.</color><color=#a6e22e>read</color><color=#f8f8f2>(</color><color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>);</color>
              <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>readCount</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
                  <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>closeInbound</color><color=#f8f8f2>();</color>
                  <color=#f8f8f2>sslInboundClosed</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
                <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>SSLException</color> <color=#f8f8f2>ssle</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                  <color=#75715e>// ignore</color>
                <color=#f8f8f2>}</color>
              <color=#f8f8f2>}</color>

              <color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>flip</color><color=#f8f8f2>();</color>
              <color=#f8f8f2>engineResult</color> <color=#f92672>=</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>unwrap</color><color=#f8f8f2>(</color><color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>appRecvBuffer</color><color=#f8f8f2>);</color>
              <color=#f8f8f2>netRecvBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>compact</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>readLock</color><color=#f8f8f2>.</color><color=#a6e22e>unlock</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>break</color><color=#f8f8f2>;</color>

      <color=#66d9ef>case</color> <color=#f8f8f2>NEED_WRAP</color><color=#f8f8f2>:</color>
        <color=#75715e>/*</color>
<color=#75715e>         * Must send data to the remote side before handshaking can</color>
<color=#75715e>         * continue, so wrap() must be called.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>writeLock</color><color=#f8f8f2>.</color><color=#a6e22e>lock</color><color=#f8f8f2>();</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>engineResult</color> <color=#f92672>=</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>wrap</color><color=#f8f8f2>(</color><color=#f8f8f2>emptyXmitBuffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>netXmitBuffer</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>writeLock</color><color=#f8f8f2>.</color><color=#a6e22e>unlock</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>engineResult</color><color=#f8f8f2>.</color><color=#a6e22e>getStatus</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>Status</color><color=#f8f8f2>.</color><color=#a6e22e>CLOSED</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#75715e>/*</color>
<color=#75715e>           * If the engine is already closed, flush may fail, and that's</color>
<color=#75715e>           * ok, so squash any exceptions that happen</color>
<color=#75715e>           */</color>
          <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#75715e>/* ignore the flush count */</color>
            <color=#f8f8f2>flush_internal</color><color=#f8f8f2>();</color>
          <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>SocketException</color> <color=#f8f8f2>se</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#f8f8f2>flushCount</color> <color=#f92672>=</color> <color=#f8f8f2>flush_internal</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>break</color><color=#f8f8f2>;</color>

      <color=#66d9ef>case</color> <color=#f8f8f2>NOT_HANDSHAKING</color><color=#f8f8f2>:</color>
        <color=#75715e>/* Not currently handshaking */</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * We may have done a wrap or unwrap above.  Check the engineResult</color>
<color=#75715e>     */</color>

    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>engineResult</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>engineResult</color><color=#f8f8f2>.</color><color=#a6e22e>getHandshakeStatus</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>HandshakeStatus</color><color=#f8f8f2>.</color><color=#a6e22e>FINISHED</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>/*</color>
<color=#75715e>         * Handshaking just completed.   Here is our chance to do any</color>
<color=#75715e>         * session validation that might be required.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>getUseClientMode</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>hostVerifier</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>peerTrusted</color> <color=#f92672>=</color> <color=#f8f8f2>hostVerifier</color><color=#f8f8f2>.</color><color=#a6e22e>verify</color><color=#f8f8f2>(</color><color=#f8f8f2>targetHost</color><color=#f8f8f2>,</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>getSession</color><color=#f8f8f2>());</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>peerTrusted</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>log</color><color=#f8f8f2>(</color><color=#f8f8f2>FINE</color><color=#f8f8f2>,</color> <color=#e6db74>"SSL host verifier reports that "</color> <color=#f92672>+</color> <color=#e6db74>"connection target is valid"</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>log</color><color=#f8f8f2>(</color>
                  <color=#f8f8f2>INFO</color><color=#f8f8f2>,</color> <color=#e6db74>"SSL host verifier reports that "</color> <color=#f92672>+</color> <color=#e6db74>"connection target is NOT valid"</color><color=#f8f8f2>);</color>
              <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IOException</color><color=#f8f8f2>(</color><color=#e6db74>"Server identity could not be verified"</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>authenticator</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>peerTrusted</color> <color=#f92672>=</color> <color=#f8f8f2>authenticator</color><color=#f8f8f2>.</color><color=#a6e22e>isTrusted</color><color=#f8f8f2>(</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>getSession</color><color=#f8f8f2>());</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>peerTrusted</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>log</color><color=#f8f8f2>(</color><color=#f8f8f2>FINE</color><color=#f8f8f2>,</color> <color=#e6db74>"SSL authenticator reports that "</color> <color=#f92672>+</color> <color=#e6db74>"channel is trusted"</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>logger</color><color=#f8f8f2>.</color><color=#a6e22e>log</color><color=#f8f8f2>(</color><color=#f8f8f2>INFO</color><color=#f8f8f2>,</color> <color=#e6db74>"SSL authenticator reports that "</color> <color=#f92672>+</color> <color=#e6db74>"channel is NOT trusted"</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
      <color=#f8f8f2>}</color>

      <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>engineResult</color><color=#f8f8f2>.</color><color=#a6e22e>getStatus</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>case</color> <color=#f8f8f2>BUFFER_UNDERFLOW</color><color=#f8f8f2>:</color>
          <color=#75715e>/*</color>
<color=#75715e>           * This must have resulted from an unwrap, meaning we need to</color>
<color=#75715e>           * do another read.  If the last read did something useful,</color>
<color=#75715e>           * tell the caller to call us again.</color>
<color=#75715e>           */</color>
          <color=#66d9ef>return</color> <color=#f8f8f2>readCount</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

        <color=#66d9ef>case</color> <color=#f8f8f2>BUFFER_OVERFLOW</color><color=#f8f8f2>:</color>
          <color=#75715e>/*</color>
<color=#75715e>           * Either we were processing an unwrap and the appRecvBuffer is</color>
<color=#75715e>           * full or we were processing a wrap and the netXmitBuffer is</color>
<color=#75715e>           * full.  For the unwrap case, the only way we can make progress</color>
<color=#75715e>           * is for the application to receive control.  For the wrap</color>
<color=#75715e>           * case, we may be able to make progress if the flush</color>
<color=#75715e>           * did something useful.</color>
<color=#75715e>           */</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>getHandshakeStatus</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>HandshakeStatus</color><color=#f8f8f2>.</color><color=#a6e22e>NEED_WRAP</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>flushCount</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>

          <color=#66d9ef>case</color> <color=#f8f8f2>CLOSED</color><color=#f8f8f2>:</color>
          <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>isOutboundDone</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
              <color=#f8f8f2>socketChannel</color><color=#f8f8f2>.</color><color=#a6e22e>socket</color><color=#f8f8f2>().</color><color=#a6e22e>shutdownOutput</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>Exception</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>}</color>
          <color=#f8f8f2>}</color>
          <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

        <color=#66d9ef>case</color> <color=#f8f8f2>OK</color><color=#f8f8f2>:</color>
          <color=#66d9ef>break</color><color=#f8f8f2>;</color>
      <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>     * Tell the caller to try again.  Cases where no handshake progress</color>
<color=#75715e>     * can be made should return false above.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
  <color=#f8f8f2>}</color>

  <color=#66d9ef>private</color> <color=#66d9ef>void</color> <color=#a6e22e>runDelegatedTasks</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>Runnable</color> <color=#f8f8f2>task</color><color=#f8f8f2>;</color>
    <color=#75715e>/*</color>
<color=#75715e>     * In theory, we could run these as a background job, but no need for</color>
<color=#75715e>     * that level of complication.  Our server doesn't serve a large number</color>
<color=#75715e>     * of clients.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>while</color> <color=#f8f8f2>((</color><color=#f8f8f2>task</color> <color=#f92672>=</color> <color=#f8f8f2>sslEngine</color><color=#f8f8f2>.</color><color=#a6e22e>getDelegatedTask</color><color=#f8f8f2>())</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
      <color=#f8f8f2>task</color><color=#f8f8f2>.</color><color=#a6e22e>run</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>
  <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>