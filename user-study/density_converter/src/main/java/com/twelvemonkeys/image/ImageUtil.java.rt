<color=#75715e>/*</color>
<color=#75715e> * Copyright (c) 2008, Harald Kuhr</color>
<color=#75715e> * All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * Redistribution and use in source and binary forms, with or without</color>
<color=#75715e> * modification, are permitted provided that the following conditions are met:</color>
<color=#75715e> *</color>
<color=#75715e> * * Redistributions of source code must retain the above copyright notice, this</color>
<color=#75715e> *   list of conditions and the following disclaimer.</color>
<color=#75715e> *</color>
<color=#75715e> * * Redistributions in binary form must reproduce the above copyright notice,</color>
<color=#75715e> *   this list of conditions and the following disclaimer in the documentation</color>
<color=#75715e> *   and/or other materials provided with the distribution.</color>
<color=#75715e> *</color>
<color=#75715e> * * Neither the name of the copyright holder nor the names of its</color>
<color=#75715e> *   contributors may be used to endorse or promote products derived from</color>
<color=#75715e> *   this software without specific prior written permission.</color>
<color=#75715e> *</color>
<color=#75715e> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</color>
<color=#75715e> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</color>
<color=#75715e> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</color>
<color=#75715e> * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</color>
<color=#75715e> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</color>
<color=#75715e> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</color>
<color=#75715e> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</color>
<color=#75715e> * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</color>
<color=#75715e> * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</color>
<color=#75715e> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.twelvemonkeys.image</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.awt.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.geom.AffineTransform</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.geom.Rectangle2D</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.image.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.util.Hashtable</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * This class contains methods for basic image manipulation and conversion.</color>
<color=#75715e> *</color>
<color=#75715e> * @author <a href="mailto:harald.kuhr@gmail.com">Harald Kuhr</a></color>
<color=#75715e> * @author last modified by $Author: haku $</color>
<color=#75715e> * @version $Id: common/common-image/src/main/java/com/twelvemonkeys/image/ImageUtil.java#3 $</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>class</color> <color=#a6e22e>ImageUtil</color> <color=#f8f8f2>{</color>
    <color=#75715e>// TODO: Split palette generation out, into ColorModel classes (?)</color>

    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>ROTATE_90_CCW</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>90</color><color=#f8f8f2>;</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>ROTATE_90_CW</color> <color=#f92672>=</color> <color=#ae81ff>90</color><color=#f8f8f2>;</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>ROTATE_180</color> <color=#f92672>=</color> <color=#ae81ff>180</color><color=#f8f8f2>;</color>

    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>FLIP_VERTICAL</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>FLIP_HORIZONTAL</color> <color=#f92672>=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Alias for {@link ConvolveOp#EDGE_ZERO_FILL}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see #convolve(BufferedImage, Kernel, int)</color>
<color=#75715e>     * @see #EDGE_REFLECT</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>EDGE_ZERO_FILL</color> <color=#f92672>=</color> <color=#f8f8f2>ConvolveOp</color><color=#f8f8f2>.</color><color=#a6e22e>EDGE_ZERO_FILL</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Alias for {@link ConvolveOp#EDGE_NO_OP}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see #convolve(BufferedImage, Kernel, int)</color>
<color=#75715e>     * @see #EDGE_REFLECT</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>EDGE_NO_OP</color> <color=#f92672>=</color> <color=#f8f8f2>ConvolveOp</color><color=#f8f8f2>.</color><color=#a6e22e>EDGE_NO_OP</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Adds a border to the image while convolving. The border will reflect the</color>
<color=#75715e>     * edges of the original image. This is usually a good default.</color>
<color=#75715e>     * Note that while this mode typically provides better quality than the</color>
<color=#75715e>     * standard modes {@code EDGE_ZERO_FILL} and {@code EDGE_NO_OP}, it does so</color>
<color=#75715e>     * at the expense of higher memory consumption and considerable more computation.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see #convolve(BufferedImage, Kernel, int)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>EDGE_REFLECT</color> <color=#f92672>=</color> <color=#ae81ff>2</color><color=#f8f8f2>;</color> <color=#75715e>// as JAI BORDER_REFLECT</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Adds a border to the image while convolving. The border will wrap the</color>
<color=#75715e>     * edges of the original image. This is usually the best choice for tiles.</color>
<color=#75715e>     * Note that while this mode typically provides better quality than the</color>
<color=#75715e>     * standard modes {@code EDGE_ZERO_FILL} and {@code EDGE_NO_OP}, it does so</color>
<color=#75715e>     * at the expense of higher memory consumption and considerable more computation.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see #convolve(BufferedImage, Kernel, int)</color>
<color=#75715e>     * @see #EDGE_REFLECT</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>EDGE_WRAP</color> <color=#f92672>=</color> <color=#ae81ff>3</color><color=#f8f8f2>;</color> <color=#75715e>// as JAI BORDER_WRAP</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Java default dither</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>DITHER_DEFAULT</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>DITHER_DEFAULT</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * No dither</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>DITHER_NONE</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>DITHER_NONE</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Error diffusion dither</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>DITHER_DIFFUSION</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>DITHER_DIFFUSION</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Error diffusion dither with alternating scans</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>DITHER_DIFFUSION_ALTSCANS</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>DITHER_DIFFUSION_ALTSCANS</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Default color selection</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>COLOR_SELECTION_DEFAULT</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>COLOR_SELECTION_DEFAULT</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Prioritize speed</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>COLOR_SELECTION_FAST</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>COLOR_SELECTION_FAST</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Prioritize quality</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>COLOR_SELECTION_QUALITY</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>COLOR_SELECTION_QUALITY</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Default transparency (none)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>TRANSPARENCY_DEFAULT</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSPARENCY_DEFAULT</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Discard any alpha information</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>TRANSPARENCY_OPAQUE</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSPARENCY_OPAQUE</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Convert alpha to bitmask</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>TRANSPARENCY_BITMASK</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSPARENCY_BITMASK</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Keep original alpha (not supported yet)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>TRANSPARENCY_TRANSLUCENT</color> <color=#f92672>=</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSPARENCY_TRANSLUCENT</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Passed to the createXxx methods, to indicate that the type does not matter</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>final</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#f8f8f2>BI_TYPE_ANY</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>
    <color=#75715e>/*</color>
<color=#75715e>    public final static int BI_TYPE_ANY_TRANSLUCENT = -1;</color>
<color=#75715e>    public final static int BI_TYPE_ANY_BITMASK = -2;</color>
<color=#75715e>    public final static int BI_TYPE_ANY_OPAQUE = -3;*/</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Tells wether this WM may support acceleration of some images</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>VM_SUPPORTS_ACCELERATION</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * The sharpen matrix</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>float</color><color=#f92672>[]</color> <color=#f8f8f2>SHARPEN_MATRIX</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>float</color><color=#f92672>[]</color><color=#f8f8f2>{</color>
            <color=#ae81ff>0.0f</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>0.3f</color><color=#f8f8f2>,</color> <color=#ae81ff>0.0f</color><color=#f8f8f2>,</color>
            <color=#f92672>-</color><color=#ae81ff>0.3f</color><color=#f8f8f2>,</color> <color=#ae81ff>2.2f</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>0.3f</color><color=#f8f8f2>,</color>
            <color=#ae81ff>0.0f</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>0.3f</color><color=#f8f8f2>,</color> <color=#ae81ff>0.0f</color>
    <color=#f8f8f2>};</color>

    <color=#75715e>/**</color>
<color=#75715e>     * The sharpen kernel. Uses the following 3 by 3 matrix:</color>
<color=#75715e>     * <TABLE border="1" cellspacing="0"></color>
<color=#75715e>     * <TR><TD>0.0</TD><TD>-0.3</TD><TD>0.0</TD></TR></color>
<color=#75715e>     * <TR><TD>-0.3</TD><TD>2.2</TD><TD>-0.3</TD></TR></color>
<color=#75715e>     * <TR><TD>0.0</TD><TD>-0.3</TD><TD>0.0</TD></TR></color>
<color=#75715e>     * </TABLE></color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Kernel</color> <color=#f8f8f2>SHARPEN_KERNEL</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Kernel</color><color=#f8f8f2>(</color><color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#f8f8f2>SHARPEN_MATRIX</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Component that can be used with the MediaTracker etc.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Component</color> <color=#f8f8f2>NULL_COMPONENT</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Component</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>};</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Our static image tracker</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>MediaTracker</color> <color=#f8f8f2>sTracker</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>MediaTracker</color><color=#f8f8f2>(</color><color=#f8f8f2>NULL_COMPONENT</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     *</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>AffineTransform</color> <color=#f8f8f2>IDENTITY_TRANSFORM</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AffineTransform</color><color=#f8f8f2>();</color>
    <color=#75715e>/**</color>
<color=#75715e>     *</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Point</color> <color=#f8f8f2>LOCATION_UPPER_LEFT</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Point</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     *</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>GraphicsConfiguration</color> <color=#f8f8f2>DEFAULT_CONFIGURATION</color> <color=#f92672>=</color> <color=#f8f8f2>getDefaultGraphicsConfiguration</color><color=#f8f8f2>();</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>GraphicsConfiguration</color> <color=#a6e22e>getDefaultGraphicsConfiguration</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>GraphicsEnvironment</color> <color=#f8f8f2>env</color> <color=#f92672>=</color> <color=#f8f8f2>GraphicsEnvironment</color><color=#f8f8f2>.</color><color=#a6e22e>getLocalGraphicsEnvironment</color><color=#f8f8f2>();</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>env</color><color=#f8f8f2>.</color><color=#a6e22e>isHeadlessInstance</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>return</color> <color=#f8f8f2>env</color><color=#f8f8f2>.</color><color=#a6e22e>getDefaultScreenDevice</color><color=#f8f8f2>().</color><color=#a6e22e>getDefaultConfiguration</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>LinkageError</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>// Means we are not in a 1.4+ VM, so skip testing for headless again</color>
            <color=#f8f8f2>VM_SUPPORTS_ACCELERATION</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>return</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates an ImageUtil. Private constructor.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#a6e22e>ImageUtil</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts the {@code RenderedImage} to a {@code BufferedImage}.</color>
<color=#75715e>     * The new image will have the <em>same</em> {@code ColorModel},</color>
<color=#75715e>     * {@code Raster} and properties as the original image, if possible.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * If the image is already a {@code BufferedImage}, it is simply returned</color>
<color=#75715e>     * and no conversion takes place.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the image to convert.</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Don't convert if it already is a BufferedImage</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"original == null"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Copy properties</color>
        <color=#f8f8f2>Hashtable</color><color=#f92672><</color><color=#f8f8f2>String</color><color=#f8f8f2>,</color> <color=#f8f8f2>Object</color><color=#f92672>></color> <color=#f8f8f2>properties</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>String</color><color=#f92672>[]</color> <color=#f8f8f2>names</color> <color=#f92672>=</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getPropertyNames</color><color=#f8f8f2>();</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>names</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>names</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>properties</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Hashtable</color><color=#f92672><</color><color=#f8f8f2>String</color><color=#f8f8f2>,</color> <color=#f8f8f2>Object</color><color=#f92672>></color><color=#f8f8f2>(</color><color=#f8f8f2>names</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

            <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>String</color> <color=#f8f8f2>name</color> <color=#f8f8f2>:</color> <color=#f8f8f2>names</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>properties</color><color=#f8f8f2>.</color><color=#a6e22e>put</color><color=#f8f8f2>(</color><color=#f8f8f2>name</color><color=#f8f8f2>,</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getProperty</color><color=#f8f8f2>(</color><color=#f8f8f2>name</color><color=#f8f8f2>));</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>properties</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// NOTE: This is a workaround for the broken Batik '*Red' classes, that</color>
        <color=#75715e>// throw NPE if copyData(null) is used. This may actually be faster too.</color>
        <color=#75715e>// See RenderedImage#copyData / RenderedImage#getData</color>
        <color=#f8f8f2>Raster</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>WritableRaster</color> <color=#f8f8f2>raster</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>data</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>WritableRaster</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>WritableRaster</color><color=#f8f8f2>)</color> <color=#f8f8f2>data</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>createCompatibleWritableRaster</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>copyData</color><color=#f8f8f2>(</color><color=#f8f8f2>raster</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Create buffered image</color>
        <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>colorModel</color> <color=#f92672>=</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>();</color>
        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>colorModel</color><color=#f8f8f2>,</color> <color=#f8f8f2>raster</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>colorModel</color><color=#f8f8f2>.</color><color=#a6e22e>isAlphaPremultiplied</color><color=#f8f8f2>(),</color>
                <color=#f8f8f2>properties</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts the {@code RenderedImage} to a {@code BufferedImage} of the</color>
<color=#75715e>     * given type.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * If the image is already a {@code BufferedImage} of the given type, it</color>
<color=#75715e>     * is simply returned and no conversion takes place.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the image to convert.</color>
<color=#75715e>     * @param pType     the type of buffered image</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pOriginal == null}</color>
<color=#75715e>     *                                  or {@code pType} is not a valid type for {@code BufferedImage}</color>
<color=#75715e>     * @see BufferedImage#getType()</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Don't convert if it already is BufferedImage and correct type</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>pOriginal</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f92672>&&</color> <color=#f8f8f2>((</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>).</color><color=#a6e22e>getType</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>pType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"original == null"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Create a buffered image</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>createBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color>
                <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(),</color>
                <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSLUCENT</color><color=#f8f8f2>);</color>

        <color=#75715e>// Draw the image onto the buffer</color>
        <color=#75715e>// NOTE: This is faster than doing a raster conversion in most cases</color>
        <color=#f8f8f2>Graphics2D</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>image</color><color=#f8f8f2>.</color><color=#a6e22e>createGraphics</color><color=#f8f8f2>();</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setComposite</color><color=#f8f8f2>(</color><color=#f8f8f2>AlphaComposite</color><color=#f8f8f2>.</color><color=#a6e22e>Src</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawRenderedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>IDENTITY_TRANSFORM</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts the {@code BufferedImage} to a {@code BufferedImage} of the</color>
<color=#75715e>     * given type. The new image will have the same {@code ColorModel},</color>
<color=#75715e>     * {@code Raster} and properties as the original image, if possible.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * If the image is already a {@code BufferedImage} of the given type, it</color>
<color=#75715e>     * is simply returned and no conversion takes place.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This method simply invokes</color>
<color=#75715e>     * {@link #toBuffered(RenderedImage, int) toBuffered((RenderedImage) pOriginal, pType)}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the image to convert.</color>
<color=#75715e>     * @param pType     the type of buffered image</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pOriginal == null}</color>
<color=#75715e>     *                                  or if {@code pType} is not a valid type for {@code BufferedImage}</color>
<color=#75715e>     * @see BufferedImage#getType()</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>toBuffered</color><color=#f8f8f2>((</color><color=#f8f8f2>RenderedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>pType</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts the {@code Image} to a {@code BufferedImage}.</color>
<color=#75715e>     * The new image will have the same {@code ColorModel}, {@code Raster} and</color>
<color=#75715e>     * properties as the original image, if possible.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * If the image is already a {@code BufferedImage}, it is simply returned</color>
<color=#75715e>     * and no conversion takes place.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the image to convert.</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pOriginal == null}</color>
<color=#75715e>     * @throws ImageConversionException if the image cannot be converted</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Don't convert if it already is BufferedImage</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"original == null"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>//System.out.println("--> Doing full BufferedImage conversion...");</color>

        <color=#f8f8f2>BufferedImageFactory</color> <color=#f8f8f2>factory</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImageFactory</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>factory</color><color=#f8f8f2>.</color><color=#a6e22e>getBufferedImage</color><color=#f8f8f2>();</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a deep copy of the given image. The image will have the same</color>
<color=#75715e>     * color model and raster type, but will not share image (pixel) data</color>
<color=#75715e>     * with the input image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the image to clone.</color>
<color=#75715e>     * @return a new {@code BufferedImage}</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pImage} is {@code null}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createCopy</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"image == null"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>cm</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>img</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>cm</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>createCompatibleWritableRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()),</color>
                <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>isAlphaPremultiplied</color><color=#f8f8f2>(),</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>drawOnto</color><color=#f8f8f2>(</color><color=#f8f8f2>img</color><color=#f8f8f2>,</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>img</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a {@code WritableRaster} for the given {@code ColorModel} and</color>
<color=#75715e>     * pixel data.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This method is optimized for the most common cases of {@code ColorModel}</color>
<color=#75715e>     * and pixel data combinations. The raster's backing {@code DataBuffer} is</color>
<color=#75715e>     * created directly from the pixel data, as this is faster and more</color>
<color=#75715e>     * resource-friendly than using</color>
<color=#75715e>     * {@code ColorModel.createCompatibleWritableRaster(w, h)}.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * For uncommon combinations, the method will fallback to using</color>
<color=#75715e>     * {@code ColorModel.createCompatibleWritableRaster(w, h)} and</color>
<color=#75715e>     * {@code WritableRaster.setDataElements(w, h, pixels)}</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * Note that the {@code ColorModel} and pixel data are <em>not</em> cloned</color>
<color=#75715e>     * (in most cases).</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pWidth      the requested raster width</color>
<color=#75715e>     * @param pHeight     the requested raster height</color>
<color=#75715e>     * @param pPixels     the pixels, as an array, of a type supported by the</color>
<color=#75715e>     *                    different {@link DataBuffer}</color>
<color=#75715e>     * @param pColorModel the color model to use</color>
<color=#75715e>     * @return a new {@code WritableRaster}</color>
<color=#75715e>     * @throws NullPointerException if either {@code pColorModel} or</color>
<color=#75715e>     *                              {@code pPixels} are {@code null}.</color>
<color=#75715e>     * @throws RuntimeException     if {@code pWidth} and {@code pHeight} does not</color>
<color=#75715e>     *                              match the pixel data in {@code pPixels}.</color>
<color=#75715e>     * @see ColorModel#createCompatibleWritableRaster(int, int)</color>
<color=#75715e>     * @see ColorModel#createCompatibleSampleModel(int, int)</color>
<color=#75715e>     * @see WritableRaster#setDataElements(int, int, Object)</color>
<color=#75715e>     * @see DataBuffer</color>
<color=#75715e>     */</color>
    <color=#66d9ef>static</color> <color=#f8f8f2>WritableRaster</color> <color=#a6e22e>createRaster</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>pPixels</color><color=#f8f8f2>,</color> <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// NOTE: This is optimized code for most common cases.</color>
        <color=#75715e>// We create a DataBuffer from the pixel array directly,</color>
        <color=#75715e>// and creating a raster based on the DataBuffer and ColorModel.</color>
        <color=#75715e>// Creating rasters this way is faster and more resource-friendly, as</color>
        <color=#75715e>// cm.createCompatibleWritableRaster allocates an</color>
        <color=#75715e>// "empty" DataBuffer with a storage array of w*h. This array is</color>
        <color=#75715e>// later discarded, and replaced in the raster.setDataElements() call.</color>
        <color=#75715e>// The "old" way is kept as a more compatible fall-back mode.</color>

        <color=#f8f8f2>DataBuffer</color> <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>WritableRaster</color> <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>bands</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pPixels</color> <color=#66d9ef>instanceof</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>)</color> <color=#f8f8f2>pPixels</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DataBufferInt</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>bands</color> <color=#f92672>=</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>.</color><color=#a6e22e>getNumComponents</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pPixels</color> <color=#66d9ef>instanceof</color> <color=#66d9ef>short</color><color=#f92672>[]</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>short</color><color=#f92672>[]</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>short</color><color=#f92672>[]</color><color=#f8f8f2>)</color> <color=#f8f8f2>pPixels</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DataBufferUShort</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>bands</color> <color=#f92672>=</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>/</color> <color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color> <color=#f92672>*</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pPixels</color> <color=#66d9ef>instanceof</color> <color=#66d9ef>byte</color><color=#f92672>[]</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>byte</color><color=#f92672>[]</color><color=#f8f8f2>)</color> <color=#f8f8f2>pPixels</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DataBufferByte</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

            <color=#75715e>// NOTE: This only holds for gray and indexed with one byte per pixel...</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pColorModel</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>IndexColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>bands</color> <color=#f92672>=</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>bands</color> <color=#f92672>=</color> <color=#f8f8f2>data</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>/</color> <color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color> <color=#f92672>*</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#75715e>// Fallback mode, slower & requires more memory, but compatible</color>
            <color=#f8f8f2>bands</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

            <color=#75715e>// Create raster from color model, w and h</color>
            <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>.</color><color=#a6e22e>createCompatibleWritableRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>raster</color><color=#f8f8f2>.</color><color=#a6e22e>setDataElements</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pPixels</color><color=#f8f8f2>);</color> <color=#75715e>// Note: This is known to throw ClassCastExceptions..</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>raster</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pColorModel</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>IndexColorModel</color> <color=#f92672>&&</color> <color=#f8f8f2>isIndexedPacked</color><color=#f8f8f2>((</color><color=#f8f8f2>IndexColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>Raster</color><color=#f8f8f2>.</color><color=#a6e22e>createPackedRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>buffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>.</color><color=#a6e22e>getPixelSize</color><color=#f8f8f2>(),</color> <color=#f8f8f2>LOCATION_UPPER_LEFT</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pColorModel</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>PackedColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>PackedColorModel</color> <color=#f8f8f2>pcm</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>PackedColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>;</color>
                <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>Raster</color><color=#f8f8f2>.</color><color=#a6e22e>createPackedRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>buffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pcm</color><color=#f8f8f2>.</color><color=#a6e22e>getMasks</color><color=#f8f8f2>(),</color> <color=#f8f8f2>LOCATION_UPPER_LEFT</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#75715e>// (A)BGR order... For TYPE_3BYTE_BGR/TYPE_4BYTE_ABGR/TYPE_4BYTE_ABGR_PRE.</color>
                <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>bandsOffsets</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[</color><color=#f8f8f2>bands</color><color=#f92672>]</color><color=#f8f8f2>;</color>
                <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bands</color><color=#f8f8f2>;</color> <color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                    <color=#f8f8f2>bandsOffsets</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>bands</color> <color=#f92672>-</color> <color=#f8f8f2>(</color><color=#f92672>++</color><color=#f8f8f2>i</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>}</color>

                <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>Raster</color><color=#f8f8f2>.</color><color=#a6e22e>createInterleavedRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>buffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color> <color=#f92672>*</color> <color=#f8f8f2>bands</color><color=#f8f8f2>,</color> <color=#f8f8f2>bands</color><color=#f8f8f2>,</color> <color=#f8f8f2>bandsOffsets</color><color=#f8f8f2>,</color> <color=#f8f8f2>LOCATION_UPPER_LEFT</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>raster</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#a6e22e>isIndexedPacked</color><color=#f8f8f2>(</color><color=#f8f8f2>IndexColorModel</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>pColorModel</color><color=#f8f8f2>.</color><color=#a6e22e>getPixelSize</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>1</color> <color=#f92672>||</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>.</color><color=#a6e22e>getPixelSize</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>2</color> <color=#f92672>||</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>.</color><color=#a6e22e>getPixelSize</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#ae81ff>4</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Workaround for bug: TYPE_3BYTE_BGR, TYPE_4BYTE_ABGR and</color>
<color=#75715e>     * TYPE_4BYTE_ABGR_PRE are all converted to TYPE_CUSTOM when using the</color>
<color=#75715e>     * default createCompatibleWritableRaster from ComponentColorModel.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the orignal image</color>
<color=#75715e>     * @param pModel    the original color model</color>
<color=#75715e>     * @param width     the requested width of the raster</color>
<color=#75715e>     * @param height    the requested height of the raster</color>
<color=#75715e>     * @return a new WritableRaster</color>
<color=#75715e>     */</color>
    <color=#66d9ef>static</color> <color=#f8f8f2>WritableRaster</color> <color=#a6e22e>createCompatibleWritableRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>pModel</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>height</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pModel</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pModel</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>bOffs</color><color=#f8f8f2>;</color>
            <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_3BYTE_BGR</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>bOffs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>};</color> <color=#75715e>// NOTE: These are reversed from what the cm.createCompatibleWritableRaster would return</color>
                    <color=#66d9ef>return</color> <color=#f8f8f2>Raster</color><color=#f8f8f2>.</color><color=#a6e22e>createInterleavedRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>DataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE</color><color=#f8f8f2>,</color>
                            <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>height</color><color=#f8f8f2>,</color>
                            <color=#f8f8f2>width</color> <color=#f92672>*</color> <color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#ae81ff>3</color><color=#f8f8f2>,</color>
                            <color=#f8f8f2>bOffs</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_4BYTE_ABGR</color><color=#f8f8f2>:</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_4BYTE_ABGR_PRE</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>bOffs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>};</color> <color=#75715e>// NOTE: These are reversed from what the cm.createCompatibleWritableRaster would return</color>
                    <color=#66d9ef>return</color> <color=#f8f8f2>Raster</color><color=#f8f8f2>.</color><color=#a6e22e>createInterleavedRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>DataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE</color><color=#f8f8f2>,</color>
                            <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>height</color><color=#f8f8f2>,</color>
                            <color=#f8f8f2>width</color> <color=#f92672>*</color> <color=#ae81ff>4</color><color=#f8f8f2>,</color> <color=#ae81ff>4</color><color=#f8f8f2>,</color>
                            <color=#f8f8f2>bOffs</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_CUSTOM</color><color=#f8f8f2>:</color>
                    <color=#75715e>// Peek into the sample model to see if we have a sample model that will be incompatible with the default case</color>
                    <color=#f8f8f2>SampleModel</color> <color=#f8f8f2>sm</color> <color=#f92672>=</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getRaster</color><color=#f8f8f2>().</color><color=#a6e22e>getSampleModel</color><color=#f8f8f2>();</color>
                    <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>sm</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>ComponentSampleModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                        <color=#f8f8f2>bOffs</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#f8f8f2>ComponentSampleModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>sm</color><color=#f8f8f2>).</color><color=#a6e22e>getBandOffsets</color><color=#f8f8f2>();</color>
                        <color=#66d9ef>return</color> <color=#f8f8f2>Raster</color><color=#f8f8f2>.</color><color=#a6e22e>createInterleavedRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>sm</color><color=#f8f8f2>.</color><color=#a6e22e>getDataType</color><color=#f8f8f2>(),</color>
                                <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>height</color><color=#f8f8f2>,</color>
                                <color=#f8f8f2>width</color> <color=#f92672>*</color> <color=#f8f8f2>bOffs</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>,</color> <color=#f8f8f2>bOffs</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>,</color>
                                <color=#f8f8f2>bOffs</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
                    <color=#f8f8f2>}</color>
                    <color=#75715e>// Else fall through</color>
                <color=#66d9ef>default</color><color=#f8f8f2>:</color>
                    <color=#66d9ef>return</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>().</color><color=#a6e22e>createCompatibleWritableRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>height</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>pModel</color><color=#f8f8f2>.</color><color=#a6e22e>createCompatibleWritableRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>height</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts the {@code Image} to a {@code BufferedImage} of the given type.</color>
<color=#75715e>     * The new image will have the same {@code ColorModel}, {@code Raster} and</color>
<color=#75715e>     * properties as the original image, if possible.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * If the image is already a {@code BufferedImage} of the given type, it</color>
<color=#75715e>     * is simply returned and no conversion takes place.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the image to convert.</color>
<color=#75715e>     * @param pType     the type of buffered image</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pOriginal == null}</color>
<color=#75715e>     *                                  or if {@code pType} is not a valid type for {@code BufferedImage}</color>
<color=#75715e>     * @see BufferedImage#getType()</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * @param pOriginal the original image</color>
<color=#75715e>     * @param pType     the type of {@code BufferedImage} to create</color>
<color=#75715e>     * @param pICM      the optional {@code IndexColorModel} to use. If not</color>
<color=#75715e>     *                  {@code null} the {@code pType} must be compatible with the color model</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pType} is not compatible with</color>
<color=#75715e>     *                                  the color model</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>IndexColorModel</color> <color=#f8f8f2>pICM</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Don't convert if it already is BufferedImage and correct type</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>pOriginal</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color>
                <color=#f92672>&&</color> <color=#f8f8f2>((</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>).</color><color=#a6e22e>getType</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>pType</color>
                <color=#f92672>&&</color> <color=#f8f8f2>(</color><color=#f8f8f2>pICM</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>equals</color><color=#f8f8f2>(((</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>).</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pICM</color><color=#f8f8f2>)))</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"original == null"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>//System.out.println("--> Doing full BufferedImage conversion, using Graphics.drawImage().");</color>

        <color=#75715e>// Create a buffered image</color>
        <color=#75715e>// NOTE: The getWidth and getHeight methods, will wait for the image</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pICM</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>createBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>getWidth</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>),</color> <color=#f8f8f2>getHeight</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>),</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSLUCENT</color><color=#f8f8f2>);</color><color=#75715e>//new BufferedImage(getWidth(pOriginal), getHeight(pOriginal), pType);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>getWidth</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>),</color> <color=#f8f8f2>getHeight</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>),</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>pICM</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Draw the image onto the buffer</color>
        <color=#f8f8f2>drawOnto</color><color=#f8f8f2>(</color><color=#f8f8f2>image</color><color=#f8f8f2>,</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Draws the source image onto the buffered image, using</color>
<color=#75715e>     * {@code AlphaComposite.Src} and coordinates {@code 0, 0}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pDestination the image to draw on</color>
<color=#75715e>     * @param pSource      the source image to draw</color>
<color=#75715e>     * @throws NullPointerException if {@code pDestination} or {@code pSource} is {@code null}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>drawOnto</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pDestination</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#f8f8f2>Image</color> <color=#f8f8f2>pSource</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>Graphics2D</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>pDestination</color><color=#f8f8f2>.</color><color=#a6e22e>createGraphics</color><color=#f8f8f2>();</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setComposite</color><color=#f8f8f2>(</color><color=#f8f8f2>AlphaComposite</color><color=#f8f8f2>.</color><color=#a6e22e>Src</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setRenderingHint</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>KEY_DITHERING</color><color=#f8f8f2>,</color> <color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>VALUE_DITHER_DISABLE</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pSource</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a flipped version of the given image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the image to flip</color>
<color=#75715e>     * @param pAxis  the axis to flip around</color>
<color=#75715e>     * @return a new {@code BufferedImage}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createFlipped</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>pAxis</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>pAxis</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>FLIP_HORIZONTAL</color><color=#f8f8f2>:</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>FLIP_VERTICAL</color><color=#f8f8f2>:</color>
                <color=#75715e>// TODO case FLIP_BOTH:?? same as rotate 180?</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>
            <color=#66d9ef>default</color><color=#f8f8f2>:</color>
                <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"Illegal direction: "</color> <color=#f92672>+</color> <color=#f8f8f2>pAxis</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>source</color> <color=#f92672>=</color> <color=#f8f8f2>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>AffineTransform</color> <color=#f8f8f2>transform</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pAxis</color> <color=#f92672>==</color> <color=#f8f8f2>FLIP_HORIZONTAL</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>transform</color> <color=#f92672>=</color> <color=#f8f8f2>AffineTransform</color><color=#f8f8f2>.</color><color=#a6e22e>getTranslateInstance</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>source</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>());</color>
            <color=#f8f8f2>transform</color><color=#f8f8f2>.</color><color=#a6e22e>scale</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>transform</color> <color=#f92672>=</color> <color=#f8f8f2>AffineTransform</color><color=#f8f8f2>.</color><color=#a6e22e>getTranslateInstance</color><color=#f8f8f2>(</color><color=#f8f8f2>source</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>transform</color><color=#f8f8f2>.</color><color=#a6e22e>scale</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
        <color=#f8f8f2>AffineTransformOp</color> <color=#f8f8f2>transformOp</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AffineTransformOp</color><color=#f8f8f2>(</color><color=#f8f8f2>transform</color><color=#f8f8f2>,</color> <color=#f8f8f2>AffineTransformOp</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_NEAREST_NEIGHBOR</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>transformOp</color><color=#f8f8f2>.</color><color=#a6e22e>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>source</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>


    <color=#75715e>/**</color>
<color=#75715e>     * Rotates the image 90 degrees, clockwise (aka "rotate right"),</color>
<color=#75715e>     * counter-clockwise (aka "rotate left") or 180 degrees, depending on the</color>
<color=#75715e>     * {@code pDirection} argument.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * The new image will be completely covered with pixels from the source</color>
<color=#75715e>     * image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage     the source image.</color>
<color=#75715e>     * @param pDirection the direction, must be either {@link #ROTATE_90_CW},</color>
<color=#75715e>     *                   {@link #ROTATE_90_CCW} or {@link #ROTATE_180}</color>
<color=#75715e>     * @return a new {@code BufferedImage}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createRotated</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>pDirection</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>pDirection</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>ROTATE_90_CW</color><color=#f8f8f2>:</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>ROTATE_90_CCW</color><color=#f8f8f2>:</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>ROTATE_180</color><color=#f8f8f2>:</color>
                <color=#66d9ef>return</color> <color=#f8f8f2>createRotated</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>toRadians</color><color=#f8f8f2>(</color><color=#f8f8f2>pDirection</color><color=#f8f8f2>));</color>
            <color=#66d9ef>default</color><color=#f8f8f2>:</color>
                <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"Illegal direction: "</color> <color=#f92672>+</color> <color=#f8f8f2>pDirection</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Rotates the image to the given angle. Areas not covered with pixels from</color>
<color=#75715e>     * the source image will be left transparent, if possible.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the source image</color>
<color=#75715e>     * @param pAngle the angle of rotation, in radians</color>
<color=#75715e>     * @return a new {@code BufferedImage}, unless {@code pAngle == 0.0}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createRotated</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>double</color> <color=#f8f8f2>pAngle</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>createRotated0</color><color=#f8f8f2>(</color><color=#f8f8f2>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>),</color> <color=#f8f8f2>pAngle</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createRotated0</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pSource</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>double</color> <color=#f8f8f2>pAngle</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>abs</color><color=#f8f8f2>(</color><color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>toDegrees</color><color=#f8f8f2>(</color><color=#f8f8f2>pAngle</color><color=#f8f8f2>))</color> <color=#f92672>%</color> <color=#ae81ff>360</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>pSource</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>fast</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>abs</color><color=#f8f8f2>(</color><color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>toDegrees</color><color=#f8f8f2>(</color><color=#f8f8f2>pAngle</color><color=#f8f8f2>))</color> <color=#f92672>%</color> <color=#ae81ff>90</color><color=#f8f8f2>)</color> <color=#f92672>==</color> <color=#ae81ff>0.0</color><color=#f8f8f2>);</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>w</color> <color=#f92672>=</color> <color=#f8f8f2>pSource</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color>
        <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>h</color> <color=#f92672>=</color> <color=#f8f8f2>pSource</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color>

        <color=#75715e>// Compute new width and height</color>
        <color=#66d9ef>double</color> <color=#f8f8f2>sin</color> <color=#f92672>=</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>abs</color><color=#f8f8f2>(</color><color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>sin</color><color=#f8f8f2>(</color><color=#f8f8f2>pAngle</color><color=#f8f8f2>));</color>
        <color=#66d9ef>double</color> <color=#f8f8f2>cos</color> <color=#f92672>=</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>abs</color><color=#f8f8f2>(</color><color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>cos</color><color=#f8f8f2>(</color><color=#f8f8f2>pAngle</color><color=#f8f8f2>));</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>newW</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>floor</color><color=#f8f8f2>(</color><color=#f8f8f2>w</color> <color=#f92672>*</color> <color=#f8f8f2>cos</color> <color=#f92672>+</color> <color=#f8f8f2>h</color> <color=#f92672>*</color> <color=#f8f8f2>sin</color><color=#f8f8f2>);</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>newH</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>floor</color><color=#f8f8f2>(</color><color=#f8f8f2>h</color> <color=#f92672>*</color> <color=#f8f8f2>cos</color> <color=#f92672>+</color> <color=#f8f8f2>w</color> <color=#f92672>*</color> <color=#f8f8f2>sin</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>AffineTransform</color> <color=#f8f8f2>transform</color> <color=#f92672>=</color> <color=#f8f8f2>AffineTransform</color><color=#f8f8f2>.</color><color=#a6e22e>getTranslateInstance</color><color=#f8f8f2>((</color><color=#f8f8f2>newW</color> <color=#f92672>-</color> <color=#f8f8f2>w</color><color=#f8f8f2>)</color> <color=#f92672>/</color> <color=#ae81ff>2.0</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#f8f8f2>newH</color> <color=#f92672>-</color> <color=#f8f8f2>h</color><color=#f8f8f2>)</color> <color=#f92672>/</color> <color=#ae81ff>2.0</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>transform</color><color=#f8f8f2>.</color><color=#a6e22e>rotate</color><color=#f8f8f2>(</color><color=#f8f8f2>pAngle</color><color=#f8f8f2>,</color> <color=#f8f8f2>w</color> <color=#f92672>/</color> <color=#ae81ff>2.0</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color> <color=#f92672>/</color> <color=#ae81ff>2.0</color><color=#f8f8f2>);</color>

        <color=#75715e>// TODO: Figure out if this is correct</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>dest</color> <color=#f92672>=</color> <color=#f8f8f2>createTransparent</color><color=#f8f8f2>(</color><color=#f8f8f2>newW</color><color=#f8f8f2>,</color> <color=#f8f8f2>newH</color><color=#f8f8f2>);</color>

        <color=#75715e>// See: http://weblogs.java.net/blog/campbell/archive/2007/03/java_2d_tricker_1.html</color>
        <color=#f8f8f2>Graphics2D</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>dest</color><color=#f8f8f2>.</color><color=#a6e22e>createGraphics</color><color=#f8f8f2>();</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>transform</color><color=#f8f8f2>(</color><color=#f8f8f2>transform</color><color=#f8f8f2>);</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>fast</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#75715e>// Max quality</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setRenderingHint</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>KEY_ALPHA_INTERPOLATION</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>VALUE_ALPHA_INTERPOLATION_QUALITY</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setRenderingHint</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>KEY_INTERPOLATION</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>VALUE_INTERPOLATION_BILINEAR</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setRenderingHint</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>KEY_ANTIALIASING</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>VALUE_ANTIALIAS_ON</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setPaint</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>TexturePaint</color><color=#f8f8f2>(</color><color=#f8f8f2>pSource</color><color=#f8f8f2>,</color>
                        <color=#66d9ef>new</color> <color=#f8f8f2>Rectangle2D</color><color=#f8f8f2>.</color><color=#a6e22e>Float</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>pSource</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pSource</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>())));</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>fillRect</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>pSource</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pSource</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>());</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pSource</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>dest</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a scaled instance of the given {@code Image}, and converts it to</color>
<color=#75715e>     * a {@code BufferedImage} if needed.</color>
<color=#75715e>     * If the original image is a {@code BufferedImage} the result will have</color>
<color=#75715e>     * same type and color model. Note that this implies overhead, and is</color>
<color=#75715e>     * probably not useful for anything but {@code IndexColorModel} images.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage  the {@code Image} to scale</color>
<color=#75715e>     * @param pWidth  width in pixels</color>
<color=#75715e>     * @param pHeight height in pixels</color>
<color=#75715e>     * @param pHints  scaling ints</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     * @throws NullPointerException if {@code pImage} is {@code null}.</color>
<color=#75715e>     * @see #createResampled(Image, int, int, int)</color>
<color=#75715e>     * @see Image#getScaledInstance(int, int, int)</color>
<color=#75715e>     * @see Image#SCALE_AREA_AVERAGING</color>
<color=#75715e>     * @see Image#SCALE_DEFAULT</color>
<color=#75715e>     * @see Image#SCALE_FAST</color>
<color=#75715e>     * @see Image#SCALE_REPLICATE</color>
<color=#75715e>     * @see Image#SCALE_SMOOTH</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createScaled</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>cm</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>type</color> <color=#f92672>=</color> <color=#f8f8f2>BI_TYPE_ANY</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>RenderedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>cm</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#f8f8f2>RenderedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>).</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>();</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>type</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>).</color><color=#a6e22e>getType</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>BufferedImageFactory</color> <color=#f8f8f2>factory</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImageFactory</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>cm</color> <color=#f92672>=</color> <color=#f8f8f2>factory</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>scaled</color> <color=#f92672>=</color> <color=#f8f8f2>createResampled</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>);</color>

        <color=#75715e>// Convert if color models or type differ, to behave as documented</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>type</color> <color=#f92672>!=</color> <color=#f8f8f2>scaled</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>()</color> <color=#f92672>&&</color> <color=#f8f8f2>type</color> <color=#f92672>!=</color> <color=#f8f8f2>BI_TYPE_ANY</color> <color=#f92672>||</color> <color=#f92672>!</color><color=#f8f8f2>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>scaled</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>(),</color> <color=#f8f8f2>cm</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#75715e>//System.out.print("Converting TYPE " + scaled.getType() + " -> " + type + "... ");</color>
            <color=#75715e>//long start = System.currentTimeMillis();</color>
            <color=#f8f8f2>WritableRaster</color> <color=#f8f8f2>raster</color><color=#f8f8f2>;</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>createCompatibleWritableRaster</color><color=#f8f8f2>((</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>cm</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>createCompatibleWritableRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>

            <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>temp</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>cm</color><color=#f8f8f2>,</color> <color=#f8f8f2>raster</color><color=#f8f8f2>,</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>isAlphaPremultiplied</color><color=#f8f8f2>(),</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cm</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>IndexColorModel</color> <color=#f92672>&&</color> <color=#f8f8f2>pHints</color> <color=#f92672>==</color> <color=#f8f8f2>Image</color><color=#f8f8f2>.</color><color=#a6e22e>SCALE_SMOOTH</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#75715e>// TODO: DiffusionDither does not support transparency at the moment, this will create bad results</color>
                <color=#66d9ef>new</color> <color=#f8f8f2>DiffusionDither</color><color=#f8f8f2>((</color><color=#f8f8f2>IndexColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>cm</color><color=#f8f8f2>).</color><color=#a6e22e>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>scaled</color><color=#f8f8f2>,</color> <color=#f8f8f2>temp</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>drawOnto</color><color=#f8f8f2>(</color><color=#f8f8f2>temp</color><color=#f8f8f2>,</color> <color=#f8f8f2>scaled</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>

            <color=#f8f8f2>scaled</color> <color=#f92672>=</color> <color=#f8f8f2>temp</color><color=#f8f8f2>;</color>
            <color=#75715e>//long end = System.currentTimeMillis();</color>
            <color=#75715e>//System.out.println("Time: " + (end - start) + " ms");</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>scaled</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorModel</color> <color=#f8f8f2>pLeft</color><color=#f8f8f2>,</color> <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>pRight</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pLeft</color> <color=#f92672>==</color> <color=#f8f8f2>pRight</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>pLeft</color><color=#f8f8f2>.</color><color=#a6e22e>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>pRight</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Now, the models are equal, according to the equals method</color>
        <color=#75715e>// Test indexcolormodels for equality, the maps must be equal</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pLeft</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>IndexColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>IndexColorModel</color> <color=#f8f8f2>icm1</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IndexColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>pLeft</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>IndexColorModel</color> <color=#f8f8f2>icm2</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>IndexColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>pRight</color><color=#f8f8f2>;</color> <color=#75715e>// NOTE: Safe, they're equal</color>


            <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>mapSize1</color> <color=#f92672>=</color> <color=#f8f8f2>icm1</color><color=#f8f8f2>.</color><color=#a6e22e>getMapSize</color><color=#f8f8f2>();</color>
            <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>mapSize2</color> <color=#f92672>=</color> <color=#f8f8f2>icm2</color><color=#f8f8f2>.</color><color=#a6e22e>getMapSize</color><color=#f8f8f2>();</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>mapSize1</color> <color=#f92672>!=</color> <color=#f8f8f2>mapSize2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>

            <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>></color> <color=#f8f8f2>mapSize1</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>icm1</color><color=#f8f8f2>.</color><color=#a6e22e>getRGB</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#f8f8f2>icm2</color><color=#f8f8f2>.</color><color=#a6e22e>getRGB</color><color=#f8f8f2>(</color><color=#f8f8f2>i</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                    <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
                <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color>

            <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a scaled instance of the given {@code Image}, and converts it to</color>
<color=#75715e>     * a {@code BufferedImage} if needed.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage  the {@code Image} to scale</color>
<color=#75715e>     * @param pWidth  width in pixels</color>
<color=#75715e>     * @param pHeight height in pixels</color>
<color=#75715e>     * @param pHints  scaling mHints</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     * @throws NullPointerException if {@code pImage} is {@code null}.</color>
<color=#75715e>     * @see Image#SCALE_AREA_AVERAGING</color>
<color=#75715e>     * @see Image#SCALE_DEFAULT</color>
<color=#75715e>     * @see Image#SCALE_FAST</color>
<color=#75715e>     * @see Image#SCALE_REPLICATE</color>
<color=#75715e>     * @see Image#SCALE_SMOOTH</color>
<color=#75715e>     * @see ResampleOp</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createResampled</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// NOTE: TYPE_4BYTE_ABGR or TYPE_3BYTE_BGR is more efficient when accelerated...</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color>
                <color=#f92672>?</color> <color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pImage</color>
                <color=#f8f8f2>:</color> <color=#f8f8f2>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_4BYTE_ABGR</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>createResampled</color><color=#f8f8f2>(</color><color=#f8f8f2>image</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a scaled instance of the given {@code RenderedImage}, and</color>
<color=#75715e>     * converts it to a {@code BufferedImage} if needed.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage  the {@code RenderedImage} to scale</color>
<color=#75715e>     * @param pWidth  width in pixels</color>
<color=#75715e>     * @param pHeight height in pixels</color>
<color=#75715e>     * @param pHints  scaling mHints</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     * @throws NullPointerException if {@code pImage} is {@code null}.</color>
<color=#75715e>     * @see Image#SCALE_AREA_AVERAGING</color>
<color=#75715e>     * @see Image#SCALE_DEFAULT</color>
<color=#75715e>     * @see Image#SCALE_FAST</color>
<color=#75715e>     * @see Image#SCALE_REPLICATE</color>
<color=#75715e>     * @see Image#SCALE_SMOOTH</color>
<color=#75715e>     * @see ResampleOp</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createResampled</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderedImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// NOTE: TYPE_4BYTE_ABGR or TYPE_3BYTE_BGR is more efficient when accelerated...</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color>
                <color=#f92672>?</color> <color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pImage</color>
                <color=#f8f8f2>:</color> <color=#f8f8f2>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>().</color><color=#a6e22e>hasAlpha</color><color=#f8f8f2>()</color> <color=#f92672>?</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_4BYTE_ABGR</color> <color=#f8f8f2>:</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_3BYTE_BGR</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>createResampled</color><color=#f8f8f2>(</color><color=#f8f8f2>image</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a scaled instance of the given {@code BufferedImage}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage  the {@code BufferedImage} to scale</color>
<color=#75715e>     * @param pWidth  width in pixels</color>
<color=#75715e>     * @param pHeight height in pixels</color>
<color=#75715e>     * @param pHints  scaling mHints</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     * @throws NullPointerException if {@code pImage} is {@code null}.</color>
<color=#75715e>     * @see Image#SCALE_AREA_AVERAGING</color>
<color=#75715e>     * @see Image#SCALE_DEFAULT</color>
<color=#75715e>     * @see Image#SCALE_FAST</color>
<color=#75715e>     * @see Image#SCALE_REPLICATE</color>
<color=#75715e>     * @see Image#SCALE_SMOOTH</color>
<color=#75715e>     * @see ResampleOp</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createResampled</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Hints are converted between java.awt.Image hints and filter types</color>
        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>ResampleOp</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>convertAWTHints</color><color=#f8f8f2>(</color><color=#f8f8f2>pHints</color><color=#f8f8f2>)).</color><color=#a6e22e>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>convertAWTHints</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>Image</color><color=#f8f8f2>.</color><color=#a6e22e>SCALE_FAST</color><color=#f8f8f2>:</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>Image</color><color=#f8f8f2>.</color><color=#a6e22e>SCALE_REPLICATE</color><color=#f8f8f2>:</color>
                <color=#66d9ef>return</color> <color=#f8f8f2>ResampleOp</color><color=#f8f8f2>.</color><color=#a6e22e>FILTER_POINT</color><color=#f8f8f2>;</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>Image</color><color=#f8f8f2>.</color><color=#a6e22e>SCALE_AREA_AVERAGING</color><color=#f8f8f2>:</color>
                <color=#66d9ef>return</color> <color=#f8f8f2>ResampleOp</color><color=#f8f8f2>.</color><color=#a6e22e>FILTER_BOX</color><color=#f8f8f2>;</color>
            <color=#75715e>//return ResampleOp.FILTER_CUBIC;</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>Image</color><color=#f8f8f2>.</color><color=#a6e22e>SCALE_SMOOTH</color><color=#f8f8f2>:</color>
                <color=#66d9ef>return</color> <color=#f8f8f2>ResampleOp</color><color=#f8f8f2>.</color><color=#a6e22e>FILTER_LANCZOS</color><color=#f8f8f2>;</color>
            <color=#66d9ef>default</color><color=#f8f8f2>:</color>
                <color=#75715e>//return ResampleOp.FILTER_TRIANGLE;</color>
                <color=#66d9ef>return</color> <color=#f8f8f2>ResampleOp</color><color=#f8f8f2>.</color><color=#a6e22e>FILTER_QUADRATIC</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Extracts an {@code IndexColorModel} from the given image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage  the image to get the color model from</color>
<color=#75715e>     * @param pColors the maximum number of colors in the resulting color model</color>
<color=#75715e>     * @param pHints  hints controlling transparency and color selection</color>
<color=#75715e>     * @return the extracted {@code IndexColorModel}</color>
<color=#75715e>     * @see #COLOR_SELECTION_DEFAULT</color>
<color=#75715e>     * @see #COLOR_SELECTION_FAST</color>
<color=#75715e>     * @see #COLOR_SELECTION_QUALITY</color>
<color=#75715e>     * @see #TRANSPARENCY_DEFAULT</color>
<color=#75715e>     * @see #TRANSPARENCY_OPAQUE</color>
<color=#75715e>     * @see #TRANSPARENCY_BITMASK</color>
<color=#75715e>     * @see #TRANSPARENCY_TRANSLUCENT</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>IndexColorModel</color> <color=#a6e22e>getIndexColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pColors</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>getIndexColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>pColors</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates an indexed version of the given image (a {@code BufferedImage}</color>
<color=#75715e>     * with an {@code IndexColorModel}.</color>
<color=#75715e>     * The resulting image will have a maximum of 256 different colors.</color>
<color=#75715e>     * Transparent parts of the original will be replaced with solid black.</color>
<color=#75715e>     * Default (possibly HW accelerated) dither will be used.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the image to convert</color>
<color=#75715e>     * @return an indexed version of the given image</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createIndexed</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>getIndexedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>),</color> <color=#ae81ff>256</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color><color=#f8f8f2>.</color><color=#a6e22e>black</color><color=#f8f8f2>,</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>DITHER_DEFAULT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates an indexed version of the given image (a {@code BufferedImage}</color>
<color=#75715e>     * with an {@code IndexColorModel}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage  the image to convert</color>
<color=#75715e>     * @param pColors number of colors in the resulting image</color>
<color=#75715e>     * @param pMatte  color to replace transparent parts of the original.</color>
<color=#75715e>     * @param pHints  hints controlling dither, transparency and color selection</color>
<color=#75715e>     * @return an indexed version of the given image</color>
<color=#75715e>     * @see #COLOR_SELECTION_DEFAULT</color>
<color=#75715e>     * @see #COLOR_SELECTION_FAST</color>
<color=#75715e>     * @see #COLOR_SELECTION_QUALITY</color>
<color=#75715e>     * @see #DITHER_NONE</color>
<color=#75715e>     * @see #DITHER_DEFAULT</color>
<color=#75715e>     * @see #DITHER_DIFFUSION</color>
<color=#75715e>     * @see #DITHER_DIFFUSION_ALTSCANS</color>
<color=#75715e>     * @see #TRANSPARENCY_DEFAULT</color>
<color=#75715e>     * @see #TRANSPARENCY_OPAQUE</color>
<color=#75715e>     * @see #TRANSPARENCY_BITMASK</color>
<color=#75715e>     * @see #TRANSPARENCY_TRANSLUCENT</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createIndexed</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pColors</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color> <color=#f8f8f2>pMatte</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>getIndexedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>),</color> <color=#f8f8f2>pColors</color><color=#f8f8f2>,</color> <color=#f8f8f2>pMatte</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates an indexed version of the given image (a {@code BufferedImage}</color>
<color=#75715e>     * with an {@code IndexColorModel}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage  the image to convert</color>
<color=#75715e>     * @param pColors the {@code IndexColorModel} to be used in the resulting</color>
<color=#75715e>     *                image.</color>
<color=#75715e>     * @param pMatte  color to replace transparent parts of the original.</color>
<color=#75715e>     * @param pHints  hints controlling dither, transparency and color selection</color>
<color=#75715e>     * @return an indexed version of the given image</color>
<color=#75715e>     * @see #COLOR_SELECTION_DEFAULT</color>
<color=#75715e>     * @see #COLOR_SELECTION_FAST</color>
<color=#75715e>     * @see #COLOR_SELECTION_QUALITY</color>
<color=#75715e>     * @see #DITHER_NONE</color>
<color=#75715e>     * @see #DITHER_DEFAULT</color>
<color=#75715e>     * @see #DITHER_DIFFUSION</color>
<color=#75715e>     * @see #DITHER_DIFFUSION_ALTSCANS</color>
<color=#75715e>     * @see #TRANSPARENCY_DEFAULT</color>
<color=#75715e>     * @see #TRANSPARENCY_OPAQUE</color>
<color=#75715e>     * @see #TRANSPARENCY_BITMASK</color>
<color=#75715e>     * @see #TRANSPARENCY_TRANSLUCENT</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createIndexed</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>IndexColorModel</color> <color=#f8f8f2>pColors</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color> <color=#f8f8f2>pMatte</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>getIndexedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>),</color> <color=#f8f8f2>pColors</color><color=#f8f8f2>,</color> <color=#f8f8f2>pMatte</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates an indexed version of the given image (a {@code BufferedImage}</color>
<color=#75715e>     * with an {@code IndexColorModel}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage  the image to convert</color>
<color=#75715e>     * @param pColors an {@code Image} used to get colors from. If the image is</color>
<color=#75715e>     *                has an {@code IndexColorModel}, it will be uesd, otherwise an</color>
<color=#75715e>     *                {@code IndexColorModel} is created from the image.</color>
<color=#75715e>     * @param pMatte  color to replace transparent parts of the original.</color>
<color=#75715e>     * @param pHints  hints controlling dither, transparency and color selection</color>
<color=#75715e>     * @return an indexed version of the given image</color>
<color=#75715e>     * @see #COLOR_SELECTION_DEFAULT</color>
<color=#75715e>     * @see #COLOR_SELECTION_FAST</color>
<color=#75715e>     * @see #COLOR_SELECTION_QUALITY</color>
<color=#75715e>     * @see #DITHER_NONE</color>
<color=#75715e>     * @see #DITHER_DEFAULT</color>
<color=#75715e>     * @see #DITHER_DIFFUSION</color>
<color=#75715e>     * @see #DITHER_DIFFUSION_ALTSCANS</color>
<color=#75715e>     * @see #TRANSPARENCY_DEFAULT</color>
<color=#75715e>     * @see #TRANSPARENCY_OPAQUE</color>
<color=#75715e>     * @see #TRANSPARENCY_BITMASK</color>
<color=#75715e>     * @see #TRANSPARENCY_TRANSLUCENT</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createIndexed</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>Image</color> <color=#f8f8f2>pColors</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color> <color=#f8f8f2>pMatte</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>getIndexedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>),</color>
                <color=#f8f8f2>IndexImage</color><color=#f8f8f2>.</color><color=#a6e22e>getIndexColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>pColors</color><color=#f8f8f2>,</color> <color=#ae81ff>255</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>),</color>
                <color=#f8f8f2>pMatte</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHints</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Sharpens an image using a convolution matrix.</color>
<color=#75715e>     * The sharpen kernel used, is defined by the following 3 by 3 matrix:</color>
<color=#75715e>     * <TABLE border="1" cellspacing="0"></color>
<color=#75715e>     * <TR><TD>0.0</TD><TD>-0.3</TD><TD>0.0</TD></TR></color>
<color=#75715e>     * <TR><TD>-0.3</TD><TD>2.2</TD><TD>-0.3</TD></TR></color>
<color=#75715e>     * <TR><TD>0.0</TD><TD>-0.3</TD><TD>0.0</TD></TR></color>
<color=#75715e>     * </TABLE></color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This is the same result returned as</color>
<color=#75715e>     * {@code sharpen(pOriginal, 0.3f)}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the BufferedImage to sharpen</color>
<color=#75715e>     * @return a new BufferedImage, containing the sharpened image.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>sharpen</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>convolve</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>SHARPEN_KERNEL</color><color=#f8f8f2>,</color> <color=#f8f8f2>EDGE_REFLECT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Sharpens an image using a convolution matrix.</color>
<color=#75715e>     * The sharpen kernel used, is defined by the following 3 by 3 matrix:</color>
<color=#75715e>     * <TABLE border="1" cellspacing="0"></color>
<color=#75715e>     * <TR><TD>0.0</TD><TD>-{@code pAmount}</TD><TD>0.0</TD></TR></color>
<color=#75715e>     * <TR><TD>-{@code pAmount}</TD></color>
<color=#75715e>     * <TD>4.0 * {@code pAmount} + 1.0</TD></color>
<color=#75715e>     * <TD>-{@code pAmount}</TD></TR></color>
<color=#75715e>     * <TR><TD>0.0</TD><TD>-{@code pAmount}</TD><TD>0.0</TD></TR></color>
<color=#75715e>     * </TABLE></color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the BufferedImage to sharpen</color>
<color=#75715e>     * @param pAmount   the amount of sharpening</color>
<color=#75715e>     * @return a BufferedImage, containing the sharpened image.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>sharpen</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>float</color> <color=#f8f8f2>pAmount</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pAmount</color> <color=#f92672>==</color> <color=#ae81ff>0f</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Create the convolution matrix</color>
        <color=#66d9ef>float</color><color=#f92672>[]</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>float</color><color=#f92672>[]</color><color=#f8f8f2>{</color>
                <color=#ae81ff>0.0f</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>pAmount</color><color=#f8f8f2>,</color> <color=#ae81ff>0.0f</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>pAmount</color><color=#f8f8f2>,</color> <color=#ae81ff>4f</color> <color=#f92672>*</color> <color=#f8f8f2>pAmount</color> <color=#f92672>+</color> <color=#ae81ff>1f</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>pAmount</color><color=#f8f8f2>,</color> <color=#ae81ff>0.0f</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>pAmount</color><color=#f8f8f2>,</color> <color=#ae81ff>0.0f</color>
        <color=#f8f8f2>};</color>

        <color=#75715e>// Do the filtering</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>convolve</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#f8f8f2>Kernel</color><color=#f8f8f2>(</color><color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>),</color> <color=#f8f8f2>EDGE_REFLECT</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a blurred version of the given image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the original image</color>
<color=#75715e>     * @return a new {@code BufferedImage} with a blurred version of the given image</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>blur</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>blur</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#ae81ff>1.5f</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>// Some work to do... Is okay now, for range 0...1, anything above creates</color>
    <color=#75715e>// artifacts.</color>
    <color=#75715e>// The idea here is that the sum of all terms in the matrix must be 1.</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a blurred version of the given image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the original image</color>
<color=#75715e>     * @param pRadius   the amount to blur</color>
<color=#75715e>     * @return a new {@code BufferedImage} with a blurred version of the given image</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>blur</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>float</color> <color=#f8f8f2>pRadius</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pRadius</color> <color=#f92672><=</color> <color=#ae81ff>1f</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// TODO: Re-implement using two-pass one-dimensional gaussion blur</color>
        <color=#75715e>// See: http://en.wikipedia.org/wiki/Gaussian_blur#Implementation</color>
        <color=#75715e>// Also see http://www.jhlabs.com/ip/blurring.html</color>

        <color=#75715e>// TODO: Rethink... Fixed amount and scale matrix instead?</color>
<color=#75715e>//        pAmount = 1f - pAmount;</color>
<color=#75715e>//        float pAmount = 1f - pRadius;</color>
<color=#75715e>//</color>
<color=#75715e>//        // Normalize amount</color>
<color=#75715e>//        float normAmt = (1f - pAmount) / 24;</color>
<color=#75715e>//</color>
<color=#75715e>//        // Create the convolution matrix</color>
<color=#75715e>//        float[] data = new float[] {</color>
<color=#75715e>//            normAmt / 2, normAmt, normAmt, normAmt, normAmt / 2,</color>
<color=#75715e>//            normAmt, normAmt, normAmt * 2, normAmt, normAmt,</color>
<color=#75715e>//            normAmt, normAmt * 2, pAmount, normAmt * 2, normAmt,</color>
<color=#75715e>//            normAmt, normAmt, normAmt * 2, normAmt, normAmt,</color>
<color=#75715e>//            normAmt / 2, normAmt, normAmt, normAmt, normAmt / 2</color>
<color=#75715e>//        };</color>
<color=#75715e>//</color>
<color=#75715e>//        // Do the filtering</color>
<color=#75715e>//        return convolve(pOriginal, new Kernel(5, 5, data), EDGE_REFLECT);</color>

        <color=#f8f8f2>Kernel</color> <color=#f8f8f2>horizontal</color> <color=#f92672>=</color> <color=#f8f8f2>makeKernel</color><color=#f8f8f2>(</color><color=#f8f8f2>pRadius</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>Kernel</color> <color=#f8f8f2>vertical</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Kernel</color><color=#f8f8f2>(</color><color=#f8f8f2>horizontal</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(),</color> <color=#f8f8f2>horizontal</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>horizontal</color><color=#f8f8f2>.</color><color=#a6e22e>getKernelData</color><color=#f8f8f2>(</color><color=#66d9ef>null</color><color=#f8f8f2>));</color>

        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>temp</color> <color=#f92672>=</color> <color=#f8f8f2>addBorder</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>horizontal</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#f8f8f2>vertical</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#f8f8f2>EDGE_REFLECT</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>temp</color> <color=#f92672>=</color> <color=#f8f8f2>convolve</color><color=#f8f8f2>(</color><color=#f8f8f2>temp</color><color=#f8f8f2>,</color> <color=#f8f8f2>horizontal</color><color=#f8f8f2>,</color> <color=#f8f8f2>EDGE_NO_OP</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>temp</color> <color=#f92672>=</color> <color=#f8f8f2>convolve</color><color=#f8f8f2>(</color><color=#f8f8f2>temp</color><color=#f8f8f2>,</color> <color=#f8f8f2>vertical</color><color=#f8f8f2>,</color> <color=#f8f8f2>EDGE_NO_OP</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>getSubimage</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>horizontal</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#f8f8f2>vertical</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()</color>
        <color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Make a Gaussian blur {@link Kernel}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param radius the blur radius</color>
<color=#75715e>     * @return a new blur {@code Kernel}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>Kernel</color> <color=#a6e22e>makeKernel</color><color=#f8f8f2>(</color><color=#66d9ef>float</color> <color=#f8f8f2>radius</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>r</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>ceil</color><color=#f8f8f2>(</color><color=#f8f8f2>radius</color><color=#f8f8f2>);</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>rows</color> <color=#f92672>=</color> <color=#f8f8f2>r</color> <color=#f92672>*</color> <color=#ae81ff>2</color> <color=#f92672>+</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>float</color><color=#f92672>[]</color> <color=#f8f8f2>matrix</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>float</color><color=#f92672>[</color><color=#f8f8f2>rows</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>float</color> <color=#f8f8f2>sigma</color> <color=#f92672>=</color> <color=#f8f8f2>radius</color> <color=#f92672>/</color> <color=#ae81ff>3</color><color=#f8f8f2>;</color>
        <color=#66d9ef>float</color> <color=#f8f8f2>sigma22</color> <color=#f92672>=</color> <color=#ae81ff>2</color> <color=#f92672>*</color> <color=#f8f8f2>sigma</color> <color=#f92672>*</color> <color=#f8f8f2>sigma</color><color=#f8f8f2>;</color>
        <color=#66d9ef>float</color> <color=#f8f8f2>sigmaPi2</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>float</color><color=#f8f8f2>)</color> <color=#f8f8f2>(</color><color=#ae81ff>2</color> <color=#f92672>*</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>PI</color> <color=#f92672>*</color> <color=#f8f8f2>sigma</color><color=#f8f8f2>);</color>
        <color=#66d9ef>float</color> <color=#f8f8f2>sqrtSigmaPi2</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>float</color><color=#f8f8f2>)</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>sqrt</color><color=#f8f8f2>(</color><color=#f8f8f2>sigmaPi2</color><color=#f8f8f2>);</color>
        <color=#66d9ef>float</color> <color=#f8f8f2>radius2</color> <color=#f92672>=</color> <color=#f8f8f2>radius</color> <color=#f92672>*</color> <color=#f8f8f2>radius</color><color=#f8f8f2>;</color>
        <color=#66d9ef>float</color> <color=#f8f8f2>total</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>index</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>row</color> <color=#f92672>=</color> <color=#f92672>-</color><color=#f8f8f2>r</color><color=#f8f8f2>;</color> <color=#f8f8f2>row</color> <color=#f92672><=</color> <color=#f8f8f2>r</color><color=#f8f8f2>;</color> <color=#f8f8f2>row</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>float</color> <color=#f8f8f2>distance</color> <color=#f92672>=</color> <color=#f8f8f2>row</color> <color=#f92672>*</color> <color=#f8f8f2>row</color><color=#f8f8f2>;</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>distance</color> <color=#f92672>></color> <color=#f8f8f2>radius2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>matrix</color><color=#f92672>[</color><color=#f8f8f2>index</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>matrix</color><color=#f92672>[</color><color=#f8f8f2>index</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#66d9ef>float</color><color=#f8f8f2>)</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>exp</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#f8f8f2>(</color><color=#f8f8f2>distance</color><color=#f8f8f2>)</color> <color=#f92672>/</color> <color=#f8f8f2>sigma22</color><color=#f8f8f2>)</color> <color=#f92672>/</color> <color=#f8f8f2>sqrtSigmaPi2</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>
            <color=#f8f8f2>total</color> <color=#f92672>+=</color> <color=#f8f8f2>matrix</color><color=#f92672>[</color><color=#f8f8f2>index</color><color=#f92672>]</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>index</color><color=#f92672>++</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>rows</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>matrix</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>/=</color> <color=#f8f8f2>total</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>Kernel</color><color=#f8f8f2>(</color><color=#f8f8f2>rows</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#f8f8f2>matrix</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>


    <color=#75715e>/**</color>
<color=#75715e>     * Convolves an image, using a convolution matrix.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal      the BufferedImage to sharpen</color>
<color=#75715e>     * @param pKernel        the kernel</color>
<color=#75715e>     * @param pEdgeOperation the edge operation. Must be one of {@link #EDGE_NO_OP},</color>
<color=#75715e>     *                       {@link #EDGE_ZERO_FILL}, {@link #EDGE_REFLECT} or {@link #EDGE_WRAP}</color>
<color=#75715e>     * @return a new BufferedImage, containing the sharpened image.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>convolve</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>Kernel</color> <color=#f8f8f2>pKernel</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pEdgeOperation</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Allow for 2 more edge operations</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>original</color><color=#f8f8f2>;</color>
        <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>pEdgeOperation</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>EDGE_REFLECT</color><color=#f8f8f2>:</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>EDGE_WRAP</color><color=#f8f8f2>:</color>
                <color=#f8f8f2>original</color> <color=#f92672>=</color> <color=#f8f8f2>addBorder</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>pKernel</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#f8f8f2>pKernel</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#f8f8f2>pEdgeOperation</color><color=#f8f8f2>);</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>
            <color=#66d9ef>default</color><color=#f8f8f2>:</color>
                <color=#f8f8f2>original</color> <color=#f92672>=</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>;</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Create convolution operation</color>
        <color=#f8f8f2>ConvolveOp</color> <color=#f8f8f2>convolve</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ConvolveOp</color><color=#f8f8f2>(</color><color=#f8f8f2>pKernel</color><color=#f8f8f2>,</color> <color=#f8f8f2>pEdgeOperation</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

        <color=#75715e>// Workaround for what seems to be a Java2D bug:</color>
        <color=#75715e>// ConvolveOp needs explicit destination image type for some "uncommon"</color>
        <color=#75715e>// image types. However, TYPE_3BYTE_BGR is what javax.imageio.ImageIO</color>
        <color=#75715e>// normally returns for color JPEGs... :-/</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>original</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_3BYTE_BGR</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>createBuffered</color><color=#f8f8f2>(</color>
                    <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(),</color>
                    <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>().</color><color=#a6e22e>getTransparency</color><color=#f8f8f2>()</color>
            <color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Do the filtering (if result is null, a new image will be created)</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>convolve</color><color=#f8f8f2>.</color><color=#a6e22e>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>original</color><color=#f8f8f2>,</color> <color=#f8f8f2>result</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color> <color=#f92672>!=</color> <color=#f8f8f2>original</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>// Remove the border</color>
            <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>image</color><color=#f8f8f2>.</color><color=#a6e22e>getSubimage</color><color=#f8f8f2>(</color>
                    <color=#f8f8f2>pKernel</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#f8f8f2>pKernel</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()</color>
            <color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>addBorder</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>pEdgeOperation</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// TODO: Might be faster if we could clone raster and strech it...</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>w</color> <color=#f92672>=</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>h</color> <color=#f92672>=</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>cm</color> <color=#f92672>=</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>WritableRaster</color> <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>createCompatibleWritableRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>w</color> <color=#f92672>+</color> <color=#ae81ff>2</color> <color=#f92672>*</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color> <color=#f92672>+</color> <color=#ae81ff>2</color> <color=#f92672>*</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>bordered</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>cm</color><color=#f8f8f2>,</color> <color=#f8f8f2>raster</color><color=#f8f8f2>,</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>isAlphaPremultiplied</color><color=#f8f8f2>(),</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>Graphics2D</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>bordered</color><color=#f8f8f2>.</color><color=#a6e22e>createGraphics</color><color=#f8f8f2>();</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setComposite</color><color=#f8f8f2>(</color><color=#f8f8f2>AlphaComposite</color><color=#f8f8f2>.</color><color=#a6e22e>Src</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setRenderingHint</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>KEY_DITHERING</color><color=#f8f8f2>,</color> <color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>VALUE_DITHER_DISABLE</color><color=#f8f8f2>);</color>

            <color=#75715e>// Draw original in center</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

            <color=#75715e>// TODO: I guess we need the top/left etc, if the corner pixels are covered by the kernel</color>
            <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>pEdgeOperation</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>EDGE_REFLECT</color><color=#f8f8f2>:</color>
                    <color=#75715e>// Top/left (empty)</color>
                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderX</color> <color=#f92672>+</color> <color=#f8f8f2>w</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>w</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Top/center</color>
                    <color=#75715e>// Top/right (empty)</color>

                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>w</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Center/left</color>
                    <color=#75715e>// Center/center (already drawn)</color>
                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>w</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#ae81ff>2</color> <color=#f92672>*</color> <color=#f8f8f2>pBorderX</color> <color=#f92672>+</color> <color=#f8f8f2>w</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#f8f8f2>w</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>w</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Center/right</color>

                    <color=#75715e>// Bottom/left (empty)</color>
                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderY</color> <color=#f92672>+</color> <color=#f8f8f2>h</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderX</color> <color=#f92672>+</color> <color=#f8f8f2>w</color><color=#f8f8f2>,</color> <color=#ae81ff>2</color> <color=#f92672>*</color> <color=#f8f8f2>pBorderY</color> <color=#f92672>+</color> <color=#f8f8f2>h</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#f8f8f2>w</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Bottom/center</color>
                    <color=#75715e>// Bottom/right (empty)</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>EDGE_WRAP</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>w</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>h</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Top/left</color>
                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>h</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Top/center</color>
                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>w</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>h</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Top/right</color>

                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>w</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Center/left</color>
                    <color=#75715e>// Center/center (already drawn)</color>
                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>w</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Center/right</color>

                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#f8f8f2>w</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Bottom/left</color>
                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Bottom/center</color>
                    <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>w</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderX</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color> <color=#f92672>+</color> <color=#f8f8f2>pBorderY</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color> <color=#75715e>// Bottom/right</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>default</color><color=#f8f8f2>:</color>
                    <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"Illegal edge operation "</color> <color=#f92672>+</color> <color=#f8f8f2>pEdgeOperation</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>//ConvolveTester.showIt(bordered, "jaffe");</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>bordered</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Adds contrast</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the BufferedImage to add contrast to</color>
<color=#75715e>     * @return an {@code Image}, containing the contrasted image.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>Image</color> <color=#a6e22e>contrast</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>contrast</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#ae81ff>0.3f</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Changes the contrast of the image</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the {@code Image} to change</color>
<color=#75715e>     * @param pAmount   the amount of contrast in the range [-1.0..1.0].</color>
<color=#75715e>     * @return an {@code Image}, containing the contrasted image.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>Image</color> <color=#a6e22e>contrast</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>float</color> <color=#f8f8f2>pAmount</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// No change, return original</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pAmount</color> <color=#f92672>==</color> <color=#ae81ff>0f</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Create filter</color>
        <color=#f8f8f2>RGBImageFilter</color> <color=#f8f8f2>filter</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BrightnessContrastFilter</color><color=#f8f8f2>(</color><color=#ae81ff>0f</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAmount</color><color=#f8f8f2>);</color>

        <color=#75715e>// Return contrast adjusted image</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>filter</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>


    <color=#75715e>/**</color>
<color=#75715e>     * Changes the brightness of the original image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the {@code Image} to change</color>
<color=#75715e>     * @param pAmount   the amount of brightness in the range [-2.0..2.0].</color>
<color=#75715e>     * @return an {@code Image}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>Image</color> <color=#a6e22e>brightness</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#66d9ef>float</color> <color=#f8f8f2>pAmount</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// No change, return original</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pAmount</color> <color=#f92672>==</color> <color=#ae81ff>0f</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Create filter</color>
        <color=#f8f8f2>RGBImageFilter</color> <color=#f8f8f2>filter</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BrightnessContrastFilter</color><color=#f8f8f2>(</color><color=#f8f8f2>pAmount</color><color=#f8f8f2>,</color> <color=#ae81ff>0f</color><color=#f8f8f2>);</color>

        <color=#75715e>// Return brightness adjusted image</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>filter</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>


    <color=#75715e>/**</color>
<color=#75715e>     * Converts an image to grayscale.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the image to convert.</color>
<color=#75715e>     * @return a new Image, containing the gray image data.</color>
<color=#75715e>     * @see GrayFilter</color>
<color=#75715e>     * @see RGBImageFilter</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>Image</color> <color=#a6e22e>grayscale</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Create filter</color>
        <color=#f8f8f2>RGBImageFilter</color> <color=#f8f8f2>filter</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>GrayFilter</color><color=#f8f8f2>();</color>

        <color=#75715e>// Convert to gray</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>filter</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Filters an image, using the given {@code ImageFilter}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pOriginal the original image</color>
<color=#75715e>     * @param pFilter   the filter to apply</color>
<color=#75715e>     * @return the new {@code Image}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>Image</color> <color=#a6e22e>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pOriginal</color><color=#f8f8f2>,</color> <color=#f8f8f2>ImageFilter</color> <color=#f8f8f2>pFilter</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Create a filtered source</color>
        <color=#f8f8f2>ImageProducer</color> <color=#f8f8f2>source</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>FilteredImageSource</color><color=#f8f8f2>(</color><color=#f8f8f2>pOriginal</color><color=#f8f8f2>.</color><color=#a6e22e>getSource</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pFilter</color><color=#f8f8f2>);</color>

        <color=#75715e>// Create new image</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>Toolkit</color><color=#f8f8f2>.</color><color=#a6e22e>getDefaultToolkit</color><color=#f8f8f2>().</color><color=#a6e22e>createImage</color><color=#f8f8f2>(</color><color=#f8f8f2>source</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Tries to use H/W-accelerated code for an image for display purposes.</color>
<color=#75715e>     * Note that transparent parts of the image might be replaced by solid</color>
<color=#75715e>     * color. Additional image information not used by the current diplay</color>
<color=#75715e>     * hardware may be discarded, like extra bith depth etc.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage any {@code Image}</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>accelerate</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>accelerate</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>DEFAULT_CONFIGURATION</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Tries to use H/W-accelerated code for an image for display purposes.</color>
<color=#75715e>     * Note that transparent parts of the image might be replaced by solid</color>
<color=#75715e>     * color. Additional image information not used by the current diplay</color>
<color=#75715e>     * hardware may be discarded, like extra bith depth etc.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage         any {@code Image}</color>
<color=#75715e>     * @param pConfiguration the {@code GraphicsConfiguration} to accelerate</color>
<color=#75715e>     *                       for</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>accelerate</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>GraphicsConfiguration</color> <color=#f8f8f2>pConfiguration</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>accelerate</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>,</color> <color=#f8f8f2>pConfiguration</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Tries to use H/W-accelerated code for an image for display purposes.</color>
<color=#75715e>     * Note that transparent parts of the image will be replaced by solid</color>
<color=#75715e>     * color. Additional image information not used by the current diplay</color>
<color=#75715e>     * hardware may be discarded, like extra bith depth etc.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage           any {@code Image}</color>
<color=#75715e>     * @param pBackgroundColor the background color to replace any transparent</color>
<color=#75715e>     *                         parts of the image.</color>
<color=#75715e>     *                         May be {@code null}, in such case the color is undefined.</color>
<color=#75715e>     * @param pConfiguration   the graphics configuration</color>
<color=#75715e>     *                         May be {@code null}, in such case the color is undefined.</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>accelerate</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color> <color=#f8f8f2>pBackgroundColor</color><color=#f8f8f2>,</color> <color=#f8f8f2>GraphicsConfiguration</color> <color=#f8f8f2>pConfiguration</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Skip acceleration if the layout of the image and color model is already ok</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>buffered</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>;</color>
            <color=#75715e>// TODO: What if the createCompatibleImage insist on TYPE_CUSTOM...? :-P</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_CUSTOM</color> <color=#f92672>&&</color> <color=#f8f8f2>equals</color><color=#f8f8f2>(</color><color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pConfiguration</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getTransparency</color><color=#f8f8f2>())))</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>return</color> <color=#f8f8f2>buffered</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"image == null"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>w</color> <color=#f92672>=</color> <color=#f8f8f2>ImageUtil</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>);</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>h</color> <color=#f92672>=</color> <color=#f8f8f2>ImageUtil</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>);</color>

        <color=#75715e>// Create accelerated version</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>temp</color> <color=#f92672>=</color> <color=#f8f8f2>createClear</color><color=#f8f8f2>(</color><color=#f8f8f2>w</color><color=#f8f8f2>,</color> <color=#f8f8f2>h</color><color=#f8f8f2>,</color> <color=#f8f8f2>BI_TYPE_ANY</color><color=#f8f8f2>,</color> <color=#f8f8f2>getTransparency</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>),</color> <color=#f8f8f2>pBackgroundColor</color><color=#f8f8f2>,</color> <color=#f8f8f2>pConfiguration</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>drawOnto</color><color=#f8f8f2>(</color><color=#f8f8f2>temp</color><color=#f8f8f2>,</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>temp</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>getTransparency</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>bi</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>;</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>bi</color><color=#f8f8f2>.</color><color=#a6e22e>getTransparency</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>OPAQUE</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a transparent image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pWidth  the requested width of the image</color>
<color=#75715e>     * @param pHeight the requested height of the image</color>
<color=#75715e>     * @return the new image</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pType} is not a valid type</color>
<color=#75715e>     *                                  for {@code BufferedImage}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createTransparent</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>createTransparent</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>BI_TYPE_ANY</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a transparent image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pWidth  the requested width of the image</color>
<color=#75715e>     * @param pHeight the requested height of the image</color>
<color=#75715e>     * @param pType   the type of {@code BufferedImage} to create</color>
<color=#75715e>     * @return the new image</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pType} is not a valid type</color>
<color=#75715e>     *                                  for {@code BufferedImage}</color>
<color=#75715e>     * @see BufferedImage#BufferedImage(int, int, int)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createTransparent</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Create</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>createBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSLUCENT</color><color=#f8f8f2>);</color>

        <color=#75715e>// Clear image with transparent alpha by drawing a rectangle</color>
        <color=#f8f8f2>Graphics2D</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>image</color><color=#f8f8f2>.</color><color=#a6e22e>createGraphics</color><color=#f8f8f2>();</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setComposite</color><color=#f8f8f2>(</color><color=#f8f8f2>AlphaComposite</color><color=#f8f8f2>.</color><color=#a6e22e>Clear</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>fillRect</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a clear image with the given background color.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pWidth      the requested width of the image</color>
<color=#75715e>     * @param pHeight     the requested height of the image</color>
<color=#75715e>     * @param pBackground the background color. The color may be translucent.</color>
<color=#75715e>     *                    May be {@code null}, in such case the color is undefined.</color>
<color=#75715e>     * @return the new image</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pType} is not a valid type</color>
<color=#75715e>     *                                  for {@code BufferedImage}</color>
<color=#75715e>     * @see BufferedImage#BufferedImage(int, int, int)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createClear</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color> <color=#f8f8f2>pBackground</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>createClear</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>BI_TYPE_ANY</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBackground</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a clear image with the given background color.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pWidth      the width of the image to create</color>
<color=#75715e>     * @param pHeight     the height of the image to create</color>
<color=#75715e>     * @param pType       the type of image to create (one of the constants from</color>
<color=#75715e>     *                    {@link BufferedImage} or {@link #BI_TYPE_ANY})</color>
<color=#75715e>     * @param pBackground the background color. The color may be translucent.</color>
<color=#75715e>     *                    May be {@code null}, in such case the color is undefined.</color>
<color=#75715e>     * @return the new image</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pType} is not a valid type</color>
<color=#75715e>     *                                  for {@code BufferedImage}</color>
<color=#75715e>     * @see BufferedImage#BufferedImage(int, int, int)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createClear</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color> <color=#f8f8f2>pBackground</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>createClear</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>OPAQUE</color><color=#f8f8f2>,</color> <color=#f8f8f2>pBackground</color><color=#f8f8f2>,</color> <color=#f8f8f2>DEFAULT_CONFIGURATION</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createClear</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color> <color=#f8f8f2>pBackground</color><color=#f8f8f2>,</color> <color=#f8f8f2>GraphicsConfiguration</color> <color=#f8f8f2>pConfiguration</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Create</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>transparency</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>pBackground</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f92672>?</color> <color=#f8f8f2>pBackground</color><color=#f8f8f2>.</color><color=#a6e22e>getTransparency</color><color=#f8f8f2>()</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>createBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>transparency</color><color=#f8f8f2>,</color> <color=#f8f8f2>pConfiguration</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pBackground</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>// Clear image with clear color, by drawing a rectangle</color>
            <color=#f8f8f2>Graphics2D</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>image</color><color=#f8f8f2>.</color><color=#a6e22e>createGraphics</color><color=#f8f8f2>();</color>
            <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setComposite</color><color=#f8f8f2>(</color><color=#f8f8f2>AlphaComposite</color><color=#f8f8f2>.</color><color=#a6e22e>Src</color><color=#f8f8f2>);</color>  <color=#75715e>// Allow color to be translucent</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setColor</color><color=#f8f8f2>(</color><color=#f8f8f2>pBackground</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>fillRect</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a {@code BufferedImage} of the given size and type. If possible,</color>
<color=#75715e>     * uses accelerated versions of BufferedImage from GraphicsConfiguration.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pWidth        the width of the image to create</color>
<color=#75715e>     * @param pHeight       the height of the image to create</color>
<color=#75715e>     * @param pType         the type of image to create (one of the constants from</color>
<color=#75715e>     *                      {@link BufferedImage} or {@link #BI_TYPE_ANY})</color>
<color=#75715e>     * @param pTransparency the transparency type (from {@link Transparency})</color>
<color=#75715e>     * @return a {@code BufferedImage}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createBuffered</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>createBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>,</color> <color=#f8f8f2>DEFAULT_CONFIGURATION</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createBuffered</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>,</color>
                                        <color=#f8f8f2>GraphicsConfiguration</color> <color=#f8f8f2>pConfiguration</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>VM_SUPPORTS_ACCELERATION</color> <color=#f92672>&&</color> <color=#f8f8f2>pType</color> <color=#f92672>==</color> <color=#f8f8f2>BI_TYPE_ANY</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>GraphicsEnvironment</color> <color=#f8f8f2>env</color> <color=#f92672>=</color> <color=#f8f8f2>GraphicsEnvironment</color><color=#f8f8f2>.</color><color=#a6e22e>getLocalGraphicsEnvironment</color><color=#f8f8f2>();</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>supportsAcceleration</color><color=#f8f8f2>(</color><color=#f8f8f2>env</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>return</color> <color=#f8f8f2>getConfiguration</color><color=#f8f8f2>(</color><color=#f8f8f2>pConfiguration</color><color=#f8f8f2>).</color><color=#a6e22e>createCompatibleImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>pHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>getImageType</color><color=#f8f8f2>(</color><color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>GraphicsConfiguration</color> <color=#a6e22e>getConfiguration</color><color=#f8f8f2>(</color><color=#66d9ef>final</color> <color=#f8f8f2>GraphicsConfiguration</color> <color=#f8f8f2>pConfiguration</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>pConfiguration</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>?</color> <color=#f8f8f2>pConfiguration</color> <color=#f8f8f2>:</color> <color=#f8f8f2>DEFAULT_CONFIGURATION</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>getImageType</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pType</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// TODO: Handle TYPE_CUSTOM?</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pType</color> <color=#f92672>!=</color> <color=#f8f8f2>BI_TYPE_ANY</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>pType</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>pTransparency</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>OPAQUE</color><color=#f8f8f2>:</color>
                    <color=#66d9ef>return</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_RGB</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>BITMASK</color><color=#f8f8f2>:</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSLUCENT</color><color=#f8f8f2>:</color>
                    <color=#66d9ef>return</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_ARGB</color><color=#f8f8f2>;</color>
                <color=#66d9ef>default</color><color=#f8f8f2>:</color>
                    <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"Unknown transparency type: "</color> <color=#f92672>+</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Tests if the given {@code GraphicsEnvironment} supports accelleration</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pEnv the environment</color>
<color=#75715e>     * @return {@code true} if the {@code GraphicsEnvironment} supports</color>
<color=#75715e>     * acceleration</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#a6e22e>supportsAcceleration</color><color=#f8f8f2>(</color><color=#f8f8f2>GraphicsEnvironment</color> <color=#f8f8f2>pEnv</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#75715e>// Acceleration only supported in non-headless environments, on 1.4+ VMs</color>
            <color=#66d9ef>return</color> <color=#75715e>/*VM_SUPPORTS_ACCELERATION &&*/</color> <color=#f92672>!</color><color=#f8f8f2>pEnv</color><color=#f8f8f2>.</color><color=#a6e22e>isHeadlessInstance</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>LinkageError</color> <color=#f8f8f2>ignore</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>// Means we are not in a 1.4+ VM, so skip testing for headless again</color>
            <color=#f8f8f2>VM_SUPPORTS_ACCELERATION</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// If the invocation fails, assume no accelleration is possible</color>
        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Gets the width of an Image.</color>
<color=#75715e>     * This method has the side-effect of completely loading the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage an image.</color>
<color=#75715e>     * @return the width of the image, or -1 if the width could not be</color>
<color=#75715e>     * determined (i.e. an error occured while waiting for the</color>
<color=#75715e>     * image to load).</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>getWidth</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>width</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(</color><color=#f8f8f2>NULL_COMPONENT</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>width</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>waitForImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>return</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>  <color=#75715e>// Error while waiting</color>
            <color=#f8f8f2>}</color>
            <color=#f8f8f2>width</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(</color><color=#f8f8f2>NULL_COMPONENT</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>width</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Gets the height of an Image.</color>
<color=#75715e>     * This method has the side-effect of completely loading the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage an image.</color>
<color=#75715e>     * @return the height of the image, or -1 if the height could not be</color>
<color=#75715e>     * determined (i.e. an error occured while waiting for the</color>
<color=#75715e>     * image to load).</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>getHeight</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>height</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(</color><color=#f8f8f2>NULL_COMPONENT</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>height</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>waitForImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>return</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>  <color=#75715e>// Error while waiting</color>
            <color=#f8f8f2>}</color>
            <color=#f8f8f2>height</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(</color><color=#f8f8f2>NULL_COMPONENT</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>height</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Waits for an image to load completely.</color>
<color=#75715e>     * Will wait forever.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage an Image object to wait for.</color>
<color=#75715e>     * @return true if the image was loaded successfully, false if an error</color>
<color=#75715e>     * occured, or the wait was interrupted.</color>
<color=#75715e>     * @see #waitForImage(Image, long)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#a6e22e>waitForImage</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>waitForImages</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>Image</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#f8f8f2>pImage</color><color=#f8f8f2>},</color> <color=#f92672>-</color><color=#ae81ff>1L</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Waits for an image to load completely.</color>
<color=#75715e>     * Will wait the specified time.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage   an Image object to wait for.</color>
<color=#75715e>     * @param pTimeOut the time to wait, in milliseconds.</color>
<color=#75715e>     * @return true if the image was loaded successfully, false if an error</color>
<color=#75715e>     * occurred, or the wait was interrupted.</color>
<color=#75715e>     * @see #waitForImages(Image[], long)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#a6e22e>waitForImage</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>pTimeOut</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>waitForImages</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>Image</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#f8f8f2>pImage</color><color=#f8f8f2>},</color> <color=#f8f8f2>pTimeOut</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Waits for a number of images to load completely.</color>
<color=#75715e>     * Will wait forever.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImages an array of Image objects to wait for.</color>
<color=#75715e>     * @return true if the images was loaded successfully, false if an error</color>
<color=#75715e>     * occurred, or the wait was interrupted.</color>
<color=#75715e>     * @see #waitForImages(Image[], long)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#a6e22e>waitForImages</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color><color=#f92672>[]</color> <color=#f8f8f2>pImages</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>waitForImages</color><color=#f8f8f2>(</color><color=#f8f8f2>pImages</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1L</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Waits for a number of images to load completely.</color>
<color=#75715e>     * Will wait the specified time.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImages  an array of Image objects to wait for</color>
<color=#75715e>     * @param pTimeOut the time to wait, in milliseconds</color>
<color=#75715e>     * @return true if the images was loaded successfully, false if an error</color>
<color=#75715e>     * occurred, or the wait was interrupted.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#a6e22e>waitForImages</color><color=#f8f8f2>(</color><color=#f8f8f2>Image</color><color=#f92672>[]</color> <color=#f8f8f2>pImages</color><color=#f8f8f2>,</color> <color=#66d9ef>long</color> <color=#f8f8f2>pTimeOut</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// TODO: Need to make sure that we don't wait for the same image many times</color>
        <color=#75715e>// Use hashcode as id? Don't remove images from tracker? Hmmm...</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

        <color=#75715e>// Create a local id for use with the mediatracker</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>imageId</color><color=#f8f8f2>;</color>

        <color=#75715e>// NOTE: This is very experimental...</color>
        <color=#f8f8f2>imageId</color> <color=#f92672>=</color> <color=#f8f8f2>pImages</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>==</color> <color=#ae81ff>1</color> <color=#f92672>?</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>identityHashCode</color><color=#f8f8f2>(</color><color=#f8f8f2>pImages</color><color=#f92672>[</color><color=#ae81ff>0</color><color=#f92672>]</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>identityHashCode</color><color=#f8f8f2>(</color><color=#f8f8f2>pImages</color><color=#f8f8f2>);</color>

        <color=#75715e>// Add images to tracker</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>image</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pImages</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>sTracker</color><color=#f8f8f2>.</color><color=#a6e22e>addImage</color><color=#f8f8f2>(</color><color=#f8f8f2>image</color><color=#f8f8f2>,</color> <color=#f8f8f2>imageId</color><color=#f8f8f2>);</color>

            <color=#75715e>// Start loading immediately</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>sTracker</color><color=#f8f8f2>.</color><color=#a6e22e>checkID</color><color=#f8f8f2>(</color><color=#f8f8f2>imageId</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#75715e>// Image is done, so remove again</color>
                <color=#f8f8f2>sTracker</color><color=#f8f8f2>.</color><color=#a6e22e>removeImage</color><color=#f8f8f2>(</color><color=#f8f8f2>image</color><color=#f8f8f2>,</color> <color=#f8f8f2>imageId</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pTimeOut</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>L</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#75715e>// Just wait</color>
                <color=#f8f8f2>sTracker</color><color=#f8f8f2>.</color><color=#a6e22e>waitForID</color><color=#f8f8f2>(</color><color=#f8f8f2>imageId</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#75715e>// Wait until timeout</color>
                <color=#75715e>// NOTE: waitForID(int, long) return value is undocumented.</color>
                <color=#75715e>// I assume that it returns true, if the image(s) loaded</color>
                <color=#75715e>// successfully before the timeout, however, I always check</color>
                <color=#75715e>// isErrorID later on, just in case...</color>
                <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#f8f8f2>sTracker</color><color=#f8f8f2>.</color><color=#a6e22e>waitForID</color><color=#f8f8f2>(</color><color=#f8f8f2>imageId</color><color=#f8f8f2>,</color> <color=#f8f8f2>pTimeOut</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>InterruptedException</color> <color=#f8f8f2>ie</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>// Interrupted while waiting, image not loaded</color>
            <color=#f8f8f2>success</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
            <color=#75715e>// Remove images from mediatracker</color>
            <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#f8f8f2>Image</color> <color=#f8f8f2>pImage</color> <color=#f8f8f2>:</color> <color=#f8f8f2>pImages</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>sTracker</color><color=#f8f8f2>.</color><color=#a6e22e>removeImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>imageId</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// If the wait was successfull, and no errors were reported for the</color>
        <color=#75715e>// images, return true</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>success</color> <color=#f92672>&&</color> <color=#f92672>!</color><color=#f8f8f2>sTracker</color><color=#f8f8f2>.</color><color=#a6e22e>isErrorID</color><color=#f8f8f2>(</color><color=#f8f8f2>imageId</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Tests whether the image has any transparent or semi-transparent pixels.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the image</color>
<color=#75715e>     * @param pFast  if {@code true}, the method tests maximum 10 x 10 pixels,</color>
<color=#75715e>     *               evenly spaced out in the image.</color>
<color=#75715e>     * @return {@code true} if transparent pixels are found, otherwise</color>
<color=#75715e>     * {@code false}.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>boolean</color> <color=#a6e22e>hasTransparentPixels</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderedImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pFast</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// First, test if the ColorModel supports alpha...</color>
        <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>cm</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>();</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>hasAlpha</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>getTransparency</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>BITMASK</color>
                <color=#f92672>&&</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>getTransparency</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSLUCENT</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// ... if so, test the pixels of the image hard way</color>
        <color=#f8f8f2>Object</color> <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

        <color=#75715e>// Loop over tiles (noramally, BufferedImages have only one)</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>yT</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getMinTileY</color><color=#f8f8f2>();</color> <color=#f8f8f2>yT</color> <color=#f92672><</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getNumYTiles</color><color=#f8f8f2>();</color> <color=#f8f8f2>yT</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>xT</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getMinTileX</color><color=#f8f8f2>();</color> <color=#f8f8f2>xT</color> <color=#f92672><</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getNumXTiles</color><color=#f8f8f2>();</color> <color=#f8f8f2>xT</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#75715e>// Test pixels of each tile</color>
                <color=#f8f8f2>Raster</color> <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getTile</color><color=#f8f8f2>(</color><color=#f8f8f2>xT</color><color=#f8f8f2>,</color> <color=#f8f8f2>yT</color><color=#f8f8f2>);</color>
                <color=#66d9ef>int</color> <color=#f8f8f2>xIncrement</color> <color=#f92672>=</color> <color=#f8f8f2>pFast</color> <color=#f92672>?</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>max</color><color=#f8f8f2>(</color><color=#f8f8f2>raster</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>10</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
                <color=#66d9ef>int</color> <color=#f8f8f2>yIncrement</color> <color=#f92672>=</color> <color=#f8f8f2>pFast</color> <color=#f92672>?</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>max</color><color=#f8f8f2>(</color><color=#f8f8f2>raster</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()</color> <color=#f92672>/</color> <color=#ae81ff>10</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>

                <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>y</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>y</color> <color=#f92672><</color> <color=#f8f8f2>raster</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color> <color=#f8f8f2>y</color> <color=#f92672>+=</color> <color=#f8f8f2>yIncrement</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                    <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>x</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>x</color> <color=#f92672><</color> <color=#f8f8f2>raster</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color> <color=#f8f8f2>x</color> <color=#f92672>+=</color> <color=#f8f8f2>xIncrement</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                        <color=#75715e>// Copy data for each pixel, without allocation array</color>
                        <color=#f8f8f2>data</color> <color=#f92672>=</color> <color=#f8f8f2>raster</color><color=#f8f8f2>.</color><color=#a6e22e>getDataElements</color><color=#f8f8f2>(</color><color=#f8f8f2>x</color><color=#f8f8f2>,</color> <color=#f8f8f2>y</color><color=#f8f8f2>,</color> <color=#f8f8f2>data</color><color=#f8f8f2>);</color>

                        <color=#75715e>// Test alpha value</color>
                        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>getAlpha</color><color=#f8f8f2>(</color><color=#f8f8f2>data</color><color=#f8f8f2>)</color> <color=#f92672>!=</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                            <color=#66d9ef>return</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>
                        <color=#f8f8f2>}</color>
                    <color=#f8f8f2>}</color>
                <color=#f8f8f2>}</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates a translucent version of the given color.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pColor        the original color</color>
<color=#75715e>     * @param pTransparency the transparency level ({@code 0 - 255})</color>
<color=#75715e>     * @return a translucent color</color>
<color=#75715e>     * @throws NullPointerException if {@code pColor} is {@code null}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>Color</color> <color=#a6e22e>createTranslucent</color><color=#f8f8f2>(</color><color=#f8f8f2>Color</color> <color=#f8f8f2>pColor</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pTransparency</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>//return new Color(pColor.getRed(), pColor.getGreen(), pColor.getBlue(), pTransparency);</color>
        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>Color</color><color=#f8f8f2>(((</color><color=#f8f8f2>pTransparency</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>24</color><color=#f8f8f2>)</color> <color=#f92672>|</color> <color=#f8f8f2>(</color><color=#f8f8f2>pColor</color><color=#f8f8f2>.</color><color=#a6e22e>getRGB</color><color=#f8f8f2>()</color> <color=#f92672>&</color> <color=#ae81ff>0x00ffffff</color><color=#f8f8f2>),</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Blends two ARGB values half and half, to create a tone in between.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pRGB1 color 1</color>
<color=#75715e>     * @param pRGB2 color 2</color>
<color=#75715e>     * @return the new rgb value</color>
<color=#75715e>     */</color>
    <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>blend</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>pRGB1</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>pRGB2</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Slightly modified from http://www.compuphase.com/graphic/scale3.htm</color>
        <color=#75715e>// to support alpha values</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>(((</color><color=#f8f8f2>pRGB1</color> <color=#f92672>^</color> <color=#f8f8f2>pRGB2</color><color=#f8f8f2>)</color> <color=#f92672>&</color> <color=#ae81ff>0xfefefefe</color><color=#f8f8f2>)</color> <color=#f92672>>></color> <color=#ae81ff>1</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>pRGB1</color> <color=#f92672>&</color> <color=#f8f8f2>pRGB2</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Blends two colors half and half, to create a tone in between.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pColor color 1</color>
<color=#75715e>     * @param pOther color 2</color>
<color=#75715e>     * @return a new {@code Color}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>Color</color> <color=#a6e22e>blend</color><color=#f8f8f2>(</color><color=#f8f8f2>Color</color> <color=#f8f8f2>pColor</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color> <color=#f8f8f2>pOther</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>Color</color><color=#f8f8f2>(</color><color=#f8f8f2>blend</color><color=#f8f8f2>(</color><color=#f8f8f2>pColor</color><color=#f8f8f2>.</color><color=#a6e22e>getRGB</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pOther</color><color=#f8f8f2>.</color><color=#a6e22e>getRGB</color><color=#f8f8f2>()),</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>        return new Color((pColor.getRed() + pOther.getRed()) / 2,</color>
<color=#75715e>                (pColor.getGreen() + pOther.getGreen()) / 2,</color>
<color=#75715e>                (pColor.getBlue() + pOther.getBlue()) / 2,</color>
<color=#75715e>                (pColor.getAlpha() + pOther.getAlpha()) / 2);</color>
<color=#75715e>                */</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Blends two colors, controlled by the blending factor.</color>
<color=#75715e>     * A factor of {@code 0.0} will return the first color,</color>
<color=#75715e>     * a factor of {@code 1.0} will return the second.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pColor       color 1</color>
<color=#75715e>     * @param pOther       color 2</color>
<color=#75715e>     * @param pBlendFactor {@code [0...1]}</color>
<color=#75715e>     * @return a new {@code Color}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>Color</color> <color=#a6e22e>blend</color><color=#f8f8f2>(</color><color=#f8f8f2>Color</color> <color=#f8f8f2>pColor</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color> <color=#f8f8f2>pOther</color><color=#f8f8f2>,</color> <color=#66d9ef>float</color> <color=#f8f8f2>pBlendFactor</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>float</color> <color=#f8f8f2>inverseBlend</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#ae81ff>1f</color> <color=#f92672>-</color> <color=#f8f8f2>pBlendFactor</color><color=#f8f8f2>);</color>
        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>Color</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>clamp</color><color=#f8f8f2>((</color><color=#f8f8f2>pColor</color><color=#f8f8f2>.</color><color=#a6e22e>getRed</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>inverseBlend</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOther</color><color=#f8f8f2>.</color><color=#a6e22e>getRed</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>pBlendFactor</color><color=#f8f8f2>)),</color>
                <color=#f8f8f2>clamp</color><color=#f8f8f2>((</color><color=#f8f8f2>pColor</color><color=#f8f8f2>.</color><color=#a6e22e>getGreen</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>inverseBlend</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOther</color><color=#f8f8f2>.</color><color=#a6e22e>getGreen</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>pBlendFactor</color><color=#f8f8f2>)),</color>
                <color=#f8f8f2>clamp</color><color=#f8f8f2>((</color><color=#f8f8f2>pColor</color><color=#f8f8f2>.</color><color=#a6e22e>getBlue</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>inverseBlend</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOther</color><color=#f8f8f2>.</color><color=#a6e22e>getBlue</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>pBlendFactor</color><color=#f8f8f2>)),</color>
                <color=#f8f8f2>clamp</color><color=#f8f8f2>((</color><color=#f8f8f2>pColor</color><color=#f8f8f2>.</color><color=#a6e22e>getAlpha</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>inverseBlend</color><color=#f8f8f2>)</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>pOther</color><color=#f8f8f2>.</color><color=#a6e22e>getAlpha</color><color=#f8f8f2>()</color> <color=#f92672>*</color> <color=#f8f8f2>pBlendFactor</color><color=#f8f8f2>))</color>
        <color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>int</color> <color=#a6e22e>clamp</color><color=#f8f8f2>(</color><color=#66d9ef>float</color> <color=#f8f8f2>f</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>f</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>