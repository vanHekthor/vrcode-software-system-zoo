<color=#75715e>/*</color>
<color=#75715e> * Copyright (c) 2008, Harald Kuhr</color>
<color=#75715e> * All rights reserved.</color>
<color=#75715e> *</color>
<color=#75715e> * Redistribution and use in source and binary forms, with or without</color>
<color=#75715e> * modification, are permitted provided that the following conditions are met:</color>
<color=#75715e> *</color>
<color=#75715e> * * Redistributions of source code must retain the above copyright notice, this</color>
<color=#75715e> *   list of conditions and the following disclaimer.</color>
<color=#75715e> *</color>
<color=#75715e> * * Redistributions in binary form must reproduce the above copyright notice,</color>
<color=#75715e> *   this list of conditions and the following disclaimer in the documentation</color>
<color=#75715e> *   and/or other materials provided with the distribution.</color>
<color=#75715e> *</color>
<color=#75715e> * * Neither the name of the copyright holder nor the names of its</color>
<color=#75715e> *   contributors may be used to endorse or promote products derived from</color>
<color=#75715e> *   this software without specific prior written permission.</color>
<color=#75715e> *</color>
<color=#75715e> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</color>
<color=#75715e> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</color>
<color=#75715e> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</color>
<color=#75715e> * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</color>
<color=#75715e> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</color>
<color=#75715e> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</color>
<color=#75715e> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</color>
<color=#75715e> * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</color>
<color=#75715e> * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</color>
<color=#75715e> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</color>
<color=#75715e> */</color>

<color=#f92672>package</color> <color=#f8f8f2>com.twelvemonkeys.image</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>magick.ImageType</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>magick.MagickException</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>magick.MagickImage</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>magick.PixelPacket</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>java.awt.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.color.ColorSpace</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.color.ICC_ColorSpace</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.color.ICC_Profile</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.image.*</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * Utility for converting JMagick {@code MagickImage}s to standard Java</color>
<color=#75715e> * {@code BufferedImage}s and back.</color>
<color=#75715e> * <p/></color>
<color=#75715e> * <em>NOTE: This class is considered an implementation detail and not part of</color>
<color=#75715e> * the public API. This class is subject to change without further notice.</color>
<color=#75715e> * You have been warned. :-)</em></color>
<color=#75715e> *</color>
<color=#75715e> * @author <a href="mailto:harald.kuhr@gmail.com">Harald Kuhr</a></color>
<color=#75715e> * @version $Id: //depot/branches/personal/haraldk/twelvemonkeys/release-2/twelvemonkeys-core/src/main/java/com/twelvemonkeys/image/MagickUtil.java#4 $</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>final</color> <color=#66d9ef>class</color> <color=#a6e22e>MagickUtil</color> <color=#f8f8f2>{</color>
    <color=#75715e>// IMPORTANT NOTE: Disaster happens if any of these constants are used outside this class</color>
    <color=#75715e>// because you then have a dependency on MagickException (this is due to Java class loading</color>
    <color=#75715e>// and initialization magic).</color>
    <color=#75715e>// Do not use outside this class. If the constants need to be shared, move to Magick or ImageUtil.</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Color Model usesd for bilevel (B/W)</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>IndexColorModel</color> <color=#f8f8f2>CM_MONOCHROME</color> <color=#f92672>=</color> <color=#f8f8f2>MonochromeColorModel</color><color=#f8f8f2>.</color><color=#a6e22e>getInstance</color><color=#f8f8f2>();</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Color Model usesd for raw ABGR</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>CM_COLOR_ALPHA</color> <color=#f92672>=</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>ComponentColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>getInstance</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>CS_sRGB</color><color=#f8f8f2>),</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>8</color><color=#f8f8f2>,</color> <color=#ae81ff>8</color><color=#f8f8f2>,</color> <color=#ae81ff>8</color><color=#f8f8f2>,</color> <color=#ae81ff>8</color><color=#f8f8f2>},</color>
                    <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSLUCENT</color><color=#f8f8f2>,</color> <color=#f8f8f2>DataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Color Model usesd for raw BGR</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>CM_COLOR_OPAQUE</color> <color=#f92672>=</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>ComponentColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>getInstance</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>CS_sRGB</color><color=#f8f8f2>),</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>8</color><color=#f8f8f2>,</color> <color=#ae81ff>8</color><color=#f8f8f2>,</color> <color=#ae81ff>8</color><color=#f8f8f2>},</color>
                    <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>OPAQUE</color><color=#f8f8f2>,</color> <color=#f8f8f2>DataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE</color><color=#f8f8f2>);</color>

    <color=#75715e>/** Color Model usesd for raw RGB */</color>
    <color=#75715e>//private static final ColorModel CM_COLOR_RGB = new DirectColorModel(24, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x0);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Color Model usesd for raw GRAY + ALPHA</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>CM_GRAY_ALPHA</color> <color=#f92672>=</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>ComponentColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>getInstance</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>CS_GRAY</color><color=#f8f8f2>),</color>
                    <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSLUCENT</color><color=#f8f8f2>,</color> <color=#f8f8f2>DataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Color Model usesd for raw GRAY</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>CM_GRAY_OPAQUE</color> <color=#f92672>=</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>ComponentColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>getInstance</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>CS_GRAY</color><color=#f8f8f2>),</color>
                    <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>OPAQUE</color><color=#f8f8f2>,</color> <color=#f8f8f2>DataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Band offsets for raw ABGR</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>BAND_OFF_TRANS</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>};</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Band offsets for raw BGR</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>BAND_OFF_OPAQUE</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>};</color>

    <color=#75715e>/**</color>
<color=#75715e>     * The point at {@code 0, 0}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>Point</color> <color=#f8f8f2>LOCATION_UPPER_LEFT</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>Point</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>DEBUG</color> <color=#f92672>=</color> <color=#f8f8f2>Magick</color><color=#f8f8f2>.</color><color=#a6e22e>DEBUG</color><color=#f8f8f2>;</color>

    <color=#75715e>// Only static members and methods</color>
    <color=#66d9ef>private</color> <color=#a6e22e>MagickUtil</color><color=#f8f8f2>()</color> <color=#f8f8f2>{</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts a {@code MagickImage} to a {@code BufferedImage}.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * The conversion depends on {@code pImage}'s {@code ImageType}:</color>
<color=#75715e>     * <dl></color>
<color=#75715e>     * <dt>{@code ImageType.BilevelType}</dt></color>
<color=#75715e>     * <dd>{@code BufferedImage} of type {@code TYPE_BYTE_BINARY}</dd></color>
<color=#75715e>     *</color>
<color=#75715e>     * <dt>{@code ImageType.GrayscaleType}</dt></color>
<color=#75715e>     * <dd>{@code BufferedImage} of type {@code TYPE_BYTE_GRAY}</dd></color>
<color=#75715e>     * <dt>{@code ImageType.GrayscaleMatteType}</dt></color>
<color=#75715e>     * <dd>{@code BufferedImage} of type {@code TYPE_USHORT_GRAY}</dd></color>
<color=#75715e>     *</color>
<color=#75715e>     * <dt>{@code ImageType.PaletteType}</dt></color>
<color=#75715e>     * <dd>{@code BufferedImage} of type {@code TYPE_BYTE_BINARY} (for images</color>
<color=#75715e>     * with a palette of <= 16 colors) or {@code TYPE_BYTE_INDEXED}</dd></color>
<color=#75715e>     * <dt>{@code ImageType.PaletteMatteType}</dt></color>
<color=#75715e>     * <dd>{@code BufferedImage} of type {@code TYPE_BYTE_BINARY} (for images</color>
<color=#75715e>     * with a palette of <= 16 colors) or {@code TYPE_BYTE_INDEXED}</dd></color>
<color=#75715e>     *</color>
<color=#75715e>     * <dt>{@code ImageType.TrueColorType}</dt></color>
<color=#75715e>     * <dd>{@code BufferedImage} of type {@code TYPE_3BYTE_BGR}</dd></color>
<color=#75715e>     * <dt>{@code ImageType.TrueColorPaletteType}</dt></color>
<color=#75715e>     * <dd>{@code BufferedImage} of type {@code TYPE_4BYTE_ABGR}</dd></color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the original {@code MagickImage}</color>
<color=#75715e>     * @return a new {@code BufferedImage}</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pImage} is {@code null}</color>
<color=#75715e>     *                                  or if the {@code ImageType} is not one mentioned above.</color>
<color=#75715e>     * @throws MagickException          if an exception occurs during conversion</color>
<color=#75715e>     * @see BufferedImage</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>MagickImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"image == null"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>long</color> <color=#f8f8f2>start</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>L</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>start</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>
        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getImageType</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>BilevelType</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>bilevelToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>);</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>GrayscaleType</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>grayToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>GrayscaleMatteType</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>grayToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>PaletteType</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>paletteToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>PaletteMatteType</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>paletteToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>TrueColorType</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>rgbToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>TrueColorMatteType</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>rgbToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>ColorSeparationType</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>cmykToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>ColorSeparationMatteType</color><color=#f8f8f2>:</color>
                    <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>cmykToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>);</color>
                    <color=#66d9ef>break</color><color=#f8f8f2>;</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ImageType</color><color=#f8f8f2>.</color><color=#a6e22e>OptimizeType</color><color=#f8f8f2>:</color>
                <color=#66d9ef>default</color><color=#f8f8f2>:</color>
                    <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"Unknown JMagick image type: "</color> <color=#f92672>+</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getImageType</color><color=#f8f8f2>());</color>
            <color=#f8f8f2>}</color>

        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>long</color> <color=#f8f8f2>time</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>start</color><color=#f8f8f2>;</color>
                <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"Converted JMagick image type: "</color> <color=#f92672>+</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getImageType</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#e6db74>" to BufferedImage: "</color> <color=#f92672>+</color> <color=#f8f8f2>image</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"Conversion to BufferedImage: "</color> <color=#f92672>+</color> <color=#f8f8f2>time</color> <color=#f92672>+</color> <color=#e6db74>" ms"</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts a {@code BufferedImage} to a {@code MagickImage}.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * The conversion depends on {@code pImage}'s {@code ColorModel}:</color>
<color=#75715e>     * <dl></color>
<color=#75715e>     * <dt>{@code IndexColorModel} with 1 bit b/w</dt></color>
<color=#75715e>     * <dd>{@code MagickImage} of type {@code ImageType.BilevelType}</dd></color>
<color=#75715e>     * <dt>{@code IndexColorModel} &gt; 1 bit,</dt></color>
<color=#75715e>     * <dd>{@code MagickImage} of type {@code ImageType.PaletteType}</color>
<color=#75715e>     * or {@code MagickImage} of type {@code ImageType.PaletteMatteType}</color>
<color=#75715e>     * depending on <tt>ColorModel.getAlpha()</dd></color>
<color=#75715e>     *</color>
<color=#75715e>     * <dt>{@code ColorModel.getColorSpace().getType() == ColorSpace.TYPE_GRAY}</dt></color>
<color=#75715e>     * <dd>{@code MagickImage} of type {@code ImageType.GrayscaleType}</color>
<color=#75715e>     * or {@code MagickImage} of type {@code ImageType.GrayscaleMatteType}</color>
<color=#75715e>     * depending on <tt>ColorModel.getAlpha()</dd></color>
<color=#75715e>     *</color>
<color=#75715e>     * <dt>{@code ColorModel.getColorSpace().getType() == ColorSpace.TYPE_RGB}</dt></color>
<color=#75715e>     * <dd>{@code MagickImage} of type {@code ImageType.TrueColorType}</color>
<color=#75715e>     * or {@code MagickImage} of type {@code ImageType.TrueColorPaletteType}</dd></color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the original {@code BufferedImage}</color>
<color=#75715e>     * @return a new {@code MagickImage}</color>
<color=#75715e>     * @throws IllegalArgumentException if {@code pImage} is {@code null}</color>
<color=#75715e>     *                                  or if the {@code ColorModel} is not one mentioned above.</color>
<color=#75715e>     * @throws MagickException          if an exception occurs during conversion</color>
<color=#75715e>     * @see BufferedImage</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>MagickImage</color> <color=#a6e22e>toMagick</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pImage</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"image == null"</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>long</color> <color=#f8f8f2>start</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>L</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>start</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>cm</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getColorModel</color><color=#f8f8f2>();</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cm</color> <color=#66d9ef>instanceof</color> <color=#f8f8f2>IndexColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#75715e>// Handles both BilevelType, PaletteType and PaletteMatteType</color>
                <color=#66d9ef>return</color> <color=#f8f8f2>indexedToMagick</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#f8f8f2>IndexColorModel</color><color=#f8f8f2>)</color> <color=#f8f8f2>cm</color><color=#f8f8f2>,</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>hasAlpha</color><color=#f8f8f2>());</color>
            <color=#f8f8f2>}</color>

            <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>getColorSpace</color><color=#f8f8f2>().</color><color=#a6e22e>getType</color><color=#f8f8f2>())</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_GRAY</color><color=#f8f8f2>:</color>
                    <color=#75715e>// Handles GrayType and GrayMatteType</color>
                    <color=#66d9ef>return</color> <color=#f8f8f2>grayToMagick</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>hasAlpha</color><color=#f8f8f2>());</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_RGB</color><color=#f8f8f2>:</color>
                    <color=#75715e>// Handles TrueColorType and TrueColorMatteType</color>
                    <color=#66d9ef>return</color> <color=#f8f8f2>rgbToMagic</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>hasAlpha</color><color=#f8f8f2>());</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_CMY</color><color=#f8f8f2>:</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_CMYK</color><color=#f8f8f2>:</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_HLS</color><color=#f8f8f2>:</color>
                <color=#66d9ef>case</color> <color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_HSV</color><color=#f8f8f2>:</color>
                    <color=#75715e>// Other types not supported yet</color>
                <color=#66d9ef>default</color><color=#f8f8f2>:</color>
                    <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"Unknown buffered image type: "</color> <color=#f92672>+</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>long</color> <color=#f8f8f2>time</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>start</color><color=#f8f8f2>;</color>
                <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>(</color><color=#e6db74>"Conversion to MagickImage: "</color> <color=#f92672>+</color> <color=#f8f8f2>time</color> <color=#f92672>+</color> <color=#e6db74>" ms"</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>MagickImage</color> <color=#a6e22e>rgbToMagic</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>MagickImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>MagickImage</color><color=#f8f8f2>();</color>

        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>buffered</color> <color=#f92672>=</color> <color=#f8f8f2>ImageUtil</color><color=#f8f8f2>.</color><color=#a6e22e>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_4BYTE_ABGR</color> <color=#f8f8f2>:</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_3BYTE_BGR</color><color=#f8f8f2>);</color>

        <color=#75715e>// Need to get data of sub raster, not the full data array, this is</color>
        <color=#75715e>// just a convenient way</color>
        <color=#f8f8f2>Raster</color> <color=#f8f8f2>raster</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getRaster</color><color=#f8f8f2>().</color><color=#a6e22e>getParent</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>Rectangle</color><color=#f8f8f2>(</color><color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()));</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getRaster</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>image</color><color=#f8f8f2>.</color><color=#a6e22e>constituteImage</color><color=#f8f8f2>(</color><color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#e6db74>"ABGR"</color> <color=#f8f8f2>:</color> <color=#e6db74>"BGR"</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>((</color><color=#f8f8f2>DataBufferByte</color><color=#f8f8f2>)</color> <color=#f8f8f2>raster</color><color=#f8f8f2>.</color><color=#a6e22e>getDataBuffer</color><color=#f8f8f2>()).</color><color=#a6e22e>getData</color><color=#f8f8f2>());</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>MagickImage</color> <color=#a6e22e>grayToMagick</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>MagickImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>MagickImage</color><color=#f8f8f2>();</color>

        <color=#75715e>// TODO: Make a fix for TYPE_USHORT_GRAY</color>
        <color=#75715e>// The code below does not seem to work (JMagick issues?)...</color>
        <color=#75715e>/*</color>
<color=#75715e>        if (pImage.getType() == BufferedImage.TYPE_USHORT_GRAY) {</color>
<color=#75715e>            short[] data = ((DataBufferUShort) pImage.getRaster().getDataBuffer()).getData();</color>
<color=#75715e>            int[] intData = new int[data.length];</color>
<color=#75715e>            for (int i = 0; i < data.length; i++) {</color>
<color=#75715e>                intData[i] = (data[i] & 0xffff) * 0xffff;</color>
<color=#75715e>            }</color>
<color=#75715e>            image.constituteImage(pImage.getWidth(), pImage.getHeight(), "I", intData);</color>

<color=#75715e>            System.out.println("storageClass: " + image.getStorageClass());</color>
<color=#75715e>            System.out.println("depth: " + image.getDepth());</color>
<color=#75715e>            System.out.println("imageType: " + image.getImageType());</color>
<color=#75715e>        }</color>
<color=#75715e>        else {</color>
<color=#75715e>        */</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>buffered</color> <color=#f92672>=</color> <color=#f8f8f2>ImageUtil</color><color=#f8f8f2>.</color><color=#a6e22e>toBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_4BYTE_ABGR</color> <color=#f8f8f2>:</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE_GRAY</color><color=#f8f8f2>);</color>

        <color=#75715e>// Need to get data of sub raster, not the full data array, this is</color>
        <color=#75715e>// just a convenient way</color>
        <color=#f8f8f2>Raster</color> <color=#f8f8f2>raster</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getRaster</color><color=#f8f8f2>().</color><color=#a6e22e>getParent</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getData</color><color=#f8f8f2>(</color><color=#66d9ef>new</color> <color=#f8f8f2>Rectangle</color><color=#f8f8f2>(</color><color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()));</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>raster</color> <color=#f92672>=</color> <color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getRaster</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>image</color><color=#f8f8f2>.</color><color=#a6e22e>constituteImage</color><color=#f8f8f2>(</color><color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>buffered</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#e6db74>"ABGR"</color> <color=#f8f8f2>:</color> <color=#e6db74>"I"</color><color=#f8f8f2>,</color> <color=#f8f8f2>((</color><color=#f8f8f2>DataBufferByte</color><color=#f8f8f2>)</color> <color=#f8f8f2>raster</color><color=#f8f8f2>.</color><color=#a6e22e>getDataBuffer</color><color=#f8f8f2>()).</color><color=#a6e22e>getData</color><color=#f8f8f2>());</color>
        <color=#75715e>//}</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>MagickImage</color> <color=#a6e22e>indexedToMagick</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>IndexColorModel</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>MagickImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#f8f8f2>rgbToMagic</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>);</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>mapSize</color> <color=#f92672>=</color> <color=#f8f8f2>pColorModel</color><color=#f8f8f2>.</color><color=#a6e22e>getMapSize</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>image</color><color=#f8f8f2>.</color><color=#a6e22e>setNumberColors</color><color=#f8f8f2>(</color><color=#f8f8f2>mapSize</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/*</color>
<color=#75715e>    public static MagickImage toMagick(BufferedImage pImage) throws MagickException {</color>
<color=#75715e>        if (pImage == null) {</color>
<color=#75715e>            throw new IllegalArgumentException("image == null");</color>
<color=#75715e>        }</color>
<color=#75715e>        </color>
<color=#75715e>        final int width = pImage.getWidth();</color>
<color=#75715e>        final int height = pImage.getHeight();</color>

<color=#75715e>        // int ARGB -> byte RGBA conversion</color>
<color=#75715e>        // NOTE: This is ImageMagick Q16 compatible raw RGBA format with 16 bits/sample...</color>
<color=#75715e>        //       For a Q8 build, we could probably go with half the space...</color>
<color=#75715e>        // NOTE: This is close to insanity, as it wastes extreme ammounts of memory</color>
<color=#75715e>        final int[] argb = new int[width];</color>
<color=#75715e>        final byte[] raw16 = new byte[width * height * 8];</color>
<color=#75715e>        for (int y = 0; y < height; y++) {</color>
<color=#75715e>            // Fetch one line of ARGB data</color>
<color=#75715e>            pImage.getRGB(0, y, width, 1, argb, 0, width);</color>

<color=#75715e>            for (int x = 0; x < width; x++) {</color>
<color=#75715e>                int pixel = (x + (y * width)) * 8;</color>
<color=#75715e>                raw16[pixel    ] = (byte) ((argb[x] >> 16) & 0xff); // R</color>
<color=#75715e>                raw16[pixel + 2] = (byte) ((argb[x] >>  8) & 0xff); // G</color>
<color=#75715e>                raw16[pixel + 4] = (byte) ((argb[x]      ) & 0xff); // B</color>
<color=#75715e>                raw16[pixel + 6] = (byte) ((argb[x] >> 24) & 0xff); // A</color>
<color=#75715e>            }</color>
<color=#75715e>        }</color>

<color=#75715e>        // Create magick image</color>
<color=#75715e>        ImageInfo info = new ImageInfo();</color>
<color=#75715e>        info.setMagick("RGBA"); // Raw RGBA samples</color>
<color=#75715e>        info.setSize(width + "x" + height); // String?!?</color>

<color=#75715e>        MagickImage image = new MagickImage(info);</color>
<color=#75715e>        image.setImageAttribute("depth", "8");</color>

<color=#75715e>        // Set pixel data in 16 bit raw RGBA format</color>
<color=#75715e>        image.blobToImage(info, raw16);</color>

<color=#75715e>        return image;</color>
<color=#75715e>    }</color>
<color=#75715e>    */</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts a bi-level {@code MagickImage} to a {@code BufferedImage}, of</color>
<color=#75715e>     * type {@code TYPE_BYTE_BINARY}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the original {@code MagickImage}</color>
<color=#75715e>     * @return a new {@code BufferedImage}</color>
<color=#75715e>     * @throws MagickException if an exception occurs during conversion</color>
<color=#75715e>     * @see BufferedImage</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>bilevelToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>MagickImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#75715e>// As there is no way to get the binary representation of the image,</color>
        <color=#75715e>// convert to gray, and the create a binary image from it</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>temp</color> <color=#f92672>=</color> <color=#f8f8f2>grayToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(),</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE_BINARY</color><color=#f8f8f2>,</color> <color=#f8f8f2>CM_MONOCHROME</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>ImageUtil</color><color=#f8f8f2>.</color><color=#a6e22e>drawOnto</color><color=#f8f8f2>(</color><color=#f8f8f2>image</color><color=#f8f8f2>,</color> <color=#f8f8f2>temp</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts a gray {@code MagickImage} to a {@code BufferedImage}, of</color>
<color=#75715e>     * type {@code TYPE_USHORT_GRAY} or {@code TYPE_BYTE_GRAY}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the original {@code MagickImage}</color>
<color=#75715e>     * @param pAlpha keep alpha channel</color>
<color=#75715e>     * @return a new {@code BufferedImage}</color>
<color=#75715e>     * @throws MagickException if an exception occurs during conversion</color>
<color=#75715e>     * @see BufferedImage</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>grayToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>MagickImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>Dimension</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getDimension</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>length</color> <color=#f92672>=</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color> <color=#f92672>*</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>height</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>bands</color> <color=#f92672>=</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#ae81ff>2</color> <color=#f8f8f2>:</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color>
        <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>pixels</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>length</color> <color=#f92672>*</color> <color=#f8f8f2>bands</color><color=#f92672>]</color><color=#f8f8f2>;</color>

        <color=#75715e>// TODO: Make a fix for 16 bit TYPE_USHORT_GRAY?!</color>
        <color=#75715e>// Note: The ordering AI or I corresponds to BufferedImage</color>
        <color=#75715e>// TYPE_CUSTOM and TYPE_BYTE_GRAY respectively</color>
        <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>dispatchImage</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>height</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#e6db74>"AI"</color> <color=#f8f8f2>:</color> <color=#e6db74>"I"</color><color=#f8f8f2>,</color> <color=#f8f8f2>pixels</color><color=#f8f8f2>);</color>

        <color=#75715e>// Init databuffer with array, to avoid allocation of empty array</color>
        <color=#f8f8f2>DataBuffer</color> <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DataBufferByte</color><color=#f8f8f2>(</color><color=#f8f8f2>pixels</color><color=#f8f8f2>,</color> <color=#f8f8f2>pixels</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

        <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>bandOffsets</color> <color=#f92672>=</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>}</color> <color=#f8f8f2>:</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>0</color><color=#f8f8f2>};</color>

        <color=#f8f8f2>WritableRaster</color> <color=#f8f8f2>raster</color> <color=#f92672>=</color>
                <color=#f8f8f2>Raster</color><color=#f8f8f2>.</color><color=#a6e22e>createInterleavedRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>buffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>height</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color> <color=#f92672>*</color> <color=#f8f8f2>bands</color><color=#f8f8f2>,</color> <color=#f8f8f2>bands</color><color=#f8f8f2>,</color> <color=#f8f8f2>bandOffsets</color><color=#f8f8f2>,</color> <color=#f8f8f2>LOCATION_UPPER_LEFT</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#f8f8f2>CM_GRAY_ALPHA</color> <color=#f8f8f2>:</color> <color=#f8f8f2>CM_GRAY_OPAQUE</color><color=#f8f8f2>,</color> <color=#f8f8f2>raster</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts a palette-based {@code MagickImage} to a</color>
<color=#75715e>     * {@code BufferedImage}, of type {@code TYPE_BYTE_BINARY} (for images</color>
<color=#75715e>     * with a palette of <= 16 colors) or {@code TYPE_BYTE_INDEXED}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the original {@code MagickImage}</color>
<color=#75715e>     * @param pAlpha keep alpha channel</color>
<color=#75715e>     * @return a new {@code BufferedImage}</color>
<color=#75715e>     * @throws MagickException if an exception occurs during conversion</color>
<color=#75715e>     * @see BufferedImage</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>paletteToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>MagickImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Create indexcolormodel for the image</color>
        <color=#f8f8f2>IndexColorModel</color> <color=#f8f8f2>cm</color><color=#f8f8f2>;</color>

        <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>cm</color> <color=#f92672>=</color> <color=#f8f8f2>createIndexColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getColormap</color><color=#f8f8f2>(),</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>catch</color> <color=#f8f8f2>(</color><color=#f8f8f2>MagickException</color> <color=#f8f8f2>e</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>// NOTE: Some MagickImages incorrecly (?) reports to be paletteType,</color>
            <color=#75715e>//       but does not have a colormap, this is a workaround.</color>
            <color=#66d9ef>return</color> <color=#f8f8f2>rgbToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// As there is no way to get the indexes of an indexed image, convert to</color>
        <color=#75715e>// RGB, and the create an indexed image from it</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>temp</color> <color=#f92672>=</color> <color=#f8f8f2>rgbToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>cm</color><color=#f8f8f2>.</color><color=#a6e22e>getMapSize</color><color=#f8f8f2>()</color> <color=#f92672><=</color> <color=#ae81ff>16</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(),</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE_BINARY</color><color=#f8f8f2>,</color> <color=#f8f8f2>cm</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>image</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(),</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE_INDEXED</color><color=#f8f8f2>,</color> <color=#f8f8f2>cm</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Create transparent background for images containing alpha</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>Graphics2D</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>image</color><color=#f8f8f2>.</color><color=#a6e22e>createGraphics</color><color=#f8f8f2>();</color>
            <color=#66d9ef>try</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setComposite</color><color=#f8f8f2>(</color><color=#f8f8f2>AlphaComposite</color><color=#f8f8f2>.</color><color=#a6e22e>Clear</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>fillRect</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>temp</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>());</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>finally</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// NOTE: This is (surprisingly) much faster than using g2d.drawImage()..</color>
        <color=#75715e>// (Tests shows 20-30ms, vs. 600-700ms on the same image)</color>
        <color=#f8f8f2>BufferedImageOp</color> <color=#f8f8f2>op</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>CopyDither</color><color=#f8f8f2>(</color><color=#f8f8f2>cm</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>op</color><color=#f8f8f2>.</color><color=#a6e22e>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>temp</color><color=#f8f8f2>,</color> <color=#f8f8f2>image</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>image</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Creates an {@code IndexColorModel} from an array of</color>
<color=#75715e>     * {@code PixelPacket}s.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pColormap the original colormap as a {@code PixelPacket} array</color>
<color=#75715e>     * @param pAlpha    keep alpha channel</color>
<color=#75715e>     * @return a new {@code IndexColorModel}</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>IndexColorModel</color> <color=#a6e22e>createIndexColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>PixelPacket</color><color=#f92672>[]</color> <color=#f8f8f2>pColormap</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>colors</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[</color><color=#f8f8f2>pColormap</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f92672>]</color><color=#f8f8f2>;</color>

        <color=#75715e>// TODO: Verify if this is correct for alpha...?</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>trans</color> <color=#f92672>=</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#f8f8f2>colors</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>-</color> <color=#ae81ff>1</color> <color=#f8f8f2>:</color> <color=#f92672>-</color><color=#ae81ff>1</color><color=#f8f8f2>;</color>

        <color=#75715e>//for (int i = 0; i < pColormap.length; i++) {</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#f8f8f2>pColormap</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>-</color> <color=#ae81ff>1</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672>!=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>--</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>PixelPacket</color> <color=#f8f8f2>color</color> <color=#f92672>=</color> <color=#f8f8f2>pColormap</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>;</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>colors</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#ae81ff>0xff</color> <color=#f92672>-</color> <color=#f8f8f2>(</color><color=#f8f8f2>color</color><color=#f8f8f2>.</color><color=#a6e22e>getOpacity</color><color=#f8f8f2>()</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>))</color> <color=#f92672><<</color> <color=#ae81ff>24</color> <color=#f92672>|</color>
                        <color=#f8f8f2>(</color><color=#f8f8f2>color</color><color=#f8f8f2>.</color><color=#a6e22e>getRed</color><color=#f8f8f2>()</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>16</color> <color=#f92672>|</color>
                        <color=#f8f8f2>(</color><color=#f8f8f2>color</color><color=#f8f8f2>.</color><color=#a6e22e>getGreen</color><color=#f8f8f2>()</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>8</color> <color=#f92672>|</color>
                        <color=#f8f8f2>(</color><color=#f8f8f2>color</color><color=#f8f8f2>.</color><color=#a6e22e>getBlue</color><color=#f8f8f2>()</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>colors</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>color</color><color=#f8f8f2>.</color><color=#a6e22e>getRed</color><color=#f8f8f2>()</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>16</color> <color=#f92672>|</color>
                        <color=#f8f8f2>(</color><color=#f8f8f2>color</color><color=#f8f8f2>.</color><color=#a6e22e>getGreen</color><color=#f8f8f2>()</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>)</color> <color=#f92672><<</color> <color=#ae81ff>8</color> <color=#f92672>|</color>
                        <color=#f8f8f2>(</color><color=#f8f8f2>color</color><color=#f8f8f2>.</color><color=#a6e22e>getBlue</color><color=#f8f8f2>()</color> <color=#f92672>&</color> <color=#ae81ff>0xff</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>InverseColorMapIndexColorModel</color><color=#f8f8f2>(</color><color=#ae81ff>8</color><color=#f8f8f2>,</color> <color=#f8f8f2>colors</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>,</color> <color=#f8f8f2>colors</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>,</color> <color=#f8f8f2>trans</color><color=#f8f8f2>,</color> <color=#f8f8f2>DataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Converts an (A)RGB {@code MagickImage} to a {@code BufferedImage}, of</color>
<color=#75715e>     * type {@code TYPE_4BYTE_ABGR} or {@code TYPE_3BYTE_BGR}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the original {@code MagickImage}</color>
<color=#75715e>     * @param pAlpha keep alpha channel</color>
<color=#75715e>     * @return a new {@code BufferedImage}</color>
<color=#75715e>     * @throws MagickException if an exception occurs during conversion</color>
<color=#75715e>     * @see BufferedImage</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>rgbToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>MagickImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>Dimension</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getDimension</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>length</color> <color=#f92672>=</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color> <color=#f92672>*</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>height</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>bands</color> <color=#f92672>=</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#ae81ff>4</color> <color=#f8f8f2>:</color> <color=#ae81ff>3</color><color=#f8f8f2>;</color>
        <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>pixels</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>length</color> <color=#f92672>*</color> <color=#f8f8f2>bands</color><color=#f92672>]</color><color=#f8f8f2>;</color>

        <color=#75715e>// TODO: If we do multiple dispatches (one per line, typically), we could provide listener</color>
        <color=#75715e>//       feedback. But it's currently a lot slower than fetching all the pixels in one go.</color>

        <color=#75715e>// Note: The ordering ABGR or BGR corresponds to BufferedImage</color>
        <color=#75715e>// TYPE_4BYTE_ABGR and TYPE_3BYTE_BGR respectively</color>
        <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>dispatchImage</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>height</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#e6db74>"ABGR"</color> <color=#f8f8f2>:</color> <color=#e6db74>"BGR"</color><color=#f8f8f2>,</color> <color=#f8f8f2>pixels</color><color=#f8f8f2>);</color>

        <color=#75715e>// Init databuffer with array, to avoid allocation of empty array</color>
        <color=#f8f8f2>DataBuffer</color> <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DataBufferByte</color><color=#f8f8f2>(</color><color=#f8f8f2>pixels</color><color=#f8f8f2>,</color> <color=#f8f8f2>pixels</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

        <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>bandOffsets</color> <color=#f92672>=</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#f8f8f2>BAND_OFF_TRANS</color> <color=#f8f8f2>:</color> <color=#f8f8f2>BAND_OFF_OPAQUE</color><color=#f8f8f2>;</color>

        <color=#f8f8f2>WritableRaster</color> <color=#f8f8f2>raster</color> <color=#f92672>=</color>
                <color=#f8f8f2>Raster</color><color=#f8f8f2>.</color><color=#a6e22e>createInterleavedRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>buffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>height</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color> <color=#f92672>*</color> <color=#f8f8f2>bands</color><color=#f8f8f2>,</color> <color=#f8f8f2>bands</color><color=#f8f8f2>,</color> <color=#f8f8f2>bandOffsets</color><color=#f8f8f2>,</color> <color=#f8f8f2>LOCATION_UPPER_LEFT</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#f8f8f2>CM_COLOR_ALPHA</color> <color=#f8f8f2>:</color> <color=#f8f8f2>CM_COLOR_OPAQUE</color><color=#f8f8f2>,</color> <color=#f8f8f2>raster</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>


    <color=#75715e>/**</color>
<color=#75715e>     * Converts an {@code MagickImage} to a {@code BufferedImage} which holds an CMYK ICC profile</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param pImage the original {@code MagickImage}</color>
<color=#75715e>     * @param pAlpha keep alpha channel</color>
<color=#75715e>     * @return a new {@code BufferedImage}</color>
<color=#75715e>     * @throws MagickException if an exception occurs during conversion</color>
<color=#75715e>     * @see BufferedImage</color>
<color=#75715e>     */</color>
    <color=#66d9ef>private</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>cmykToBuffered</color><color=#f8f8f2>(</color><color=#f8f8f2>MagickImage</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>,</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>MagickException</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>Dimension</color> <color=#f8f8f2>size</color> <color=#f92672>=</color> <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getDimension</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>length</color> <color=#f92672>=</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color> <color=#f92672>*</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>height</color><color=#f8f8f2>;</color>

        <color=#75715e>// Retreive the ICC profile</color>
        <color=#f8f8f2>ICC_Profile</color> <color=#f8f8f2>profile</color> <color=#f92672>=</color> <color=#f8f8f2>ICC_Profile</color><color=#f8f8f2>.</color><color=#a6e22e>getInstance</color><color=#f8f8f2>(</color><color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>getColorProfile</color><color=#f8f8f2>().</color><color=#a6e22e>getInfo</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>ColorSpace</color> <color=#f8f8f2>cs</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ICC_ColorSpace</color><color=#f8f8f2>(</color><color=#f8f8f2>profile</color><color=#f8f8f2>);</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>bands</color> <color=#f92672>=</color> <color=#f8f8f2>cs</color><color=#f8f8f2>.</color><color=#a6e22e>getNumComponents</color><color=#f8f8f2>()</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#ae81ff>1</color> <color=#f8f8f2>:</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>

        <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>bits</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[</color><color=#f8f8f2>bands</color><color=#f92672>]</color><color=#f8f8f2>;</color>
        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>bands</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>bits</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color> <color=#f92672>=</color> <color=#ae81ff>8</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>ColorModel</color> <color=#f8f8f2>cm</color> <color=#f92672>=</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color>
                <color=#66d9ef>new</color> <color=#f8f8f2>ComponentColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>cs</color><color=#f8f8f2>,</color> <color=#f8f8f2>bits</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#66d9ef>true</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>TRANSLUCENT</color><color=#f8f8f2>,</color> <color=#f8f8f2>DataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE</color><color=#f8f8f2>)</color> <color=#f8f8f2>:</color>
                <color=#66d9ef>new</color> <color=#f8f8f2>ComponentColorModel</color><color=#f8f8f2>(</color><color=#f8f8f2>cs</color><color=#f8f8f2>,</color> <color=#f8f8f2>bits</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#66d9ef>false</color><color=#f8f8f2>,</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>OPAQUE</color><color=#f8f8f2>,</color> <color=#f8f8f2>DataBuffer</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_BYTE</color><color=#f8f8f2>);</color>

        <color=#66d9ef>byte</color><color=#f92672>[]</color> <color=#f8f8f2>pixels</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#66d9ef>byte</color><color=#f92672>[</color><color=#f8f8f2>length</color> <color=#f92672>*</color> <color=#f8f8f2>bands</color><color=#f92672>]</color><color=#f8f8f2>;</color>

        <color=#75715e>// TODO: If we do multiple dispatches (one per line, typically), we could provide listener</color>
        <color=#75715e>//       feedback. But it's currently a lot slower than fetching all the pixels in one go.</color>
        <color=#75715e>// TODO: handle more generic cases if profile is not CMYK</color>
        <color=#75715e>// TODO: Test "ACMYK"</color>
        <color=#f8f8f2>pImage</color><color=#f8f8f2>.</color><color=#a6e22e>dispatchImage</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>height</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#e6db74>"ACMYK"</color> <color=#f8f8f2>:</color> <color=#e6db74>"CMYK"</color><color=#f8f8f2>,</color> <color=#f8f8f2>pixels</color><color=#f8f8f2>);</color>

        <color=#75715e>// Init databuffer with array, to avoid allocation of empty array</color>
        <color=#f8f8f2>DataBuffer</color> <color=#f8f8f2>buffer</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>DataBufferByte</color><color=#f8f8f2>(</color><color=#f8f8f2>pixels</color><color=#f8f8f2>,</color> <color=#f8f8f2>pixels</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

        <color=#75715e>// TODO: build array from bands variable, here it just works for CMYK</color>
        <color=#75715e>// The values has not been tested with an alpha picture actually...</color>
        <color=#66d9ef>int</color><color=#f92672>[]</color> <color=#f8f8f2>bandOffsets</color> <color=#f92672>=</color> <color=#f8f8f2>pAlpha</color> <color=#f92672>?</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#ae81ff>4</color><color=#f8f8f2>}</color> <color=#f8f8f2>:</color> <color=#66d9ef>new</color> <color=#66d9ef>int</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#ae81ff>3</color><color=#f8f8f2>};</color>

        <color=#f8f8f2>WritableRaster</color> <color=#f8f8f2>raster</color> <color=#f92672>=</color>
                <color=#f8f8f2>Raster</color><color=#f8f8f2>.</color><color=#a6e22e>createInterleavedRaster</color><color=#f8f8f2>(</color><color=#f8f8f2>buffer</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>height</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>size</color><color=#f8f8f2>.</color><color=#a6e22e>width</color> <color=#f92672>*</color> <color=#f8f8f2>bands</color><color=#f8f8f2>,</color> <color=#f8f8f2>bands</color><color=#f8f8f2>,</color> <color=#f8f8f2>bandOffsets</color><color=#f8f8f2>,</color> <color=#f8f8f2>LOCATION_UPPER_LEFT</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>cm</color><color=#f8f8f2>,</color> <color=#f8f8f2>raster</color><color=#f8f8f2>,</color> <color=#f8f8f2>pAlpha</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>