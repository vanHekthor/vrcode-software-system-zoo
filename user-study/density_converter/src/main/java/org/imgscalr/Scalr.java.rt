<color=#75715e>/**</color>
<color=#75715e> * Copyright 2011 The Buzz Media, LLC</color>
<color=#75715e> * <p></color>
<color=#75715e> * Licensed under the Apache License, Version 2.0 (the "License");</color>
<color=#75715e> * you may not use this file except in compliance with the License.</color>
<color=#75715e> * You may obtain a copy of the License at</color>
<color=#75715e> * <p></color>
<color=#75715e> * http://www.apache.org/licenses/LICENSE-2.0</color>
<color=#75715e> * <p></color>
<color=#75715e> * Unless required by applicable law or agreed to in writing, software</color>
<color=#75715e> * distributed under the License is distributed on an "AS IS" BASIS,</color>
<color=#75715e> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</color>
<color=#75715e> * See the License for the specific language governing permissions and</color>
<color=#75715e> * limitations under the License.</color>
<color=#75715e> */</color>
<color=#f92672>package</color> <color=#f8f8f2>org.imgscalr</color><color=#f8f8f2>;</color>

<color=#f92672>import</color> <color=#f8f8f2>javax.imageio.ImageIO</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.*</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.color.ColorSpace</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.geom.AffineTransform</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.geom.Rectangle2D</color><color=#f8f8f2>;</color>
<color=#f92672>import</color> <color=#f8f8f2>java.awt.image.*</color><color=#f8f8f2>;</color>

<color=#75715e>/**</color>
<color=#75715e> * Class used to implement performant, high-quality and intelligent image</color>
<color=#75715e> * scaling and manipulation algorithms in native Java 2D.</color>
<color=#75715e> * <p/></color>
<color=#75715e> * This class utilizes the Java2D "best practices" for image manipulation,</color>
<color=#75715e> * ensuring that all operations (even most user-provided {@link BufferedImageOp}</color>
<color=#75715e> * s) are hardware accelerated if provided by the platform and host-VM.</color>
<color=#75715e> * <p/></color>
<color=#75715e> * <h3>Image Quality</h3></color>
<color=#75715e> * This class implements a few different methods for scaling an image, providing</color>
<color=#75715e> * either the best-looking result, the fastest result or a balanced result</color>
<color=#75715e> * between the two depending on the scaling hint provided (see {@link Method}).</color>
<color=#75715e> * <p/></color>
<color=#75715e> * This class also implements an optimized version of the incremental scaling</color>
<color=#75715e> * algorithm presented by Chris Campbell in his <a href="http://today.java</color>
<color=#75715e> * .net/pub/a/today/2007/04/03/perils-of-image-getscaledinstance.html">Perils of</color>
<color=#75715e> * Image.getScaledInstance()</a> article in order to give the best-looking image</color>
<color=#75715e> * resize results (e.g. generating thumbnails that aren't blurry or jagged).</color>
<color=#75715e> * <p></color>
<color=#75715e> * The results generated by imgscalr using this method, as compared to a single</color>
<color=#75715e> * {@link RenderingHints#VALUE_INTERPOLATION_BICUBIC} scale operation look much</color>
<color=#75715e> * better, especially when using the {@link Method#ULTRA_QUALITY} method.</color>
<color=#75715e> * <p/></color>
<color=#75715e> * Only when scaling using the {@link Method#AUTOMATIC} method will this class</color>
<color=#75715e> * look at the size of the image before selecting an approach to scaling the</color>
<color=#75715e> * image. If {@link Method#QUALITY} is specified, the best-looking algorithm</color>
<color=#75715e> * possible is always used.</color>
<color=#75715e> * <p/></color>
<color=#75715e> * Minor modifications are made to Campbell's original implementation in the</color>
<color=#75715e> * form of:</color>
<color=#75715e> * <ol></color>
<color=#75715e> * <li>Instead of accepting a user-supplied interpolation method,</color>
<color=#75715e> * {@link RenderingHints#VALUE_INTERPOLATION_BICUBIC} interpolation is always</color>
<color=#75715e> * used. This was done after A/B comparison testing with large images</color>
<color=#75715e> * down-scaled to thumbnail sizes showed noticeable "blurring" when BILINEAR</color>
<color=#75715e> * interpolation was used. Given that Campbell's algorithm is only used in</color>
<color=#75715e> * QUALITY mode when down-scaling, it was determined that the user's expectation</color>
<color=#75715e> * of a much less blurry picture would require that BICUBIC be the default</color>
<color=#75715e> * interpolation in order to meet the QUALITY expectation.</li></color>
<color=#75715e> * <li>After each iteration of the do-while loop that incrementally scales the</color>
<color=#75715e> * source image down, an explicit effort is made to call</color>
<color=#75715e> * {@link BufferedImage#flush()} on the interim temporary {@link BufferedImage}</color>
<color=#75715e> * instances created by the algorithm in an attempt to ensure a more complete GC</color>
<color=#75715e> * cycle by the VM when cleaning up the temporary instances (this is in addition</color>
<color=#75715e> * to disposing of the temporary {@link Graphics2D} references as well).</li></color>
<color=#75715e> * <li>Extensive comments have been added to increase readability of the code.</li></color>
<color=#75715e> * <li>Variable names have been expanded to increase readability of the code.</li></color>
<color=#75715e> * </ol></color>
<color=#75715e> * <p/></color>
<color=#75715e> * <strong>NOTE</strong>: This class does not call {@link BufferedImage#flush()}</color>
<color=#75715e> * on any of the <em>source images</em> passed in by calling code; it is up to</color>
<color=#75715e> * the original caller to dispose of their source images when they are no longer</color>
<color=#75715e> * needed so the VM can most efficiently GC them.</color>
<color=#75715e> * <h3>Image Proportions</h3></color>
<color=#75715e> * All scaling operations implemented by this class maintain the proportions of</color>
<color=#75715e> * the original image unless a mode of {@link Mode#FIT_EXACT} is specified; in</color>
<color=#75715e> * which case the orientation and proportion of the source image is ignored and</color>
<color=#75715e> * the image is stretched (if necessary) to fit the exact dimensions given.</color>
<color=#75715e> * <p/></color>
<color=#75715e> * When not using {@link Mode#FIT_EXACT}, in order to maintain the</color>
<color=#75715e> * proportionality of the original images, this class implements the following</color>
<color=#75715e> * behavior:</color>
<color=#75715e> * <ol></color>
<color=#75715e> * <li>If the image is LANDSCAPE-oriented or SQUARE, treat the</color>
<color=#75715e> * <code>targetWidth</code> as the primary dimension and re-calculate the</color>
<color=#75715e> * <code>targetHeight</code> regardless of what is passed in.</li></color>
<color=#75715e> * <li>If image is PORTRAIT-oriented, treat the <code>targetHeight</code> as the</color>
<color=#75715e> * primary dimension and re-calculate the <code>targetWidth</code> regardless of</color>
<color=#75715e> * what is passed in.</li></color>
<color=#75715e> * <li>If a {@link Mode} value of {@link Mode#FIT_TO_WIDTH} or</color>
<color=#75715e> * {@link Mode#FIT_TO_HEIGHT} is passed in to the <code>resize</code> method,</color>
<color=#75715e> * the image's orientation is ignored and the scaled image is fit to the</color>
<color=#75715e> * preferred dimension by using the value passed in by the user for that</color>
<color=#75715e> * dimension and recalculating the other (regardless of image orientation). This</color>
<color=#75715e> * is useful, for example, when working with PORTRAIT oriented images that you</color>
<color=#75715e> * need to all be the same width or visa-versa (e.g. showing user profile</color>
<color=#75715e> * pictures in a directory listing).</li></color>
<color=#75715e> * </ol></color>
<color=#75715e> * <h3>Optimized Image Handling</h3></color>
<color=#75715e> * Java2D provides support for a number of different image types defined as</color>
<color=#75715e> * <code>BufferedImage.TYPE_*</code> variables, unfortunately not all image</color>
<color=#75715e> * types are supported equally in the Java2D rendering pipeline.</color>
<color=#75715e> * <p/></color>
<color=#75715e> * Some more obscure image types either have poor or no support, leading to</color>
<color=#75715e> * severely degraded quality and processing performance when an attempt is made</color>
<color=#75715e> * by imgscalr to create a scaled instance <em>of the same type</em> as the</color>
<color=#75715e> * source image. In many cases, especially when applying {@link BufferedImageOp}</color>
<color=#75715e> * s, using poorly supported image types can even lead to exceptions or total</color>
<color=#75715e> * corruption of the image (e.g. solid black image).</color>
<color=#75715e> * <p/></color>
<color=#75715e> * imgscalr specifically accounts for and automatically hands</color>
<color=#75715e> * <strong>ALL</strong> of these pain points for you internally by shuffling all</color>
<color=#75715e> * images into one of two types:</color>
<color=#75715e> * <ol></color>
<color=#75715e> * <li>{@link BufferedImage#TYPE_INT_RGB}</li></color>
<color=#75715e> * <li>{@link BufferedImage#TYPE_INT_ARGB}</li></color>
<color=#75715e> * </ol></color>
<color=#75715e> * depending on if the source image utilizes transparency or not. This is a</color>
<color=#75715e> * recommended approach by the Java2D team for dealing with poorly (or non)</color>
<color=#75715e> * supported image types. More can be read about this issue <a href=</color>
<color=#75715e> * "http://www.mail-archive.com/java2d-interest@capra.eng.sun.com/msg05621.html"</color>
<color=#75715e> * >here</a>.</color>
<color=#75715e> * <p/></color>
<color=#75715e> * This is also the reason we recommend using</color>
<color=#75715e> * {@link #apply(BufferedImage, BufferedImageOp...)} to apply your own ops to</color>
<color=#75715e> * images even if you aren't using imgscalr for anything else.</color>
<color=#75715e> * <h3>GIF Transparency</h3></color>
<color=#75715e> * Unfortunately in Java 6 and earlier, support for GIF's</color>
<color=#75715e> * {@link IndexColorModel} is sub-par, both in accurate color-selection and in</color>
<color=#75715e> * maintaining transparency when moving to an image of type</color>
<color=#75715e> * {@link BufferedImage#TYPE_INT_ARGB}; because of this issue when a GIF image</color>
<color=#75715e> * is processed by imgscalr and the result saved as a GIF file (instead of PNG),</color>
<color=#75715e> * it is possible to lose the alpha channel of a transparent image or in the</color>
<color=#75715e> * case of applying an optional {@link BufferedImageOp}, lose the entire picture</color>
<color=#75715e> * all together in the result (long standing JDK bugs are filed for all of these</color>
<color=#75715e> * issues).</color>
<color=#75715e> * <p/></color>
<color=#75715e> * imgscalr currently does nothing to work around this manually because it is a</color>
<color=#75715e> * defect in the native platform code itself. Fortunately it looks like the</color>
<color=#75715e> * issues are half-fixed in Java 7 and any manual workarounds we could attempt</color>
<color=#75715e> * internally are relatively expensive, in the form of hand-creating and setting</color>
<color=#75715e> * RGB values pixel-by-pixel with a custom {@link ColorModel} in the scaled</color>
<color=#75715e> * image. This would lead to a very measurable negative impact on performance</color>
<color=#75715e> * without the caller understanding why.</color>
<color=#75715e> * <p></color>
<color=#75715e> * <strong>Workaround</strong>: A workaround to this issue with all version of</color>
<color=#75715e> * Java is to simply save a GIF as a PNG; no change to your code needs to be</color>
<color=#75715e> * made except when the image is saved out, e.g. using {@link ImageIO}.</color>
<color=#75715e> * <p></color>
<color=#75715e> * When a file type of "PNG" is used, both the transparency and high color</color>
<color=#75715e> * quality will be maintained as the PNG code path in Java2D is superior to the</color>
<color=#75715e> * GIF implementation.</color>
<color=#75715e> * <p></color>
<color=#75715e> * If the issue with optional {@link BufferedImageOp}s destroying GIF image</color>
<color=#75715e> * content is ever fixed in the platform, saving out resulting images as GIFs</color>
<color=#75715e> * should suddenly start working.</color>
<color=#75715e> * <p></color>
<color=#75715e> * More can be read about the issue <a</color>
<color=#75715e> * href="http://gman.eichberger.de/2007/07/transparent-gifs-in-java.html"</color>
<color=#75715e> * >here</a> and <a</color>
<color=#75715e> * href="http://ubuntuforums.org/archive/index.php/t-1060128.html">here</a>.</color>
<color=#75715e> * <h3>Thread Safety</h3></color>
<color=#75715e> * The {@link Scalr} class is <strong>thread-safe</strong> (as all the methods</color>
<color=#75715e> * are <code>static</code>); this class maintains no internal state while</color>
<color=#75715e> * performing any of the provided operations and is safe to call simultaneously</color>
<color=#75715e> * from multiple threads.</color>
<color=#75715e> * <h3>Logging</h3></color>
<color=#75715e> * This class implements all its debug logging via the</color>
<color=#75715e> * {@link #log(int, String, Object...)} method. At this time logging is done</color>
<color=#75715e> * directly to <code>System.out</code> via the <code>printf</code> method. This</color>
<color=#75715e> * allows the logging to be light weight and easy to capture (every imgscalr log</color>
<color=#75715e> * message is prefixed with the {@link #LOG_PREFIX} string) while adding no</color>
<color=#75715e> * dependencies to the library.</color>
<color=#75715e> * <p/></color>
<color=#75715e> * Implementation of logging in this class is as efficient as possible; avoiding</color>
<color=#75715e> * any calls to the logger method or passing of arguments if logging is not</color>
<color=#75715e> * enabled to avoid the (hidden) cost of constructing the Object[] argument for</color>
<color=#75715e> * the varargs-based method call.</color>
<color=#75715e> *</color>
<color=#75715e> * @author Riyad Kalla (software@thebuzzmedia.com)</color>
<color=#75715e> * @since 1.1</color>
<color=#75715e> */</color>
<color=#66d9ef>public</color> <color=#66d9ef>class</color> <color=#a6e22e>Scalr</color> <color=#f8f8f2>{</color>
    <color=#75715e>/**</color>
<color=#75715e>     * System property name used to define the debug boolean flag.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * Value is "<code>imgscalr.debug</code>".</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>DEBUG_PROPERTY_NAME</color> <color=#f92672>=</color> <color=#e6db74>"imgscalr.debug"</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * System property name used to define a custom log prefix.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * Value is "<code>imgscalr.logPrefix</code>".</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>LOG_PREFIX_PROPERTY_NAME</color> <color=#f92672>=</color> <color=#e6db74>"imgscalr.logPrefix"</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Flag used to indicate if debugging output has been enabled by setting the</color>
<color=#75715e>     * "<code>imgscalr.debug</code>" system property to <code>true</code>. This</color>
<color=#75715e>     * value will be <code>false</code> if the "<code>imgscalr.debug</code>"</color>
<color=#75715e>     * system property is undefined or set to <code>false</code>.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This property can be set on startup with:<br/></color>
<color=#75715e>     * <code></color>
<color=#75715e>     * -Dimgscalr.debug=true</color>
<color=#75715e>     * </code> or by calling {@link System#setProperty(String, String)} to set a</color>
<color=#75715e>     * new property value for {@link #DEBUG_PROPERTY_NAME} before this class is</color>
<color=#75715e>     * loaded.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * Default value is <code>false</code>.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>boolean</color> <color=#f8f8f2>DEBUG</color> <color=#f92672>=</color> <color=#f8f8f2>Boolean</color><color=#f8f8f2>.</color><color=#a6e22e>getBoolean</color><color=#f8f8f2>(</color><color=#f8f8f2>DEBUG_PROPERTY_NAME</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Prefix to every log message this library logs. Using a well-defined</color>
<color=#75715e>     * prefix helps make it easier both visually and programmatically to scan</color>
<color=#75715e>     * log files for messages produced by this library.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This property can be set on startup with:<br/></color>
<color=#75715e>     * <code></color>
<color=#75715e>     * -Dimgscalr.logPrefix=&lt;YOUR PREFIX HERE&gt;</color>
<color=#75715e>     * </code> or by calling {@link System#setProperty(String, String)} to set a</color>
<color=#75715e>     * new property value for {@link #LOG_PREFIX_PROPERTY_NAME} before this</color>
<color=#75715e>     * class is loaded.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * Default value is "<code>[imgscalr] </code>" (including the space).</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>String</color> <color=#f8f8f2>LOG_PREFIX</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>getProperty</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>LOG_PREFIX_PROPERTY_NAME</color><color=#f8f8f2>,</color> <color=#e6db74>"[imgscalr] "</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * A {@link ConvolveOp} using a very light "blur" kernel that acts like an</color>
<color=#75715e>     * anti-aliasing filter (softens the image a bit) when applied to an image.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * A common request by users of the library was that they wished to "soften"</color>
<color=#75715e>     * resulting images when scaling them down drastically. After quite a bit of</color>
<color=#75715e>     * A/B testing, the kernel used by this Op was selected as the closest match</color>
<color=#75715e>     * for the target which was the softer results from the deprecated</color>
<color=#75715e>     * {@link AreaAveragingScaleFilter} (which is used internally by the</color>
<color=#75715e>     * deprecated {@link Image#getScaledInstance(int, int, int)} method in the</color>
<color=#75715e>     * JDK that imgscalr is meant to replace).</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This ConvolveOp uses a 3x3 kernel with the values:</color>
<color=#75715e>     * <table cellpadding="4" border="1"></color>
<color=#75715e>     * <tr></color>
<color=#75715e>     * <td>.0f</td></color>
<color=#75715e>     * <td>.08f</td></color>
<color=#75715e>     * <td>.0f</td></color>
<color=#75715e>     * </tr></color>
<color=#75715e>     * <tr></color>
<color=#75715e>     * <td>.08f</td></color>
<color=#75715e>     * <td>.68f</td></color>
<color=#75715e>     * <td>.08f</td></color>
<color=#75715e>     * </tr></color>
<color=#75715e>     * <tr></color>
<color=#75715e>     * <td>.0f</td></color>
<color=#75715e>     * <td>.08f</td></color>
<color=#75715e>     * <td>.0f</td></color>
<color=#75715e>     * </tr></color>
<color=#75715e>     * </table></color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * For those that have worked with ConvolveOps before, this Op uses the</color>
<color=#75715e>     * {@link ConvolveOp#EDGE_NO_OP} instruction to not process the pixels along</color>
<color=#75715e>     * the very edge of the image (otherwise EDGE_ZERO_FILL would create a</color>
<color=#75715e>     * black-border around the image). If you have not worked with a ConvolveOp</color>
<color=#75715e>     * before, it just means this default OP will "do the right thing" and not</color>
<color=#75715e>     * give you garbage results.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This ConvolveOp uses no {@link RenderingHints} values as internally the</color>
<color=#75715e>     * {@link ConvolveOp} class only uses hints when doing a color conversion</color>
<color=#75715e>     * between the source and destination {@link BufferedImage} targets.</color>
<color=#75715e>     * imgscalr allows the {@link ConvolveOp} to create its own destination</color>
<color=#75715e>     * image every time, so no color conversion is ever needed and thus no</color>
<color=#75715e>     * hints.</color>
<color=#75715e>     * <h3>Performance</h3></color>
<color=#75715e>     * Use of this (and other) {@link ConvolveOp}s are hardware accelerated when</color>
<color=#75715e>     * possible. For more information on if your image op is hardware</color>
<color=#75715e>     * accelerated or not, check the source code of the underlying JDK class</color>
<color=#75715e>     * that actually executes the Op code, <a href=</color>
<color=#75715e>     * "http://www.docjar.com/html/api/sun/awt/image/ImagingLib.java.html"</color>
<color=#75715e>     * >sun.awt.image.ImagingLib</a>.</color>
<color=#75715e>     * <h3>Known Issues</h3></color>
<color=#75715e>     * In all versions of Java (tested up to Java 7 preview Build 131), running</color>
<color=#75715e>     * this op against a GIF with transparency and attempting to save the</color>
<color=#75715e>     * resulting image as a GIF results in a corrupted/empty file. The file must</color>
<color=#75715e>     * be saved out as a PNG to maintain the transparency.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @since 3.0</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>ConvolveOp</color> <color=#f8f8f2>OP_ANTIALIAS</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ConvolveOp</color><color=#f8f8f2>(</color>
            <color=#66d9ef>new</color> <color=#f8f8f2>Kernel</color><color=#f8f8f2>(</color><color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#ae81ff>3</color><color=#f8f8f2>,</color> <color=#66d9ef>new</color> <color=#66d9ef>float</color><color=#f92672>[]</color><color=#f8f8f2>{</color><color=#ae81ff>.0f</color><color=#f8f8f2>,</color> <color=#ae81ff>.08f</color><color=#f8f8f2>,</color> <color=#ae81ff>.0f</color><color=#f8f8f2>,</color> <color=#ae81ff>.08f</color><color=#f8f8f2>,</color> <color=#ae81ff>.68f</color><color=#f8f8f2>,</color> <color=#ae81ff>.08f</color><color=#f8f8f2>,</color>
                    <color=#ae81ff>.0f</color><color=#f8f8f2>,</color> <color=#ae81ff>.08f</color><color=#f8f8f2>,</color> <color=#ae81ff>.0f</color><color=#f8f8f2>}),</color> <color=#f8f8f2>ConvolveOp</color><color=#f8f8f2>.</color><color=#a6e22e>EDGE_NO_OP</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * A {@link RescaleOp} used to make any input image 10% darker.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This operation can be applied multiple times in a row if greater than 10%</color>
<color=#75715e>     * changes in brightness are desired.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @since 4.0</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>RescaleOp</color> <color=#f8f8f2>OP_DARKER</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RescaleOp</color><color=#f8f8f2>(</color><color=#ae81ff>0.9f</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * A {@link RescaleOp} used to make any input image 10% brighter.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This operation can be applied multiple times in a row if greater than 10%</color>
<color=#75715e>     * changes in brightness are desired.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @since 4.0</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>RescaleOp</color> <color=#f8f8f2>OP_BRIGHTER</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>RescaleOp</color><color=#f8f8f2>(</color><color=#ae81ff>1.1f</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * A {@link ColorConvertOp} used to convert any image to a grayscale color</color>
<color=#75715e>     * palette.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * Applying this op multiple times to the same image has no compounding</color>
<color=#75715e>     * effects.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @since 4.0</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#f8f8f2>ColorConvertOp</color> <color=#f8f8f2>OP_GRAYSCALE</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>ColorConvertOp</color><color=#f8f8f2>(</color>
            <color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>getInstance</color><color=#f8f8f2>(</color><color=#f8f8f2>ColorSpace</color><color=#f8f8f2>.</color><color=#a6e22e>CS_GRAY</color><color=#f8f8f2>),</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Static initializer used to prepare some of the variables used by this</color>
<color=#75715e>     * class.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>static</color> <color=#f8f8f2>{</color>
        <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#e6db74>"Debug output ENABLED"</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to define the different scaling hints that the algorithm can use.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @author Riyad Kalla (software@thebuzzmedia.com)</color>
<color=#75715e>     * @since 1.1</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>enum</color> <color=#f8f8f2>Method</color> <color=#f8f8f2>{</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Used to indicate that the scaling implementation should decide which</color>
<color=#75715e>         * method to use in order to get the best looking scaled image in the</color>
<color=#75715e>         * least amount of time.</color>
<color=#75715e>         * <p/></color>
<color=#75715e>         * The scaling algorithm will use the</color>
<color=#75715e>         * {@link Scalr#THRESHOLD_QUALITY_BALANCED} or</color>
<color=#75715e>         * {@link Scalr#THRESHOLD_BALANCED_SPEED} thresholds as cut-offs to</color>
<color=#75715e>         * decide between selecting the <code>QUALITY</code>,</color>
<color=#75715e>         * <code>BALANCED</code> or <code>SPEED</code> scaling algorithms.</color>
<color=#75715e>         * <p/></color>
<color=#75715e>         * By default the thresholds chosen will give nearly the best looking</color>
<color=#75715e>         * result in the fastest amount of time. We intend this method to work</color>
<color=#75715e>         * for 80% of people looking to scale an image quickly and get a good</color>
<color=#75715e>         * looking result.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>AUTOMATIC</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Used to indicate that the scaling implementation should scale as fast</color>
<color=#75715e>         * as possible and return a result. For smaller images (800px in size)</color>
<color=#75715e>         * this can result in noticeable aliasing but it can be a few magnitudes</color>
<color=#75715e>         * times faster than using the QUALITY method.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>SPEED</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Used to indicate that the scaling implementation should use a scaling</color>
<color=#75715e>         * operation balanced between SPEED and QUALITY. Sometimes SPEED looks</color>
<color=#75715e>         * too low quality to be useful (e.g. text can become unreadable when</color>
<color=#75715e>         * scaled using SPEED) but using QUALITY mode will increase the</color>
<color=#75715e>         * processing time too much. This mode provides a "better than SPEED"</color>
<color=#75715e>         * quality in a "less than QUALITY" amount of time.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>BALANCED</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Used to indicate that the scaling implementation should do everything</color>
<color=#75715e>         * it can to create as nice of a result as possible. This approach is</color>
<color=#75715e>         * most important for smaller pictures (800px or smaller) and less</color>
<color=#75715e>         * important for larger pictures as the difference between this method</color>
<color=#75715e>         * and the SPEED method become less and less noticeable as the</color>
<color=#75715e>         * source-image size increases. Using the AUTOMATIC method will</color>
<color=#75715e>         * automatically prefer the QUALITY method when scaling an image down</color>
<color=#75715e>         * below 800px in size.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>QUALITY</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Used to indicate that the scaling implementation should go above and</color>
<color=#75715e>         * beyond the work done by {@link Method#QUALITY} to make the image look</color>
<color=#75715e>         * exceptionally good at the cost of more processing time. This is</color>
<color=#75715e>         * especially evident when generating thumbnails of images that look</color>
<color=#75715e>         * jagged with some of the other {@link Method}s (even</color>
<color=#75715e>         * {@link Method#QUALITY}).</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>ULTRA_QUALITY</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to define the different modes of resizing that the algorithm can</color>
<color=#75715e>     * use.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @author Riyad Kalla (software@thebuzzmedia.com)</color>
<color=#75715e>     * @since 3.1</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>enum</color> <color=#f8f8f2>Mode</color> <color=#f8f8f2>{</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Used to indicate that the scaling implementation should calculate</color>
<color=#75715e>         * dimensions for the resultant image by looking at the image's</color>
<color=#75715e>         * orientation and generating proportional dimensions that best fit into</color>
<color=#75715e>         * the target width and height given</color>
<color=#75715e>         *</color>
<color=#75715e>         * See "Image Proportions" in the {@link Scalr} class description for</color>
<color=#75715e>         * more detail.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>AUTOMATIC</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Used to fit the image to the exact dimensions given regardless of the</color>
<color=#75715e>         * image's proportions. If the dimensions are not proportionally</color>
<color=#75715e>         * correct, this will introduce vertical or horizontal stretching to the</color>
<color=#75715e>         * image.</color>
<color=#75715e>         * <p/></color>
<color=#75715e>         * It is recommended that you use one of the other <code>FIT_TO</code></color>
<color=#75715e>         * modes or {@link Mode#AUTOMATIC} if you want the image to look</color>
<color=#75715e>         * correct, but if dimension-fitting is the #1 priority regardless of</color>
<color=#75715e>         * how it makes the image look, that is what this mode is for.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>FIT_EXACT</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Used to indicate that the scaling implementation should calculate</color>
<color=#75715e>         * dimensions for the resultant image that best-fit within the given</color>
<color=#75715e>         * width, regardless of the orientation of the image.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>FIT_TO_WIDTH</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Used to indicate that the scaling implementation should calculate</color>
<color=#75715e>         * dimensions for the resultant image that best-fit within the given</color>
<color=#75715e>         * height, regardless of the orientation of the image.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>FIT_TO_HEIGHT</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to define the different types of rotations that can be applied to an</color>
<color=#75715e>     * image during a resize operation.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @author Riyad Kalla (software@thebuzzmedia.com)</color>
<color=#75715e>     * @since 3.2</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>enum</color> <color=#f8f8f2>Rotation</color> <color=#f8f8f2>{</color>
        <color=#75715e>/**</color>
<color=#75715e>         * 90-degree, clockwise rotation (to the right). This is equivalent to a</color>
<color=#75715e>         * quarter-turn of the image to the right; moving the picture on to its</color>
<color=#75715e>         * right side.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>CW_90</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * 180-degree, clockwise rotation (to the right). This is equivalent to</color>
<color=#75715e>         * 1 half-turn of the image to the right; rotating the picture around</color>
<color=#75715e>         * until it is upside down from the original position.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>CW_180</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * 270-degree, clockwise rotation (to the right). This is equivalent to</color>
<color=#75715e>         * a quarter-turn of the image to the left; moving the picture on to its</color>
<color=#75715e>         * left side.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>CW_270</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Flip the image horizontally by reflecting it around the y axis.</color>
<color=#75715e>         * <p/></color>
<color=#75715e>         * This is not a standard rotation around a center point, but instead</color>
<color=#75715e>         * creates the mirrored reflection of the image horizontally.</color>
<color=#75715e>         * <p/></color>
<color=#75715e>         * More specifically, the vertical orientation of the image stays the</color>
<color=#75715e>         * same (the top stays on top, and the bottom on bottom), but the right</color>
<color=#75715e>         * and left sides flip. This is different than a standard rotation where</color>
<color=#75715e>         * the top and bottom would also have been flipped.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>FLIP_HORZ</color><color=#f8f8f2>,</color>
        <color=#75715e>/**</color>
<color=#75715e>         * Flip the image vertically by reflecting it around the x axis.</color>
<color=#75715e>         * <p/></color>
<color=#75715e>         * This is not a standard rotation around a center point, but instead</color>
<color=#75715e>         * creates the mirrored reflection of the image vertically.</color>
<color=#75715e>         * <p/></color>
<color=#75715e>         * More specifically, the horizontal orientation of the image stays the</color>
<color=#75715e>         * same (the left stays on the left and the right stays on the right),</color>
<color=#75715e>         * but the top and bottom sides flip. This is different than a standard</color>
<color=#75715e>         * rotation where the left and right would also have been flipped.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>FLIP_VERT</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Threshold (in pixels) at which point the scaling operation using the</color>
<color=#75715e>     * {@link Method#AUTOMATIC} method will decide if a {@link Method#BALANCED}</color>
<color=#75715e>     * method will be used (if smaller than or equal to threshold) or a</color>
<color=#75715e>     * {@link Method#SPEED} method will be used (if larger than threshold).</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * The bigger the image is being scaled to, the less noticeable degradations</color>
<color=#75715e>     * in the image becomes and the faster algorithms can be selected.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * The value of this threshold (1600) was chosen after visual, by-hand, A/B</color>
<color=#75715e>     * testing between different types of images scaled with this library; both</color>
<color=#75715e>     * photographs and screenshots. It was determined that images below this</color>
<color=#75715e>     * size need to use a {@link Method#BALANCED} scale method to look decent in</color>
<color=#75715e>     * most all cases while using the faster {@link Method#SPEED} method for</color>
<color=#75715e>     * images bigger than this threshold showed no noticeable degradation over a</color>
<color=#75715e>     * <code>BALANCED</code> scale.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>THRESHOLD_BALANCED_SPEED</color> <color=#f92672>=</color> <color=#ae81ff>1600</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Threshold (in pixels) at which point the scaling operation using the</color>
<color=#75715e>     * {@link Method#AUTOMATIC} method will decide if a {@link Method#QUALITY}</color>
<color=#75715e>     * method will be used (if smaller than or equal to threshold) or a</color>
<color=#75715e>     * {@link Method#BALANCED} method will be used (if larger than threshold).</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * The bigger the image is being scaled to, the less noticeable degradations</color>
<color=#75715e>     * in the image becomes and the faster algorithms can be selected.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * The value of this threshold (800) was chosen after visual, by-hand, A/B</color>
<color=#75715e>     * testing between different types of images scaled with this library; both</color>
<color=#75715e>     * photographs and screenshots. It was determined that images below this</color>
<color=#75715e>     * size need to use a {@link Method#QUALITY} scale method to look decent in</color>
<color=#75715e>     * most all cases while using the faster {@link Method#BALANCED} method for</color>
<color=#75715e>     * images bigger than this threshold showed no noticeable degradation over a</color>
<color=#75715e>     * <code>QUALITY</code> scale.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#66d9ef>final</color> <color=#66d9ef>int</color> <color=#f8f8f2>THRESHOLD_QUALITY_BALANCED</color> <color=#f92672>=</color> <color=#ae81ff>800</color><color=#f8f8f2>;</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to apply, in the order given, 1 or more {@link BufferedImageOp}s to</color>
<color=#75715e>     * a given {@link BufferedImage} and return the result.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>Feature</strong>: This implementation works around <a</color>
<color=#75715e>     * href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4965606">a</color>
<color=#75715e>     * decade-old JDK bug</a> that can cause a {@link RasterFormatException}</color>
<color=#75715e>     * when applying a perfectly valid {@link BufferedImageOp}s to images.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>Feature</strong>: This implementation also works around</color>
<color=#75715e>     * {@link BufferedImageOp}s failing to apply and throwing</color>
<color=#75715e>     * {@link ImagingOpException}s when run against a <code>src</code> image</color>
<color=#75715e>     * type that is poorly supported. Unfortunately using {@link ImageIO} and</color>
<color=#75715e>     * standard Java methods to load images provides no consistency in getting</color>
<color=#75715e>     * images in well-supported formats. This method automatically accounts and</color>
<color=#75715e>     * corrects for all those problems (if necessary).</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * It is recommended you always use this method to apply any</color>
<color=#75715e>     * {@link BufferedImageOp}s instead of relying on directly using the</color>
<color=#75715e>     * {@link BufferedImageOp#filter(BufferedImage, BufferedImage)} method.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>Performance</strong>: Not all {@link BufferedImageOp}s are</color>
<color=#75715e>     * hardware accelerated operations, but many of the most popular (like</color>
<color=#75715e>     * {@link ConvolveOp}) are. For more information on if your image op is</color>
<color=#75715e>     * hardware accelerated or not, check the source code of the underlying JDK</color>
<color=#75715e>     * class that actually executes the Op code, <a href=</color>
<color=#75715e>     * "http://www.docjar.com/html/api/sun/awt/image/ImagingLib.java.html"</color>
<color=#75715e>     * >sun.awt.image.ImagingLib</a>.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will have the ops applied to it.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>1</code> or more ops to apply to the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} that represents the <code>src</code></color>
<color=#75715e>     *         with all the given operations applied to it.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>ops</code> is <code>null</code> or empty.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>apply</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>t</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>src</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"src cannot be null"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ops</color> <color=#f92672>==</color> <color=#66d9ef>null</color> <color=#f92672>||</color> <color=#f8f8f2>ops</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>==</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"ops cannot be null or empty"</color><color=#f8f8f2>);</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>type</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getType</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Ensure the src image is in the best supported image type before we</color>
<color=#75715e>         * continue, otherwise it is possible our calls below to getBounds2D and</color>
<color=#75715e>         * certainly filter(...) may fail if not.</color>
<color=#75715e>         *</color>
<color=#75715e>         * Java2D makes an attempt at applying most BufferedImageOps using</color>
<color=#75715e>         * hardware acceleration via the ImagingLib internal library.</color>
<color=#75715e>         *</color>
<color=#75715e>         * Unfortunately may of the BufferedImageOp are written to simply fail</color>
<color=#75715e>         * with an ImagingOpException if the operation cannot be applied with no</color>
<color=#75715e>         * additional information about what went wrong or attempts at</color>
<color=#75715e>         * re-applying it in different ways.</color>
<color=#75715e>         *</color>
<color=#75715e>         * This is assuming the failing BufferedImageOp even returns a null</color>
<color=#75715e>         * image after failing to apply; some simply return a corrupted/black</color>
<color=#75715e>         * image that result in no exception and it is up to the user to</color>
<color=#75715e>         * discover this.</color>
<color=#75715e>         *</color>
<color=#75715e>         * In internal testing, EVERY failure I've ever seen was the result of</color>
<color=#75715e>         * the source image being in a poorly-supported BufferedImage Type like</color>
<color=#75715e>         * BGR or ABGR (even though it was loaded with ImageIO).</color>
<color=#75715e>         *</color>
<color=#75715e>         * To avoid this nasty/stupid surprise with BufferedImageOps, we always</color>
<color=#75715e>         * ensure that the src image starts in an optimally supported format</color>
<color=#75715e>         * before we try and apply the filter.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f92672>!</color><color=#f8f8f2>(</color><color=#f8f8f2>type</color> <color=#f92672>==</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_RGB</color> <color=#f92672>||</color> <color=#f8f8f2>type</color> <color=#f92672>==</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_ARGB</color><color=#f8f8f2>))</color>
            <color=#f8f8f2>src</color> <color=#f92672>=</color> <color=#f8f8f2>copyToOptimalImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#e6db74>"Applying %d BufferedImageOps..."</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>);</color>

        <color=#66d9ef>boolean</color> <color=#f8f8f2>hasReassignedSrc</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>

        <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>ops</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>long</color> <color=#f8f8f2>subT</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>
            <color=#f8f8f2>BufferedImageOp</color> <color=#f8f8f2>op</color> <color=#f92672>=</color> <color=#f8f8f2>ops</color><color=#f92672>[</color><color=#f8f8f2>i</color><color=#f92672>]</color><color=#f8f8f2>;</color>

            <color=#75715e>// Skip null ops instead of throwing an exception.</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>op</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
                <color=#66d9ef>continue</color><color=#f8f8f2>;</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#e6db74>"Applying BufferedImageOp [class=%s, toString=%s]..."</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>op</color><color=#f8f8f2>.</color><color=#a6e22e>getClass</color><color=#f8f8f2>(),</color> <color=#f8f8f2>op</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>());</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Must use op.getBounds instead of src.getWidth and src.getHeight</color>
<color=#75715e>             * because we are trying to create an image big enough to hold the</color>
<color=#75715e>             * result of this operation (which may be to scale the image</color>
<color=#75715e>             * smaller), in that case the bounds reported by this op and the</color>
<color=#75715e>             * bounds reported by the source image will be different.</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>Rectangle2D</color> <color=#f8f8f2>resultBounds</color> <color=#f92672>=</color> <color=#f8f8f2>op</color><color=#f8f8f2>.</color><color=#a6e22e>getBounds2D</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>);</color>

            <color=#75715e>// Watch out for flaky/misbehaving ops that fail to work right.</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>resultBounds</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
                <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>ImagingOpException</color><color=#f8f8f2>(</color>
                        <color=#e6db74>"BufferedImageOp ["</color>
                                <color=#f92672>+</color> <color=#f8f8f2>op</color><color=#f8f8f2>.</color><color=#a6e22e>toString</color><color=#f8f8f2>()</color>
                                <color=#f92672>+</color> <color=#e6db74>"] getBounds2D(src) returned null bounds for the target image; this should not happen and indicates a problem with application of this type of op."</color><color=#f8f8f2>);</color>

            <color=#75715e>/*</color>
<color=#75715e>             * We must manually create the target image; we cannot rely on the</color>
<color=#75715e>             * null-destination filter() method to create a valid destination</color>
<color=#75715e>             * for us thanks to this JDK bug that has been filed for almost a</color>
<color=#75715e>             * decade:</color>
<color=#75715e>             * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4965606</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>dest</color> <color=#f92672>=</color> <color=#f8f8f2>createOptimalImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>round</color><color=#f8f8f2>(</color><color=#f8f8f2>resultBounds</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>()),</color>
                    <color=#f8f8f2>(</color><color=#66d9ef>int</color><color=#f8f8f2>)</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>round</color><color=#f8f8f2>(</color><color=#f8f8f2>resultBounds</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>()));</color>

            <color=#75715e>// Perform the operation, update our result to return.</color>
            <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>op</color><color=#f8f8f2>.</color><color=#a6e22e>filter</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>dest</color><color=#f8f8f2>);</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Flush the 'src' image ONLY IF it is one of our interim temporary</color>
<color=#75715e>             * images being used when applying 2 or more operations back to</color>
<color=#75715e>             * back. We never want to flush the original image passed in.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>hasReassignedSrc</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>flush</color><color=#f8f8f2>();</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Incase there are more operations to perform, update what we</color>
<color=#75715e>             * consider the 'src' reference to our last result so on the next</color>
<color=#75715e>             * iteration the next op is applied to this result and not back</color>
<color=#75715e>             * against the original src passed in.</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>src</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Keep track of when we re-assign 'src' to an interim temporary</color>
<color=#75715e>             * image, so we know when we can explicitly flush it and clean up</color>
<color=#75715e>             * references on future iterations.</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>hasReassignedSrc</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color>
                        <color=#e6db74>"Applied BufferedImageOp in %d ms, result [width=%d, height=%d]"</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>subT</color><color=#f8f8f2>,</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color>
                        <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>());</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#e6db74>"All %d BufferedImageOps applied in %d ms"</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>.</color><color=#a6e22e>length</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>t</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>src</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to crop the given <code>src</code> image from the top-left corner</color>
<color=#75715e>     * and applying any optional {@link BufferedImageOp}s to the result before</color>
<color=#75715e>     * returning it.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image to crop.</color>
<color=#75715e>     * @param width</color>
<color=#75715e>     *            The width of the bounding cropping box.</color>
<color=#75715e>     * @param height</color>
<color=#75715e>     *            The height of the bounding cropping box.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more ops to apply to the image. If</color>
<color=#75715e>     *            <code>null</code> or empty then <code>src</code> is return</color>
<color=#75715e>     *            unmodified.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the cropped region of</color>
<color=#75715e>     *         the <code>src</code> image with any optional operations applied</color>
<color=#75715e>     *         to it.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if any coordinates of the bounding crop box is invalid within</color>
<color=#75715e>     *             the bounds of the <code>src</code> image (e.g. negative or</color>
<color=#75715e>     *             too big).</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>crop</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>height</color><color=#f8f8f2>,</color>
                                     <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>crop</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>height</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to crop the given <code>src</code> image and apply any optional</color>
<color=#75715e>     * {@link BufferedImageOp}s to it before returning the result.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image to crop.</color>
<color=#75715e>     * @param x</color>
<color=#75715e>     *            The x-coordinate of the top-left corner of the bounding box</color>
<color=#75715e>     *            used for cropping.</color>
<color=#75715e>     * @param y</color>
<color=#75715e>     *            The y-coordinate of the top-left corner of the bounding box</color>
<color=#75715e>     *            used for cropping.</color>
<color=#75715e>     * @param width</color>
<color=#75715e>     *            The width of the bounding cropping box.</color>
<color=#75715e>     * @param height</color>
<color=#75715e>     *            The height of the bounding cropping box.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more ops to apply to the image. If</color>
<color=#75715e>     *            <code>null</code> or empty then <code>src</code> is return</color>
<color=#75715e>     *            unmodified.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the cropped region of</color>
<color=#75715e>     *         the <code>src</code> image with any optional operations applied</color>
<color=#75715e>     *         to it.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if any coordinates of the bounding crop box is invalid within</color>
<color=#75715e>     *             the bounds of the <code>src</code> image (e.g. negative or</color>
<color=#75715e>     *             too big).</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>crop</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>x</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>y</color><color=#f8f8f2>,</color>
                                     <color=#66d9ef>int</color> <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>height</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>t</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>src</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"src cannot be null"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>x</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>y</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>width</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>height</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"Invalid crop bounds: x ["</color> <color=#f92672>+</color> <color=#f8f8f2>x</color>
                    <color=#f92672>+</color> <color=#e6db74>"], y ["</color> <color=#f92672>+</color> <color=#f8f8f2>y</color> <color=#f92672>+</color> <color=#e6db74>"], width ["</color> <color=#f92672>+</color> <color=#f8f8f2>width</color> <color=#f92672>+</color> <color=#e6db74>"] and height ["</color>
                    <color=#f92672>+</color> <color=#f8f8f2>height</color> <color=#f92672>+</color> <color=#e6db74>"] must all be >= 0"</color><color=#f8f8f2>);</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>srcWidth</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>srcHeight</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>x</color> <color=#f92672>+</color> <color=#f8f8f2>width</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#f8f8f2>srcWidth</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
                    <color=#e6db74>"Invalid crop bounds: x + width ["</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>x</color> <color=#f92672>+</color> <color=#f8f8f2>width</color><color=#f8f8f2>)</color>
                            <color=#f92672>+</color> <color=#e6db74>"] must be <= src.getWidth() ["</color> <color=#f92672>+</color> <color=#f8f8f2>srcWidth</color> <color=#f92672>+</color> <color=#e6db74>"]"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>y</color> <color=#f92672>+</color> <color=#f8f8f2>height</color><color=#f8f8f2>)</color> <color=#f92672>></color> <color=#f8f8f2>srcHeight</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
                    <color=#e6db74>"Invalid crop bounds: y + height ["</color> <color=#f92672>+</color> <color=#f8f8f2>(</color><color=#f8f8f2>y</color> <color=#f92672>+</color> <color=#f8f8f2>height</color><color=#f8f8f2>)</color>
                            <color=#f92672>+</color> <color=#e6db74>"] must be <= src.getHeight() ["</color> <color=#f92672>+</color> <color=#f8f8f2>srcHeight</color>
                            <color=#f92672>+</color> <color=#e6db74>"]"</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color>
                    <color=#e6db74>"Cropping Image [width=%d, height=%d] to [x=%d, y=%d, width=%d, height=%d]..."</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>srcWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>srcHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>x</color><color=#f8f8f2>,</color> <color=#f8f8f2>y</color><color=#f8f8f2>,</color> <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>height</color><color=#f8f8f2>);</color>

        <color=#75715e>// Create a target image of an optimal type to render into.</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>createOptimalImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>height</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>Graphics</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>getGraphics</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Render the region specified by our crop bounds from the src image</color>
<color=#75715e>         * directly into our result image (which is the exact size of the crop</color>
<color=#75715e>         * region).</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#f8f8f2>height</color><color=#f8f8f2>,</color> <color=#f8f8f2>x</color><color=#f8f8f2>,</color> <color=#f8f8f2>y</color><color=#f8f8f2>,</color> <color=#f8f8f2>(</color><color=#f8f8f2>x</color> <color=#f92672>+</color> <color=#f8f8f2>width</color><color=#f8f8f2>),</color> <color=#f8f8f2>(</color><color=#f8f8f2>y</color> <color=#f92672>+</color> <color=#f8f8f2>height</color><color=#f8f8f2>),</color>
                <color=#66d9ef>null</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#e6db74>"Cropped Image in %d ms"</color><color=#f8f8f2>,</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>t</color><color=#f8f8f2>);</color>

        <color=#75715e>// Apply any optional operations (if specified).</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ops</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>ops</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>apply</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to apply padding around the edges of an image using</color>
<color=#75715e>     * {@link Color#BLACK} to fill the extra padded space and then return the</color>
<color=#75715e>     * result.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * The amount of <code>padding</code> specified is applied to all sides;</color>
<color=#75715e>     * more specifically, a <code>padding</code> of <code>2</code> would add 2</color>
<color=#75715e>     * extra pixels of space (filled by the given <code>color</code>) on the</color>
<color=#75715e>     * top, bottom, left and right sides of the resulting image causing the</color>
<color=#75715e>     * result to be 4 pixels wider and 4 pixels taller than the <code>src</code></color>
<color=#75715e>     * image.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image the padding will be added to.</color>
<color=#75715e>     * @param padding</color>
<color=#75715e>     *            The number of pixels of padding to add to each side in the</color>
<color=#75715e>     *            resulting image. If this value is <code>0</code> then</color>
<color=#75715e>     *            <code>src</code> is returned unmodified.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more ops to apply to the image. If</color>
<color=#75715e>     *            <code>null</code> or empty then <code>src</code> is return</color>
<color=#75715e>     *            unmodified.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing <code>src</code> with</color>
<color=#75715e>     *         the given padding applied to it.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>padding</code> is &lt; <code>1</code>.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>pad</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>padding</color><color=#f8f8f2>,</color>
                                    <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>pad</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>padding</color><color=#f8f8f2>,</color> <color=#f8f8f2>Color</color><color=#f8f8f2>.</color><color=#a6e22e>BLACK</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to apply padding around the edges of an image using the given color</color>
<color=#75715e>     * to fill the extra padded space and then return the result. {@link Color}s</color>
<color=#75715e>     * using an alpha channel (i.e. transparency) are supported.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * The amount of <code>padding</code> specified is applied to all sides;</color>
<color=#75715e>     * more specifically, a <code>padding</code> of <code>2</code> would add 2</color>
<color=#75715e>     * extra pixels of space (filled by the given <code>color</code>) on the</color>
<color=#75715e>     * top, bottom, left and right sides of the resulting image causing the</color>
<color=#75715e>     * result to be 4 pixels wider and 4 pixels taller than the <code>src</code></color>
<color=#75715e>     * image.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image the padding will be added to.</color>
<color=#75715e>     * @param padding</color>
<color=#75715e>     *            The number of pixels of padding to add to each side in the</color>
<color=#75715e>     *            resulting image. If this value is <code>0</code> then</color>
<color=#75715e>     *            <code>src</code> is returned unmodified.</color>
<color=#75715e>     * @param color</color>
<color=#75715e>     *            The color to fill the padded space with. {@link Color}s using</color>
<color=#75715e>     *            an alpha channel (i.e. transparency) are supported.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more ops to apply to the image. If</color>
<color=#75715e>     *            <code>null</code> or empty then <code>src</code> is return</color>
<color=#75715e>     *            unmodified.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing <code>src</code> with</color>
<color=#75715e>     *         the given padding applied to it.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>padding</code> is &lt; <code>1</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>color</code> is <code>null</code>.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>pad</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>padding</color><color=#f8f8f2>,</color>
                                    <color=#f8f8f2>Color</color> <color=#f8f8f2>color</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>t</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>src</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"src cannot be null"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>padding</color> <color=#f92672><</color> <color=#ae81ff>1</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"padding ["</color> <color=#f92672>+</color> <color=#f8f8f2>padding</color>
                    <color=#f92672>+</color> <color=#e6db74>"] must be > 0"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>color</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"color cannot be null"</color><color=#f8f8f2>);</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>srcWidth</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>srcHeight</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Double the padding to account for all sides of the image. More</color>
<color=#75715e>         * specifically, if padding is "1" we add 2 pixels to width and 2 to</color>
<color=#75715e>         * height, so we have 1 new pixel of padding all the way around our</color>
<color=#75715e>         * image.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>sizeDiff</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>padding</color> <color=#f92672>*</color> <color=#ae81ff>2</color><color=#f8f8f2>);</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>newWidth</color> <color=#f92672>=</color> <color=#f8f8f2>srcWidth</color> <color=#f92672>+</color> <color=#f8f8f2>sizeDiff</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>newHeight</color> <color=#f92672>=</color> <color=#f8f8f2>srcHeight</color> <color=#f92672>+</color> <color=#f8f8f2>sizeDiff</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color>
                    <color=#e6db74>"Padding Image from [originalWidth=%d, originalHeight=%d, padding=%d] to [newWidth=%d, newHeight=%d]..."</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>srcWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>srcHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>padding</color><color=#f8f8f2>,</color> <color=#f8f8f2>newWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>newHeight</color><color=#f8f8f2>);</color>

        <color=#66d9ef>boolean</color> <color=#f8f8f2>colorHasAlpha</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>color</color><color=#f8f8f2>.</color><color=#a6e22e>getAlpha</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#ae81ff>255</color><color=#f8f8f2>);</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>imageHasAlpha</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getTransparency</color><color=#f8f8f2>()</color> <color=#f92672>!=</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>OPAQUE</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We need to make sure our resulting image that we render into contains</color>
<color=#75715e>         * alpha if either our original image OR the padding color we are using</color>
<color=#75715e>         * contain it.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>colorHasAlpha</color> <color=#f92672>||</color> <color=#f8f8f2>imageHasAlpha</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color>
                        <color=#e6db74>"Transparency FOUND in source image or color, using ARGB image type..."</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>newWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>newHeight</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_ARGB</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color>
                        <color=#e6db74>"Transparency NOT FOUND in source image or color, using RGB image type..."</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>newWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>newHeight</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_RGB</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#f8f8f2>Graphics</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>getGraphics</color><color=#f8f8f2>();</color>

        <color=#75715e>// "Clear" the background of the new image with our padding color first.</color>
        <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>setColor</color><color=#f8f8f2>(</color><color=#f8f8f2>color</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>fillRect</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>newWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>newHeight</color><color=#f8f8f2>);</color>

        <color=#75715e>// Draw the image into the center of the new padded image.</color>
        <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>padding</color><color=#f8f8f2>,</color> <color=#f8f8f2>padding</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#e6db74>"Padding Applied in %d ms"</color><color=#f8f8f2>,</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>t</color><color=#f8f8f2>);</color>

        <color=#75715e>// Apply any optional operations (if specified).</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ops</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>ops</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>apply</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Resize a given image (maintaining its original proportion) to a width and</color>
<color=#75715e>     * height no bigger than <code>targetSize</code> and apply the given</color>
<color=#75715e>     * {@link BufferedImageOp}s (if any) to the result before returning it.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * A scaling method of {@link Method#AUTOMATIC} and mode of</color>
<color=#75715e>     * {@link Mode#AUTOMATIC} are used.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param targetSize</color>
<color=#75715e>     *            The target width and height (square) that you wish the image</color>
<color=#75715e>     *            to fit within.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more optional image operations (e.g.</color>
<color=#75715e>     *            sharpen, blur, etc.) that can be applied to the final result</color>
<color=#75715e>     *            before returning the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the scaled</color>
<color=#75715e>     *         <code>src</code> image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>targetSize</code> is &lt; 0.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color>
                                       <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>,</color> <color=#f8f8f2>Mode</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Resize a given image (maintaining its original proportion) to a width and</color>
<color=#75715e>     * height no bigger than <code>targetSize</code> using the given scaling</color>
<color=#75715e>     * method and apply the given {@link BufferedImageOp}s (if any) to the</color>
<color=#75715e>     * result before returning it.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * A mode of {@link Mode#AUTOMATIC} is used.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param scalingMethod</color>
<color=#75715e>     *            The method used for scaling the image; preferring speed to</color>
<color=#75715e>     *            quality or a balance of both.</color>
<color=#75715e>     * @param targetSize</color>
<color=#75715e>     *            The target width and height (square) that you wish the image</color>
<color=#75715e>     *            to fit within.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more optional image operations (e.g.</color>
<color=#75715e>     *            sharpen, blur, etc.) that can be applied to the final result</color>
<color=#75715e>     *            before returning the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the scaled</color>
<color=#75715e>     *         <code>src</code> image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>scalingMethod</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>targetSize</code> is &lt; 0.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see Method</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Method</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>,</color>
                                       <color=#66d9ef>int</color> <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>,</color> <color=#f8f8f2>Mode</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Resize a given image (maintaining its original proportion) to a width and</color>
<color=#75715e>     * height no bigger than <code>targetSize</code> (or fitting the image to</color>
<color=#75715e>     * the given WIDTH or HEIGHT explicitly, depending on the {@link Mode}</color>
<color=#75715e>     * specified) and apply the given {@link BufferedImageOp}s (if any) to the</color>
<color=#75715e>     * result before returning it.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * A scaling method of {@link Method#AUTOMATIC} is used.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param resizeMode</color>
<color=#75715e>     *            Used to indicate how imgscalr should calculate the final</color>
<color=#75715e>     *            target size for the image, either fitting the image to the</color>
<color=#75715e>     *            given width ({@link Mode#FIT_TO_WIDTH}) or fitting the image</color>
<color=#75715e>     *            to the given height ({@link Mode#FIT_TO_HEIGHT}). If</color>
<color=#75715e>     *            {@link Mode#AUTOMATIC} is passed in, imgscalr will calculate</color>
<color=#75715e>     *            proportional dimensions for the scaled image based on its</color>
<color=#75715e>     *            orientation (landscape, square or portrait). Unless you have</color>
<color=#75715e>     *            very specific size requirements, most of the time you just</color>
<color=#75715e>     *            want to use {@link Mode#AUTOMATIC} to "do the right thing".</color>
<color=#75715e>     * @param targetSize</color>
<color=#75715e>     *            The target width and height (square) that you wish the image</color>
<color=#75715e>     *            to fit within.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more optional image operations (e.g.</color>
<color=#75715e>     *            sharpen, blur, etc.) that can be applied to the final result</color>
<color=#75715e>     *            before returning the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the scaled</color>
<color=#75715e>     *         <code>src</code> image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>resizeMode</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>targetSize</code> is &lt; 0.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see Mode</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Mode</color> <color=#f8f8f2>resizeMode</color><color=#f8f8f2>,</color>
                                       <color=#66d9ef>int</color> <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>,</color> <color=#f8f8f2>resizeMode</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Resize a given image (maintaining its original proportion) to a width and</color>
<color=#75715e>     * height no bigger than <code>targetSize</code> (or fitting the image to</color>
<color=#75715e>     * the given WIDTH or HEIGHT explicitly, depending on the {@link Mode}</color>
<color=#75715e>     * specified) using the given scaling method and apply the given</color>
<color=#75715e>     * {@link BufferedImageOp}s (if any) to the result before returning it.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param scalingMethod</color>
<color=#75715e>     *            The method used for scaling the image; preferring speed to</color>
<color=#75715e>     *            quality or a balance of both.</color>
<color=#75715e>     * @param resizeMode</color>
<color=#75715e>     *            Used to indicate how imgscalr should calculate the final</color>
<color=#75715e>     *            target size for the image, either fitting the image to the</color>
<color=#75715e>     *            given width ({@link Mode#FIT_TO_WIDTH}) or fitting the image</color>
<color=#75715e>     *            to the given height ({@link Mode#FIT_TO_HEIGHT}). If</color>
<color=#75715e>     *            {@link Mode#AUTOMATIC} is passed in, imgscalr will calculate</color>
<color=#75715e>     *            proportional dimensions for the scaled image based on its</color>
<color=#75715e>     *            orientation (landscape, square or portrait). Unless you have</color>
<color=#75715e>     *            very specific size requirements, most of the time you just</color>
<color=#75715e>     *            want to use {@link Mode#AUTOMATIC} to "do the right thing".</color>
<color=#75715e>     * @param targetSize</color>
<color=#75715e>     *            The target width and height (square) that you wish the image</color>
<color=#75715e>     *            to fit within.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more optional image operations (e.g.</color>
<color=#75715e>     *            sharpen, blur, etc.) that can be applied to the final result</color>
<color=#75715e>     *            before returning the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the scaled</color>
<color=#75715e>     *         <code>src</code> image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>scalingMethod</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>resizeMode</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>targetSize</code> is &lt; 0.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see Method</color>
<color=#75715e>     * @see Mode</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Method</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>,</color>
                                       <color=#f8f8f2>Mode</color> <color=#f8f8f2>resizeMode</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>,</color> <color=#f8f8f2>resizeMode</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetSize</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Resize a given image (maintaining its original proportion) to the target</color>
<color=#75715e>     * width and height and apply the given {@link BufferedImageOp}s (if any) to</color>
<color=#75715e>     * the result before returning it.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * A scaling method of {@link Method#AUTOMATIC} and mode of</color>
<color=#75715e>     * {@link Mode#AUTOMATIC} are used.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: See the class description to understand how this</color>
<color=#75715e>     * class handles recalculation of the <code>targetWidth</code> or</color>
<color=#75715e>     * <code>targetHeight</code> depending on the image's orientation in order</color>
<color=#75715e>     * to maintain the original proportion.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param targetWidth</color>
<color=#75715e>     *            The target width that you wish the image to have.</color>
<color=#75715e>     * @param targetHeight</color>
<color=#75715e>     *            The target height that you wish the image to have.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more optional image operations (e.g.</color>
<color=#75715e>     *            sharpen, blur, etc.) that can be applied to the final result</color>
<color=#75715e>     *            before returning the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the scaled</color>
<color=#75715e>     *         <code>src</code> image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>targetWidth</code> is &lt; 0 or if</color>
<color=#75715e>     *             <code>targetHeight</code> is &lt; 0.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color>
                                       <color=#66d9ef>int</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>,</color> <color=#f8f8f2>Mode</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Resize a given image (maintaining its original proportion) to the target</color>
<color=#75715e>     * width and height using the given scaling method and apply the given</color>
<color=#75715e>     * {@link BufferedImageOp}s (if any) to the result before returning it.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * A mode of {@link Mode#AUTOMATIC} is used.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: See the class description to understand how this</color>
<color=#75715e>     * class handles recalculation of the <code>targetWidth</code> or</color>
<color=#75715e>     * <code>targetHeight</code> depending on the image's orientation in order</color>
<color=#75715e>     * to maintain the original proportion.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param scalingMethod</color>
<color=#75715e>     *            The method used for scaling the image; preferring speed to</color>
<color=#75715e>     *            quality or a balance of both.</color>
<color=#75715e>     * @param targetWidth</color>
<color=#75715e>     *            The target width that you wish the image to have.</color>
<color=#75715e>     * @param targetHeight</color>
<color=#75715e>     *            The target height that you wish the image to have.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more optional image operations (e.g.</color>
<color=#75715e>     *            sharpen, blur, etc.) that can be applied to the final result</color>
<color=#75715e>     *            before returning the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the scaled</color>
<color=#75715e>     *         <code>src</code> image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>scalingMethod</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>targetWidth</code> is &lt; 0 or if</color>
<color=#75715e>     *             <code>targetHeight</code> is &lt; 0.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see Method</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Method</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>,</color>
                                       <color=#66d9ef>int</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>,</color> <color=#f8f8f2>Mode</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Resize a given image (maintaining its original proportion) to the target</color>
<color=#75715e>     * width and height (or fitting the image to the given WIDTH or HEIGHT</color>
<color=#75715e>     * explicitly, depending on the {@link Mode} specified) and apply the given</color>
<color=#75715e>     * {@link BufferedImageOp}s (if any) to the result before returning it.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * A scaling method of {@link Method#AUTOMATIC} is used.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: See the class description to understand how this</color>
<color=#75715e>     * class handles recalculation of the <code>targetWidth</code> or</color>
<color=#75715e>     * <code>targetHeight</code> depending on the image's orientation in order</color>
<color=#75715e>     * to maintain the original proportion.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param resizeMode</color>
<color=#75715e>     *            Used to indicate how imgscalr should calculate the final</color>
<color=#75715e>     *            target size for the image, either fitting the image to the</color>
<color=#75715e>     *            given width ({@link Mode#FIT_TO_WIDTH}) or fitting the image</color>
<color=#75715e>     *            to the given height ({@link Mode#FIT_TO_HEIGHT}). If</color>
<color=#75715e>     *            {@link Mode#AUTOMATIC} is passed in, imgscalr will calculate</color>
<color=#75715e>     *            proportional dimensions for the scaled image based on its</color>
<color=#75715e>     *            orientation (landscape, square or portrait). Unless you have</color>
<color=#75715e>     *            very specific size requirements, most of the time you just</color>
<color=#75715e>     *            want to use {@link Mode#AUTOMATIC} to "do the right thing".</color>
<color=#75715e>     * @param targetWidth</color>
<color=#75715e>     *            The target width that you wish the image to have.</color>
<color=#75715e>     * @param targetHeight</color>
<color=#75715e>     *            The target height that you wish the image to have.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more optional image operations (e.g.</color>
<color=#75715e>     *            sharpen, blur, etc.) that can be applied to the final result</color>
<color=#75715e>     *            before returning the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the scaled</color>
<color=#75715e>     *         <code>src</code> image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>resizeMode</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>targetWidth</code> is &lt; 0 or if</color>
<color=#75715e>     *             <code>targetHeight</code> is &lt; 0.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see Mode</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Mode</color> <color=#f8f8f2>resizeMode</color><color=#f8f8f2>,</color>
                                       <color=#66d9ef>int</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color> <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>,</color> <color=#f8f8f2>resizeMode</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Resize a given image (maintaining its original proportion) to the target</color>
<color=#75715e>     * width and height (or fitting the image to the given WIDTH or HEIGHT</color>
<color=#75715e>     * explicitly, depending on the {@link Mode} specified) using the given</color>
<color=#75715e>     * scaling method and apply the given {@link BufferedImageOp}s (if any) to</color>
<color=#75715e>     * the result before returning it.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: See the class description to understand how this</color>
<color=#75715e>     * class handles recalculation of the <code>targetWidth</code> or</color>
<color=#75715e>     * <code>targetHeight</code> depending on the image's orientation in order</color>
<color=#75715e>     * to maintain the original proportion.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param scalingMethod</color>
<color=#75715e>     *            The method used for scaling the image; preferring speed to</color>
<color=#75715e>     *            quality or a balance of both.</color>
<color=#75715e>     * @param resizeMode</color>
<color=#75715e>     *            Used to indicate how imgscalr should calculate the final</color>
<color=#75715e>     *            target size for the image, either fitting the image to the</color>
<color=#75715e>     *            given width ({@link Mode#FIT_TO_WIDTH}) or fitting the image</color>
<color=#75715e>     *            to the given height ({@link Mode#FIT_TO_HEIGHT}). If</color>
<color=#75715e>     *            {@link Mode#AUTOMATIC} is passed in, imgscalr will calculate</color>
<color=#75715e>     *            proportional dimensions for the scaled image based on its</color>
<color=#75715e>     *            orientation (landscape, square or portrait). Unless you have</color>
<color=#75715e>     *            very specific size requirements, most of the time you just</color>
<color=#75715e>     *            want to use {@link Mode#AUTOMATIC} to "do the right thing".</color>
<color=#75715e>     * @param targetWidth</color>
<color=#75715e>     *            The target width that you wish the image to have.</color>
<color=#75715e>     * @param targetHeight</color>
<color=#75715e>     *            The target height that you wish the image to have.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            <code>0</code> or more optional image operations (e.g.</color>
<color=#75715e>     *            sharpen, blur, etc.) that can be applied to the final result</color>
<color=#75715e>     *            before returning the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the scaled</color>
<color=#75715e>     *         <code>src</code> image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>scalingMethod</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>resizeMode</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>targetWidth</code> is &lt; 0 or if</color>
<color=#75715e>     *             <code>targetHeight</code> is &lt; 0.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see Method</color>
<color=#75715e>     * @see Mode</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>resize</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Method</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>,</color>
                                       <color=#f8f8f2>Mode</color> <color=#f8f8f2>resizeMode</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color>
                                       <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>t</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>src</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"src cannot be null"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetWidth</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"targetWidth must be >= 0"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetHeight</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"targetHeight must be >= 0"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>scalingMethod</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
                    <color=#e6db74>"scalingMethod cannot be null. A good default value is Method.AUTOMATIC."</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>resizeMode</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color>
                    <color=#e6db74>"resizeMode cannot be null. A good default value is Mode.AUTOMATIC."</color><color=#f8f8f2>);</color>

        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>null</color><color=#f8f8f2>;</color>

        <color=#66d9ef>int</color> <color=#f8f8f2>currentWidth</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>currentHeight</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color>

        <color=#75715e>// <= 1 is a square or landscape-oriented image, > 1 is a portrait.</color>
        <color=#66d9ef>float</color> <color=#f8f8f2>ratio</color> <color=#f92672>=</color> <color=#f8f8f2>((</color><color=#66d9ef>float</color><color=#f8f8f2>)</color> <color=#f8f8f2>currentHeight</color> <color=#f92672>/</color> <color=#f8f8f2>(</color><color=#66d9ef>float</color><color=#f8f8f2>)</color> <color=#f8f8f2>currentWidth</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color>
                    <color=#e6db74>"Resizing Image [size=%dx%d, resizeMode=%s, orientation=%s, ratio(H/W)=%f] to [targetSize=%dx%d]"</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>currentWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>currentHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>resizeMode</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>(</color><color=#f8f8f2>ratio</color> <color=#f92672><=</color> <color=#ae81ff>1</color> <color=#f92672>?</color> <color=#e6db74>"Landscape/Square"</color> <color=#f8f8f2>:</color> <color=#e6db74>"Portrait"</color><color=#f8f8f2>),</color> <color=#f8f8f2>ratio</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * First determine if ANY size calculation needs to be done, in the case</color>
<color=#75715e>         * of FIT_EXACT, ignore image proportions and orientation and just use</color>
<color=#75715e>         * what the user sent in, otherwise the proportion of the picture must</color>
<color=#75715e>         * be honored.</color>
<color=#75715e>         *</color>
<color=#75715e>         * The way that is done is to figure out if the image is in a</color>
<color=#75715e>         * LANDSCAPE/SQUARE or PORTRAIT orientation and depending on its</color>
<color=#75715e>         * orientation, use the primary dimension (width for LANDSCAPE/SQUARE</color>
<color=#75715e>         * and height for PORTRAIT) to recalculate the alternative (height and</color>
<color=#75715e>         * width respectively) value that adheres to the existing ratio.</color>
<color=#75715e>         *</color>
<color=#75715e>         * This helps make life easier for the caller as they don't need to</color>
<color=#75715e>         * pre-compute proportional dimensions before calling the API, they can</color>
<color=#75715e>         * just specify the dimensions they would like the image to roughly fit</color>
<color=#75715e>         * within and it will do the right thing without mangling the result.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>resizeMode</color> <color=#f92672>!=</color> <color=#f8f8f2>Mode</color><color=#f8f8f2>.</color><color=#a6e22e>FIT_EXACT</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>((</color><color=#f8f8f2>ratio</color> <color=#f92672><=</color> <color=#ae81ff>1</color> <color=#f92672>&&</color> <color=#f8f8f2>resizeMode</color> <color=#f92672>==</color> <color=#f8f8f2>Mode</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>)</color>
                    <color=#f92672>||</color> <color=#f8f8f2>(</color><color=#f8f8f2>resizeMode</color> <color=#f92672>==</color> <color=#f8f8f2>Mode</color><color=#f8f8f2>.</color><color=#a6e22e>FIT_TO_WIDTH</color><color=#f8f8f2>))</color> <color=#f8f8f2>{</color>
                <color=#75715e>// First make sure we need to do any work in the first place</color>
                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetWidth</color> <color=#f92672>==</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>())</color>
                    <color=#66d9ef>return</color> <color=#f8f8f2>src</color><color=#f8f8f2>;</color>

                <color=#75715e>// Save for detailed logging (this is cheap).</color>
                <color=#66d9ef>int</color> <color=#f8f8f2>originalTargetHeight</color> <color=#f92672>=</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>;</color>

                <color=#75715e>/*</color>
<color=#75715e>                 * Landscape or Square Orientation: Ignore the given height and</color>
<color=#75715e>                 * re-calculate a proportionally correct value based on the</color>
<color=#75715e>                 * targetWidth.</color>
<color=#75715e>                 */</color>
                <color=#f8f8f2>targetHeight</color> <color=#f92672>=</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>round</color><color=#f8f8f2>((</color><color=#66d9ef>float</color><color=#f8f8f2>)</color> <color=#f8f8f2>targetWidth</color> <color=#f92672>*</color> <color=#f8f8f2>ratio</color><color=#f8f8f2>);</color>

                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color> <color=#f92672>&&</color> <color=#f8f8f2>originalTargetHeight</color> <color=#f92672>!=</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>)</color>
                    <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color>
                            <color=#e6db74>"Auto-Corrected targetHeight [from=%d to=%d] to honor image proportions."</color><color=#f8f8f2>,</color>
                            <color=#f8f8f2>originalTargetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#75715e>// First make sure we need to do any work in the first place</color>
                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetHeight</color> <color=#f92672>==</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>())</color>
                    <color=#66d9ef>return</color> <color=#f8f8f2>src</color><color=#f8f8f2>;</color>

                <color=#75715e>// Save for detailed logging (this is cheap).</color>
                <color=#66d9ef>int</color> <color=#f8f8f2>originalTargetWidth</color> <color=#f92672>=</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>;</color>

                <color=#75715e>/*</color>
<color=#75715e>                 * Portrait Orientation: Ignore the given width and re-calculate</color>
<color=#75715e>                 * a proportionally correct value based on the targetHeight.</color>
<color=#75715e>                 */</color>
                <color=#f8f8f2>targetWidth</color> <color=#f92672>=</color> <color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>round</color><color=#f8f8f2>((</color><color=#66d9ef>float</color><color=#f8f8f2>)</color> <color=#f8f8f2>targetHeight</color> <color=#f92672>/</color> <color=#f8f8f2>ratio</color><color=#f8f8f2>);</color>

                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color> <color=#f92672>&&</color> <color=#f8f8f2>originalTargetWidth</color> <color=#f92672>!=</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>)</color>
                    <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color>
                            <color=#e6db74>"Auto-Corrected targetWidth [from=%d to=%d] to honor image proportions."</color><color=#f8f8f2>,</color>
                            <color=#f8f8f2>originalTargetWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color>
                        <color=#e6db74>"Resize Mode FIT_EXACT used, no width/height checking or re-calculation will be done."</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// If AUTOMATIC was specified, determine the real scaling method.</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>scalingMethod</color> <color=#f92672>==</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>AUTOMATIC</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>scalingMethod</color> <color=#f92672>=</color> <color=#f8f8f2>determineScalingMethod</color><color=#f8f8f2>(</color><color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>ratio</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color> <color=#e6db74>"Using Scaling Method: %s"</color><color=#f8f8f2>,</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>);</color>

        <color=#75715e>// Now we scale the image</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>scalingMethod</color> <color=#f92672>==</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>SPEED</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>scaleImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>VALUE_INTERPOLATION_NEAREST_NEIGHBOR</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>scalingMethod</color> <color=#f92672>==</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>BALANCED</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>scaleImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>VALUE_INTERPOLATION_BILINEAR</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>scalingMethod</color> <color=#f92672>==</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>QUALITY</color>
                <color=#f92672>||</color> <color=#f8f8f2>scalingMethod</color> <color=#f92672>==</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>ULTRA_QUALITY</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#75715e>/*</color>
<color=#75715e>             * If we are scaling up (in either width or height - since we know</color>
<color=#75715e>             * the image will stay proportional we just check if either are</color>
<color=#75715e>             * being scaled up), directly using a single BICUBIC will give us</color>
<color=#75715e>             * better results then using Chris Campbell's incremental scaling</color>
<color=#75715e>             * operation (and take a lot less time).</color>
<color=#75715e>             *</color>
<color=#75715e>             * If we are scaling down, we must use the incremental scaling</color>
<color=#75715e>             * algorithm for the best result.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>targetWidth</color> <color=#f92672>></color> <color=#f8f8f2>currentWidth</color> <color=#f92672>||</color> <color=#f8f8f2>targetHeight</color> <color=#f92672>></color> <color=#f8f8f2>currentHeight</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
                    <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color>
                            <color=#e6db74>"QUALITY scale-up, a single BICUBIC scale operation will be used..."</color><color=#f8f8f2>);</color>

                <color=#75715e>/*</color>
<color=#75715e>                 * BILINEAR and BICUBIC look similar the smaller the scale jump</color>
<color=#75715e>                 * upwards is, if the scale is larger BICUBIC looks sharper and</color>
<color=#75715e>                 * less fuzzy. But most importantly we have to use BICUBIC to</color>
<color=#75715e>                 * match the contract of the QUALITY rendering scalingMethod.</color>
<color=#75715e>                 * This note is just here for anyone reading the code and</color>
<color=#75715e>                 * wondering how they can speed their own calls up.</color>
<color=#75715e>                 */</color>
                <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>scaleImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>VALUE_INTERPOLATION_BICUBIC</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color> <color=#66d9ef>else</color> <color=#f8f8f2>{</color>
                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
                    <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>1</color><color=#f8f8f2>,</color>
                            <color=#e6db74>"QUALITY scale-down, incremental scaling will be used..."</color><color=#f8f8f2>);</color>

                <color=#75715e>/*</color>
<color=#75715e>                 * Originally we wanted to use BILINEAR interpolation here</color>
<color=#75715e>                 * because it takes 1/3rd the time that the BICUBIC</color>
<color=#75715e>                 * interpolation does, however, when scaling large images down</color>
<color=#75715e>                 * to most sizes bigger than a thumbnail we witnessed noticeable</color>
<color=#75715e>                 * "softening" in the resultant image with BILINEAR that would</color>
<color=#75715e>                 * be unexpectedly annoying to a user expecting a "QUALITY"</color>
<color=#75715e>                 * scale of their original image. Instead BICUBIC was chosen to</color>
<color=#75715e>                 * honor the contract of a QUALITY scale of the original image.</color>
<color=#75715e>                 */</color>
                <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>scaleImageIncrementally</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>VALUE_INTERPOLATION_BICUBIC</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>}</color>
        <color=#f8f8f2>}</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#e6db74>"Resized Image in %d ms"</color><color=#f8f8f2>,</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>t</color><color=#f8f8f2>);</color>

        <color=#75715e>// Apply any optional operations (if specified).</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ops</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>ops</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>apply</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to apply a {@link Rotation} and then <code>0</code> or more</color>
<color=#75715e>     * {@link BufferedImageOp}s to a given image and return the result.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>TIP</strong>: This operation leaves the original <code>src</code></color>
<color=#75715e>     * image unmodified. If the caller is done with the <code>src</code> image</color>
<color=#75715e>     * after getting the result of this operation, remember to call</color>
<color=#75715e>     * {@link BufferedImage#flush()} on the <code>src</code> to free up native</color>
<color=#75715e>     * resources and make it easier for the GC to collect the unused image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will have the rotation applied to it.</color>
<color=#75715e>     * @param rotation</color>
<color=#75715e>     *            The rotation that will be applied to the image.</color>
<color=#75715e>     * @param ops</color>
<color=#75715e>     *            Zero or more optional image operations (e.g. sharpen, blur,</color>
<color=#75715e>     *            etc.) that can be applied to the final result before returning</color>
<color=#75715e>     *            the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing <code>src</code> rotated</color>
<color=#75715e>     *         by the given amount and any optional ops applied to it.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>rotation</code> is <code>null</code>.</color>
<color=#75715e>     * @throws ImagingOpException</color>
<color=#75715e>     *             if one of the given {@link BufferedImageOp}s fails to apply.</color>
<color=#75715e>     *             These exceptions bubble up from the inside of most of the</color>
<color=#75715e>     *             {@link BufferedImageOp} implementations and are explicitly</color>
<color=#75715e>     *             defined on the imgscalr API to make it easier for callers to</color>
<color=#75715e>     *             catch the exception (if they are passing along optional ops</color>
<color=#75715e>     *             to be applied). imgscalr takes detailed steps to avoid the</color>
<color=#75715e>     *             most common pitfalls that will cause {@link BufferedImageOp}s</color>
<color=#75715e>     *             to fail, even when using straight forward JDK-image</color>
<color=#75715e>     *             operations.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see Rotation</color>
<color=#75715e>     */</color>
    <color=#66d9ef>public</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>rotate</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>Rotation</color> <color=#f8f8f2>rotation</color><color=#f8f8f2>,</color>
                                       <color=#f8f8f2>BufferedImageOp</color><color=#f8f8f2>...</color> <color=#f8f8f2>ops</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>,</color>
            <color=#f8f8f2>ImagingOpException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>long</color> <color=#f8f8f2>t</color> <color=#f92672>=</color> <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>src</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"src cannot be null"</color><color=#f8f8f2>);</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>rotation</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"rotation cannot be null"</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#e6db74>"Rotating Image [%s]..."</color><color=#f8f8f2>,</color> <color=#f8f8f2>rotation</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Setup the default width/height values from our image.</color>
<color=#75715e>         *</color>
<color=#75715e>         * In the case of a 90 or 270 (-90) degree rotation, these two values</color>
<color=#75715e>         * flip-flop and we will correct those cases down below in the switch</color>
<color=#75715e>         * statement.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>newWidth</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>newHeight</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * We create a transform per operation request as (oddly enough) it ends</color>
<color=#75715e>         * up being faster for the VM to create, use and destroy these instances</color>
<color=#75715e>         * than it is to re-use a single AffineTransform per-thread via the</color>
<color=#75715e>         * AffineTransform.setTo(...) methods which was my first choice (less</color>
<color=#75715e>         * object creation); after benchmarking this explicit case and looking</color>
<color=#75715e>         * at just how much code gets run inside of setTo() I opted for a new AT</color>
<color=#75715e>         * for every rotation.</color>
<color=#75715e>         *</color>
<color=#75715e>         * Besides the performance win, trying to safely reuse AffineTransforms</color>
<color=#75715e>         * via setTo(...) would have required ThreadLocal instances to avoid</color>
<color=#75715e>         * race conditions where two or more resize threads are manipulating the</color>
<color=#75715e>         * same transform before applying it.</color>
<color=#75715e>         *</color>
<color=#75715e>         * Misusing ThreadLocals are one of the #1 reasons for memory leaks in</color>
<color=#75715e>         * server applications and since we have no nice way to hook into the</color>
<color=#75715e>         * init/destroy Servlet cycle or any other initialization cycle for this</color>
<color=#75715e>         * library to automatically call ThreadLocal.remove() to avoid the</color>
<color=#75715e>         * memory leak, it would have made using this library *safely* on the</color>
<color=#75715e>         * server side much harder.</color>
<color=#75715e>         *</color>
<color=#75715e>         * So we opt for creating individual transforms per rotation op and let</color>
<color=#75715e>         * the VM clean them up in a GC. I only clarify all this reasoning here</color>
<color=#75715e>         * for anyone else reading this code and being tempted to reuse the AT</color>
<color=#75715e>         * instances of performance gains; there aren't any AND you get a lot of</color>
<color=#75715e>         * pain along with it.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>AffineTransform</color> <color=#f8f8f2>tx</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>AffineTransform</color><color=#f8f8f2>();</color>

        <color=#66d9ef>switch</color> <color=#f8f8f2>(</color><color=#f8f8f2>rotation</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>case</color> <color=#f8f8f2>CW_90</color><color=#f8f8f2>:</color>
                <color=#75715e>/*</color>
<color=#75715e>                 * A 90 or -90 degree rotation will cause the height and width to</color>
<color=#75715e>                 * flip-flop from the original image to the rotated one.</color>
<color=#75715e>                 */</color>
                <color=#f8f8f2>newWidth</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color>
                <color=#f8f8f2>newHeight</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color>

                <color=#75715e>// Reminder: newWidth == result.getHeight() at this point</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>translate</color><color=#f8f8f2>(</color><color=#f8f8f2>newWidth</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>rotate</color><color=#f8f8f2>(</color><color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>toRadians</color><color=#f8f8f2>(</color><color=#ae81ff>90</color><color=#f8f8f2>));</color>

                <color=#66d9ef>break</color><color=#f8f8f2>;</color>

            <color=#66d9ef>case</color> <color=#f8f8f2>CW_270</color><color=#f8f8f2>:</color>
                <color=#75715e>/*</color>
<color=#75715e>                 * A 90 or -90 degree rotation will cause the height and width to</color>
<color=#75715e>                 * flip-flop from the original image to the rotated one.</color>
<color=#75715e>                 */</color>
                <color=#f8f8f2>newWidth</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color>
                <color=#f8f8f2>newHeight</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color>

                <color=#75715e>// Reminder: newHeight == result.getWidth() at this point</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>translate</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>newHeight</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>rotate</color><color=#f8f8f2>(</color><color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>toRadians</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>90</color><color=#f8f8f2>));</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>

            <color=#66d9ef>case</color> <color=#f8f8f2>CW_180</color><color=#f8f8f2>:</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>translate</color><color=#f8f8f2>(</color><color=#f8f8f2>newWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>newHeight</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>rotate</color><color=#f8f8f2>(</color><color=#f8f8f2>Math</color><color=#f8f8f2>.</color><color=#a6e22e>toRadians</color><color=#f8f8f2>(</color><color=#ae81ff>180</color><color=#f8f8f2>));</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>

            <color=#66d9ef>case</color> <color=#f8f8f2>FLIP_HORZ</color><color=#f8f8f2>:</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>translate</color><color=#f8f8f2>(</color><color=#f8f8f2>newWidth</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>scale</color><color=#f8f8f2>(</color><color=#f92672>-</color><color=#ae81ff>1.0</color><color=#f8f8f2>,</color> <color=#ae81ff>1.0</color><color=#f8f8f2>);</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>

            <color=#66d9ef>case</color> <color=#f8f8f2>FLIP_VERT</color><color=#f8f8f2>:</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>translate</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>newHeight</color><color=#f8f8f2>);</color>
                <color=#f8f8f2>tx</color><color=#f8f8f2>.</color><color=#a6e22e>scale</color><color=#f8f8f2>(</color><color=#ae81ff>1.0</color><color=#f8f8f2>,</color> <color=#f92672>-</color><color=#ae81ff>1.0</color><color=#f8f8f2>);</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color>

        <color=#75715e>// Create our target image we will render the rotated result to.</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>createOptimalImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>newWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>newHeight</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>Graphics2D</color> <color=#f8f8f2>g2d</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>Graphics2D</color><color=#f8f8f2>)</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>createGraphics</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Render the resultant image to our new rotatedImage buffer, applying</color>
<color=#75715e>         * the AffineTransform that we calculated above during rendering so the</color>
<color=#75715e>         * pixels from the old position are transposed to the new positions in</color>
<color=#75715e>         * the resulting image correctly.</color>
<color=#75715e>         */</color>
        <color=#f8f8f2>g2d</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>tx</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>g2d</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#e6db74>"Rotation Applied in %d ms, result [width=%d, height=%d]"</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>currentTimeMillis</color><color=#f8f8f2>()</color> <color=#f92672>-</color> <color=#f8f8f2>t</color><color=#f8f8f2>,</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color>
                    <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>());</color>

        <color=#75715e>// Apply any optional operations (if specified).</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>ops</color> <color=#f92672>!=</color> <color=#66d9ef>null</color> <color=#f92672>&&</color> <color=#f8f8f2>ops</color><color=#f8f8f2>.</color><color=#a6e22e>length</color> <color=#f92672>></color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>apply</color><color=#f8f8f2>(</color><color=#f8f8f2>result</color><color=#f8f8f2>,</color> <color=#f8f8f2>ops</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to write out a useful and well-formatted log message by any piece of</color>
<color=#75715e>     * code inside of the imgscalr library.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * If a message cannot be logged (logging is disabled) then this method</color>
<color=#75715e>     * returns immediately.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * <strong>NOTE</strong>: Because Java will auto-box primitive arguments</color>
<color=#75715e>     * into Objects when building out the <code>params</code> array, care should</color>
<color=#75715e>     * be taken not to call this method with primitive values unless</color>
<color=#75715e>     * {@link Scalr#DEBUG} is <code>true</code>; otherwise the VM will be</color>
<color=#75715e>     * spending time performing unnecessary auto-boxing calculations.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param depth</color>
<color=#75715e>     *            The indentation level of the log message.</color>
<color=#75715e>     * @param message</color>
<color=#75715e>     *            The log message in <a href=</color>
<color=#75715e>     *            "http://download.oracle.com/javase/6/docs/api/java/util/Formatter.html#syntax"</color>
<color=#75715e>     *            >format string syntax</a> that will be logged.</color>
<color=#75715e>     * @param params</color>
<color=#75715e>     *            The parameters that will be swapped into all the place holders</color>
<color=#75715e>     *            in the original messages before being logged.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see Scalr#LOG_PREFIX</color>
<color=#75715e>     * @see Scalr#LOG_PREFIX_PROPERTY_NAME</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#66d9ef>void</color> <color=#a6e22e>log</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>depth</color><color=#f8f8f2>,</color> <color=#f8f8f2>String</color> <color=#f8f8f2>message</color><color=#f8f8f2>,</color> <color=#f8f8f2>Object</color><color=#f8f8f2>...</color> <color=#f8f8f2>params</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>Scalr</color><color=#f8f8f2>.</color><color=#a6e22e>DEBUG</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
            <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>print</color><color=#f8f8f2>(</color><color=#f8f8f2>Scalr</color><color=#f8f8f2>.</color><color=#a6e22e>LOG_PREFIX</color><color=#f8f8f2>);</color>

            <color=#66d9ef>for</color> <color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>i</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color> <color=#f92672><</color> <color=#f8f8f2>depth</color><color=#f8f8f2>;</color> <color=#f8f8f2>i</color><color=#f92672>++</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>print</color><color=#f8f8f2>(</color><color=#e6db74>"\t"</color><color=#f8f8f2>);</color>

            <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>printf</color><color=#f8f8f2>(</color><color=#f8f8f2>message</color><color=#f8f8f2>,</color> <color=#f8f8f2>params</color><color=#f8f8f2>);</color>
            <color=#f8f8f2>System</color><color=#f8f8f2>.</color><color=#a6e22e>out</color><color=#f8f8f2>.</color><color=#a6e22e>println</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>}</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to create a {@link BufferedImage} with the most optimal RGB TYPE (</color>
<color=#75715e>     * {@link BufferedImage#TYPE_INT_RGB} or {@link BufferedImage#TYPE_INT_ARGB}</color>
<color=#75715e>     * ) capable of being rendered into from the given <code>src</code>. The</color>
<color=#75715e>     * width and height of both images will be identical.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This does not perform a copy of the image data from <code>src</code> into</color>
<color=#75715e>     * the result image; see {@link #copyToOptimalImage(BufferedImage)} for</color>
<color=#75715e>     * that.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * We force all rendering results into one of these two types, avoiding the</color>
<color=#75715e>     * case where a source image is of an unsupported (or poorly supported)</color>
<color=#75715e>     * format by Java2D causing the rendering result to end up looking terrible</color>
<color=#75715e>     * (common with GIFs) or be totally corrupt (e.g. solid black image).</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * Originally reported by Magnus Kvalheim from Movellas when scaling certain</color>
<color=#75715e>     * GIF and PNG images.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The source image that will be analyzed to determine the most</color>
<color=#75715e>     *            optimal image type it can be rendered into.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the most optimal target</color>
<color=#75715e>     *         image type that <code>src</code> can be rendered into.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see <a</color>
<color=#75715e>     *      href="http://www.mail-archive.com/java2d-interest@capra.eng.sun.com/msg05621.html">How</color>
<color=#75715e>     *      Java2D handles poorly supported image types</a></color>
<color=#75715e>     * @see <a</color>
<color=#75715e>     *      href="http://code.google.com/p/java-image-scaling/source/browse/trunk/src/main/java/com/mortennobel/imagescaling/MultiStepRescaleOp.java">Thanks</color>
<color=#75715e>     *      to Morten Nobel for implementation hint</a></color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createOptimalImage</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>createOptimalImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>());</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to create a {@link BufferedImage} with the given dimensions and the</color>
<color=#75715e>     * most optimal RGB TYPE ( {@link BufferedImage#TYPE_INT_RGB} or</color>
<color=#75715e>     * {@link BufferedImage#TYPE_INT_ARGB} ) capable of being rendered into from</color>
<color=#75715e>     * the given <code>src</code>.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This does not perform a copy of the image data from <code>src</code> into</color>
<color=#75715e>     * the result image; see {@link #copyToOptimalImage(BufferedImage)} for</color>
<color=#75715e>     * that.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * We force all rendering results into one of these two types, avoiding the</color>
<color=#75715e>     * case where a source image is of an unsupported (or poorly supported)</color>
<color=#75715e>     * format by Java2D causing the rendering result to end up looking terrible</color>
<color=#75715e>     * (common with GIFs) or be totally corrupt (e.g. solid black image).</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * Originally reported by Magnus Kvalheim from Movellas when scaling certain</color>
<color=#75715e>     * GIF and PNG images.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The source image that will be analyzed to determine the most</color>
<color=#75715e>     *            optimal image type it can be rendered into.</color>
<color=#75715e>     * @param width</color>
<color=#75715e>     *            The width of the newly created resulting image.</color>
<color=#75715e>     * @param height</color>
<color=#75715e>     *            The height of the newly created resulting image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a new {@link BufferedImage} representing the most optimal target</color>
<color=#75715e>     *         image type that <code>src</code> can be rendered into.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>width</code> or <code>height</code> are &lt; 0.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @see <a</color>
<color=#75715e>     *      href="http://www.mail-archive.com/java2d-interest@capra.eng.sun.com/msg05621.html">How</color>
<color=#75715e>     *      Java2D handles poorly supported image types</a></color>
<color=#75715e>     * @see <a</color>
<color=#75715e>     *      href="http://code.google.com/p/java-image-scaling/source/browse/trunk/src/main/java/com/mortennobel/imagescaling/MultiStepRescaleOp.java">Thanks</color>
<color=#75715e>     *      to Morten Nobel for implementation hint</a></color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>createOptimalImage</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color>
                                                      <color=#66d9ef>int</color> <color=#f8f8f2>width</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>height</color><color=#f8f8f2>)</color> <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>width</color> <color=#f92672><</color> <color=#ae81ff>0</color> <color=#f92672>||</color> <color=#f8f8f2>height</color> <color=#f92672><</color> <color=#ae81ff>0</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"width ["</color> <color=#f92672>+</color> <color=#f8f8f2>width</color>
                    <color=#f92672>+</color> <color=#e6db74>"] and height ["</color> <color=#f92672>+</color> <color=#f8f8f2>height</color> <color=#f92672>+</color> <color=#e6db74>"] must be >= 0"</color><color=#f8f8f2>);</color>

        <color=#66d9ef>return</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color>
                <color=#f8f8f2>width</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>height</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getTransparency</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>OPAQUE</color> <color=#f92672>?</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_RGB</color>
                        <color=#f8f8f2>:</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_ARGB</color><color=#f8f8f2>));</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to copy a {@link BufferedImage} from a non-optimal type into a new</color>
<color=#75715e>     * {@link BufferedImage} instance of an optimal type (RGB or ARGB). If</color>
<color=#75715e>     * <code>src</code> is already of an optimal type, then it is returned</color>
<color=#75715e>     * unmodified.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This method is meant to be used by any calling code (imgscalr's or</color>
<color=#75715e>     * otherwise) to convert any inbound image from a poorly supported image</color>
<color=#75715e>     * type into the 2 most well-supported image types in Java2D (</color>
<color=#75715e>     * {@link BufferedImage#TYPE_INT_RGB} or {@link BufferedImage#TYPE_INT_ARGB}</color>
<color=#75715e>     * ) in order to ensure all subsequent graphics operations are performed as</color>
<color=#75715e>     * efficiently and correctly as possible.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * When using Java2D to work with image types that are not well supported,</color>
<color=#75715e>     * the results can be anything from exceptions bubbling up from the depths</color>
<color=#75715e>     * of Java2D to images being completely corrupted and just returned as solid</color>
<color=#75715e>     * black.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image to copy (if necessary) into an optimally typed</color>
<color=#75715e>     *            {@link BufferedImage}.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return a representation of the <code>src</code> image in an optimally</color>
<color=#75715e>     *         typed {@link BufferedImage}, otherwise <code>src</code> if it was</color>
<color=#75715e>     *         already of an optimal type.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @throws IllegalArgumentException</color>
<color=#75715e>     *             if <code>src</code> is <code>null</code>.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>copyToOptimalImage</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throws</color> <color=#f8f8f2>IllegalArgumentException</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>src</color> <color=#f92672>==</color> <color=#66d9ef>null</color><color=#f8f8f2>)</color>
            <color=#66d9ef>throw</color> <color=#66d9ef>new</color> <color=#f8f8f2>IllegalArgumentException</color><color=#f8f8f2>(</color><color=#e6db74>"src cannot be null"</color><color=#f8f8f2>);</color>

        <color=#75715e>// Calculate the type depending on the presence of alpha.</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>type</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getTransparency</color><color=#f8f8f2>()</color> <color=#f92672>==</color> <color=#f8f8f2>Transparency</color><color=#f8f8f2>.</color><color=#a6e22e>OPAQUE</color> <color=#f92672>?</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_RGB</color>
                <color=#f8f8f2>:</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>.</color><color=#a6e22e>TYPE_INT_ARGB</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#66d9ef>new</color> <color=#f8f8f2>BufferedImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>(),</color>
                <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>(),</color> <color=#f8f8f2>type</color><color=#f8f8f2>);</color>

        <color=#75715e>// Render the src image into our new optimal source.</color>
        <color=#f8f8f2>Graphics</color> <color=#f8f8f2>g</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>getGraphics</color><color=#f8f8f2>();</color>
        <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>g</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to determine the scaling {@link Method} that is best suited for</color>
<color=#75715e>     * scaling the image to the targeted dimensions.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This method is intended to be used to select a specific scaling</color>
<color=#75715e>     * {@link Method} when a {@link Method#AUTOMATIC} method is specified. This</color>
<color=#75715e>     * method utilizes the {@link Scalr#THRESHOLD_QUALITY_BALANCED} and</color>
<color=#75715e>     * {@link Scalr#THRESHOLD_BALANCED_SPEED} thresholds when selecting which</color>
<color=#75715e>     * method should be used by comparing the primary dimension (width or</color>
<color=#75715e>     * height) against the threshold and seeing where the image falls. The</color>
<color=#75715e>     * primary dimension is determined by looking at the orientation of the</color>
<color=#75715e>     * image: landscape or square images use their width and portrait-oriented</color>
<color=#75715e>     * images use their height.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param targetWidth</color>
<color=#75715e>     *            The target width for the scaled image.</color>
<color=#75715e>     * @param targetHeight</color>
<color=#75715e>     *            The target height for the scaled image.</color>
<color=#75715e>     * @param ratio</color>
<color=#75715e>     *            A height/width ratio used to determine the orientation of the</color>
<color=#75715e>     *            image so the primary dimension (width or height) can be</color>
<color=#75715e>     *            selected to test if it is greater than or less than a</color>
<color=#75715e>     *            particular threshold.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return the fastest {@link Method} suited for scaling the image to the</color>
<color=#75715e>     *         specified dimensions while maintaining a good-looking result.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#f8f8f2>Method</color> <color=#a6e22e>determineScalingMethod</color><color=#f8f8f2>(</color><color=#66d9ef>int</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color>
                                                   <color=#66d9ef>int</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>float</color> <color=#f8f8f2>ratio</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Get the primary dimension based on the orientation of the image</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>length</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>ratio</color> <color=#f92672><=</color> <color=#ae81ff>1</color> <color=#f92672>?</color> <color=#f8f8f2>targetWidth</color> <color=#f8f8f2>:</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>);</color>

        <color=#75715e>// Default to speed</color>
        <color=#f8f8f2>Method</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>SPEED</color><color=#f8f8f2>;</color>

        <color=#75715e>// Figure out which scalingMethod should be used</color>
        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>length</color> <color=#f92672><=</color> <color=#f8f8f2>Scalr</color><color=#f8f8f2>.</color><color=#a6e22e>THRESHOLD_QUALITY_BALANCED</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>QUALITY</color><color=#f8f8f2>;</color>
        <color=#66d9ef>else</color> <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>length</color> <color=#f92672><=</color> <color=#f8f8f2>Scalr</color><color=#f8f8f2>.</color><color=#a6e22e>THRESHOLD_BALANCED_SPEED</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>BALANCED</color><color=#f8f8f2>;</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#e6db74>"AUTOMATIC scaling method selected: %s"</color><color=#f8f8f2>,</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>name</color><color=#f8f8f2>());</color>

        <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to implement a straight-forward image-scaling operation using Java</color>
<color=#75715e>     * 2D.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * This method uses the Oracle-encouraged method of</color>
<color=#75715e>     * <code>Graphics2D.drawImage(...)</code> to scale the given image with the</color>
<color=#75715e>     * given interpolation hint.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param targetWidth</color>
<color=#75715e>     *            The target width for the scaled image.</color>
<color=#75715e>     * @param targetHeight</color>
<color=#75715e>     *            The target height for the scaled image.</color>
<color=#75715e>     * @param interpolationHintValue</color>
<color=#75715e>     *            The {@link RenderingHints} interpolation value used to</color>
<color=#75715e>     *            indicate the method that {@link Graphics2D} should use when</color>
<color=#75715e>     *            scaling the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return the result of scaling the original <code>src</code> to the given</color>
<color=#75715e>     *         dimensions using the given interpolation method.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>scaleImage</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color>
                                              <color=#66d9ef>int</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>Object</color> <color=#f8f8f2>interpolationHintValue</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#75715e>// Setup the rendering resources to match the source image's</color>
        <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>result</color> <color=#f92672>=</color> <color=#f8f8f2>createOptimalImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>targetHeight</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>Graphics2D</color> <color=#f8f8f2>resultGraphics</color> <color=#f92672>=</color> <color=#f8f8f2>result</color><color=#f8f8f2>.</color><color=#a6e22e>createGraphics</color><color=#f8f8f2>();</color>

        <color=#75715e>// Scale the image to the new buffer using the specified rendering hint.</color>
        <color=#f8f8f2>resultGraphics</color><color=#f8f8f2>.</color><color=#a6e22e>setRenderingHint</color><color=#f8f8f2>(</color><color=#f8f8f2>RenderingHints</color><color=#f8f8f2>.</color><color=#a6e22e>KEY_INTERPOLATION</color><color=#f8f8f2>,</color>
                <color=#f8f8f2>interpolationHintValue</color><color=#f8f8f2>);</color>
        <color=#f8f8f2>resultGraphics</color><color=#f8f8f2>.</color><color=#a6e22e>drawImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#ae81ff>0</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#66d9ef>null</color><color=#f8f8f2>);</color>

        <color=#75715e>// Just to be clean, explicitly dispose our temporary graphics object</color>
        <color=#f8f8f2>resultGraphics</color><color=#f8f8f2>.</color><color=#a6e22e>dispose</color><color=#f8f8f2>();</color>

        <color=#75715e>// Return the scaled image to the caller.</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>result</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>

    <color=#75715e>/**</color>
<color=#75715e>     * Used to implement Chris Campbell's incremental-scaling algorithm: <a</color>
<color=#75715e>     * href="http://today.java.net/pub/a/today/2007/04/03/perils</color>
<color=#75715e>     * -of-image-getscaledinstance</color>
<color=#75715e>     * .html">http://today.java.net/pub/a/today/2007/04/03/perils</color>
<color=#75715e>     * -of-image-getscaledinstance.html</a>.</color>
<color=#75715e>     * <p/></color>
<color=#75715e>     * Modifications to the original algorithm are variable names and comments</color>
<color=#75715e>     * added for clarity and the hard-coding of using BICUBIC interpolation as</color>
<color=#75715e>     * well as the explicit "flush()" operation on the interim BufferedImage</color>
<color=#75715e>     * instances to avoid resource leaking.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @param src</color>
<color=#75715e>     *            The image that will be scaled.</color>
<color=#75715e>     * @param targetWidth</color>
<color=#75715e>     *            The target width for the scaled image.</color>
<color=#75715e>     * @param targetHeight</color>
<color=#75715e>     *            The target height for the scaled image.</color>
<color=#75715e>     * @param scalingMethod</color>
<color=#75715e>     *            The scaling method specified by the user (or calculated by</color>
<color=#75715e>     *            imgscalr) to use for this incremental scaling operation.</color>
<color=#75715e>     * @param interpolationHintValue</color>
<color=#75715e>     *            The {@link RenderingHints} interpolation value used to</color>
<color=#75715e>     *            indicate the method that {@link Graphics2D} should use when</color>
<color=#75715e>     *            scaling the image.</color>
<color=#75715e>     *</color>
<color=#75715e>     * @return an image scaled to the given dimensions using the given rendering</color>
<color=#75715e>     *         hint.</color>
<color=#75715e>     */</color>
    <color=#66d9ef>protected</color> <color=#66d9ef>static</color> <color=#f8f8f2>BufferedImage</color> <color=#a6e22e>scaleImageIncrementally</color><color=#f8f8f2>(</color><color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>src</color><color=#f8f8f2>,</color>
                                                           <color=#66d9ef>int</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>,</color> <color=#66d9ef>int</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>Method</color> <color=#f8f8f2>scalingMethod</color><color=#f8f8f2>,</color>
                                                           <color=#f8f8f2>Object</color> <color=#f8f8f2>interpolationHintValue</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
        <color=#66d9ef>boolean</color> <color=#f8f8f2>hasReassignedSrc</color> <color=#f92672>=</color> <color=#66d9ef>false</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>incrementCount</color> <color=#f92672>=</color> <color=#ae81ff>0</color><color=#f8f8f2>;</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>currentWidth</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getWidth</color><color=#f8f8f2>();</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>currentHeight</color> <color=#f92672>=</color> <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>getHeight</color><color=#f8f8f2>();</color>

        <color=#75715e>/*</color>
<color=#75715e>         * The original QUALITY mode, representing Chris Campbell's algorithm,</color>
<color=#75715e>         * is to step down by 1/2s every time when scaling the image</color>
<color=#75715e>         * incrementally. Users pointed out that using this method to scale</color>
<color=#75715e>         * images with noticeable straight lines left them really jagged in</color>
<color=#75715e>         * smaller thumbnail format.</color>
<color=#75715e>         *</color>
<color=#75715e>         * After investigation it was discovered that scaling incrementally by</color>
<color=#75715e>         * smaller increments was the ONLY way to make the thumbnail sized</color>
<color=#75715e>         * images look less jagged and more accurate; almost matching the</color>
<color=#75715e>         * accuracy of Mac's built in thumbnail generation which is the highest</color>
<color=#75715e>         * quality resize I've come across (better than GIMP Lanczos3 and</color>
<color=#75715e>         * Windows 7).</color>
<color=#75715e>         *</color>
<color=#75715e>         * A divisor of 7 was chose as using 5 still left some jaggedness in the</color>
<color=#75715e>         * image while a divisor of 8 or higher made the resulting thumbnail too</color>
<color=#75715e>         * soft; like our OP_ANTIALIAS convolve op had been forcibly applied to</color>
<color=#75715e>         * the result even if the user didn't want it that soft.</color>
<color=#75715e>         *</color>
<color=#75715e>         * Using a divisor of 7 for the ULTRA_QUALITY seemed to be the sweet</color>
<color=#75715e>         * spot.</color>
<color=#75715e>         *</color>
<color=#75715e>         * NOTE: Below when the actual fraction is used to calculate the small</color>
<color=#75715e>         * portion to subtract from the current dimension, this is a</color>
<color=#75715e>         * progressively smaller and smaller chunk. When the code was changed to</color>
<color=#75715e>         * do a linear reduction of the image of equal steps for each</color>
<color=#75715e>         * incremental resize (e.g. say 50px each time) the result was</color>
<color=#75715e>         * significantly worse than the progressive approach used below; even</color>
<color=#75715e>         * when a very high number of incremental steps (13) was tested.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>int</color> <color=#f8f8f2>fraction</color> <color=#f92672>=</color> <color=#f8f8f2>(</color><color=#f8f8f2>scalingMethod</color> <color=#f92672>==</color> <color=#f8f8f2>Method</color><color=#f8f8f2>.</color><color=#a6e22e>ULTRA_QUALITY</color> <color=#f92672>?</color> <color=#ae81ff>7</color> <color=#f8f8f2>:</color> <color=#ae81ff>2</color><color=#f8f8f2>);</color>

        <color=#66d9ef>do</color> <color=#f8f8f2>{</color>
            <color=#66d9ef>int</color> <color=#f8f8f2>prevCurrentWidth</color> <color=#f92672>=</color> <color=#f8f8f2>currentWidth</color><color=#f8f8f2>;</color>
            <color=#66d9ef>int</color> <color=#f8f8f2>prevCurrentHeight</color> <color=#f92672>=</color> <color=#f8f8f2>currentHeight</color><color=#f8f8f2>;</color>

            <color=#75715e>/*</color>
<color=#75715e>             * If the current width is bigger than our target, cut it in half</color>
<color=#75715e>             * and sample again.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentWidth</color> <color=#f92672>></color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>currentWidth</color> <color=#f92672>-=</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentWidth</color> <color=#f92672>/</color> <color=#f8f8f2>fraction</color><color=#f8f8f2>);</color>

                <color=#75715e>/*</color>
<color=#75715e>                 * If we cut the width too far it means we are on our last</color>
<color=#75715e>                 * iteration. Just set it to the target width and finish up.</color>
<color=#75715e>                 */</color>
                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentWidth</color> <color=#f92672><</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>)</color>
                    <color=#f8f8f2>currentWidth</color> <color=#f92672>=</color> <color=#f8f8f2>targetWidth</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>

            <color=#75715e>/*</color>
<color=#75715e>             * If the current height is bigger than our target, cut it in half</color>
<color=#75715e>             * and sample again.</color>
<color=#75715e>             */</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentHeight</color> <color=#f92672>></color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>)</color> <color=#f8f8f2>{</color>
                <color=#f8f8f2>currentHeight</color> <color=#f92672>-=</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentHeight</color> <color=#f92672>/</color> <color=#f8f8f2>fraction</color><color=#f8f8f2>);</color>

                <color=#75715e>/*</color>
<color=#75715e>                 * If we cut the height too far it means we are on our last</color>
<color=#75715e>                 * iteration. Just set it to the target height and finish up.</color>
<color=#75715e>                 */</color>

                <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentHeight</color> <color=#f92672><</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>)</color>
                    <color=#f8f8f2>currentHeight</color> <color=#f92672>=</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>;</color>
            <color=#f8f8f2>}</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Stop when we cannot incrementally step down anymore.</color>
<color=#75715e>             *</color>
<color=#75715e>             * This used to use a || condition, but that would cause problems</color>
<color=#75715e>             * when using FIT_EXACT such that sometimes the width OR height</color>
<color=#75715e>             * would not change between iterations, but the other dimension</color>
<color=#75715e>             * would (e.g. resizing 500x500 to 500x250).</color>
<color=#75715e>             *</color>
<color=#75715e>             * Now changing this to an && condition requires that both</color>
<color=#75715e>             * dimensions do not change between a resize iteration before we</color>
<color=#75715e>             * consider ourselves done.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>prevCurrentWidth</color> <color=#f92672>==</color> <color=#f8f8f2>currentWidth</color>
                    <color=#f92672>&&</color> <color=#f8f8f2>prevCurrentHeight</color> <color=#f92672>==</color> <color=#f8f8f2>currentHeight</color><color=#f8f8f2>)</color>
                <color=#66d9ef>break</color><color=#f8f8f2>;</color>

            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#e6db74>"Scaling from [%d x %d] to [%d x %d]"</color><color=#f8f8f2>,</color> <color=#f8f8f2>prevCurrentWidth</color><color=#f8f8f2>,</color>
                        <color=#f8f8f2>prevCurrentHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>currentWidth</color><color=#f8f8f2>,</color> <color=#f8f8f2>currentHeight</color><color=#f8f8f2>);</color>

            <color=#75715e>// Render the incremental scaled image.</color>
            <color=#f8f8f2>BufferedImage</color> <color=#f8f8f2>incrementalImage</color> <color=#f92672>=</color> <color=#f8f8f2>scaleImage</color><color=#f8f8f2>(</color><color=#f8f8f2>src</color><color=#f8f8f2>,</color> <color=#f8f8f2>currentWidth</color><color=#f8f8f2>,</color>
                    <color=#f8f8f2>currentHeight</color><color=#f8f8f2>,</color> <color=#f8f8f2>interpolationHintValue</color><color=#f8f8f2>);</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Before re-assigning our interim (partially scaled)</color>
<color=#75715e>             * incrementalImage to be the new src image before we iterate around</color>
<color=#75715e>             * again to process it down further, we want to flush() the previous</color>
<color=#75715e>             * src image IF (and only IF) it was one of our own temporary</color>
<color=#75715e>             * BufferedImages created during this incremental down-sampling</color>
<color=#75715e>             * cycle. If it wasn't one of ours, then it was the original</color>
<color=#75715e>             * caller-supplied BufferedImage in which case we don't want to</color>
<color=#75715e>             * flush() it and just leave it alone.</color>
<color=#75715e>             */</color>
            <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>hasReassignedSrc</color><color=#f8f8f2>)</color>
                <color=#f8f8f2>src</color><color=#f8f8f2>.</color><color=#a6e22e>flush</color><color=#f8f8f2>();</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Now treat our incremental partially scaled image as the src image</color>
<color=#75715e>             * and cycle through our loop again to do another incremental</color>
<color=#75715e>             * scaling of it (if necessary).</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>src</color> <color=#f92672>=</color> <color=#f8f8f2>incrementalImage</color><color=#f8f8f2>;</color>

            <color=#75715e>/*</color>
<color=#75715e>             * Keep track of us re-assigning the original caller-supplied source</color>
<color=#75715e>             * image with one of our interim BufferedImages so we know when to</color>
<color=#75715e>             * explicitly flush the interim "src" on the next cycle through.</color>
<color=#75715e>             */</color>
            <color=#f8f8f2>hasReassignedSrc</color> <color=#f92672>=</color> <color=#66d9ef>true</color><color=#f8f8f2>;</color>

            <color=#75715e>// Track how many times we go through this cycle to scale the image.</color>
            <color=#f8f8f2>incrementCount</color><color=#f92672>++</color><color=#f8f8f2>;</color>
        <color=#f8f8f2>}</color> <color=#66d9ef>while</color> <color=#f8f8f2>(</color><color=#f8f8f2>currentWidth</color> <color=#f92672>!=</color> <color=#f8f8f2>targetWidth</color> <color=#f92672>||</color> <color=#f8f8f2>currentHeight</color> <color=#f92672>!=</color> <color=#f8f8f2>targetHeight</color><color=#f8f8f2>);</color>

        <color=#66d9ef>if</color> <color=#f8f8f2>(</color><color=#f8f8f2>DEBUG</color><color=#f8f8f2>)</color>
            <color=#f8f8f2>log</color><color=#f8f8f2>(</color><color=#ae81ff>2</color><color=#f8f8f2>,</color> <color=#e6db74>"Incrementally Scaled Image in %d steps."</color><color=#f8f8f2>,</color> <color=#f8f8f2>incrementCount</color><color=#f8f8f2>);</color>

        <color=#75715e>/*</color>
<color=#75715e>         * Once the loop has exited, the src image argument is now our scaled</color>
<color=#75715e>         * result image that we want to return.</color>
<color=#75715e>         */</color>
        <color=#66d9ef>return</color> <color=#f8f8f2>src</color><color=#f8f8f2>;</color>
    <color=#f8f8f2>}</color>
<color=#f8f8f2>}</color>